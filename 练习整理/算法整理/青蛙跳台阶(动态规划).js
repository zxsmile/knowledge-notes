/* 动态规划
  
      - 将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息
      - 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中
 
例题1：一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法

 分析：1.阶数为1时，只有一种跳法
      2.阶数为2时，有两种跳法
      3.阶数为3时，有三种跳法
      4.阶数为4时，有五种跳法
      5.阶数为5时，有八种跳法
      。。。。。。
1,2,3,5,8.....组成斐波拉契序列

算法：

   1. 递归法：

          function jump(n){
             
             if(n==1){
                 return 1
             }
             if(n==2){
                 return 2
             }
             if(n>0){
                 return jump(n-1)+jump(n-2)
             }else{
                 return 0
             }

          }

递归算法虽然可以计算出答案，但是会存在重复，比如n=5:

                        f(5)=f(4)+f(3)
                        f(4)=f(3)+f(2),f(3)=f(2)+f(1)
                        f(3)=f(2)+f(1)

                       这样f(3)计算了2次，如果数据再增大，重复更多


    2. 动态规划

        - 是用动态规划，可以将每一步的结果存入数组中，就不用重复计算了

         function jump(n){
             
            var res=new Array(n+1)
            res[1]=1
            res[2]=2
            if(n==1){
                return res[1]
            }
            if(n==2){
                return res[2]
            }
            for(var i=3;i<=n;i++){
                res[i] = res[i-1]+res[i-2]
            }
            return res[n]
        }


例题2： 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

1.当阶数为1时，有1种方法
2.当阶数为2时，有2种方法
3.当阶数为3时，有1+f(1)+f(2)=4种方法
4.当阶数为4时，有1+f(1)+f(2)+f(3)=f(3)+f(3)=2f(3)=8种方法
5.当阶数为5时，有1+f(1)+f(2)+f(3)+f(4)=f(4)+f(4)=2f(4)=16种方法

......


分析：
*/
function jump(n){
             
    var res=new Array(n+1)
    res[1]=1
    res[2]=2
    res[3]=4
    
    if(n==1){
        return res[1]
    }
    if(n==2){
        return res[2]
    }
    if(n==3){
        return res[3]
    }

    for(var i=4;i<=n;i++){
        res[i] = 2*res[i-1]
    }
    return res[n]
}

console.log(jump(5))