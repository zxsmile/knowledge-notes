* [js总结](#js总结)
  * [一、js事件流](#一、js事件流)
  * [二、token、cookie、session](#二、token、cookie、session)
* [css总结](#css总结)
  * [一、BFC（块级格式化上下文）](#一、BFC（块级格式化上下文）)
  * [二、清除浮动](#二、清除浮动)
  * [三、css3动画](#三、css3动画)
  * [四、box-sizing](#四、box-sizing)
  * [五、](#五、)
  * [六、](#六、)
* [vue总结](#vue总结)
* [网络总结](#网络总结)
  * [一、http请求和响应](#一、http请求和响应)
  * [二、http的请求方法](#二、http的请求方法)
  * [三、http常用状态码](#三、http常用状态码)
  * [四、](#四、)
* [es6总结](#es6总结)
  * [一、promise](#一、promise)
* [node总结](#node总结)

<h1 id='js总结'>js总结<h1>

<h3 id='一、js事件流'>一、js事件流</h3>

1.事件流

   - js事件流就是指，元素触发事件时，事件在页面中的传播过程。它一共分为三个阶段，捕获阶段、处于目标阶段和冒泡阶段。捕获阶段就是由最不具体的节点先接收事件，由上至下依次传播直至目标节
点。冒泡阶段就是目标节点先接收事件，由下至上依次传播直至window。

   - 默认情况下，事件使用冒泡事件流，不使用捕获事件流。addEventListener方法可以显式的指定事件是使用捕获事件流还是冒泡事件流。addEventListener事件接受三个参数，第一个事件名称，第二个是作为事件处理程序的函数，第三个为一个布尔值，true表示捕获阶段，false表示冒泡阶段（btn.addEventListener('click',handler,false)）。addEventListener是DOM2级事件，与DOM0级事件（btn.onclick)不同的是同一事件（如click)它可以添加多个事件处理程序,执行顺序按照添加时的顺序。与之对应的移除事件处理程序的方法是removeEventListener,接收的参数和添加事件处理程序时的参数是相同的，所以这也意味着，添加的匿名事件处理程序函数将无法移除。DOM0级移除（btn.onclick=null）。

   - IE实现了和DOM中类似的两个方法attachEvent和detachEvent,这两个方法接收相同的两个参数，事件名称(注意是onclick)和事件处理程序函数（btn.attachEvent('onclick',handler)）。由于IE8及更早的版本只支持事件冒泡，所以通过attachEvent添加的事件都会被添加到冒泡阶段。attachEvent和addEventListener一样都可以为同一个元素添加相同的事件，不过它俩不同的是，attachEvent添加的事件处理程序不是以添加的顺序执行的，而是以相反的顺序执行的。


   - IE中的attachEvent和DOM中的方法的主要区别还在于，事件处理程序的作用域不同，使用DOM级方法的情况下，事件处理程序会在其所属元素的作用域运行，this执行该元素。使用attachEvent情况下，事件处理程序会在全局作用域中运行，因此this等于window

 2.事件委托（事件代理）

  - 事件委托就是利用了事件冒泡，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。事件委托的好处就是将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a,span,div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历

 
 3.阻止冒泡和默认行为

    event.preventDefault可以阻止默认行为但不阻止冒泡
    event.stoppropagation 可以阻止冒泡但不阻止默认行为
    return false 可以阻止默认行为但不阻止冒泡



<h3 id='二、token、cookie、session'>二、token、cookie、session</h3>

#### 一、产生背景 ####

- 由于http是无状态的，它不会去记录服务器和浏览器的会话信息，对它来说每一次请求都是一个新的请求。随着网络的发展，比如购物车功能就必须知道用户身份才能够执行接下来的一系列操作，所以就产生了cookie、session、token来帮助服务器来记住一些信息。

#### 二、cookie ####

1. 概念

- cookie是http头部的一个字段，它是由服务器产生的，是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上
- cookie是存在当前访问服务器的浏览器中的，比如你使用的是chrome浏览器，cookie就会存在chrome浏览器中，如果此时你换成了Firefox等其他的浏览器，因为Cookie刚才是存储在Chrome里面的，所以服务器又蒙圈了，不知道你是谁，就会给Firefox再次发送一个cookie。

2. cookie识别用户身份过程：

   - 浏览器第一次访问服务端时，服务器此时肯定不知道他的身份，所以创建一个独特的身份标识数据，格式为key=value（比如：isLogin=true），放入到Set-Cookie字段里，随着响应报文发给浏览器。
   - 浏览器看到有Set-Cookie字段以后就知道这是服务器给的身份标识，于是就保存起来，下次请求时会自动将此key=value值放入到Cookie字段中发给服务端。
   - 服务端收到请求报文后，发现Cookie字段中有值，就能根据此值识别用户的身份然后提供个性化的服务。

3. cookie的缺点：

   - 用户本人可以通过修改document.cookie="isLogin = true"伪造登陆凭证
   - 如果将账户的一些信息都存入Cookie中的话，一旦信息被拦截，那么我们所有的账户信息都会丢失掉。
   - 能存储的数据量不能超过 4kb
   - 一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie
   - 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token


#### 三、session ####

1. 概念

- session 是另一种记录服务器和客户端会话状态的机制
- session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中

2. session认证流程：

     - 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，开辟了一块 Session 空间（创建了Session对象），同时生成一个SessionId
     - 请求返回时将此 Session 的唯一标识信息 SessionId放入到Set-Cookie字段里，随着响应报文发给浏览器
     - 浏览器接收到服务器返回的 SessionId 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionId 属于哪个域名
     - 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionId，再根据SessionId查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

3. 有了 Cookie 为什么还要 Session

     - 使用 session 只需要在客户端保存一个 sessionId，实际上大量数据都是保存在服务端。如果全部用 cookie，数据量大的时候客户端是没有那么多空间的（ 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie）。
     - 全部在客户端保存，服务端无法验证，这样伪造和仿冒会更加容易。（伪造一个随机的id很难，但伪造另一个用户名是很容易的）
     - cookie 只是实现 session 的其中一种方案。虽然是最常用的，但并不是唯一的方法。(禁用cookie后还有其他方法存储，比如放在url中,但放在url中涉及安全性和SEO的影响)
     - 全部保存在客户端，那么一旦被劫持，全部信息都会泄露
     - 客户端数据量变大，网络传输的数据量也会变大

4. session缺点

     - Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。（解决方法：Nginx ip_hash 策略、Session 复制、共享 Session）
     - Session存储在服务器，大量的存储会给服务器带来压力

5. 如何考虑分布式 Session 问题？

      - 在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

      - 分布式 Session 一般会有以下几种解决方案：

         - （1）session 复制

                - 采用 session 复制方案，整体的流程非常简单：假设现在有三台服务器，当一个 session 在其中一台服务器上被创建，则同时把这个 session 复制到其他两台服务器上。这样当用户的请求无论到达哪台服务器，都会有相应的 session 数据。
                - 这种方案的优势在于服务器可以任意水平扩展，每个服务器都保留着所有的 session 信息，当加入一台服务器只需要把所有的 session 信息复制过去即可。
                - 但是劣势更加明显
                     - 每个服务器上都保存着全部的 session 信息，服务器占用的资源大大增加。
                     - session 同步需要占用网络带宽，最重要的是如果采用的异步复制方式，数据会有短暂性的不一致，可能会导致用户访问失败。

         - （2）Nginx ip_hash 策略
         
               - nginx 可以根据“hash_ip”算法将同一个 IP 的请求固定到某台服务器，这样来自于同一个 ip 的 session 请求总是请求到同样的服务器。
               - 这种方式比 session 同步方式要好很多，每台服务器只存储对应的 session 数据，这大大节省了内存资源，而且服务器之间没有数据同步过程。当有新服务器加入的时候，只需要修改负载均衡器的配置即可，这样很方便就支持了服务器水平扩展。
               - 但是，同时也面临着一些不足

                     - 服务器重启意味着对应的 session 信息丢失，这在一些重要的业务场景中是不允许的
                     - 服务器的水平扩展需要修改负载均衡器的配置，修改之后可能会导致之前的 session 重新分布，这样会导致一部分用户路由不到正确的 session

        - （3）共享 Session

               - 现在应用更广泛的分布式 session 技术是把 session 数据彻底从业务服务器中剥离，单独存储在其他外部设备中，而这些外部设备可以采用主备或者主从，甚至集群的模式来达到高可用。比如现在最常用的方案是把 session 数据存储在 redis 中，虽然从 redis 读写 session 数据需要花费一定的网络耗时，但是对于一般的应用来说在可以接受范围之内。
               - 这种方案好处是整体架构更加清晰，也更加灵活，应用的服务器整体扩展能力再也不用考虑 session 的影响，而 session 的问题被转移到外部设备，通常可以利用内存性 NOSql 来解决性能问题，而这些外部设备一般都会有对应的分布式集群方案，例如 redis，可以利用主从或者哨兵模式甚至集群来提供更大规模的数据支撑能力。

               ![](./images/共享session.jpg)


6. 禁用cookies，如何使用session

     - 如果禁用了 Cookies，服务器仍会将 sessionId 以 cookie 的方式发送给浏览器，但是，浏览器不再保存这个cookie (即sessionId) 了。
     - 如果想要继续使用 session，需要采用 URL 重写 的方式来实现

#### 四、Cookie 和 Session 的区别 ####

- 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，session在超过一定的操作时间(通常为30分钟)后会失效，但是当关闭浏览器时，为了保护用户信息，会自动调用session.invalidate()方法，该方法会清除掉session中的信息。
- 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。


#### 五、token ####

1. 概念

- Token是在服务端将用户信息以及用户信息经过算法生成的签名传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息通过验证签名判断该请求的合法性。
- 基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

2. token认证流程：

     - 客户端使用用户名跟密码请求登录
     - 服务端收到请求，去验证用户名与密码
     - 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
     - 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
     - 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
     - 服务端收到请求，然后去验证客户端请求里面带着的 token（使用相同加密算法加密，将结果和token中的签名对比） ，如果验证成功，就向客户端返回请求的数据

3. token 的过期

   - 那我们如何控制 token 的有效期呢？很简单，把「过期时间」和数据一起塞进去，验证时判断就好

4. token优点

    - 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
    - token 完全由应用管理，所以它可以避开同源策略

5. access token和refresh token

    - token，作为权限守护者，最重要的就是「安全」。业务接口用来鉴权的 token，我们称之为 access token。越是权限敏感的业务，我们越希望 access token 有效期足够短，以避免被盗用。但过短的有效期会造成 access token 经常过期，过期后怎么办呢？

        - 一种办法是，让用户重新登录获取新 token，显然不够友好，要知道有的 access token 过期时间可能只有几分钟。
        - 另外一种办法是，再来一个 token，一个专门生成 access token 的 token，我们称为 refresh token。

            - access token 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活
            - refresh token 用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理

        - 有了 refresh token 后，几种情况的请求流程变成这样：

          ![](./images/access token&refresh token.jpg)



#### 六、JWT ####

1. 概念

- JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。它是一种成熟的 token 字符串生成方案,相当于规定了怎样定义一个token

2. JWT由三部分组成：头部、负载和签名

     - Header

         - Header通常由两部分组成：token的类型(即 JWT)和使用的签名算法，例如 HMAC SHA256 或 RSA。
         
			例如：{

				  "alg": "HS256",
				  "typ": "JWT"
				 }

        - 指定类型和签名算法后，Json 块被 Base64Url 编码形成 JWT 的第一部分。


    - Payload
    
        - 负载是Token要存储的信息（比如存储用户姓名和昵称信息）
        - JWT 规定了7个官方字段，供选用。
        
            - iss (issuer)：签发人
            - exp (expiration time)：过期时间
            - sub (subject)：主题
            - aud (audience)：受众
            - nbf (Not Before)：生效时间
            - iat (Issued At)：签发时间
            - jti (JWT ID)：编号
 
       - 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

			例如：{
	
				  "name": "John Doe",
				  "admin": true
				}
        - 然后 payload Json 块会被Base64Url 编码形成 JWT 的第二部分。


    - signature

       - JWT 的第三部分是一个签证信息，这个签证信息由三部分组成
       
         - header (base64后的)
         - payload (base64后的)
         - secret（密钥）

       - 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名形成JWT的第三部分

			HMACSHA256(
			  base64UrlEncode(header) + "." +
			  base64UrlEncode(payload),
			  secret)

    - 最后将这三部分用.号连接，就可以得到了一个Token了。
    ![](./images/JWT.jpg)

3. JWT 的几个特点：

    - JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
    - JWT 不加密的情况下，不能将秘密数据写入 JWT。
    - JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
    - JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
    - JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
    - 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。


#### 七、session和token ####

     - session 是「种在 cookie 上、数据存在服务端」的认证方案，token 是「客户端存哪都行、数据存在 token 里」的认证方案。
     - token保存在客户端，在分布式环境下不需要做额外工作。而session因为保存在服务端，分布式环境下需要实现多机数据共享
     - session一般需要结合Cookie实现认证，所以需要浏览器支持cookie，因此移动端无法使用session认证方案
     - JWT的payload使用的是base64编码的，因此在JWT中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全
     - 经过编码之后JWT将非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以JWT一般放在local storage里面。并且用户在系统中的每一次http请求都会把JWT携带在Header里面，HTTP请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用token的HTTP请求比使用session的开销大得多
     - session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 token 是令牌，访问资源接口（API）时所需要的资源凭证。token 使服务端无状态化，不会存储会话信息。
     - session 和 Token 并不矛盾，作为身份认证 token 安全性比 session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 session 来在服务器端保存一些状态。





   
<h1 id='css总结' style='background-color:darkgrey;'>css总结<h1>

<h3 id='一、BFC（块级格式化上下文）' style="color:#ccc;">一、BFC（块级格式化上下文）</h3>

- 我们看到的页面是由一个一个的盒子组成的，元素的类型和display属性决定了这个盒子的类型，不同类型的盒子会参与不同的格式化上下文。格式化上下文就是页面中一块独立的渲染区域，并且有一套自己的渲染规则，它规定了其内部的子元素如何布局，而BFC就是display属性为block（此元素将显示为块级），list-item（此元素将显示为列表），table（此元素会作为块级表格来显示）的元素参与的格式化上下文，直译为块级格式化上下文。
 - 它的布局规则是：
       - 内部的盒子会在垂直方向上一个接一个的排列
       - 盒子垂直方向上的距离由margin决定，属于同一个BFC的相邻的两个盒子的margin会发生重叠
       - 对于从左往右的格式来说，盒子的左外边缘（margin-left）会触碰到容器的左边缘（border-left）
       - BFC区域和浮动区域不会重叠（自适应两栏布局）
       - BFC区域就是页面中的一块独立的区域，容器里面的子元素不会影响到外面的元素
       - 计算BFC时浮动元素也会参与计算（解决高度塌陷）        

 - 开启BFC:
       
       - 根元素（html）
       - float属性不为none
       - position属性为absolute,fixed
       - overflow属性不为visible
       - display属性为inline-block,table-cell,table-caption,flex,inline-flex

 - 应用

    - 解决高度塌陷

         - 高度塌陷是由于父元素没有设置高度，高度是由子元素撑起来的，当子元素设置了浮动脱离文档流之后，父元素就会塌陷，这时候我们可以给父元素开启BFC,因为计算BFC时浮动元素也会参与计算，所以就解决了父元素的高度塌陷问题

    - 实现自适应两栏布局BFC

         - 设置两个div，第一个div宽度固定，设置左浮动，第二个div就会自动填满剩余的宽度，正常情况下，第一个div会覆盖一部分第二个div。这时候我们可以给第二个div开启BFC，由于BFC和浮动元素不会重叠，这样就实现了两栏布局

    - 解决margin重叠

         - 由于属于同一个BFC相邻的两个块级元素会发生margin重叠，所以我们可以给其中一个盒子包一层div，然后激活它的BFC，这样它俩就不属于同一个BFC了，就不会margin重叠了


<h3 id='二、清除浮动'>二、清除浮动（https://blog.csdn.net/u012207345/article/details/78279961）</h3>

- 清除浮动的方法主要分为两类，一类是使用clear属性，一类是使用BFC
  - clear属性只能影响使用该属性的元素本身，不能影响其他元素。clear属性规定元素盒子的边不能和浮动元素相邻，所以我们使用clear清除浮动的原理就是，在父元素的最后加一个具有clear属性的块级元素，由于该块级元素不能和浮动元素相邻，而浮动元素的位置我们已经确定了，所以为了满足该元素的需求，将该元素渲染在了浮动元素的下面，由于该元素在父元素的边界内，所以父元素必须增加高度将它包含在内，这样就达到了清除浮动的目的
  - BFC原理是由于开启了BFC的元素在计算其高度时，是要包含浮动元素的，所以给父元素开启BFC就能清除浮动

<h3 id='三、css3动画'>三、css3动画</h3>

- css动画主要有transform，translation，animation。transform可以理解为元素的几何变形，它不会产生动画效果。translation和animation都可以实现过渡动画，不同的是translation只能定义开始状态和结束状态，不能定义中间状态，并且translation动画是需要事件触发的（：hover,:focus,js触发），不能在网页加载时自动执行，并且动画是不能循环的。

<h3 id='四、box-sizing'>四、box-sizing</h3>

- box-sizing 是用于告诉浏览器如何计算一个元素是总宽度和总高度
  - 标准盒模型 box-sizing: content-box

       - width = content width
       - height = content height

  - IE盒模型 box-sizing: border-box

       - width = border + padding + content width
       - heigth = border + padding + content heigth
       

<h1 id='vue总结'><font color='darkgrey'>vue总结</font><h1>

<h1 id='网络总结'><font color='darkgrey'>网络总结</font><h1>

<h3 id='一、http请求和响应'>一、http请求和响应</h3>

1.http请求报文

   - 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。

![](./images/http1.JPG)

 (1)请求行

  - 请求行由请求方法字段，URL字段和HTTP协议版本等3个字段组成，它们用空格分隔
    
     例如：GET /index.html HTTP/1.1

 (2)请求头部

  - 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息。
  - 请求头都有：

      - Accept：
      
			例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8

			表示客户端支持的数据格式，或者说客户端“希望”接受到的内容类型。这里只是希望，但是服务器具体返回什么样的内容类型，还是由服务器自己决定，但是无论服务器返回什么样的内容类型，客户端都会接收响应报文，不可能说因为内容类型不同，接收不到服务器响应报文，这不符合http协议规范。

			我们通过浏览器发起get或post请求，该字段都是浏览器自动添加的，同样在服务器端也不会解析该字段的值；
			通过ajax请求或其他手段，我们可以设置该字段的值，但是通常也不进行设置。
			
			该字段的应用场景可以是这样的，有两个终端，比如一个是纯文本阅读器，如Kinder（不能显示图片），另一个是移动终端（可以播放图片和视频），均向服务器请求有关“斑马”的信息，那么这时候服务器端就需要判断什么样的终端应该返回什么样的信息，那么它就可以根据Accept的信息来进行判断，如果解析到的Accept的值为“text/plain”，那么就表示客户端只支持文本类型；如果向上面例子中的那样，则表示客户端文本图片视频都可以。如果我们不加判断，当返回给文本阅读器一张图片时，可能它显示的就是乱码。

      - Accept-Encoding:
      
			例：Accept-Encoding:gzip, deflate, br
			
			表示客户端所支持的解码（解压缩）格式。网络数据的传输都是占据带宽的，而将文件数据压缩能够降低数据量，减少传输时间。所以服务器在返回数据给客户端时，常常对数据进行压缩（对用户透明，通常由服务器或代理来做），而压缩的方式有多种，到底采用哪一种则需要看客户端支持哪种解码方式，这时候就可以根据header中Accept-Encoding的值。
			
			文件或数据的压缩，由服务器或代理来做，一般不需要程序员干预；客户端接收到数据时解压缩，通常由浏览器自动完成，对用户透明。
			对于我们主动发起的ajax请求，一般数据量较少，不需要设置该字段。

     - Accept-Language:
     
			例：Accept-Language:zh-CN,zh;q=0.9
			
			表示客户端支持的语言格式（不是编码格式），如中文/英文，通常浏览器直接发起请求时，浏览器会根据被设置的语言环境（默认语言），来附加上该字段。
			
			一般我们服务器解析报文时，是不理会该字段的。
			
			他的使用场景可以是这样的，假如有个文件，有各种语言的版本，这样当不同请求发来时，我们可以根据Accept-Language的值来判断到底返回哪种语言版本给客户端。
			（其实这种应用场景也一般不采用判断Accept-Language字段的方法，不靠谱，还不如直接在url中体现语言版本呢）

    - Accept-Charset：
    
			例：Accept-Charset:gbk,utf-8;q=0.8
			
			表示客户端支持编码格式。服务器在返回报文时，需要将字符按照一定的编码格式转换为字节序列发送给客户端，那么该采用哪种编码格式呢？
			当然作为服务器端，他可以采用任何一种编码方式，客户端都得完完整整的接收响应报文。因为目前客户端几乎都支持常见编码类型，所以服务器在返回数据时，只需要按照既定的编码方式编码，然后在响应报文中告知客户端所使用的编码方式。这样客户端在接收到报文后按照该方式进行解码，就就不会出现乱码问题。
			
			但是，如果客户端已经定了就使用某种解码方式，那么这时候服务器端就不能那么任性了，他就需要解析Accept-Charset字段，根据这个值，来设定采用的编码方式。
			如上例中，以逗号分隔，客户端支持两种编码方式，gbk和utf-8（gbk优先级高于utf8），其中utf-8后的q值，表示utf-8占的“权重”。
			
            - 题外话：

			服务器端怎么通知浏览器所采用的编码格式呢？
			如果不通知浏览器，那么浏览器会采用什么样的格式解码呢？
			
			服务器端以原生的Servlet & JSP为例：

			  1）当返回的是HTML页面，那么页面meta charset就指定了编码格式
			  2）当返回的是JSP页面，那么页面pageEncoding就指定了编码格式
			  3）当通过resp的Outputstream返回原生内容时，我们可以通过设置响应头content-type/content-charset字段来指定编码格式
			
			那么如果服务器不指定编码格式呢？

			  我的测试环境为win10中文操作系统，浏览器：Chrome 64.0.3282.186（正式版本）
				
				1）返回的html页面不设置meta标签，但是文件本身是utf-8或gbk编码，中文不乱码，服务器会将html页面转换为字节流写给浏览器，浏览器读取字节流，由于找不到meta标签设置的文件格式，就会按照默认的格式解码。这时出现的情况是，当原页面是gbk编码时，浏览器能正常显示页面；当原页面是utf-8编码时，浏览器显示中文乱码。这说明当前Chrome浏览器的默认编码格式为gbk。使用微软自带的Microsoft Edge测试结果一样 。
				
				2）返回JSP页面时，必须指定pageEncoding。
				
				3）通过response的输入流，直接返回生成的字节流。
 
                     当服务器使用gbk编码返回字节流时，地址栏的http请求不乱码，但是ajax请求响应乱码；
			         当服务器使用utf-8返回字节流时，地址栏的http请求乱码，但是ajax不乱码。
			
			
			这说明同一个浏览器，在不同的地方采用的编码格式不同，当浏览器解析页面时，它默认使用的是gbk编码（可能因为我们的中文操作系统，同时是中文版的软件，所以浏览器默认使用gbk格式来解析页面）；当浏览器使用内核XMLHttpRequest对象来解析响应时，默认采用的是utf-8（这个应该跟操作系统语言没关系，内核层面的应该在哪个国家都一样）。所以，如果为了确保在各种情况下都不乱码，服务器一定要通知客户端所采用的编码格式


    - Referer：
    
			例：Referer:http://localhost:8080/test/11.html
			
			表示当前请求是从哪个资源发起的；或者是请求的上一步的地址。
			
			我在11.html页面发起一个请求，这时候浏览器封装的请求头就有上例中的referer字段，表示当前请求是这个资源链接中发起的。
			
			Referer是常用于网站的访问统计，比如我在很多地方都做了广告链接到我网站的主页，这时候我就可以通过Referer来查看哪些地方跳转过来的人多，就说广告的效果好。
			另外，Referer还经常用于防盗链。
			
			   1.防盗链：所谓防盗链是指防止其他web站点页面通过连接本站点的页面来访问本站点内容，这样对于本站点来说侵犯了本站点的版权
               
               2.非法用户： 

                  常访问本站点页面的链接有三种出处:

					  (1) 地址栏输入链接地址。如地址栏上输入www.csdn.net/a.jsp；
					
					  (2)其他站点上的应用程序的页面上通过链接本站点页面资源。如(www.b.com/index.jsp页面上有一链接指向www.csdn.net/a.jsp)；
					
					  (3)本站点上的页面资源连接到本站点的另外的页面资源。如(www.csdn.net/index.jsp页面上有一链接指向www.csdn.net/a.jsp)；
					
				  这三类用户中第一类和第二类通常是非法用户。

               3.如何防盗链

                  通过调用request.getHeader("Referer");判断访问本页面的链接来自哪里。
                  Refer代表网页的来源，及上一页的地址，如果是直接在浏览器上输入地址，回车进来，则没有Refer头。


   - If-Modified-Since：
   
            例：If-Modified-Since:Thu, 29 Mar 2018 08:37:45 GMT

			表示客户端缓存文件的时间。字面翻译的意思是，“如果从…时间改变了”（就请再发送给我一遍新的文件）。
			
			当客户端访问服务器的静态文件时，通常会将资源结果缓存下来，并标记一下文件的缓存时间（根据响应头中的Last-Modified字段）；当接下来再发送同样的请求时，会在请求头中添加上这个字段If-Modified-Since；
			
			服务器端读取字段值，判断服务器端文件的最后修改时间，如果如果不晚于该值，说明浏览器缓存的文件是最新的，然后就不会重新发送文件内容，而是将相应报文的状态设置为304，表示你读取缓存的文件就可以了，这就很大程度上节省了带宽。
			第一次请求头：
			
			GET /mvctest/11.html HTTP/1.1
			Host: localhost:8080
			Connection: keep-alive
			Upgrade-Insecure-Requests: 1
			User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
			Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
			Accept-Encoding: gzip, deflate, br
			Accept-Language: zh-CN,zh;q=0.9
			1
			2
			3
			4
			5
			6
			7
			8
			第一次响应头：
			这里写图片描述
			
			第二次请求头：
			这里写图片描述
			第二次响应头：
			这里写图片描述
			
			需要说明的是，If-Modified-Since字段的值，为服务器端文件最后修改的时间，不是请求的访问时间，时间值为GMT格林尼治时间，不是本地时间。
			浏览器一般只对.html,.jpg,.css,.js等这些静态资源进行缓存，对于jsp页面以及ajax请求的动态结果，不缓存。服务器如Tomcat会自动给静态文件的响应报文添加“Last-Modified”字段，同时解析请求报文中的If-Modified-Since字段，这些都是对我们透明的。
			
			例如，我们将11.html改为11.jsp，那么浏览器将不会缓存页面内容，服务器每次都响应一个完整的页面内容给客户端，也不会在响应报文中添加“Last-Modified”字段。
			每次对于JSP请求的响应结果：
			这里写图片描述
		
		If-None-Match:
		例：
		If-None-Match:W/”607-1522312665174”
		该字段同If-Modified-Since字段一样，都是用来表示资源文件是否是最新的。只不过If-Modified-Since的值为文件的最后修改时间，而该值为资源实体的哈希值，同样是由服务器生成的。
		从上面的截图中我们可以看到：
		第一次请求时，服务器的响应报文中有字段Etag，这就是实体的哈希值，浏览器会缓存文件并记录该值。
		第二次请求时，请求头字段中就有If-None-Match，值为Etag的值，而服务器会判断该值与服务器中文件的哈希值是否相同，如果相同，就返回304，让浏览器读取缓存；否则会返回新的资源文件，并在响应头中设置新的Etag值。
		
		Last-Modified/If-Modified-Since 和 Etag/If-None-Match这两对头字段都是来标记缓存资源的，但是后者的优先级要高于前者。

  - Cache-Control:

		例：Cache-Control:no-cache
	
		字段的字面意思为“缓存-控制”，前面我们将了几个字段表面客户端/服务器如何使用缓存机制，而这个字段就是用来控制缓存的。
		Cache-Control在请求/响应报文头中均可设置，分别表明不同的意思，下面我们以响应报文为例：cache-control在响应报文的的取值可以为：public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。
		所代表的意思为：
		这里写图片描述
		其中，no-cache、no-store、max-age为常用的取值。
		比如，服务器在响应报文中添加Cache-Control：no-store，表示浏览器或各级代理，不要缓存本次的相应内容（即使响应报文中有Etag和Last-Modified）;
		
		比如，响应报文中有Cache-Control：no-cache，表示浏览器可以缓存响应文件，但是在使用缓存之前，必须通过令牌（Etag）来与服务器进行沟通确认缓存有效。
		
		比如，响应报文中有Cache-Control：max-age=500，表示在接下来的500秒内，浏览器可以自主使用缓存内容，不需要向服务器发送同样的请求。
		
		在请求报文中，也可以添加cache-control字段，其取值可以为no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached。
		客户端在发送请求到服务器时，可能会经过很多层代理，而这些代理可能就缓存了本次请求想要的文件，而请求中的cache-control就可以控制，是否使用代理中的缓存文件。
		
		比如，请求报文头中有cache-control：no-cache，那就表示，代理如果返回给我缓存文件时，需要到服务器端进行确认，缓存是不是最新的。
		
		比如，请求报文头中有cache-control：no-store，那就表示，我不需要代理中的缓存文件，我需要直接请求服务器。
		
		所以我们可以看到，cache-control就是用来控制缓存使用的，如是否缓存，是否使用缓存，缓存到期时间等，而Last-Modified/If-Modified-Since 和 Etag/If-None-Match是标识C/S之间怎么使用缓存。
		缓存的使用都是服务器和客户端的默认行为，对用户和程序员的透明的，当然我们可以通过配置文件或程序修改他们的行为规则。
		附：http协议中对缓存的说明

  - User-Agent:

		例：User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
		表示客户端的软件环境。如上可以看出使用的是Window10 64位操作系统，Chrome浏览器等信息。服务器可以根据该字段评估客户端的环境从而给出不同的响应。（比如根据请求是从手机端或是电脑端发起的，返回不同版本的页面）

  - Host：

		例：Host:localhost:8080
		表示请求者的主机地址（IP地址）和端口号。
		服务器端可以根据该字段进行ip过滤等操作。

(3)响应头

    - Etag、Last-Modified、cache-control在前文中已经说明。

    - Content-Length:

		例：Content-Length:607
		表示接收到的响应报文的总长度为607。
		根据这个长度，客户端可以更准确的接收和解析报文内容。或者可以根据当前接收/解析的长度占总长度的百分比，做出进度条的效果。

   - Accept-Ranges:

		例：Accept-Ranges:bytes
		表示服务器支持http中的Range功能，能够分段请求客户端能够分段请求服务器。
		我们上网时常用的“断点续传”，或者服务器所谓的“多线程下载”就是靠的服务器端的Range技术。
		Range功能的请求-响应流程如此：
		客户端发起带range的请求：
		
		GET  /test.rar  HTTP/1.1
		Connection:  close
		Host:  116.1.219.219
		Range:  bytes=0-100
		1
		2
		3
		4
		在头中添加Range字段，表示我要请求[0-100]这101个字节的数据。
		此处Range的值，可以添加多个片段，如 Range：bytes=0-100,200-300等。
		
		服务器响应报文：
		
		HTTP/1.1 206 OK
		Content-Length:  801     
		Content-Type:  application/octet-stream 
		Content-Location: http://www.onlinedown.net/hj_index.htm
		Content-Range:  bytes  0-100/2350        //2350:文件总大小
		Last-Modified: Mon, 16 Feb 2009 16:10:12 GMT
		Accept-Ranges: bytes
		ETag: "d67a4bc5190c91:512"
		Date: Wed, 18 Feb 2009 07:55:26 GMT
		1
		2
		3
		4
		5
		6
		7
		8
		9
		响应报文中有Content-Range字段，表示响应的报文片段内容范围，已经总的数据大小。
		同时Range请求的正常的返回码是206，不是200。
		
		而即使我们请求的不是Range功能请求，那么服务器的返回字段中会有Accept-Range，表示服务器支持Range功能。

  - Server:
  
		例：Server: Apache/2.4.1 (Unix)
		表示服务器的名称，是Unix下的Apache服务器

<h3 id='二、http的请求方法'><font color='#ccc'>二、http的请求方法</font></h3>

  - HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。
  - HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

   1. GET - 默认的请求方式，返回页面具体内容，参数会显示在地址栏中
   2. POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
   3. HEAD - 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
   4. PUT - 从客户端向服务器传送的数据取代指定的文档的内容。
   5. DELETE	- 请求服务器删除指定的页面。
   6. CONNECT - HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
   7. OPTIONS - 允许客户端查看服务器的性能。
   8. TRACE - 回显服务器收到的请求，主要用于测试或诊断。

<h3 id='三、http常用状态码'>三、http常用状态码</h3>

1.1xx - 信息提示：这类状态码表示一个临时的响应信息，并需要请求者继续执行操作的一个状态码

   - 100：继续，客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收,且仍未被拒绝.客户端应当继续发送请求的剩余部分,或者如果请求已经完成,忽略这个响应.服务器必须在请求完成后向客户端发送一个最终响应。（http1.1可用）
   - 101：切换协议，服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 在Upgrade消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特 性的资源。（http1.1可用）

 2.2xx - 成功：这类状态代码表明服务器成功地接受了客户端请求

   - 200:成功,服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
   - 201:已创建,请求成功且服务器已创建了新的资源。 
   - 202:已接受,服务器已接受了请求，但尚未对其进行处理。 
   - 203:非授权信息,服务器已成功处理了请求，但返回了可能来自另一来源的信息。 
   - 204:无内容,服务器成功处理了请求，但未返回任何内容。 
   - 205:重置内容,服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 
   - 206:部分内容,服务器成功处理了部分 GET 请求。

 3.3xx - 重定向：客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。

   - 301：永久重定向，请求的网页已永久移动到新位置，返回信息的location头中会包含新的url，服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
   - 302：暂时重定向
   - 304：使用缓存（协商缓存）
   - 301，302，303，307详解

         - 302

              - HTTP1.0中，在 POST 请求方式上，客户端收到服务端的301或302状态码，那么不能自动的向新的URI发送重复请求，必须跟用户确认是否该重发，因为第二次 POST 时，POST 方法不是幂等，（也就是请求时服务器的资源有可能已经发生了变化），POST 操作会不符合用户预期。但是很多浏览器（user agent）在这种情况下都会把 POST 请求变为 GET 请求。

              - HTTP1.1中，如果客户端发出非 GET、HEAD 请求后，收到服务端的301或302状态码，那么就不能自动的向新URI发送重复请求，除非得到用户的确认。但是，很多浏览器都把301或302当作303 处理了（注意，303 是 HTTP1.1 才加进来的，其实从 HTTP1.0 进化到 HTTP1.1，浏览器什么都没动），它们获取到 HTTP 响应报文头部的 Location 字段信息，并发起一个 GET 请求。

         - 303和307

              - 从上面的介绍可以知道，HTTP1.1和HTTP1.0的302或301状态码意义是一样的，浏览器对它的处理也是一样的，POST方法的重定向在未询问用户的情况下就变成GET，HTTP1.1新加入303和307状态码。
              - 文档中规定303状态码的响应，也就是上边提到的现在浏览器对302状态码的处理：POST重定向为GET。
              - HTTP1.1文档中307状态码则相当于HTTP1.0文档中的302状态码，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。
              - 文档也说到，为兼容很多HTTP1.1之前的浏览器，服务端在需要发出303状态码时，会选择用302状态码替代；而对于307的处理，则需要在响应实体中包含信息，以便不能处理307状态码的用户有能力在新URI中发起重复请求，也就是说，把重定向的页面展示给用户，让用户去点重定向URI链接。
              - 303和307的存在，归根结底是由于POST方法的非幂等属性引起的。


 4.4xx - 客户端错误/请求错误

   - 400：错误请求，客户端请求语法出现错误，服务器无法理解请求的语法。
   - 401：未授权， 请求要求身份验证。 需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过.对于需要登录的网页，服务器可能返回此响应。
   - 403：禁止，客户端没有权利访问所请求内容,服务器拒绝本次请求。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。
   - 404：未找到，服务器找不到所请求的资源。


 5.5xx - 服务器错误:这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

   - 500:服务器内部错误,服务器遇到错误，无法完成请求。 
   - 501:尚未实施,服务器不具备完成请求的功能。 例如，服务器不支持该请求中使用的方法,比如POST 和 PUT.只有GET 和 HEAD 是RFC2616规范中规定服务器必须实现的方法.
   - 502:错误网关,服务器作为网关或代理，从上游服务器收到无效响应。 
   - 503:服务不可用,由于临时的服务器维护或者过载,服务器当前无法处理请求.这个状况是临时的,并且将在一段时间以后恢复.如果能够预计延迟时间,那么响应中可以包含一个Retry-After:头用以标明这个
         延迟时间.如果没有给出这个Retry-After:信息，那么客户端应当以处理500响应的方式处理它.同时,这种情况下,一个友好的用于解释服务器出现问题的页面应当被返回,并且,缓存相关的HTTP头信息
         也应该包含,因为通常这种错误提示网页不应当被客户端缓存. 
   - 504:网关超时,服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
   - 505:HTTP 版本不受支持,服务器不支持请求中所用的 HTTP 协议版本。





<h1 id='es6总结'><font color='darkgrey'>es6总结</font><h1>

<h3 id='一、promise'>一、promise</h3>

1.Promise.all()

   - Promise.all()接受一个数组作为参数，数组成员都是promise对象，当数组中的所有promise对象的状态变为resloved的时候，Promise.all()的状态就会变为resloved；当有一个状态变为rejected的时候，Promise.all()的状态就会变为rejected；
   - 调用then方法时，结果成功的回调函数的参数也是一个数组，按照顺序保存着每一个promise对象reslove执行的值；结果失败的回调函数的参数是第一个变为rejected的promise对象的reject执行的值；
   - Promise.all()可以解决异步并行的问题

     例1：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       resolve(1);
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      resolve(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       resolve(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) // 进入成功的回调，输出[1,2,3]
		},(err)=>{
		    console.log(err)
		})

    - 上例也表明，与哪个promise的状态先变成resolved无关

    例2：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reject(1);
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      reject(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reslove(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) // 进入失败的回调，promise2先进入rejected，所以输出2
		})

    
    例3：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(1)
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      reslove(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) 
		})

    - 上例中只会输出1，3但不会执行then里面的回调，是因为promise里面的代码是同步执行的所以里面的console.log会输出，但promise.all()的状态是pedding，所以不会执行then

    例4：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reject(1)
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      console.log(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) 
		})

    - 上例会输出2，1，3，是因为promise1的状态变为rejected，所以会执行then里面的失败回调，而两个console是同步的依然会执行


 - 由例3和例4可以看出，只要有一个状态为rejected，Promise.all()的状态就会变为rejected，当所有状态为resloved的时候Promise.all()的状态才会变为resloved

2.Promise.race()

   - Promise.race()也是接受一个数组，数组里面的成员为promise对象，它就相当于竞赛一样，第一个promise对象的状态变为resloved的时候，Promise.race()的状态就变为resloved,第一个promise的状态变为rejectd的时候，Promise.race()的状态就变为rejected
   

    例1：
        let promise1 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(1);
			},10000)
		});
		let promise2 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(2);
			},9000)
		});
		let promise3 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(3);
			},11000)
		});
		
		let promiseRace = Promise.race([promise1,promise2,promise3])
		
		promiseRace.then((res)=>{
		    console.log(res) // promise2的状态先发生变化，变为resloved,所以Promise.race的状态变为resloved，输出2
		},(err)=>{
		    console.log(err)
		})
		

    例2：
        let promise1 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(1);
			},10000)
		});
		let promise2 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(2)
			},9000)
		});
		let promise3 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(3);
			},11000)
		});
		
		let promiseRace = Promise.race([promise1,promise2,promise3])
		
		promiseRace.then((res)=>{
		    console.log(res) // promise2的状态先发生变化，变为rejectd,所以Promise.race的状态变为rejected，输出2
		},(err)=>{
		    console.log(err)
		})

3.使用Promise.race()实现超时处理

	let promise1 = new Promise((reslove,reject)=>{
	    setTimeout(()=>{
	       reslove(1)
	    },3000)
	})
	
	let promise2 = new Promise((reslove,reject)=>{
	   setTimeout(()=>{
	      reject(2);
	   },2000)
	})
	
	let promise3 = new Promise((reslove,reject)=>{
	    setTimeout(()=>{
	      reslove(3);
	    },5000)
	})
	
	let promiseAll = Promise.all([promise1,promise2,promise3])
	
   // 超时处理

	function timeoutPromise(promise,delay){
	
	    let timeout = new Promise((reslove,reject)=>{
	        setTimeout(()=>{
	            reject('异步处理超时')
	        },delay)
	    })
	    
	    let promiseRace = Promise.race([promise,timeout])
	    return promiseRace
	}
	


	timeoutPromise(promiseAll,1000).then((res)=>{
	    console.log(res) 
	},(err)=>{
	    console.log(err) 
	})
	
	


<h1 id='node总结'><font color='darkgrey'>node总结</font><h1>