* [html总结](#html总结)
  * [一、src和href的区别](#一、src和href的区别)
  * [二、html语义化](#二、html语义化)
  * [三、浏览器的怪异模式和标准模式](#三、浏览器的怪异模式和标准模式)
  * [四、script标签中defer和async的区别](#四、script标签中defer和async的区别)
  * [五、html5有哪些更新](#五、html5有哪些更新)
  * [六、块级元素和行内元素的区别](#六、块级元素和行内元素的区别)
  * [七、webworker](#七、webworker)
  * [八、HTML5离线缓存](#八、HTML5离线缓存)
  * [九、Canvas和SVG的区别](#九、Canvas和SVG的区别)
  

* [js总结](#js总结)
  * [一、js事件流](#一、js事件流)
  * [二、token、cookie、session](#二、token、cookie、session)
  * [三、深入理解函数执行上下文](#三、深入理解函数执行上下文)
  * [四、闭包](#四、闭包)
  * [五、js函数的参数按值传递](#五、js函数的参数按值传递)
  * [六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？](#六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？)
  * [七、ASI自动分号插入机制](#七、ASI自动分号插入机制)
  * [八、V8如何存储js对象](#八、V8如何存储js对象)
  * [九、垃圾回收机制](#九、垃圾回收机制)
  * [十、V8引擎对垃圾回收的优化](#十、V8引擎对垃圾回收的优化)
  * [十一、浏览器和node事件循环的区别](#十一、浏览器和node事件循环的区别)
  * [十二、观察者模式和发布订阅模式](#十二、观察者模式和发布订阅模式)
  * [十三、判断js的数据类型的方法](#十三、判断js的数据类型的方法)
  * [十四、js数据类型转换](#十四、js数据类型转换)
  * [十五、深拷贝与浅拷贝](#十五、深拷贝与浅拷贝)
  * [十六、跨域的几种方式](#十六、跨域的几种方式)
  * [十七、jsonp的安全问题](#十七、jsonp的安全问题)
  * [十八、内部属性Class是什么？](#十八、内部属性[[Class]]是什么？)
  * 
  * 
  
* [css总结](#css总结)
  * [一、BFC（块级格式化上下文）](#一、BFC（块级格式化上下文）)
  * [二、清除浮动](#二、清除浮动)
  * [三、css3动画](#三、css3动画)
  * [四、box-sizing](#四、box-sizing)
  * [五、min/max-width/height](#五、min/max-width/height)
  * [六、css选择器](#六、css选择器)
  * [七、css选择器权重的计算以及性能优化](#七、css选择器权重的计算以及性能优化)
  * [八、css可继承属性和不可继承属性](#八、css可继承属性和不可继承属性)
  * [九、隐藏元素的方法](#九、隐藏元素的方法)
  * [十、引入css样式的方式以及优先级](#十、引入css样式的方式以及优先级)
  * [十一、requestAnimationframe动画](#十一、requestAnimationframe动画)
  * [十二、盒模型](#十二、盒模型)
  * [十三、css3新特性](#十三、css3新特性)
  * [十四、替换元素的概念及计算规则](#十四、替换元素的概念及计算规则)
  * [十五、常见的图片格式及使用场景](#十五、常见的图片格式及使用场景)
  * [十六、雪碧图](#十六、雪碧图)
  * [十七、对line-height的理解及其赋值方式](#十七、对line-height的理解及其赋值方式)
  * [十八、CSS优化和提高性能的方法有哪些？](#十八、CSS优化和提高性能的方法有哪些？)
  * [十九、单行、多行文本溢出隐藏](#十九、单行、多行文本溢出隐藏)
  * [二十、对CSS工程化的理解](#二十、对CSS工程化的理解)
  * [二十一、z-index属性在什么情况下会失效](#二十一、z-index属性在什么情况下会失效)
  * [二十二、css单位](#二十二、css单位)
  * [二十三、flex布局](#二十三、flex布局)
  * [二十四、flex1详解](#二十四、flex1详解)
  * [二十五、两栏布局](#二十五、两栏布局)
  * [二十六、三栏布局](#二十六、三栏布局)
  * [二十七、水平垂直居中](#二十七、水平垂直居中)
  * [二十八、移动端适配](#二十八、移动端适配)
  * [二十九、清除浮动](#二十九、清除浮动)
  * [三十、margin塌陷和重叠](#三十、margin塌陷和重叠)
  * [三十一、元素的层叠顺序](#三十一、元素的层叠顺序)
  * [三十二、position](#三十二、position)
  * [三十三、移动端点透现象](#三十三、移动端点透现象)
  * [三十四、伪类和伪元素](#三十四、伪类和伪元素)
  * [三十五、用css绘制一个三角形原理](#三十五、用css绘制一个三角形原理)
  * [三十六、品字布局](#三十六、品字布局)
  * [三十七、多列等高布局](#三十七、多列等高布局)
  * [三十八、什么是包含块？](#三十八、什么是包含块？)
  * [三十九、css的visibility属性的collapse值](#三十九、css的visibility属性的collapse值)
  * [四十、width是auto和width是100%的区别](#四十、width是auto和width是100%的区别)
  * [四十一、图片base64编码的优点和缺点](#四十一、图片base64编码的优点和缺点)
  * [四十二、'display'、'position'和'float'的相互关系？](#四十二、'display'、'position'和'float'的相互关系？)
  * [四十三、margin重叠](#四十三、margin重叠)
  * [四十四、](#四十四、)
  * [四十五、清除浮动](#四十五、清除浮动)
  * [四十六、清除浮动](#四十六、清除浮动)
  * [四十七、清除浮动](#四十七、清除浮动)
  * [四十八、清除浮动](#四十八、清除浮动)
  * [四十九、清除浮动](#四十九、清除浮动)
  * [五十、清除浮动](#五十、清除浮动)
  * [五十一、清除浮动](#五十一、清除浮动)
  * [五十二、清除浮动](#五十二、清除浮动)


* [vue总结](#vue总结)
  * [一、MVVM](#一、MVVM)
  * [二、vue双向绑定原理](#二、vue双向绑定原理)
  * [三、vue双向绑定原理再理解](#三、vue双向绑定原理再理解)
  * [四、diff算法](#四、diff算法)
  * [五、vue的nextTick](#五、vue的nextTick)
  * [六、vue2.0为什么不能检查数组变化](#六、vue2.0为什么不能检查数组变化)
  * [七、computed原理](#七、computed原理)
* [网络总结](#网络总结)
  * [一、http请求和响应](#一、http请求和响应)
  * [二、http的请求方法](#二、http的请求方法)
  * [三、http常用状态码](#三、http常用状态码)
  * [四、](#四、)
* [es6总结](#es6总结)
  * [一、promise](#一、promise)
  * [二、promise实现原理](#二、promise实现原理)
  * [三、async/await](#三、async/await)
  * [四、try...catch...](#四、try...catch...)
  * [五、Object&Map&WeakMap&Set&WeakSet](#五、Object&Map&WeakMap&Set&WeakSet)
* [node总结](#node总结)



<h1 id='html总结'>html总结<h1>

<h3 id='一、src和href的区别'>一、src和href的区别</h3>

#### 一、区别 ####

- src和href都是用来引用外部的资源，它们的区别如下：

   - src： (Source)是指向物件的来源地址，是**引入**，在 img、script、iframe 等元素上使用；表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。
   - href： 表示超文本**引用**，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。
   - src通常用作“拿取”（引入），href 用作 "连结前往"（引用）。

<h3 id='二、html语义化'>二、html语义化</h3>

#### 一、理解 ####

- 通俗的来讲就是从代码上来展示页面的结构，而不是从最终视觉上来展示结构。单纯的HTML代码是不带任何样式的只是用来标记这一段是标题、这一块是代码、那一个是要强调的内容等等，但是为什么我们只写HTML在浏览器中不同的标签也是有不同的样式呢？那是因为各个浏览器都自带的有相应标签的默认样式，为了方便在没有设定样式的情况下友好的展示页面。良好的语义化代码可以直接从代码上就能看出来那一块到底是要表达什么内容。

#### 二、为什么要使用HTML语义化标签 ####

- 为什么要使用语义化标签？我用DIV+CSS也能做出来一样的效果，确实单纯看效果两者并没有什么区别，但是页面不止是给人看的，机器也要看爬虫也要看。
- 随着 Web 规模的不断扩大，信息量之大已经不在人肉处理的范围之内了。这个时候人们开始用机器来处理 Web 上发布的各种内容，搜索引擎就诞生了。再后来，人们又设计了各种智能程序来对索引好的内容作各种处理和挖掘。所以让机器能够更好地读懂 Web 上发布的各种内容就变得越来越重要。机器也要借助 HTML 提供的语义以及自然语言处理的手段来「读懂」它们从网上获取的 HTML 文档，

#### 三、优点 ####

- 网页加载慢导致CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看。
- 提升用户体验，例如title、alt可用于解释名词或解释图片信息。
- 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息。简单来说，试想在H1标签中匹配到的关键词和在div中匹配到的关键词搜索引擎会吧那个结果放在前面。
- 方便其他设备（如屏幕阅读器、盲人阅读器、移动设备）更好的解析页面。
- 使代码更具可读性，便于团队开发和维护。

#### 三、写语义化代码应该注意什么 ####

- 尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；
- 不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
- 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
- 表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。


#### 四、常见的语义化标签 ####

- h1~h6 ，作为标题使用，并且依据重要性递减，h1 是最高的等级。
- p段落标记，知道了p作为段落，你就不会再使用 br 来换行了，而且不需要 br 来区分段落与段落。p 中的文字会自动换行，而且换行的效果优于 br 。段落与段落之间的空隙也可以利用 CSS 来控制，很容易而且清晰的区分出段落与段落。
- ul、ol、li，ul 无序列表，这个被大家广泛的使用，ol 有序列表不常用。在 Web 标准化过程中，ul 还被更多的用于导航条，本来导航条就是个列表，这样做是完全正确的，而且当你的浏览器不支持 CSS 的时候，导航链接仍然很好使，只是美观方面差了一点而已。
- dl、dt、dd，dl 就是“定义列表”。比如说词典里面的词的解释、定义就可以用这种列表。**dl不单独使用，它通常与dt和dd一起使用。dl开启一个定义列表，dt表示要定义的项目名称，dd表示对dt的项目的描述。**
- em、strong，em 是用作强调，strong 是用作重点强调。
- table、thead、tbody、td、th、caption， 就是用来做表格不要用来布局

#### 五、HTML5新增的那些 ####

- header元素：header 元素代表“网页”或“section”的页眉。
- footer元素：footer元素代表“网页”或“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。
- hgroup元素：
- nav元素：nav元素代表页面的导航链接区域。用于定义页面的主要导航部分。
- aside元素：aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section）
- section元素：section元素代表文档中的“节”或“段”，“段”可以是指一篇文章里按照主题的分段；“节”可以是指一个页面里的分组。section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。
- article元素：article元素最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。（特殊的section）除了它的内容，article会有一个标题（通常会在header里），会有一个footer页脚。

<h3 id='三、浏览器的怪异模式和标准模式'>三、浏览器的怪异模式和标准模式</h3>

#### 一、出现原因 ####

   - 由于历史原因，各个浏览器在对页面的渲染上存在差异，甚至同一浏览器在不同的版本中，对页面的渲染也会产生差异。
   - 在W3C标准出现之前，浏览器对页面的渲染没有统一的规范，产生了差异；由于W3C标准的推出，浏览器渲染页面有了统一的标准。
   - W3C标准推出之后，浏览器都开始采纳新标准，但存在一个问题就是旧的网页还能继续浏览，在标准出来之前，很多页面都是根据旧的渲染方法编写的，如果用新标准来渲染将会导致页面显示异常。所以为了保证浏览器的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法，这样浏览器渲染上就产生了Quircks mode（怪异模式或兼容模式）和Standars mode（标准模式或严格模式），两种渲染方法共存在一个浏览器上。
   
#### 二、如何决定使用哪一种渲染模式呢？####

- 在知道这个问题的答案之前我们先了解一些知识

  1. HTML-超文本标记语言

     - （1）超文本

         - 什么使文本文件：就是只有文本内容，不包含格式。例如

            - 在记事本中输入“带你出师、闯荡江湖！”，并设置相应的格式，但是在其它电脑上打开并没有显示同样的格式，说明其不包含任何格式信息。

         - 超文本：不仅仅能表示文本信息，还能表示音视频、格式等等信息。和普通文本相比，超文本文件中多了一些对文件内容的注释，这些注释表明了当前文字显示的位置、颜色等信息，更重要的是，在有些注释中包含了对用户计算机应做出何种反应的说明，这些注释的内容经过浏览器的翻译后就成了不同的操作。

           - 在word中输入同样的内容，同时设置格式，在另一个电脑上看到的是同样的内容和同样的格式。说明word文档中除了存储内容，还存储了格式等信息（document.xml,）ml就是标记语言（Markup Language）的缩写。

    - （2）标记语言

         - 标记语言注释文本的语言，以便计算机可以操作文本。例如

            - <p>我是一个段落</p>，这个例子由一个开始标记（<p>），一个结束标记（</p>）和一个将在屏幕上显示的的实际文本组成。这个标记就告诉了该段文字是一个段落。

  2. SGML

     - SGML是标准通用标记语言，它是一个用于定义标记语言的系统，它的组成包括语法定义，DTD，文件实例三部分。每一个使用SGML定义的标记语言都被称为SGML应用。
             

  3. XML,HTML,XHTML之间的区别

    - （1）XML是可扩展标记语言，它是基于SGML的，XML被设计用来存储和传输数据，它没有被预定义，需要自己定义标签，标签具有自我描述性。
    - （2）HTML是超文本标记语言，它也是基于SGML的，HTML被设计是用来显示数据的，它是被定义好的，不能自己定义标签
    - （3）XHTML是可扩展超文本标记语言，它是基于XML的，本质上说，XHTML是一个过渡技术，结合了部分XML的强大功能及大多数HTML的简单特性。建立XHTML的目的就是实现HTML向XML的过渡。

        - XHTML 出现的原因是：HTML 是一种语法形式比较松散的标记语言，语法要求也不严格。比如大小可以混用，属性值随便你加不加引号，单引号还是双引号也随便你，标签也可以不闭合。HTML 标准的制定者 W3C 一看这样下去不行，所谓无规矩不成方圆，所以就把 XML 的语法形式往 HTML 上一套，出现了 XHTML，所以你也可以把 XHTML 理解为 HTML 的严格语法形式，除此之外，其它方面基本一样

  4. HTML5

     - 现在说的HTML一般指HTML4.01，而HTML5是HTML的第五个修订版，HTML5本身并非技术而是标准， 它所使用的技术早已很成熟，国内通常所说的html5实际上是html与css3及JavaScript和api等的一个组合，大概可以用以下公式说明：HTML5≈HTML+CSS3+JavaScript+API
     - 如今的HTML5标准制定了两种实现语法HTML和XHTML。HTML不再基于任何特定的标记语言系统，它有自己完整的标准。而XHTML是XML的一个应用。

  5. DTD和DOCTYPE

    - （1）DTD为英文Document Type Definition,中文意思为“文档类型定义”，它规定了XML或html文件结构，为XML或html文件提供了语法和规则。在DTD中定义XML或html文件的结构，然后按照DTD的声明来编写XML或html文件。它就好像编程语言中的函数定义，在使用函数时要根据函数声明的格式进行来引用。
    - （2）DOCTYPE标签是一种标准通用标记语言的文档类型声明，声明文档的解析类型，它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的DTD（用什么样的文档标准）来解析文档。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML版本。

      - HTML4.01中<!DOCTYPE>的用法：

		<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

		解析：在上面的声明中，声明了文档的根元素是 html，它在公共标识符被定义为 "-//W3C//DTD XHTML 1.0 Strict//EN" 的 DTD 中进行了定义。浏览器将明白如何寻找匹配此公共标识符的 DTD。如果找不到，浏览器将使用公共标识符后面的 URL 作为寻找 DTD 的位置。

    - （3）HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。

       - 如果需要干净的标记，免于表现层的混乱，用HTML Strict DTD类型：
	
	      <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" " http://www.w3.org/TR/html4/strict.dtd">
	
       - Transitional DTD 可包含 W3C 所期望移入样式表的呈现属性和元素. 如果用户使用了不支持层叠样式表（CSS）的浏览器以至于你不得不使用 HTML 的呈现特性时，用TransitionalDTD 类型：
	
	     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" " http://www.w3.org/TR/html4/loose.dtd">
	
       - Frameset DTD 被用于带有框架的文档。除 frameset 元素取代了 body 元素之外，Frameset DTD 等同于 Transitional DTD：
	
	     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" " http://www.w3.org/TR/html4/frameset.dtd">

    - （4）XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。

       - 如果需要干净的标记，免于表现层的混乱，用XHTML Strict DTD类型：

         <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

       - Transitional DTD 可包含 W3C 所期望移入样式表的呈现属性和元素. 如果用户使用了不支持层叠样式表（CSS）的浏览器以至于你不得不使用 HTML 的呈现特性时，用     Transitional DTD 类型：

         <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

       - Frameset DTD 被用于带有框架的文档。除 frameset 元素取代了 body 元素之外，Frameset DTD 等同于 Transitional DTD：

         <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">

    - （5）HTML5的文档类型声明

         <!DOCTYPE HTML>

    - （6）HTML5为什么只需要写 <!DOCTYPE HTML>？

       - <!DOCTYPE> 声明不是一个 HTML 标签，它是用来告知 Web 浏览器页面使用了哪种 HTML 版本，<!DOCTYPE html>这个的意思就是告诉浏览器页面是html，并且使用html5最新规范来处理。HTML5 不是基于 SGML的，因此不需要对DTD进行引用，但是仍然需要doctype来规范浏览器的行为，至于不声明DOCTYPE的后果，就是某些css的处理方式是根据浏览器喜好定的，不是根据标准走的，这样同一份代码在不同浏览器可能产生不同效果，所以写之前必须声明！而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型

   
   - 所以回答前边的问题，声明了文档类型就是标准模式，不声明文档类型就是怪异模式。

#### 三、标准模式和怪异模式的区别 ####

 1. 盒模型不同

    - 标准盒模型：width = content的width,height = content的height
    - IE盒模型：width = content的width + padding + border，height = content的height + padding + border

 2. 可以设置行内元素的高宽

    - 在标准模式下，给span等行内元素设置wdith和height都不会生效，而在怪异模式下，则会生效。
    
 3. 可设置百分比的高度
        
    - 在标准模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。
    
 4. 用margin:0 auto设置水平居中在IE下会失效
        
    - 使用margin:0 auto在标准模式下可以使元素水平居中，但在怪异模式下却会失效, 怪异模式下的解决办法，用text一align属性:body{text一align:center};#content{text一align:left}
    
 5. 怪异模式下设置图片的padding会失效
    
 6. 怪异模式下Table中的字体属性不能继承上层的设置
    
 7. 怪异模式下white一space:pre会失效


<h3 id='四、script标签中defer和async的区别'>四、script标签中defer和async的区别</h3>

#### 一、问题引入 ####

- 在 HTML 中会遇到以下三类 script：

		<script src='xxx'></script>
		<script src='xxx' async></script>
		<script src='xxx' defer></script>

- async 和 defer 他们对于内联脚本无作用（即没有 src 属性的脚本）
- 那么这三类 script 有什么区别呢？

#### 二、script ####

- 浏览器在解析 HTML 的时候，如果遇到一个没有任何属性的 script 标签，就会暂停解析，先发送网络请求获取该 JS 脚本的代码内容，然后让 JS 引擎执行该代码，当代码执行完毕后恢复解析。所以，script 阻塞了浏览器对 HTML 的解析，如果获取 JS 脚本的网络请求迟迟得不到响应，或者 JS 脚本执行时间过长，都会导致白屏，用户看不到页面内容。

#### 三、async script ####

- async 表示异步，当浏览器遇到带有 async 属性的 script 时，请求该脚本的网络请求是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器会暂停解析，先让 JS 引擎执行代码，执行完毕后再进行解析。当然，如果在 JS 脚本请求回来之前，HTML 已经解析完毕了，那就啥事没有，立即执行 JS 代码，所以 async 是不可控的，因为执行时间不确定，你如果在异步 JS 脚本中获取某个 DOM 元素，有可能获取到也有可能获取不到。而且如果存在多个 async 的时候，它们之间的执行顺序也不确定，完全依赖于网络传输结果，谁先到执行谁。

#### 四、defer script ####

- defer 表示延迟，当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码，如果存在多个 defer script 标签，浏览器（IE9及以下除外）会保证它们按照在 HTML 中出现的顺序执行，不会破坏 JS 脚本之间的依赖关系。

#### 五、总结 ####

- 最后，根据上面的分析，不同类型 script 的执行顺序及其是否阻塞解析 HTML 总结如下：

  - script：

    - js执行顺序：在HTML中的标签顺序
    - 是否阻塞解析HTML：阻塞

  - async script：

    - js执行顺序：网络请求返回顺序
    - 是否阻塞解析HTML：可能阻塞，也可能不阻塞

  - defer script：

    - js执行顺序：在HTML中的标签顺序
    - 是否阻塞解析HTML：不阻塞

<h3 id='五、html5有哪些更新'>五、html5有哪些更新</h3>

#### 一、语义化标签 ####

- header：定义文档的页眉（头部）；
- nav：定义导航链接的部分；
- footer：定义文档或节的页脚（底部）；
- article：定义文章内容；
- section：定义文档中的节（section、区段）；
- aside：定义其所处内容之外的内容（侧边）；

#### 二、媒体标签 ####

1. audio：音频

	<audio src='' controls autoplay loop='true'></audio>

  - 属性：

	- controls 控制面板
	- autoplay 自动播放
	- loop=‘true’ 循环播放

2. video视频

	<video src='' poster='imgs/aa.jpg' controls></video>

   - 属性：

     - poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。
     - controls 控制面板
     - width
     - height

3. source标签

   - 因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。

	<video>
	 	<source src='aa.flv' type='video/flv'></source>
	 	<source src='aa.mp4' type='video/mp4'></source>
	</video>

#### 三、表单 ####

1. 表单类型：

- email ：能够验证当前输入的邮箱地址是否合法
- url ： 验证URL
- number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。
- search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。
- range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值
- color ： 提供了一个颜色拾取器
- time ： 时分秒
- data ： 日期选择年月日
- datatime ： 时间和日期(目前只有Safari支持)
- datatime-local ：日期时间控件
- week ：周控件
- month：月控件

2. 表单属性：

- placeholder ：提示信息
- autofocus ：自动获取焦点
- autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：

  - 表单必须提交过
  - 必须有name属性。

- required：要求输入框不能为空，必须有值才能够提交。
- pattern=" " 里面写入想要的正则模式，例如手机号patte="^(+86)?\d{10}$"
- multiple：可以选择多个文件或者多个邮箱
- form=" form表单的ID"

3. 表单事件：

- oninput 每当input里的输入框内容发生变化都会触发此事件。
- oninvalid 当验证不通过时触发此事件。

#### 四、进度条、度量器 ####

- progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少
- meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）

  - high/low：规定被视作高/低的范围
  - max/min：规定最大/小值
  - value：规定当前度量值
  - 设置规则：min < low < high < max

#### 五、DOM查询操作 ####

- document.querySelector()
- document.querySelectorAll()
  
  - 它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)

#### 六、Web存储 ####

- HTML5 提供了两种在客户端存储数据的新方法：

  - localStorage - 没有时间限制的数据存储
  - sessionStorage - 针对一个 session 的数据存储

#### 七、其他 ####

- 拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：

	<img draggable="true" />

- 画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。

	<canvas id="myCanvas" width="200" height="100"></canvas>

- SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准
- 地理定位：Geolocation（地理定位）用于定位用户的位置。

#### 八、总结： ####

- 新增语义化标签：nav、header、footer、aside、section、article
- 音频、视频标签：audio、video
- 数据存储：localStorage、sessionStorage
- canvas（画布）、Geolocation（地理定位）、websocket（通信协议）
- input标签新增属性：placeholder、autocomplete、autofocus、required
- history API：go、forward、back、pushstate

- 移除的元素有：

  - 纯表现的元素：basefont，big，center，font, s，strike，tt，u;
  - 对可用性产生负面影响的元素：frame，frameset，noframes；


<h3 id='六、块级元素和行内元素的区别'>六、块级元素和行内元素的区别</h3>

#### 一、行内元素与块级元素的区别 ####

1. 块级元素

   * 总是从新行开始，独占一行
   * 高度，宽度，内边距，外边距都可控制
   * 如果没有设置宽度，默认为父元素的100%
   * 它可以容纳行内元素和其他块级元素

2. 行内元素

   * 和其他元素都在一行上
   * 宽度就是它的文字或图片的宽度，不可改变
   * height无效(可以设置inline-height)，margin上下无效，padding上下无效
   * 内联元素只能容纳文本或者其他内联元素

#### 二、相互转换 ####

* display:inline
* display:block

#### 三、inline-block ####

* img、video、input、textarea、button

* inline-block 的元素（如input、img)既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。当然不仅仅是这些特性，比如 inline-block 元素也可以设置 vertical-align（因为这个垂直对齐属性只对设置了inline-block的元素有效） 属性。

#### 四、内联元素之间有时候会有空白间隔是为什么？

- 浏览器会把inline或inline-block内联元素间的换行符、空格符、制表符等合并为空白符，字体大小不为 0 的情况下，空白符自然占据一定的宽度，使用元素间会产生空隙

		  比如：<span>lalla</span>
		       <span>lllll</span>

  - 浏览器显示出来会有空格
  
          比如：<span>lalla</span><span>lllll</span>

  - 这样写就没有空格了


- 消除空隙

   - (1)全写在一行
	
			<div class="space">
			    <a href="##">惆怅</a><a href="##">淡定</a><a href="##">热血</a>
			</div>

   - (2)margin负边距

			如：.space a {
				    display: inline-block;
				    margin-right: -3px;
				}

     - margin负值的大小与上下文的字体和文字大小相关


  - (3)font-size:0

	      .space{
	            font-size:0;
	        }
	
		 .space a {
	            display: inline-block;
	            padding: .5em 1em;
	            background-color: #cad5eb;
	            font-size: 12px;
	        }

       
  - (4)letter-spacing(字符间距)
     - 可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。
	
			.space a {
	            display: inline-block;
	            padding: .5em 1em;
	            background-color: #cad5eb;
	            font-size: 12px;
	        }
	
	        .space {
	            letter-spacing: -3px;
	        }
	        .space a {
	            letter-spacing: 0;
	        }

  - (5)word-spacing(单词间距)
  
     - letter-spacing作用于所有字符，但word-spacing仅作用于空格字符，即只用来增加空格的间隙宽度

			.space a {
			            display: inline-block;
			            padding: .5em 1em;
			            background-color: #cad5eb;
			            font-size: 12px;
			        }
			
			.space {
			    word-spacing: -6px;
			}

#### 五、空元素 ####

- 空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：
- 常见的有：br、hr、img、input、link、meta；
- 鲜见的有：area、base、col、colgroup、command、embed、keygen、param、source、track、wbr。

<h3 id='七、webworker'>七、webworker</h3>

#### 一、前言 ####

- 我们都知道JS是单线程的，所有任务在一个线程上，一次只能做一件事。虽然可以通过AJAX、定时器等可以实现"并行"，但还是没有改变JS单线程的本质，把一些复杂的运算放在页面上执行，还是会导致很卡，甚至卡死。
- 而HTML5标准中的Web Worker为JS创造多线程环境，允许主线程创建Worker线程并给它分配任务，而且在主线程执行任务的时候，worker线程可以同时在后台执行它的任务，互不干扰。这让我们可以将一些复杂运算、高频输入的响应处理、大文件分片上传等放在worker线程处理，最后再返回给主线程。很大程度上缓解了主线程UI渲染阻塞的问题，页面就会很流畅

#### 二、异步和webworker的区别是什么？ ####

- 异步主要是当主线程在进行处理的时候，遇到同步的就直接运行，如果遇到异步的就将异步的方法放到事件队列中，当主线程中所有的同步任务处理完成之后，再进行异步任务的处理，这也就是为什么会出现setTIme 0 设定了时间之后不是立即执行了。
- 他们的一个主要的区别是：异步任务实质上是在主线程上进行处理的，而webworker是创建了一个新的子线程进行处理。

#### 三、那么webWork所创建的这个线程的主要的功能是什么呢 ####

- 主要是负责处理一些数据的问题，比如请求数据，他并不可以对DOM进行操作，他和主线程所在的上下文并不一致，而且他只能够处理网络请求的文件

#### 四、使用限制 ####

1. 同源限制

- 分配给worker线程运行的脚本文件，必须与主线程的脚本文件同源。

2. 文件限制

- Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自服务器。即使UI线程所属页面也是本地页面

3. DOM限制

- worker线程所在的全局对象，与主线程不一样，Worker 的全局对象WorkerGlobalScope，通过self或this引用,调用全局对象的属性和方法时可以省略全局对象。所以worker线程无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以使用navigator对象和location对象，不过只能只读不能改写；还可以使用XMLHttpRequest发送AJAX请求；还可以使用缓存。

4. 通信联系

- Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

#### 五、基本用法 ####

1. 主线程

- 浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。

		var worker = new Worker(jsUrl, options)

- Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。
	
		// 主线程
		var worker = new Worker('worker.js', { name : 'myWorker' });
		
		// Worker 线程
		self.name // myWorker

- Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。
- 然后，主线程调用worker.postMessage()方法，向 Worker 发消息。worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。

		worker.postMessage('这是发给worker线程的消息')

- 主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。通过 event.data 可以获取 Worker 子线程发过来的数据。

		worker.onmessage = function (event) {
		  doSomething(event.data);
		}
		function doSomething() {
		  ...
		}

- Worker 完成任务以后，主线程就可以把它关掉。

		worker.terminate()

2. Worker 线程

- Worker 线程内部需要有一个监听函数，监听message事件。通过 e.data 可以获取主线程发过来的数据。

		self.addEventListener('message', function (e) {
		  doSomething(e.data)
		}, false)
		function doSomething() {
		  ...
		}

- 上面代码中，self代表子线程自身，即子线程的全局对象。
- self.postMessage()方法用来向主线程发送消息。

		self.postMessage(...)

- Worker 也可以关闭自身

		self.close()

3.  Worker 加载脚本

- Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。

		importScripts('script1.js')

- 该方法可以同时加载多个脚本。

		importScripts('script1.js', 'script2.js');

    - 脚本的下载顺序是不固定的，但执行时会按照传入 importScripts() 中的文件名顺序进行，这个过程是同步的。直到所有脚本都下载并运行完毕， importScripts() 才会返回。

4. 错误处理

- 主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。Worker 内部也可以监听error事件。

		worker.addEventListener('error', function (event) {
		   console.log(
		    'ERROR: Line ', event.lineno, ' in ', event.filename, ': ', event.message
		  )
		});

#### 六、worker 线程直接写在主线程的页面里 ####

		const script = `onmessage = function (e) {
				        var data = e.data;
				        data.push('hello');
				        console.log('worker:', data); // worker: [1, 2, 3, "hello"]
				        postMessage(data);
                       }`;                                                                                                                                                                                                              
	                                                                                                                                                                                                                                      
		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
		var blob = new Blob([myTask]);
		var myWorker = new Worker(window.URL.createObjectURL(blob));
		
		myWorker.onmessage = function (e) {
		    var data = e.data;
		    console.log('page:', data); // page: [1, 2, 3, "hello"]
		    console.log('arr:', arr); // arr: [1, 2, 3]
		};

		var arr = [1,2,3];
		myWorker.postMessage(arr);

- worker与其主页面之间的通信是通过onmessage事件和postMessage（）方法实现的。
- 在主页面与Worker之间传递的数据是通过拷贝（深拷贝），而不是共享来完成的。传递给worker对象会自动经过序列化，接下来在另一端还需要反序列化，所以worker不会共享同一个实例，最终的结果就是在每次通讯结束时生成了数据的一个副本。
- 也就是说，worker与其主页面之间只能单纯的传递数据，不能传递复杂的引用类型：如通过构造函数创建的对象等。并且，传递的数据也是经过拷贝生成的一个副本，在一端对数据进行修改不会影响另一端。 

#### 七、线程间转移二进制数据 ####

- 因为主线程与 worker 线程之间的通信是拷贝关系，当我们要传递一个巨大的二进制文件给 worker 线程处理时(worker 线程就是用来干这个的)，这时候使用拷贝的方式来传递数据，无疑会造成性能问题。
- 幸运的是，Web Worker 提供了一中转移数据的方式，允许主线程把二进制数据直接转移给子线程。这种方式比原先拷贝的方式，有巨大的性能提升。
- 一旦数据转移到其他线程，原先线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面

		// 创建二进制数据
		var uInt8Array = new Uint8Array(1024*1024*32); // 32MB
		for (var i = 0; i < uInt8Array .length; ++i) {
		    uInt8Array[i] = i;
		}
		console.log(uInt8Array.length); // 传递前长度:33554432
		// 字符串形式创建worker线程
		var myTask = `
		    onmessage = function (e) {
		        var data = e.data;
		        console.log('worker:', data);
		    };
		`;
		
		var blob = new Blob([myTask]);
		var myWorker = new Worker(window.URL.createObjectURL(blob));
		
		// 使用这个格式(a,[a]) 来转移二进制数据
		myWorker.postMessage(uInt8Array.buffer, [uInt8Array.buffer]); // 发送数据、转移数据
		
		console.log(uInt8Array.length); // 传递后长度:0，原先线程内没有这个数据了


#### 八、多个worker线程 ####

- 在主线程内可以创建多个 worker 线程
- worker 线程内还可以新建 worker 线程，使用同源的脚本文件创建。
- 在 worker 线程内再新建 worker 线程就不能使用window.URL.createObjectURL(blob)，需要使用同源的脚本文件来创建新的 worker 线程，因为我们无法访问到window对象。

#### 九、共享Worker ####

- 上面介绍的worker是只能被生成它的父页面所调用，他是被一个主页面所独占的，这样的worker就叫做专用worker
- 除了专用worker，还有一种工作线程可以被多个主页面所调用，这种worker就叫做共享Worker。
- window提供shareWorker类来创建共享Worker

    // 传入的参数与专用worker一致
    const share = new ShareWorker(URL, options)
    
     //share返回一个port属性
     //share.port
     //share.port.start() 开放传输的端口
     //share.port.end() 关闭传输的端口
     //share.port.postMessage() 发送消息，必须先调用share.port.start方法

- 简单示例

  - UI主线程

		const worker = new SharedWorker('./worker.js')                                                                                                                                                                                             
		worker.port.addEventListener('message', e => {                                                                                                                                                                                             
		  console.log(e.data)                                                                                                                                                                                                                      
		}, false)                                                                                                                                                                                                                                  
		worker.port.start()  // 连接worker线程                                                                                                                                                                                                     
		worker.port.postMessage('hi')                                                                                                                                                                                                              
		                                                                                                                                                                                                                                              
		setTimeout(()=>{                                                                                                                                                                                                                           
		  worker.port.close() // 关闭连接                                                                                                                                                                                                          
		}, 10000)                                                                                                                                                                                                                                  
		

  - Shared Web Worker线程

		let conns = 0                                                                                                                                                                                                                              
		                                                                                                                                                                                                                                              
		// 当UI线程执行worker.port.start()时触发建立连接                                                                                                                                                                                           
		self.addEventListener('connect', e => {                                                                                                                                                                                                    
		  const port = e.ports[0]                                                                                                                                                                                                                  
		  conns+=1                                                                                                                                                                                                                                 
		                                                                                                                                                                                                                                              
		  port.addEventListener('message', e => {                                                                                                                                                                                                  
		    console.log(e.data)  // 注意console对象指向第一个创建Worker线程的UI线程的console对象。即如果A先创建Worker线程，那么后续B、C等UI线程执行worker.port.postMessage时回显信心依然会发送给A页面。                                            
		  })                                                                                                                                                                                                                                       
		                                                                                                                                                                                                                                              
		  // 建立双向连接，可相互通信                                                                                                                                                                                                              
		  port.start()                                                                                                                                                                                                                             
		  port.postMessage('hey')                                                                                                                                                                                                                  
		})                                             


#### 十、应用场景 ####

1. 使用专用线程进行数学运算

- Web Worker 最简单的应用就是用来做后台计算，而这种计算并不会中断前台用户的操作

2. 图像处理

- 通过使用从<canvas> 或者<video> 元素中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同 Workers 来做计算

3. 大量数据的检索

- 当需要在调用 ajax 后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在 Web Worker 中来做这些，避免冻结 UI 线程。

4. 背景数据分析

- 由于在使用 Web Worker 的时候，我们有更多潜在的 CPU 可用时间，我们现在可以考虑一下 JavaScript 中的新应用场景。例如，我们可以想像在不影响 UI 体验的情况下实时处理用户输入。利用这样一种可能，我们可以想像一个像 Word（Office Web Apps 套装）一样的应用：当用户打字时后台在词典中进行查找，帮助用户自动纠错等等。


<h3 id='八、HTML5离线缓存'>八、HTML5离线缓存</h3>

#### 一、什么是离线缓存？ ####

- HTML5 引入离线缓存（Application Cache），这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。

#### 二、优势 ####

- 离线浏览 - 用户可在应用离线时使用它们。
- 速度 - 已缓存资源加载得更快。
- 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。

#### 三、应用场景 ####

- h5游戏及一些页面内容不经常会变动、相对较为固定的内容。

#### 四、原理 ####

- HTML5的离线存储是基于一个manifest文件(缓存清单文件，后缀为.appcache)的缓存机制(不是存储技术)，通过这个文件上的清单解析离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态时，浏览器会通过被离线存储的数据进行页面展示。

#### 五、如何使用？ ####

- 目前html5 manifest也可以纯前端开发，不需要后端和服务器端的配合。
- html5 manifest纯前端开发是如何做的呢？之前的写法是

		<html lang="en" manifest="haorooms.manifest">

- 这种写法要在web 服务器上配置正确的 MIME-type，即 "text/cache-manifest"。例如对Apache服务器进行配置的时候，需要找到 ｛apache_home｝/conf/mime.type这个文件(.htaccess)，并在文件最后添加如下所示代码：text/cache-manifest .manifest 等等。

- 新的写法：

		<html manifest="haorooms.appcache">

- 扩展名".appcache"为后缀，不需要我们再进行服务器端的配置了。就可以纯前端的进行离线缓存的操作

- 使用过程：

  - step1:在文档的demo.html标签中设置manifest 属性，引用manifest文件 。
    - demo.appcache文件名和html文件名一致
    - manifest 属性可指向绝对网址或相对路径，但绝对网址必须与相应的网络应用同源。
  
		demo.html代码如下：
		
		&lt;!DOCTYPE html&gt;
		&lt;html lang="en" manifest="demo.appcache"&gt;
		&lt;head&gt;
		    &lt;meta charset="UTF-8"&gt;
		    &lt;title&gt;demo</title&gt;
		&lt;/head&gt;
		&lt;body&gt;
		    &lt;img src="img.jpg" height="500" width="900" alt=""&gt;
		    其它内容...
		&lt;/body&gt;
		&lt;/html&gt;

   - step2:配置manifest文件，在manifest文件中编写离线存储的资源。

        demo.appcache代码如下：
		
		CACHE MANIFEST
		#version 1.0
		CACHE：
		    img.jpg
		NETWORK:
		    *
		FALLBACK:
		    /demo/ /404.html

       - demo.appcache中的配置意为：demo.html中的img在首次下载后进行缓存；其他文件内容都需要因特网连接；如果无法建立因特网连接，则用 "404.html" 替代 /demo/ 目录中的所有文件。

      - manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。
      - CACHE MANIFEST写在第一行
      - manifest 文件可分为三个部分：

        - CACHE  
          - 在此标题下列出的文件将在首次下载后进行缓存。
          
        - NETWORK 
          - 在此标题下列出的文件需要与服务器的连接，且不会被缓存。可以使用*，表示除CACHE 外的所有其他资源/文件都需要因特网连接。
          
        - FALLBACK 
          - 在此标题下列出的文件指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。
          - 该段落的每条记录都列出两个 URI。第一个表示资源， 第二个表示后备页面。
          - 两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。


#### 六、更新缓存 ####

- 一旦应用被缓存，它就会保持缓存直到发生下列情况：

  - manifest文件被修改：给manifest添加或删除文件，都可更新缓存，如果我们更改了js，而没有新增或删除，前面例子中注释中的版本号、时间戳或者md5码等进行修改，都可以很好的用来更新manifest文
  - 通过javascript操作：html5中引入了js操作离线缓存的方法，下面的js可以手动更新本地缓存。window.applicationCache.update();
  - 清除浏览器缓存：如果用户清除了浏览器缓存（手动或用其他一些工具）都会重新下载文件。 

#### 七、浏览器是如何对 HTML5 的离线储存资源进行管理和加载？ ####

- 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。
- 离线的情况下，浏览器会直接使用离线存储的资源。

#### 八、注意事项 ####

- 更新清单中列出的某个文件并不意味着浏览器会重新缓存该资源，清单文件本身必须进行更改。
- 浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点5MB）。
- 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。
- 引用manifest的html必须与manifest文件同源，在同一个域下。FALLBACK中的资源必须和manifest文件同源。
- 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问。
- 浏览器会自动缓存引用manifest文件的HTML文件，这就导致如果改了HTML内容，也需要更新manifest 文件版本或者由程序来更新应用缓存才能做到更新。

#### 九、与传统浏览器缓存区别 ####

- 离线缓存是针对整个应用，浏览器缓存是单个文件。
- 离线缓存断网了还是可以打开页面，浏览器缓存不行。
- 离线缓存可以主动通知浏览器更新资源。


<h3 id='九、Canvas和SVG的区别'>九、Canvas和SVG的区别</h3>

#### 一、SVG ####

- SVG叫可伸缩的矢量图形，它是基于XML格式的，特点是不管放大多少倍都不会失真。 svg绘图时，每个图形都是以DOM节点的形式插入到页面中的，我们可以通过js来直接操作这些图形，所以支持事件处理器

1. 圆形

		<svg width="300" height="180">
		  <circle cx="30"  cy="50" r="25" />
		  <circle cx="90"  cy="50" r="25" class="red" />
		  <circle cx="150" cy="50" r="25" class="fancy" />
		</svg>
		
		.fancy {
		  fill: none;
		  stroke: black;
		  stroke-width: 3pt;
		}

- cx,cy,r表示圆心横纵坐标，半径。fill填充色，stroke描边色，stroke-width描边宽度。

2. 直线

		<svg width="300" height="180">
		  <line x1="0" y1="0" x2="200" y2="0" style="stroke:rgb(0,0,0);stroke-width:5" />
		</svg>

3. <polyline>标签绘制一根折线

		<svg width="300" height="180">
		  <polyline points="3,3 30,28 3,53" fill="none" stroke="black" />
		</svg>

4. <polygon>标签用于绘制多边形

		<svg width="300" height="180">
		  <polygon fill="green" stroke="orange" stroke-width="1" points="0,0 100,0 100,100 0,100 0,0"/>
		</svg>

#### 二、canvas ####

- 和svg不同，canvas是基于像素进行渲染的，通过javascript进行绘制。所以一旦图形被绘制完成，就不会再得到浏览器的关注，不支持事件绑定。

		<canvas id="myCanvas" width="200px" height="100px" style="border:1px solid #333">
		</canvas>
		<script type="text/javascript">
		    var c=document.getElementById("myCanvas");
		    var ct=c.getContext("2d");
		    ct.fillStyle="#ccc";
		    ct.fillRect(5,10,150,10);
		</script>

- canvas标签本身并没有绘制图像的能力，是通过javascript绘制的

#### 三、区别 ####

- 在HTML5之前，人们通常使用SVG来在页面上绘制出图形。SVG使用XML来定义图形，就像使用HTML标签和样式定义DIV一样，我们也可以将一个空白的DIV想象为长方形的SVG，两者的设计思想是相通的，SVG的本质就是一个DOM元素。而Canvas则不同，Canvas提供的是 JavaScript 的绘图 API，而不是像 SVG那样使用XML 描述绘图，通过JavaScript API直接完成绘制，比起修改XML来说要更简便、更直接。
- 除了定义的方式不同，Canvas和DOM（当然也包含SVG）的差异更多的体现在浏览器的渲染方式上。浏览器在做页面渲染时，Dom元素是作为矢量图进行渲染的。每一个元素的边距都需要单独处理，浏览器需要将它们全都处理成像素才能输出到屏幕上，计算量十分庞大。当页面上内容非常多，存在大量DOM元素的时候，这些内容的渲染速度就会变得很慢。而Canvas与DOM的区别则是Canvas的本质就是一张位图，类似img标签，或者一个div加了一张背景图（background-image）。所以，DOM那种矢量图在渲染中存在的问题换到Canvas身上就完全不同了。在渲染Canvas时，浏览器只需要在JavaScript引擎中执行绘制逻辑，在内存中构建出画布，然后遍历整个画布里所有像素点的颜色，直接输出到屏幕就可以了。不管Canvas里面的元素有多少个，浏览器在渲染阶段也仅需要处理一张画布。
- canvas绘画出来的图形一般成为位图，也就是放大缩小的情况下会出现失真的情况，svg绘制的图形是矢量图，不存在失真的情况
- canvas绘制的图形不会出现在DOM结构中，svg绘制的会存在于DOM结构
- canvas类似于动画，每次图形的改变都是先清除原来的图形，然后把新的图形画上去，svg则是可以直接通过js来进行某些操作
- canvas依赖于分辨率，svg不依赖分辨率
- canvas最适合图像密集型的游戏，其中的许多对象会被频繁重绘，svg不适合游戏应用










































<h1 id='js总结'>js总结<h1>

<h3 id='一、js事件流'>一、js事件流</h3>

1.事件流

   - js事件流就是指，元素触发事件时，事件在页面中的传播过程。它一共分为三个阶段，捕获阶段、处于目标阶段和冒泡阶段。捕获阶段就是由最不具体的节点先接收事件，由上至下依次传播直至目标节
点。冒泡阶段就是目标节点先接收事件，由下至上依次传播直至window。

   - 默认情况下，事件使用冒泡事件流，不使用捕获事件流。addEventListener方法可以显式的指定事件是使用捕获事件流还是冒泡事件流。addEventListener事件接受三个参数，第一个事件名称，第二个是作为事件处理程序的函数，第三个为一个布尔值，true表示捕获阶段，false表示冒泡阶段（btn.addEventListener('click',handler,false)）。addEventListener是DOM2级事件，与DOM0级事件（btn.onclick)不同的是同一事件（如click)它可以添加多个事件处理程序,执行顺序按照添加时的顺序。与之对应的移除事件处理程序的方法是removeEventListener,接收的参数和添加事件处理程序时的参数是相同的，所以这也意味着，添加的匿名事件处理程序函数将无法移除。DOM0级移除（btn.onclick=null）。

   - IE实现了和DOM中类似的两个方法attachEvent和detachEvent,这两个方法接收相同的两个参数，事件名称(注意是onclick)和事件处理程序函数（btn.attachEvent('onclick',handler)）。由于IE8及更早的版本只支持事件冒泡，所以通过attachEvent添加的事件都会被添加到冒泡阶段。attachEvent和addEventListener一样都可以为同一个元素添加相同的事件，不过它俩不同的是，attachEvent添加的事件处理程序不是以添加的顺序执行的，而是以相反的顺序执行的。


   - IE中的attachEvent和DOM中的方法的主要区别还在于，事件处理程序的作用域不同，使用DOM级方法的情况下，事件处理程序会在其所属元素的作用域运行，this执行该元素。使用attachEvent情况下，事件处理程序会在全局作用域中运行，因此this等于window

 2.事件委托（事件代理）

  - 事件委托就是利用了事件冒泡，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。事件委托的好处就是将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a,span,div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历

 
 3.阻止冒泡和默认行为

   - event.preventDefault可以阻止默认行为但不阻止冒泡
   - event.stoppropagation 可以阻止冒泡但不阻止默认行为
   - return false 可以阻止默认行为但不阻止冒泡



<h3 id='二、token、cookie、session'>二、token、cookie、session</h3>

#### 一、产生背景 ####

- 由于http是无状态的，它不会去记录服务器和浏览器的会话信息，对它来说每一次请求都是一个新的请求。随着网络的发展，比如购物车功能就必须知道用户身份才能够执行接下来的一系列操作，所以就产生了cookie、session、token来帮助服务器来记住一些信息。

#### 二、cookie ####

1. 概念

   - cookie是http头部的一个字段，它是由服务器产生的，是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上
   - cookie是存在当前访问服务器的浏览器中的，比如你使用的是chrome浏览器，cookie就会存在chrome浏览器中，如果此时你换成了Firefox等其他的浏览器，因为Cookie刚才是存储在Chrome里面的，所以服务器又蒙圈了，不知道你是谁，就会给Firefox再次发送一个cookie。

2. cookie识别用户身份过程：

   - 浏览器第一次访问服务端时，服务器此时肯定不知道他的身份，所以创建一个独特的身份标识数据，格式为key=value（比如：isLogin=true），放入到Set-Cookie字段里，随着响应报文发给浏览器。
   - 浏览器看到有Set-Cookie字段以后就知道这是服务器给的身份标识，于是就保存起来，下次请求时会自动将此key=value值放入到Cookie字段中发给服务端。
   - 服务端收到请求报文后，发现Cookie字段中有值，就能根据此值识别用户的身份然后提供个性化的服务。

3. cookie的缺点：

   - 用户本人可以通过修改document.cookie="isLogin = true"伪造登陆凭证
   - 如果将账户的一些信息都存入Cookie中的话，一旦信息被拦截，那么我们所有的账户信息都会丢失掉。
   - 能存储的数据量不能超过 4kb
   - 一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie
   - 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token


#### 三、session ####

1. 概念

     - session 是另一种记录服务器和客户端会话状态的机制
     - session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中

2. session认证流程：

     - 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，开辟了一块 Session 空间（创建了Session对象），同时生成一个SessionId
     - 请求返回时将此 Session 的唯一标识信息 SessionId放入到Set-Cookie字段里，随着响应报文发给浏览器
     - 浏览器接收到服务器返回的 SessionId 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionId 属于哪个域名
     - 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionId，再根据SessionId查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

3. 有了 Cookie 为什么还要 Session

     - 使用 session 只需要在客户端保存一个 sessionId，实际上大量数据都是保存在服务端。如果全部用 cookie，数据量大的时候客户端是没有那么多空间的（ 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie）。
     - 全部在客户端保存，服务端无法验证，这样伪造和仿冒会更加容易。（伪造一个随机的id很难，但伪造另一个用户名是很容易的）
     - cookie 只是实现 session 的其中一种方案。虽然是最常用的，但并不是唯一的方法。(禁用cookie后还有其他方法存储，比如放在url中,但放在url中涉及安全性和SEO的影响)
     - 全部保存在客户端，那么一旦被劫持，全部信息都会泄露
     - 客户端数据量变大，网络传输的数据量也会变大

4. session缺点

     - Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。（解决方法：Nginx ip_hash 策略、Session 复制、共享 Session）
     - Session存储在服务器，大量的存储会给服务器带来压力

5. 如何考虑分布式 Session 问题？

      - 在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

      - 分布式 Session 一般会有以下几种解决方案：

         - （1）session 复制

             - 采用 session 复制方案，整体的流程非常简单：假设现在有三台服务器，当一个 session 在其中一台服务器上被创建，则同时把这个 session 复制到其他两台服务器上。这样当用户的请求无论到达哪台服务器，都会有相应的 session 数据。
             - 这种方案的优势在于服务器可以任意水平扩展，每个服务器都保留着所有的 session 信息，当加入一台服务器只需要把所有的 session 信息复制过去即可。
             - 但是劣势更加明显
                - 每个服务器上都保存着全部的 session 信息，服务器占用的资源大大增加。
                - session 同步需要占用网络带宽，最重要的是如果采用的异步复制方式，数据会有短暂性的不一致，可能会导致用户访问失败。

         - （2）Nginx ip_hash 策略
         
             - nginx 可以根据“hash_ip”算法将同一个 IP 的请求固定到某台服务器，这样来自于同一个 ip 的 session 请求总是请求到同样的服务器。
             - 这种方式比 session 同步方式要好很多，每台服务器只存储对应的 session 数据，这大大节省了内存资源，而且服务器之间没有数据同步过程。当有新服务器加入的时候，只需要修改负载均衡器的配置即可，这样很方便就支持了服务器水平扩展。
             - 但是，同时也面临着一些不足

                - 服务器重启意味着对应的 session 信息丢失，这在一些重要的业务场景中是不允许的
                - 服务器的水平扩展需要修改负载均衡器的配置，修改之后可能会导致之前的 session 重新分布，这样会导致一部分用户路由不到正确的 session

        - （3）共享 Session

            - 现在应用更广泛的分布式 session 技术是把 session 数据彻底从业务服务器中剥离，单独存储在其他外部设备中，而这些外部设备可以采用主备或者主从，甚至集群的模式来达到高可用。比如现在最常用的方案是把 session 数据存储在 redis 中，虽然从 redis 读写 session 数据需要花费一定的网络耗时，但是对于一般的应用来说在可以接受范围之内。
            - 这种方案好处是整体架构更加清晰，也更加灵活，应用的服务器整体扩展能力再也不用考虑 session 的影响，而 session 的问题被转移到外部设备，通常可以利用内存性 NOSql 来解决性能问题，而这些外部设备一般都会有对应的分布式集群方案，例如 redis，可以利用主从或者哨兵模式甚至集群来提供更大规模的数据支撑能力。

  ![](//images/共享session.jpg)
<img src="knowledge-notes/面试复习总结/images/session.jpg" />


6. 禁用cookies，如何使用session

    - 如果禁用了 Cookies，服务器仍会将 sessionId 以 cookie 的方式发送给浏览器，但是，浏览器不再保存这个cookie (即sessionId) 了。
    - 如果想要继续使用 session，需要采用 URL 重写 的方式来实现

#### 四、Cookie 和 Session 的区别 ####

- 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，session在超过一定的操作时间(通常为30分钟)后会失效，但是当关闭浏览器时，为了保护用户信息，会自动调用session.invalidate()方法，该方法会清除掉session中的信息。
- 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。


#### 五、token ####

1. 概念

     - Token是在服务端将用户信息以及用户信息经过算法生成的签名传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息通过验证签名判断该请求的合法性。
     - 基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

2. token认证流程：

     - 客户端使用用户名跟密码请求登录
     - 服务端收到请求，去验证用户名与密码
     - 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
     - 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
     - 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
     - 服务端收到请求，然后去验证客户端请求里面带着的 token（使用相同加密算法加密，将结果和token中的签名对比） ，如果验证成功，就向客户端返回请求的数据

3. token 的过期

   - 那我们如何控制 token 的有效期呢？很简单，把「过期时间」和数据一起塞进去，验证时判断就好

4. token优点

    - 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
    - token 完全由应用管理，所以它可以避开同源策略

5. access token和refresh token

    - token，作为权限守护者，最重要的就是「安全」。业务接口用来鉴权的 token，我们称之为 access token。越是权限敏感的业务，我们越希望 access token 有效期足够短，以避免被盗用。但过短的有效期会造成 access token 经常过期，过期后怎么办呢？

        - 一种办法是，让用户重新登录获取新 token，显然不够友好，要知道有的 access token 过期时间可能只有几分钟。
        - 另外一种办法是，再来一个 token，一个专门生成 access token 的 token，我们称为 refresh token。

            - access token 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活
            - refresh token 用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理

        - 有了 refresh token 后，几种情况的请求流程变成这样：
   ![](./images/access token&refresh token.jpg)



#### 六、JWT ####

1. 概念

     - JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。它是一种成熟的 token 字符串生成方案,相当于规定了怎样定义一个token

2. JWT由三部分组成：头部、负载和签名

     - Header

         - Header通常由两部分组成：token的类型(即 JWT)和使用的签名算法，例如 HMAC SHA256 或 RSA。
         
			例如：{

				  "alg": "HS256",
				  "typ": "JWT"
				 }

        - 指定类型和签名算法后，Json 块被 Base64Url 编码形成 JWT 的第一部分。


    - Payload
    
        - 负载是Token要存储的信息（比如存储用户姓名和昵称信息）
        - JWT 规定了7个官方字段，供选用。
        
            - iss (issuer)：签发人
            - exp (expiration time)：过期时间
            - sub (subject)：主题
            - aud (audience)：受众
            - nbf (Not Before)：生效时间
            - iat (Issued At)：签发时间
            - jti (JWT ID)：编号
 
       - 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

			例如：{
	
				  "name": "John Doe",
				  "admin": true
				}
        - 然后 payload Json 块会被Base64Url 编码形成 JWT 的第二部分。


    - signature

       - JWT 的第三部分是一个签证信息，这个签证信息由三部分组成
       
         - header (base64后的)
         - payload (base64后的)
         - secret（密钥）

       - 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名形成JWT的第三部分

			HMACSHA256(
			  base64UrlEncode(header) + "." +
			  base64UrlEncode(payload),
			  secret)

    - 最后将这三部分用.号连接，就可以得到了一个Token了。
   ![](./images/JWT.jpg)

3. JWT 的几个特点：

    - JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
    - JWT 不加密的情况下，不能将秘密数据写入 JWT。
    - JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
    - JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
    - JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
    - 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。


#### 七、session和token ####
    
- session 是「种在 cookie 上、数据存在服务端」的认证方案，token 是「客户端存哪都行、数据存在 token 里」的认证方案。
- token保存在客户端，在分布式环境下不需要做额外工作。而session因为保存在服务端，分布式环境下需要实现多机数据共享
- session一般需要结合Cookie实现认证，所以需要浏览器支持cookie，因此移动端无法使用session认证方案
- JWT的payload使用的是base64编码的，因此在JWT中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全
- 经过编码之后JWT将非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以JWT一般放在local storage里面。并且用户在系统中的每一次http请求都会把JWT携带在Header里面，HTTP请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用token的HTTP请求比使用session的开销大得多
- session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 token 是令牌，访问资源接口（API）时所需要的资源凭证。token 使服务端无状态化，不会存储会话信息。
- session 和 Token 并不矛盾，作为身份认证 token 安全性比 session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 session 来在服务器端保存一些状态。

<h3 id='三、深入理解函数执行上下文'>三、深入理解函数执行上下文</h3>

#### 一、词法作用域（静态作用域）和动态作用域 ####

1. 作用域

- 作用域是指程序源代码中定义变量的区域，作用域规定了如何查找变量，也就是当前执行代码对变量的访问权限
- JavaScript采用词法作用域，也叫静态作用域

2. 静态作用域和动态作用域

- 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。
- 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

			var value = 1;
	
			function foo() {
			    console.log(value);
			}
			
			function bar() {
			    var value = 2;
			    foo();
			}
			
			bar();
			
			// 结果是 ???

        上面例子，如果是静态作用域结果就为1，动态作用域结果就为2，原因我们看接下来的分析

3. 作用域链

    - 我们知道在执行一段代码的时候，会创建对应的执行上下文，执行上下文中包含了this、变量对象VO、作用域链。但在创建执行上下文之前，我们还有一个创建作用域链的过程，最后我们的作用域链就是这两个作用域链之和。
    - 上面我们讲到函数的作用域在函数定义的时候就已经决定了，这是因为我们的函数有一个内部属性[[scope]]，当函数创建时，就会保存所有的父变量对象到其中。当执行函数时，创建函数的执行上下文，先创建变量对象，然后复制函数[[scope]]属性创建作用域链，将变量对象加到作用域的最前边形成完整作用域链，开始执行函数，随着函数的执行，修改 AO 的属性值。

         例：
			var value = 1;
		
			function foo() {
			    console.log(value);
			}
			
			function bar() {
			    var value = 2;
			    foo();
			}
			
			bar(); // 1

     - 过程分析：

        - （1）foo函数被创建，保存作用域链到内部属性[[scope]]
        
               foo.[[scope]] = [
				    globalContext.VO
				];
        
        - （2）bar函数被创建，保存作用域链到内部属性[[scope]]

               bar.[[scope]] = [
				    globalContext.VO
				];

        - （3）执行bar函数，创建bar函数执行上下文，bar函数执行上下文被压入执行上下文栈

				ECStack = [
				    barContext,
				    globalContext
				];
		
        - （4）barscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

				barContext = {
				    Scope: barscope.[[scope]],
				}

        - （5）第二步：用 arguments 创建变量对象，随后初始化活动对象，加入形参、函数声明、变量声明

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        value: undefined
				    }，
				    Scope: barscope.[[scope]],
				}

        - （6）第三步：将变量对象压入 barscope 作用域链顶端

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        value: undefined
				    },
				    Scope: [VO, [[Scope]]]
				}

       - （7）准备工作做完，开始执行函数，随着函数的执行，函数执行时，变量对象（VO）变为活动对象AO，修改 AO 的属性值

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        vaule: 2
				    },
				    Scope: [AO, [[Scope]]]
				}

       - （8）执行过程中，遇到foo()，则创建foo的执行上下文将其压入执行上下文栈中，和上边过程一样，复制函数[[scope]]属性创建作用域链

                fooContext = {
				    Scope: fooscope.[[scope]],
				}

       - （9）创建变量对象
 
                fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				    }，
				    Scope: fooscope.[[scope]],
				}

         - （10）将变量对象压入 fooscope 作用域链顶端

				fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        }				   
				    },
				    Scope: [VO, [[Scope]]]
				}

               这块就能看出，foo的作用域链是自己的变量对象+定义foo时的父级作用域链，所以最后结果为1
                
        - （11）准备工作做完，开始执行函数，随着函数的执行，函数执行时，变量对象（VO）变为活动对象AO，修改 AO 的属性值

				fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				    },
				    Scope: [AO, [[Scope]]]
				}


#### 二、函数执行上下文（EC）####
https://segmentfault.com/a/1190000009041008

- 每当控制器转到ECMScript的可执行代码的时候，就会进入一个执行上下文
- 可执行代码包括：

   - 全局代码：例如加载外部js文件或者本地的<script></script>标签内的代码。全局代码不包括任何函数体内的代码，这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。
      
   - 函数代码：任何一个函数体内的代码，需要注意的是，任何一个函数体的代码是不包括内部函数的代码的

   - Eval代码：eval内部的代码

#### 三、执行环境栈（ECS）####

 - 我们知道js引擎是单线程的，也就是说同一时间只能发生一件事情，其他事情将被放在执行栈中排队等待。
 
 - 所以当浏览器首次载入你的脚本的时候，默认进入全局执行上下文，这时全局上下文就会被推入执行环境栈。如果你在你的全局代码中调用一个函数,这时，你的程序时序将进入被调用的函数，并创建一个新的执行上下文，并将该执行上下文推入执行环境栈的顶部。如果你调用的函数内部又调用了一个内部函数，会重复上述过程。

 - 上述是在一层一层的创建执行上下文的过程，并没有执行代码，该过程中会存在一个变量对象（VO）。
 
 - 先创建完所有的执行上下文之后才开始执行上下文，该过程中会存在一个活动对象（AO）。
 
 - 浏览器总会执行位于栈顶的执行上下文，一旦当前执行上下文函数执行结束，它将从栈顶弹出，并将上下文控制权交给当前栈

#### 四、变量对象（VO）和活动对象（AO）####

 1. 变量对象（VO）

    - js的执行上下文都有一个对象用来存放执行上下文可被访问但是不能被delete的函数标识符、形参、变量声明等，这个对象就叫变量对象（VO），它们会被挂在这个对象上。对象的属性名对应它们的名字，对象的属性值对应它们的值，但这个对象是规范上的或者说是引擎实现上的不可在js环境中访问到的活动对象。

 2. 活动对象（AO）

    - 有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文中的变量对象就会被激活，也就是该上下文中的函数标识符、形参、变量声明等就可以被访问到了。

#### 五、执行上下文建立细节分析 ####

1. 创建阶段（当函数被调用，函数所在的执行上下文被推入执行环境栈中，还未执行函数内部代码）

    - 创建作用域链（Scope Chain）
    - 创建参数、函数和变量
    - 求this的值

      - 我们可以将每个执行上下文抽象成一个对象，这个对象具有三个属性

	          ECObj={
	             scopeChain:{/*变量对象+所有腹肌执行上下文的变量对象*/}，
	             variableObject:{/*函数 arguments/参数，内部变量和函数声明*/}，
	             this:{}
	          }

2. 执行阶段

   - 初始化变量的值和函数的引用，执行代码

3. 解释器执行代码流程

   - （1）查找调用函数的代码
      
   - （2）执行代码之前，先进入创建执行上下文阶段

      - 初始化作用域链

         - 进入一个新的执行环境之后就会创建该环境的作用域链。
         - 作用链的作用是保证执行环境有权访问的所有变量和函数的有序访问。
         - 作用链的前端始终都是当前执行环境的活动对象，作用域链的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。

      - 创建变量对象（VO）

         - 创建arguments对象，检查上下文
         - 初始化参数名称和值并创建引用的复制
         - 扫描上下文的函数声明（而非函数表达式）

           - 为发现的每一个函数，在变量对象上创建一个属性，属性名字为函数名字，其有一个指向函数在内存中的引用
           - 如果有和函数名字相同的属性已经存在，则就不用新建函数名字的属性了，直接覆盖该属性
                
         - 扫描上下文的变量声明

           - 为发现的每个变量声明，在变量对象上创建一个属性，属性名字为变量的名字，并且将变量的值初始化为undefined
           - 如果有和变量名字相同的属性已经存在，将不会进行任何操作并继续扫描（注意和函数声明的区别）

         - 求出上下文内部的this值

   - （3）激活/代码执行阶段

       - 在当前上下文上运行/解释函数代码，并随着代码一行行执行为变量赋值

			     例如：function foo(i){
			            var a = 'hello'
			            var b = function(){}
			            function c(){}
			          }
			
			          foo(22)

    
        - 当我们调用foo(22)时，先进入创建执行上下文阶段(VO初始化阶段)

    
			         ECObj={
			           scopeChain:{...},
			           variableObject:{
			             arguments:{
			                0:22,
			                length:1
			             },
			             i:22,
			             c:pointer to function c(),
			             a:undefined,
			             b:undefined
			           },
			           this:{...}
			         }
 
        - 正如上述过程所述：VO的初始化过程是有顺序的：形参->函数声明->变量声明

           - 形参：变量对象的一个属性，其属性名为形参的名字，属性值为实参的值，如果没有传递参数，其值为undefined
           - 函数声明：变量对象的一个属性，其属性名和属性值都是函数对象创建出来的，如果变量对象已经包含了相同名字的属性，则替换它的值

		                例：function foo1(a){
		                     console.log(a)
		                     function a(){}
		                   }
		
		                   foo1(20) //'function a(){}'

           - 变量声明：变量对象的一个属性，其属性名即如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性

		                例1：function foo2(a){
		                      console.log(a)
		                      var a = 10  
		                    }
		              
		                    foo2(20) //'20'
		
		                例2：function foo2(){
		                      console.log(a)
		                      var a = 10  
		                      function a(){}
		                    }
		              
		                    foo2(20) //'function a(){}'

           - 函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值

			                例1：function foo3(a){
			                      var a = 10  
			                      function a(){}
			                      console.log(a)
			                    }
			               
			                    foo3(20) //'10'
			
			                
			                例2：function foo3(a){
			                      var a
			                      function a(){}
			                      console.log(a)
			                    }
			               
			                    foo3(20) //'function a(){}'


       - （4） 然后是执行阶段（AO）

            - 正如上面过程所述，创建的过程仅负责处理定义属性的名字，而并不为他们指派具体的值，当然还有对形参/实参的处理。一旦创建阶段完成，执行流进入函数并且激活/代码执行阶段，看下面函数执行完成后的样子：

                          ECObj={
				           scopeChain:{...},
				           variableObject:{
				             arguments:{
				                0:22,
				                length:1
				             },
				             i:22,
				             c:pointer to function c(),
				             a:'hello',
				             b:pointer to function privateB()
				           },
				           this:{...}
				         }


#### 六、总结 ####

  1. 函数作用域链分为两部分，[[scope]]中的作用域链+变量对象
  1. EC分为两个阶段。创建执行上下文和执行代码
  2. 每个EC都可以抽离成一个对象，这个对象具有三个属性，分别为：作用域链Scope，VO/AO（VO和AO只能有一个）以及this
  3. 函数EC中的AO在进入函数EC时，确定了arguments对象的属性，在执行函数EC时，其他变量属性具体化
  4. EC创建过程是有先后顺序的：参数声明 > 函数声明 > 变量声明
  

<h3 id='四、闭包'>四、闭包</h3>

#### 一、概念 ####

- 闭包是指有权访问另一个函数作用域中的变量的函数
 - 闭包的本质就是当前环境中存在指向父级作用域的引用

         例：function f1() {
			  var a = 2
			  function f2() {
			    console.log(a);//2
			  }
			  return f2;
			}
			var x = f1();
			
- 上面函数如果只执行到这里是没有产生闭包的，因为当js引擎一进入程序的时候，就创建了一个全局执行上下文。然后在全局代码中又调用了函数f1()这时又产生了f1的函数执行上下文，由于没有调用f2函数，所以没有产生f2函数的执行上下文，所以当前环境指的是f1的作用域，所以当前环境中并没有对父级作用域的引用，所以没有产生闭包

- 如果要产生闭包最后加一句 x()就可以了

#### 二、原理理解 ###

1. 理论上的闭包

- 闭包是指那些能够访问自由变量的函数。
- 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
- 由此，我们可以看出闭包共有两部分组成：

   - 闭包 = 函数 + 函数能够访问的自由变量

				举个例子：
				
				var a = 1;
				
				function foo() {
				    console.log(a);
				}
				
				foo();

    - foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。
    - 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……

- 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。

2. 实践上的闭包

- ECMAScript中，闭包指的是：

    - 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
    - 从实践角度：以下函数才算是闭包：
    
       - 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
       - 在代码中引用了自由变量

	     	var scope = "global scope";
			function checkscope(){
			    var scope = "local scope";
			    function f(){
			        return scope;
			    }
			    return f;
			}
			
			var foo = checkscope();
			foo();

         - 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
         - 全局执行上下文初始化
         - 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
         - checkscope 执行上下文初始化，创建变量对象、作用域链、this等
         - checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
         - 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
         - f 执行上下文初始化，创建变量对象、作用域链、this等
         - f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

      - 了解到这个过程，我们应该思考一个问题，那就是：

         - 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

            - 我们知道 f 执行上下文维护了一个作用域链：

					fContext = {
					    Scope: [AO, checkscopeContext.AO, globalContext.VO],
					}

              - 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。

     - 所以，让我们再看一遍实践角度上闭包的定义：

       - 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
       - 在代码中引用了自由变量


					接下来，看这道刷题必刷，面试必考的闭包题：
					
					var data = [];
					
					for (var i = 0; i < 3; i++) {
					  data[i] = function () {
					    console.log(i);
					  };
					}
					
					data[0]();
					data[1]();
					data[2]();
					答案是都是 3，让我们分析一下原因：
					
					当执行到 data[0] 函数之前，此时全局上下文的 VO 为：
					
					globalContext = {
					    VO: {
					        data: [...],
					        i: 3
					    }
					}
					当执行 data[0] 函数的时候，data[0] 函数的作用域链为：
					
					data[0]Context = {
					    Scope: [AO, globalContext.VO]
					}
					data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。
					
					data[1] 和 data[2] 是一样的道理。
					
					所以让我们改成闭包看看：
					
					var data = [];
					
					for (var i = 0; i < 3; i++) {
					  data[i] = (function (i) {
					        return function(){
					            console.log(i);
					        }
					  })(i);
					}
					
					data[0]();
					data[1]();
					data[2]();
					当执行到 data[0] 函数之前，此时全局上下文的 VO 为：
					
					globalContext = {
					    VO: {
					        data: [...],
					        i: 3
					    }
					}
					跟没改之前一模一样。
					
					当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：
					
					data[0]Context = {
					    Scope: [AO, 匿名函数Context.AO globalContext.VO]
					}
					匿名函数执行上下文的AO为：
					
					匿名函数Context = {
					    AO: {
					        arguments: {
					            0: 0,
					            length: 1
					        },
					        i: 0
					    }
					}
					data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。
					
					data[1] 和 data[2] 是一样的道理。


#### 三、闭包的表现形式 ####

 1. 返回一个函数。刚刚已经举例。
 2. 作为函数参数传递

		    var a = 1;
			function foo(){
			  var a = 2;
			  function baz(){
			    console.log(a);
			  }
			  bar(baz);
			}
			function bar(fn){
			  // 这就是闭包
			  fn();
			}
			// 输出2，而不是1
			foo();

#### 四、闭包的用途 ####

* 可以读取内部函数的变量
* 让这些变量的值始终保存在内存中，不会被调用后就被垃圾回收机制收回
* 用来模块化代码（类块级作用域）

#### 五、优点 ####

* 可以将一个变量长期驻扎在内存中
* 避免全局变量的污染
* 私有成员的存在

#### 六、缺点 ####

* 会使函数的变量被保存在内存中，内存消耗极大，会造成网页性能问题，在IE中会导致内存泄漏
* 闭包会在父函数外部改变父函数内部变量的值。所以，如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，注意不要随意改变父函数内部的值

<h3 id='五、js函数的参数按值传递'>五、js函数的参数按值传递</h3>

#### 一、概念 ####

- ECMAScript中所有函数的参数都是按值传递的。
- 按值传递：也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。
- 按引用传递：就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。


   - 基本类型值

			var value = 1;
			function foo(v) {
			    v = 2;
			    console.log(v); //2
			}
			foo(value);
			console.log(value) // 1

            很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，
            函数中修改的都是 _value 的值，而不会影响原来的 value 值。


   - 复杂类型

           var obj = {
			    value: 1
			};
			function foo(o) {
			    o.value = 2;
			    console.log(o.value); //2
			}
			foo(obj);
			console.log(obj.value) // 2


- 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按"引用传递"成功呢？而这究竟是不是引用传递呢？

			var obj = {
			    value: 1
			};
			function foo(o) {
			    o = 2;
			    console.log(o); //2
			}
			foo(obj);
			console.log(obj.value) // 1

- 上面例子，如果 JavaScript 采用的是引用传递，就是obj和o两个是绑定在一块的，o指向了新的值，obj必定也指向新的值
- 所以对于引用类型拷贝的是指向堆内存的指针，所以也是值的传递


			
            

<h3 id='六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？'>六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？</h3>

#### 一、前言 ####

- 我们编写的源代码是人类语言，我们自己能够轻松理解；但是对于计算机硬件（CPU），源代码就是天书，根本无法执行，计算机只能识别某些特定的二进制指令，在程序真正运行之前必须将源代码转换成二进制指令。所谓的二进制指令，也就是机器码，是 CPU 能够识别的硬件层面的“代码”，然而，究竟在什么时候将源代码转换成二进制指令呢？不同的编程语言有不同的规定：

     - 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（Windows 下的 .exe），比如C语言、C++、Golang、Pascal（Delphi）、汇编等，这种编程语言称为编译型语言，使用的转换工具称为编译器。
     - 有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 Python、JavaScript、PHP、Shell、MATLAB 等，这种编程语言称为解释型语言，使用的转换工具称为解释器。

- Java 和 C# 是一种比较奇葩的存在，它们是半编译半解释型的语言，源代码需要先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行。Java 引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率；C# 是后来的跟随者，但是 C# 一直止步于 Windows 平台，在其它平台鲜有作为。

#### 二、编程语言  ####

- 编程语言可以分为机器语言、汇编语言、高级语言。

     - 机器语言：由 0 和 1 组成的二进制码，对于人类来说是很难记忆的，还要考虑不同 CPU 平台的兼容性。
     - 汇编语言：用更容易记忆的英文缩写标识符代替二进制指令，但还是需要开发人员有足够的硬件知识。
     - 高级语言：更简单抽象且不需要考虑硬件，但是需要更复杂、耗时更久的翻译过程才能被执行。

- 高级语言一定要转化为机器语言才能被计算机执行，而且越高级的语言转化的时间越久。高级语言又可以分为解释型语言、编译型语言。


#### 三、编译型语言 ####

- 对于编译型语言，开发完成以后需要将所有的源代码都转换成可执行程序，比如 Windows 下的.exe文件，可执行程序里面包含的就是机器码。只要我们拥有可执行程序，就可以随时运行，不用再重新编译了，也就是“一次编译，无限次运行”。

     - 在运行的时候，我们只需要编译生成的可执行程序，不再需要源代码和编译器了，所以说编译型语言可以脱离开发环境运行。

     - 编译型语言一般是不能跨平台的，也就是不能在不同的操作系统之间随意切换。

     - 编译型语言不能跨平台表现在两个方面：

          1. 可执行程序不能跨平台

              - 可执行程序不能跨平台很容易理解，因为不同操作系统对可执行文件的内部结构有着截然不同的要求，彼此之间也不能兼容。比如，不能将 Windows 下的可执行程序拿到 Linux 下使用，也不能将 Linux 下的可执行程序拿到 Mac OS 下使用（虽然它们都是类 Unix 系统）。另外，相同操作系统的不同版本之间也不一定兼容，比如不能将 x64 程序（Windows 64 位程序）拿到 x86 平台（Windows 32 位平台）下运行。但是反之一般可行，因为 64 位 Windows 对 32 位程序作了很好的兼容性处理。

         2. 源代码不能跨平台

              - 不同平台支持的函数、类型、变量等都可能不同，基于某个平台编写的源代码一般不能拿到另一个平台下编译。我们以C语言为例来说明。

                    在C语言中要想让程序暂停可以使用“睡眠”函数，在 Windows 平台下该函数是 Sleep()，在 Linux 平台下该函数是 sleep()，首字母大小写不同。其次，Sleep() 的参数是毫秒，sleep() 的参数是秒，单位也不一样。
                    以上两个原因导致使用暂停功能的C语言程序不能跨平台，除非在代码层面做出兼容性处理，非常麻烦。

#### 四、解释型语言 ####

- 对于解释型语言，每次执行程序都需要一边转换一边执行，用到哪些源代码就将哪些源代码转换成机器码，用不到的不进行任何处理。每次执行程序时可能使用不同的功能，这个时候需要转换的源代码也不一样。
- 因为每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至存在数量级的差距。计算机的一些底层功能，或者关键算法，一般都使用 C/C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。
- 在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。
- 当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：

   - 对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是闭源的。
   - 对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是开源的。

- 相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真是存在的，而且比比皆是。那么，为什么解释型语言就能跨平台呢？

  - 这一切都要归功于解释器！我们所说的跨平台，是指源代码跨平台，而不是解释器跨平台。解释器用来将源代码转换成机器码，它就是一个可执行程序，是绝对不能跨平台的。官方需要针对不同的平台开发不同的解释器，这些解释器必须要能够遵守同样的语法，识别同样的函数，完成同样的功能，只有这样，同样的代码在不同平台的执行结果才是相同的。    
  - 你看，解释型语言之所以能够跨平台，是因为有了解释器这个中间层。在不同的平台下，解释器会将相同的源代码转换成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异。
 

#### 五、解释型语言和编译型语言对比 ####

- 解释器是一条一条的解释执行源语言(边解释边运行)。比如php，postscritp，javascript就是典型的解释性语言。 运行效率低，所以通常会进行一些预编译的优化。
- 编译器是把源代码整个编译成目标代码，执行时不在需要编译器，直接在支持目标代码的平台上运行，这样执行效率比解释执行快很多。比如C语言代码被编译成二进制代码（exe程序），在windows平台上执行。
- 他们最大的区别是程序运行时需要解释器边解释边执行，而编译器则在运行时是完全不需要的。
- 解释器的优点是比较容易让用户实现自己跨平台的代码，比如java，php等，同一套代码可以在几乎所有的操作系统上执行，而无需根据操作系统做修改；
- 编译器的目的就是生成目标代码再由连接器生成可执行的机器码，这样的话需要根据不同的操作系统编制代码，虽然有像Qt这样的源代码级跨平台的编程工具库，但在不同的平台上仍然需要重新编译连接成可执行文件，但其执行效率要远远高于解释运行的程序。


#### 六、js是怎样运行起来的 ####

- js是由js引擎运行的，Js 引擎有很多种，比如 Chrome 使用的 V8 引擎，Webkit 使用的是 JavaScriptCore，React Native 使用的是 Hermes。
- 着重看下V8引擎

    1. V8引擎内部有许多小的模块组成。这里我们只需要了解其中最常用的四个模块即可。

          - Parser（解析器）
          - Ignition（解释器）
          - TurboFan（编译器）
          - Orinoco（垃圾回收）

	2. V8执行JavaScript的过程
	
          - 初始化基础环境；
          - 解析源码生成 AST 和作用域；
          - 依据 AST 和作用域生成字节码；
          - 解释执行字节码；
          - 监听热点代码，优化热点代码为二进制的机器代码；
          - 反优化生成的二进制机器代码。
             
          - （1）初始化基础环境
              - V8 执行 Js 代码是离不开宿主环境的，V8 的宿主可以是浏览器，也可以是 Node.js。当打开一个渲染进程时，就为 V8 初始化了一个运行时环境
              - 运行时环境为 V8 提供了堆空间，栈空间、全局执行上下文、消息循环系统、宿主对象及宿主 API 等。V8 的核心是实现了 ECMAScript 标准，此外还提供了垃圾回收器等内容。
	
          - （2）解析源码生成AST和作用域
              - 这里有词法分析和语法分析两个过程
              - 词法分析
         
                - V8引擎会扫描所有源代码，将一行行的源码拆解成一个个 token。所谓词法单元 token，指的是语法上不可能再分的、最小的单个字符或字符串。固定 type 表述类型/属性，value 表示对应的值
	
	                           比如：var a = 2;这句代码经过词法分析会被分成以下token
	
	                                [{
	                                   "type":"Keyword",
	                                   "value":"var"
	                                 },
	                                 {
	                                   "type":"Identifier",
	                                   "value":"a"
	                                 },
	                                 {
	                                   "type":"Punctuator",
	                                   "value":"="
	                                 },
	                                 {
	                                   "type":"Numeric",
	                                    "value":"2"
	                                 },
	                                 {
	                                   "type":"Punctuator",
	                                    "value":";"
	                                 }
	                               ]
	    
              - 语法分析
              
                 - 在V8中有两个解析器用于解析 JavaScript 代码，分别是 Parser 和 Pre-Parser 。
                 - Parser解析器又称为 full parser（全量解析） 或者 eager parser（饥饿解析）。它会解析所有立即执行的代码，包括语法检查，生成 AST，以及确定词法作用域。
                               
                   - Parser 是 V8 的解析器，负责根据生成的 Tokens 进行语法分析。Parser 的主要工作包括：
                   - 分析语法错误：遇到错误的语法会抛出异常；
                   - 输出 AST：将词法分析输出的词法单元流（数组）转换为一个由元素逐级嵌套所组成的代表了程序语法结构的树——抽象语法树（Abstract Syntax Tree, AST）；
                   - 确定词法作用域；
                   - 生成执行上下文
                                  
                 - Pre-Parser又称为惰性解析，它只解析未被立即执行的代码（如函数），不生成 AST ，只确定作用域，以此来提高性能。当预解析后的代码开始执行时，才进行 Parser 解析。
                   - Pre-Parser（预解析）

                               function foo () {
								 console.log('function foo')
								}
								
								function bar () {
								  console.log('function bar')
								}
								
								foo()


                           - 上面这段代码中，如果使用 Parser 解析后，会生成 foo 函数 和 bar 函数的 AST。然而 bar 函数并没有被调用，所以生成 bar 函数的 AST 实际上是没有任何意义且浪费时间的。那么有没有办法解决呢？此时就用到了 Pre-Parser 技术。

										我们还是以示例来说明：
										function foo() {
										    console.log('a');
										    function inline() {
										        console.log('b')
										    }
										}
										
										(function bar() {
										    console.log('c')
										})()；
										
										foo();


                           - 当 V8 引擎遇到 foo 函数声明时，发现它未被立即执行，就会采用  Pre-Parser 对其进行解析（inline 函数同）。
                           - 当 V8 遇到(function bar() {console.log(c)})()时，它会知道这是一个立即执行表达式（IIFE），会立即被执行，所以会使用 Parser 对其解析。
                           - 当 foo 函数被调用时，会使用 Parser 对 foo 函数进行解析，此时会对 inline 函数再进行一次预解析，也就是说 inline 函数被预解析了两次。如果嵌套层级较深，那么内层的函数会被预解析多次，所以在写代码时，尽可能避免嵌套多层函数，会影响性能。

              - （3）依据 AST 和作用域生成字节码
             
                   - 在解析器（Parser）将 JS 代码解析成 AST 之后，解释器（Ignition）根据 AST 来生成字节码（也称中间码）。前文提到 CPU 只能识别机器码，对字节码是识别不了的，这里就衍生出一个问题，如果 CPU 识别不了字节码，那为什么还要在中间插一步来耗费资源转字节码呢？效率不是很更低吗？
                   - 在计算机学科里聊效率，都逃避不了时间和空间这两个概念，绝大部分的优化都是空间换时间和时间换空间，两者的平衡，效率如何达到最高，是一个很值得深入研究的问题。拿之前版本的 V8 引擎执行 JS 来说，是没有转字节码这一步骤的，直接从 AST 转成机器码，这个过程称为编译过程，所以每次拿到 JS 文件的时候，首先都会编译，而这个过程还是比较浪费时间的，这是一件比较头疼的事情，需要一个解决办法。
                   - 缓存机器码
                   
                      - 绝大多数情况下，文件不会修改，那编译后的机器码可以考虑缓存下来，这样一来，下次再打开或者刷新页面的时候就省去编译的过程了，可以直接执行了，存储机器码被分成了两种情况，一个是浏览器未关闭时候，直接存储到浏览器本地的内存中，一个是浏览器关闭了，直接存储在磁盘上，而早期的 V8 也确实是这么做的，典型的牺牲空间换时间。
                      - 但是一个很小的代码片段，转换成 AST 之后，变大了很多，文件大了导致一个问题就是需要更大的内存来存储，而 JS 文件转成机器码（即二进制文件），会比原来的 JS 文件大几百甚至几千倍，这就意味这一个几十 KB 的 JS 文件将会达到几十 MB，这就很可怕，本来 Chrome 多进程架构就已经很占用内存了，再来这一出，配置再好的电脑，也怕是无福消受 Chrome 了，毕竟使用者体验的好坏，直接决定了一个产品在市场上是否能生存下去，尽管 V8 缓存了编译后的代码，减少了编译的时间，提高了时间上的效率，但代价是内存占用太大了，所以 Chrome 团队是有必要优化这个问题的。
                         
                  - 惰性编译

                      - 早期版本的 V8 为了解决占用内存和启动速度，引进了惰性编译，那么问题来了，惰性编译做了什么去提高效率的呢？
                      - 惰性编译还是比较容易理解的，从作用域的角度思考，ES6 之前之只有全局作用域和函数作用域，而惰性编译的思路就是 V8 启动的时候只编译和缓存全局作用域的代码，而函数作用域中的代码，会在调用的时候去编译，同样函数内部编译后的代码一样不会被缓存下来。
                      - 引入惰性编译之后，在编译速度和缓存上看来，都得到了提升，一切看起来似乎很完美了，对，是看起来，但是设计出来的东西，你永远不知道使用者会怎么使用，在 ES6 和 Vue、React 等这些没有普及之前，绝大部分开发者都使用的是 jQuery，以及 RequireJS 等类似产品，JQ 插件各种引用，各种插件或者开发者自己封装的方法，为了不污染其他使用者的变量，一般都封装成一个函数，这样问题就来了，惰性编译不会保存函数编译后的机器码和理解编译函数，如果一个插件太大那等到使用函数再去编译，编译的时间上就会变得很慢，这相当于是开发者将惰性编译给玩完了，路给封死了。
                   - 引入字节码

                     - 首先要理解什么是字节码，字节码其实是机器码的抽象，各种字节码的相互构成，可以实现 JS 所需的所有功能，当然首先一点，字节码比机器码占用的内存要小很多很多，基本是机器码所在内存的几十甚至几百分之一，这样一来字节码缓存下来所消耗的内存还是可以接受的。
                     - 这里会有一个疑问，既然 CPU 不能识别字节码，那是不是还需要将字节码转成机器码呢？不然怎么执行，答案是肯定。解释器在将 AST 转为字节码之后，会在执行的时候将字节码转成机器码，这个执行过程肯定是比直接执行机器码要慢的，所以在执行方面，速度上会比较慢，但是 JS 源码通过解析器转 AST，然后再通过解释器转字节码，这个过程是比编译器直接将 JS 源码转机器码要快很多的，全流程看来，整个时间上是差不了多少的，但是却减小了大量的内存占用，何乐而不为。

               - （4）解释执行字节码
               
                    - 通过Ignition（解释器）将AST转为字节码之后，Ignition（解释器）会逐行解释字节码成机器码并执行（已经开始执行JavaScript代码了）
                           
               - （5）监听热点代码，优化热点代码为二进制的机器代码

                    - 当 Ignition 开始执行 JavaScript 代码后，V8 会一直观察 JavaScript 代码的执行情况，并记录执行信息，如每个函数的执行次数、每次调用函数时，传递的参数类型等。如果一个函数被调用的次数超过了内设的阈值，监视器就会将当前函数标记为热点函数（Hot Function），并将该函数的字节码以及执行的相关信息发送给 TurboFan（优化编译器）。TurboFan 会根据执行信息做出一些进一步优化此代码的假设，在假设的基础上将字节码编译为优化的机器代码。如果假设成立，那么当下一次调用该函数时，就会执行优化编译后的机器代码，以提高代码的执行性能。这种字节码配合解释器和编译器的技术被称为即时编译（JIT）
                    - 那如果假设不成立，将优化编译后的机器代码还原为字节码。

                            
               - （6）反优化生成的二进制机器代码。

                    - JS 语言是动态语言，非常之灵活，对象的结构和属性在运行时是可以发生改变的，设想一个问题，如果热代码在某次执行的时候，突然其中的某个属性被修改了，那么编译成机器码的热代码还能继续执行吗？答案是肯定不能。这个时候就要使用到优化编译器的反优化了，他会将热代码退回到 AST 这一步，这个时候解释器会重新解释执行被修改的代码，如果代码再次被标记为热代码，那么会重复执行优化编译器的这个步骤。


							function sum (a, b) {
							    return a + b;
							}
							
							我们都知道 JavaScript 是基于动态类型的，a 和 b 可以是任意类型数据，当执行 sum 函数时，Ignition 解释器会检查 a 和 b 的数据类型，并相应地执行加法或者连接字符串的操作。
							如果 sum 函数被调用多次，每次执行时都要检查参数的数据类型是很浪费时间的。此时 TurboFan 就出场了。它会分析监视器收集的信息，如果以前每次调用 sum 函数时传递的参数类型都是数字，那么 TurboFan 就预设 sum 的参数类型是数字类型，然后将其编译为机器指令。
							但是当某一次的调用传入的参数不再是数字时，表示 TurboFan 的假设是错误的，此时优化编译生成的机器代码就不能再使用了，于是就需要进行优化回退。


<h3 id='七、ASI自动分号插入机制'>七、ASI（自动分号插入机制）</h3>

#### 一、前言 ####

- 学习C#的时候我们知道分号是用作断句的，而且必须加分号，否则编译就不通过了。但JavaScript由于存在ASI机制，因此允许我们省略分号。
- ASI机制不是说在解析过程中解析器自动把分号添加到代码中，而是说解析器除了分号还会以换行为基础按一定的规则作为断句的依据，从而保证解析的正确性。
- 这些规则是基于两点：

   - 以换行为基础；
   - 解析器会尽量将新行并入当前行，当且仅当符合ASI规则时才会将新行视为独立的语句。


#### 二、ASI规则 ####

1. 新行并入当前行将构成非法语句，自动插入分号

        if(1 < 10) a = 1
		console.log(a)

		// 等价于
		if(1 < 10) a = 1;
		console.log(a);

2. 在continue,return,break,throw后自动插入分号

        return
		{a: 1}

		// 等价于
		return;
		{a: 1};

3. ++、--后缀表达式作为新行的开始，在行首自动插入分号

        x
		++
		y
		
        //等价于
		x;
		++y；

4. 代码块的最后一个语句会自动插入分号

		function(){ a = 1 }

		// 等价于
		function(){ a = 1; }

#### 三、	NO ASI规则 ####

1. 新行以 ( 开始

	var a = 1
	var b = a
	(a+b).toString()

	// 会被解析为以a+b为入参调用函数a，然后调用函数返回值的toString函数
	var a = 1
	var b =a(a+b).toString()

2. 新行以 [ 开始

	var a = ['a1', 'a2']
	var b = a
	[0,1].slice(1)

	// 会被解析先获取a[1]，然后调用a[1].slice(1)。
	// 由于逗号位于[]内，且不被解析为数组字面量，而被解析为运算符，而逗号运算符会先执行左侧表达式，然后执行右侧表达式并且以右侧表达式的计算结果作为返回值
	var a = ['a1', 'a2']
	var b = a[0,1].slice(1)

3. 新行以 / 开始

	var a = 1
	var b = a
	/test/.test(b)

	// /会被解析为整除运算符，而不是正则表达式字面量的起始符号。浏览器中会报test前多了个.号
	var a = 1
	var b = a / test / .test(b)

4. 新行以 + 、 - 、 % 和 * 开始

	var a = 2
	var b = a
	 +a

	// 会解析如下格式
	var a = 2
	var b = a + a

5.  新行以 , 或 . 开始

	var a = 2
	var b = a
	.toString()
	console.log(typeof b)
	
	// 会解析为
	var a = 2
	var b = a.toString()
	console.log(typeof b)

- 因为这些符号开头的话，根据上述的ASI的第一条规则，这一行和上一行并成一行的时候，并不会形成非法语句。例如[]会被识别成属性。()会被识别成函数执行语句。
- 在以 ([/+- 开头的语句前加分号，由于正常写法均不会出现以 .,*% 作为语句开头，因此只需记住前面5个即可

      ；(function(){})()



<h3 id='八、V8如何存储js对象'>八、V8如何存储js对象</h3>

#### 一、前言 ####

- JS对象存储在堆中，它更像一个字典，字符串作为键名，任意对象都可以作为键值，通过键名读写键值。然而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8 为了提升存储和查找效率，采用了一套复杂的存储策略。线性结构是一块连续的内存，如线性表和数组，非线性结构一般占用非连续性内存，如链表和树
- 在V8中对象主要由三个指针构成，Element、property、隐藏类。其中Element、property用于存放对象的属性，隐藏类用于描述对象的结构，隐藏类的出现主要是为了提高存取对象属性的效率

#### 二、Element和property ####

先看下下面的一个实例：

	function Foo() {
	    this[100] = 'test-100'
	    this[1] = 'test-1'
	    this["B"] = 'bar-B'
	    this[50] = 'test-50'
	    this[9] =  'test-9'
	    this[8] = 'test-8'
	    this[3] = 'test-3'
	    this[5] = 'test-5'
	    this["A"] = 'bar-A'
	    this["C"] = 'bar-C'
	}
	var bar = new Foo()
	
	for(key in bar){
	    console.log(`index:${key}  value:${bar[key]}`)
	}
	
	console.log(bar)   

    输出：index:1  value:test-1
		 index:3  value:test-3    
		 index:5  value:test-5    
		 index:8  value:test-8    
		 index:9  value:test-9    
		 index:50  value:test-50  
		 index:100  value:test-100
		 index:B  value:bar-B     
		 index:A  value:bar-A     
		 index:C  value:bar-C  

明显看结果没按顺序我们设置的顺序来，这是为什么呢？

- 在 V8 的对象中有两种属性，排序属性 (elements)和常规属性 (properties)。

   - 把对象中的数字属性称为排序属性，在 V8 中被称为 elements。数字属性应该按照索引值大小升序排列。
   - 字符串属性就被称为常规属性，在 V8 中被称为 properties，字符串属性根据创建时的顺序升序排列。
   - 两个属性都有时，排序属性 (elements)先于常规属性(properties)。

- 在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构 来分别保存排序属性和常规属性。分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。
- element默认应该采用连续的存储结构，通过浪费空间换取时间，直接下标访问，提升访问速度。 但当element的序号十分不连续时，会优化成为hash表，因为要浪费的空间太大了，不合算。

		function Foo() {}
		var bar = new Foo()
		for (let i = 0; i < 10; i++) {
		    bar[i] = 'bar' + i
		}
		// bar[1111] = 'bar1111'
	
	    当我们添加了 bar[1111] 之后，数组会变成稀疏数组。为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。


#### 三、快属性和慢属性 ###

- V8将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行 obj.B这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)。
- 采用对象内属性之后，常规属性就被保存到 testObj 对象本身了，这样当再次使用testObj.B来查找 B 的属性值时，V8 就可以直接从 testObj 对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。
- 不过 对象内属性的数量是固定的，默认是 10 个，如果添加的属性 超出了对象分配的空间，则它们将被保存在常规属性存储中。相较于对象内属性，在properties中的常规属性需要额外多一次 properties 的寻址时间，之后便是与对象内属性一致的线性查找（properties 的属性是有规律的类似数组、链表存放）。虽然属性存储多了一层间接层，但可以自由地扩容。
- 通常，我们将保存在线性数据结构中的属性称之为“【快属性】”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。
- 因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“【慢属性】”策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。
- 实例分析对象在内存中是如何布局的

    - 小于等于10个

        function testObj() {}

		var test10 = new testObj()
		
		for (var i = 0; i < 10; i++) {
		  test10[i+'x'] = 'xxx'
		}

      - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内;
      - 并没有 properties 属性 而是直接保存在对象内的，为了减少查找这些属性查找流程，在对象内直接生成映射，快速查找，但是最多 10 个。

    - 大于 10 个

		function testObj() {}
		
		var test20 = new testObj()
		
		for (var i = 0; i < 20; i++) {
		  test20[i+'x'] = 'xxx'
		}

       - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内，其他常规属性以线性数据结构方式存放在 properties 属性里面;
       - 当对象内属性放满（属性超过了 10 个）之后，会以快属性的方式，在 properties 下按创建顺序存放（0、1...9），注意因为 properties 中只有 10 个属性，所以依然是线性的数据结构，我们可以看其都是按照创建时的顺序来排列的。
       - 相较于对象内属性，快属性需要额外多一次 properties 的寻址时间，之后便是与对象内属性一致的线性查找（properties 的属性是有规律的类似数组、链表存放）

    - 大于 20 个
    
		function testObj() {}
		
		var test50 = new testObj()
		
		for (var i = 0; i < 50; i++) {
		  test50[i+'x'] = 'xxx'
		}

       - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内;其他常规属性以非线性字典的数据结构方式存放在 properties 属性里面;
       - 我们可以看到，当数据量大起来以后，在 properties 里的属性已经不线性（119、120），而是以非线性的散列表（字典）（哈希-分离链路）形式存储的。
       - 附：分离链路是哈希 key+链表 value 的结构

#### 四、隐藏类 ####

- JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类

1. 为什么静态语言的效率更高?

- 静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。引擎就可以通过这个数据来提前计算好该属性相对于对象地址的偏移值，在后面需要用到该对象的属性时，可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。
- JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。

2. 将静态的特性引入到 V8

- V8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的。
具体地讲，V8 对每个对象做如下两点假设：

  - 对象创建好了之后就不会添加新的属性；
  - 对象创建好了之后也不会删除属性。
  
- 符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：

  - 对象中所包含的所有的属性；
  - 每个属性相对于对象的偏移量。

- 有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。
- 在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类；
- map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。

3. 多个对象共用一个隐藏类

- 在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：

   - 减少隐藏类的创建次数，也间接加速了代码的执行速度；
   - 减少了隐藏类的存储空间。

- 那么，什么情况下两个对象的形状是相同的，要满足以下条件

   - 从相同的起点，以相同的顺序，添加结构相同的属性（除 Value 外，属性的 Attribute 一致）。

	     let a = {};
		 a.name = 'thorn1'
		 let b = { name: 'thorn2' }
	
	     上例中a和b的隐藏类不一样，那是因为在创建 b 的对象时，省略了下创建空对象这一步，所以a和b的起点不一样

4. 重新构建隐藏类

- 给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。

5. 对象操作的最佳实践

- 前文我们知道频繁改变对象的属性或属性值的数据类型会导致频道重新构建隐藏类的性能问题，基于此我们可以推测出操作对象的最佳实践。

  - 使用字面量初始化对象时，尽量保证属性的顺序一致。

		// bad
		let point = {x:100,y:200};
		let point2 = {y:100,x:200};
		
		// good
		let point = {x:100,y:200};
		let point2 = {x:100,y:200};
		
	为什么不推荐第一种做法呢？因为两个对象的形状不同，会生成不同的隐藏类。
 
 - 尽量使用字面量一次性初始化完整对象属性。
 
   - 因为每次为对象添加属性时V8都需要为该对象重新设置隐藏类。

 - 避免使用delete方法

  - 同样的，删除对象的属性会导致V8会重新构建隐藏类。


#### 五、内联缓存 ####

- 首先我们来看一个代码片:

		function loadX(o) { 
		    return o.x
		}
		var o = { x: 1,y:3}
		var o1 = { x: 3 ,y:6}
		for (var i = 0; i < 90000; i++) {
		    loadX(o)
		    loadX(o1)
		}

- 我们定义了一个 loadX 函数，它有一个参数 o ，该函数只是返回了 o.x 。
- 通常 V8 获取 o.x 的流程是这样的： 查找对象 **o** 的隐藏类，再通过隐藏类查找 **x** 属性偏移量，然后根据偏移量获取属性值 ，在这段代码中 loadX 函数会被反复执行，那么获取 o.x 流程也需要反复被执行。我们有没有办法再度简化这个查找过程，最好能一步到位查找到 x 的属性值呢？答案是，有的。

- V8通过内联缓存策略压缩这个查找过程，提升对象的查找效率。那什么是内联缓存呢？它具体是怎么工作的呢？
 
   - 内联缓存(Inline Cache)，简称IC。在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。
   
   - 接下来我们以示例代码为例详细看看IC的工作流程：
   
     - IC 会为每个函数维护一个 反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。
     - 代码片中 return o.x 是一个调用点，因为它使用了对象和属性，那么V8会在 loadX 函数的反馈向量中为这个调用点分配一个插槽，每个插槽中包括了插槽的索引 (slot index)、插槽的类型 (type)、插槽的状态 (state)、隐藏类 (map) 的地址、还有属性的偏移量，当V8再次调用 loadX 函数执行到 return o.x 时，它会在对应的插槽中查找 x 属性的偏移量，之后 V8就能直接去内存中获取 o.x 的属性值了，可以大大提升执行效率。

#### 六、多态和超态 ####

- 通过缓存执行过程中的基础信息，就能够提升下次执行函数时的效率，但是这有一个前提，那就是多次执行时，对象的形状是固定的，如果对象的形状不是固定的，那 V8 会怎么处理呢？
- 我们调整一下上面这段 loadX 函数的代码，调整后的代码如下所示：
	
	    function loadX(o) { 
		    return o.x
		}
		var o = { x: 1,y:3}
		var o1 = { x: 3, y:6,z:4}
		for (var i = 0; i < 90000; i++) {
		    loadX(o)
		    loadX(o1)
		}

  - 我们可以看到，对象 o 和 o1 的形状是不同的，这意味着 V8 为它们创建的隐藏类也是不同的。
  - 第一次执行时 loadX 时，V8 会将 o 的隐藏类记录在反馈向量中，并记录属性 x 的偏移量。那么当再次调用 loadX 函数时，V8 会取出反馈向量中记录的隐藏类，并和新的 o1 的隐藏类进行比较，发现不是一个隐藏类，那么此时 V8 就无法使用反馈向量中记录的偏移量信息了。
  - 面对这种情况，V8 会选择将新的隐藏类也记录在反馈向量中，同时记录属性值的偏移量，这时，反馈向量中的第一个槽里就包含了两个隐藏类和偏移量。当 V8 再次执行 loadX 函数中的 o.x 语句时，同样会查找反馈向量表，发现第一个槽中记录了两个隐藏类。这时，V8 需要额外做一件事，那就是拿这个新的隐藏类和第一个插槽中的两个隐藏类来一一比较，如果新的隐藏类和第一个插槽中某个隐藏类相同，那么就使用该命中的隐藏类的偏移量。如果没有相同的呢？同样将新的信息添加到反馈向量的第一个插槽中。
  - 一个反馈向量的一个插槽中可以包含多个隐藏类的信息，那么：

     - 如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；
     - 如果一个插槽中包含了 2～4 个隐藏类，那我们称这种状态为多态 (polymorphic)；
     - 如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。

- 如果函数 loadX 的反馈向量中存在多态或者超态的情况，其执行效率肯定要低于单态的，比如当执行到 o.x 的时候，V8 会查询反馈向量的第一个插槽，发现里面有多个 map 的记录，那么 V8 就需要取出 o 的隐藏类，来和插槽中记录的隐藏类一一比较，如果记录的隐藏类越多，那么比较的次数也就越多，这就意味着执行效率越低。
- 所以我们得出一个结论是 尽量保持单态，因为单态的性能优于多态和超态 。

#### 七、在 V8 引擎里 5 个优化代码的技巧 ####

- 对象属性的顺序: 在实例化你的对象属性的时候一定要使用相同的顺序，这样隐藏类和随后的优化代码才能共享；
- 动态属性: 在对象实例化之后再添加属性会强制使得隐藏类变化，并且会减慢为旧隐藏类所优化的代码的执行。所以，要在对象的构造函数中完成所有属性的分配；
- 方法: 重复执行相同的方法会运行的比不同的方法只执行一次要快 (因为内联缓存)；
- 数组: 避免使用 keys 不是递增的数字的稀疏数组，这种 key 值不是递增数字的稀疏数组其实是一个 hash 表。在这种数组中每一个元素的获取都是昂贵的代价。同时，要避免提前申请大数组。最好的做法是随着你的需要慢慢的增大数组。最后，不要删除数组中的元素，因为这会使得 keys 变得稀疏；



<h3 id='九、垃圾回收机制'>九、垃圾回收机制</h3>

#### 一、概念####

   - 垃圾回收机制只作用于对象，因为原始类型的值存在于栈中，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收，而引用类型的值存在于堆中，它们的内存地址存在于栈中，我们在变量中保存的其实是指向引用变量的指针，所以我们不引用一个保存在堆内存中的引用类型的值的时候，需要垃圾回收机制帮我们回收掉这个对象，然后释放掉它的内存
   - 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
   
   - JavaScript的内存管理是自动的，而且是不可见的，当我们创建一个基本类型的值，对象，函数...所有这些都是需要内存的，只要我们创建的值被引用了，该值就保证存在内存中，当该值没有被引用的时候，就需要被回收释放掉它所占用的内存。垃圾回收机制就是找出那些没有被引用的引用类型的值，然后释放掉它的内存。由于垃圾回收器回收内存这个过程的开销比较大，所以这个过程不是实时的，而是定期（周期性）的。

      例1：var a={
               obj:2
              }

         上例中，由于{obj:2}这个对象被a变量引用了，所以这个值就一直存在内存中，如果将a重新赋值为null,这时{obj:2}没有被引用了，则{obj:2}就会被回收，它的内存会被释放掉。

      例2：var a={
               obj:2
              }

           var b = a
           a=null

         上例中，{obj:2}不会被回收，因为虽然a没有引用它，但b引用了它。如果b=null，那么{obj:2}就会被回收。

#### 二、垃圾回收策略####

1. 引用计数(不太常用)

  - （1）原理

         - 引用计数就是跟踪每个引用类型被引用的次数，被引用一次加1，当引用次数为0的时候，就被视为可回收的对象，每当过一段时间开始垃圾回收的时候，就把引用次数为0的变量回收。

  - （2）过程

         - 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型的值的引用次数就是1
         - 同一个值又被赋值给了另一个变量，这个引用类型值的引用次数加1
         - 当包含这个引用类型值的变量又被赋值成另一个值了，那麽这个引用类型值的引用次数减1
         - 当引用次数变成0时，说明没办法访问这个值了
         - 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

         例：var a={name:'jone'}
             var b = a
             a=12
             b=456

          上例中，声明了一个变量并将{name:'jone'}赋值给a,所以{name:'jone'}的引用次数为1，又将{name:'jone'}赋值给了b,所以{name:'jone'}的引用次数为2，第三行又将a的值重新赋值为12，所以{name:'jone'}的引用次数又变成1，第四行又将b的值重新赋值为456，所以{name:'jone'}的引用次数又变成0，这是{name:'jone'}就变成了可回收的对象，垃圾回收器运行的时候它就会被回收。

  - （3）循环引用

          function f() {
           var o1 = {name:566}
           var o2 = {name:122}
           o1.p = o2
           o2.p = o1
          }
             
         上例中,{name:566}和{name:122}两个对象都被引用了两次，由于函数的局部变量只在函数的执行过程中存在，当函数运行结束，会将局部变量o1和o2赋值为null，但此时{name:566}和{name:122}两个对象的引用次数为1不为0，所以这两个对象都不会被垃圾回收机制回收，但是这两个对象已经没有作用了，在函数外部也不可能使用到它们，所以这就造成了内存泄露

         解决方式：

             不使用的时候手动清除：o1.p = null
                                o2.p = null


2. 标记清除（常用）

  - （1）原理

        - 根节点：一般来说，根是代码中引用的全局变量。例如，在 JavaScript 中，可以充当根节点的全局变量是“window”对象。Node.js 中的全局对象被称为“global”。完整的根节点列表由垃圾收集器构建。
      
        - 标记清除分为标记阶段和清除阶段
        
             - 标记阶段：标记清除其实就是可达性（对象是否可访问）测试，垃圾回收器从根集合出发，检查所有的根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。
	       
             - 清除阶段：从根节点开始遍历堆，垃圾收集器释放所有未被标记为活跃的内存块，并将这些内存返回给操作系统

        - 在使用标记清除算法时,未引用对象并不会被立即回收.取而代之的做法是,垃圾对象将一直累计到内存耗尽为止.当内存耗尽时,程序将会被挂起,垃圾回收开始执行.当所有的未引用对象被清理完毕时,程序才会继续执行.
   
  - （2）解决循环引用

           function f() {
           var o1 = {name:566}
           var o2 = {name:122}
           o1.p = o2
           o2.p = o1
          }

         上例中，由于函数执行结束后，局部变量o1和o2就会被回收，全局对象就访问不到这两个对象了，因此，垃圾回收器会认为它们不可访问


<h3 id='十、V8引擎对垃圾回收的优化'>十、V8引擎对垃圾回收的优化</h3>

接上篇垃圾回收~

#### 一、V8内存限制 ####

- 所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？
- 究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。

   - 首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 
   - 另一方面垃圾回收其实是非常耗时间的操作，在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。

- 垃圾回收策略主要有标记清除和引用计数，现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化

#### 二、分代式垃圾回收 ####

- 我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了

1. **新老生代** 

- V8中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收
- 新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，在 64 位和 32 位系统下分别为 32MB 和 16MB，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大
- V8 整个堆内存的大小就等于新生代加上老生代的内存
- 对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器（副垃圾回收器），同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器（主垃圾回收器）好了

![](./images/GC1.jpg)

2. **新生代垃圾回收**

- 新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法 
- Cheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为空闲区，如下图所示

![](GC2.jpg)

- 新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作
- 当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区
- 新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。
- 发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:

   - 已经经历过一次 Scavenge 回收。
   - 空闲区空间的内存占用超过25%,设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

- 不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

3. **老生代垃圾回收**

- 相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了,标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间

	- 首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象，清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉
	- 标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
![](./images/GC3.jpg)
	
	- 假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配
	- 那如何找到合适的块呢？我们可以采取下面三种分配策略
	 
	  - First-fit，找到大于等于 size 的块立即返回
	  - Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块
	  - Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回
	
	- 这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择
	- 综上所述，标记清除算法或者说策略就有两个很明显的缺点
	
	   - 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
	   - 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
	
	- 而标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）
![](./images/GC4.jpg)

4. **并行回收(Parallel)**

- 在介绍并行之前，我们先要了解一个概念全停顿（Stop-The-World），我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做全停顿
- 既然存在执行一次 GC 比较耗时的情况，考虑到一个人盖房子难，那两个人、十个人...呢？切换到程序这边，那我们可不可以引入多个辅助线程来同时处理，这样是不是就会加速垃圾回收的执行速度呢？因此 V8 团队引入了并行回收机制
- 所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作
![](./images/GC5.jpg)

- 简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了,不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单
- 新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收

5. **增量标记与懒性清理**

- 我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间,所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记
- 增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 GC 标记（如下图）
![](./images/GC6.jpg)

- 试想一下，将一次完整的 GC 标记分次执行，那在每一小次 GC 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？
- 可以看出增量的实现要比并行复杂一点，V8 对这两个问题对应的解决方案分别是三色标记法与写屏障

6. **三色标记法(暂停与恢复)**

- 我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法之前，单纯使用黑色和白色来标记数据就可以了，其标记流程即在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在会从一组跟对象出发，将所有能访问到的数据标记为黑色，遍历结束之后，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象
如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了
- 为了解决这个问题，V8 团队采用了一种特殊方式： 三色标记法
- 三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑

  - 白色指的是未被标记的对象
  - 灰色指自身被标记，成员变量（该对象的引用对象）未被标记
  - 黑色指自身和成员变量皆被标记

- 我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色，就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收
- 采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以
- 三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 全停顿 的时间

7. **写屏障**

- 假如我们有 A、B、C 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 B 的指向由对象 C 改为了对象 D ，接着恢复执行下一次增量分段
- 这时其实对象 C 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 GC 是不会清理 C 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 GC 也会清理，这对我们程序运行并没有太大影响
- 我们再看新的对象 D 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 D 呢，这肯定是不对的
- 为了解决这个问题，V8 增量回收使用 写屏障 (Write-barrier) 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 GC 标记阶段可以正确标记，这个机制也被称作 强三色不变性
- 那在我们上图的例子中，将对象 B 的指向由对象 C 改为对象 D 后，白色对象 D 会被强制改为灰色

8. **懒性清理**

- 增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(Lazy Sweeping)
- 增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记

9. **增量标记与惰性清理的优缺？**

- 增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：
- 首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量

10. **并发回收(Concurrent)**

- 前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？这就要说到并发回收了，它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）
![](./images/GC7.jpg)

- 辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 JavaScript  时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点

11. **V8当前垃圾回收机制**

- V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “
- 其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的
- （1）副垃圾回收器

    - V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从from-to复制到space-to的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。
    
- （2）主垃圾回收器

    - V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，写入屏障（write barriers）技术会在辅助线程在进行并发标记的时候进行追踪。
    - 当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。


<h3 id='十一、浏览器和node事件循环的区别'>十一、浏览器和node事件循环的区别</h3>

#### 一、浏览器事件循环 ####

1. 事件循环概念

- js分为同步任务和异步任务，同步任务都在主线程上执行形成一个执行栈，主线程之外存在一个回调队列
- 同步任务在执行的时候会调用浏览器的API，此时会产生一些异步任务
- 异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。
- 一旦执行栈中的所有同步任务执行完毕(此时js引擎空闲)，系统就会读取任务列队，将可运行的异步任务添加到可执行栈，开始执行
- 上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）。

- 回调队列可分为宏任务和微任务

2. async/await

- async 函数会返回一个 Promise 对象，如果在函数中 return 一个直接量（普通变量），async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。如果你返回了promise那就以你返回的promise为准。
- await 是在等待，等待运行的结果也就是返回值。await后面通常是一个异步操作（promise），但是这不代表 await 后面只能跟异步操作 await 后面实际是可以接普通函数调用或者常量的。

   - 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果
   - 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。

			async function async1(){
			    await async2()
			    console.log('async1 end')
			} 
			
			  function async2(){
			    console.log('async2 end')
			}
			  async1()
			
			setTimeout(()=>{
			   console.log('setTimeout')
			},0)
			
			new Promise(reslove=>{
			    reslove()
			}).then(()=>{
			    console.log('promise')
			})
	
				async2 end
				async1 end
				promise
				setTimeout

 - 上面代码中，调用async1函数，里边await后面跟着async2函数，所以执行async2函数输出async2 end，async2是一个同步函数，所以await后面的语句相当于在.then函数里边，所以会被注册成微任务，继续执行遇到setTimeout加入宏任务队列，遇到Promise.then是微任务，加入微任务列队，第一个宏任务执行完，执行微任务队列的微任务，输出async1 end，promise，执行第二个宏任务输出setTimeout

 - 将上面async2函数改一下

		 async function async1(){
		    await async2()
		    console.log('async1 end')
		} 
		
		async function async2(){
		    console.log('async2 end')
		    return new Promise(reslove=>{
		        reslove()
		    }).then((res)=>{
		        console.log('async2.then end')
		    })
		}
		async1()
		
		setTimeout(()=>{
		   console.log('setTimeout')
		},0)
		
		new Promise(reslove=>{
		    reslove()
		}).then(()=>{
		    console.log('promise')
		})

		async2 end
		async2.then end
		promise
		async1 end
		setTimeout

- 输出变了，async1 end在promise之后了，这是因为await后面的函数返回一个promise，那么

	     await async2
	     console.log(async1 end)
	
	     相当于
	      new Promise(reslove=>{
			    reslove()
			 }).then((res)=>{
			    console.log('async2.then end')
			 }).then(()=>{
	            console.log('async1.then end')
	         })

- 所以是输出async2.then end的then函数先被注册为微任务，然后是下面的promise.then被注册微任务，执行async2.then end的then函数是又产生了一个输出async1 end的then函数微任务，添加到promis后面，所以async1 end在promise之后了
     

#### 二、node事件循环 ####

1. 阶段概述

   - 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。
   - I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。比如网络通信的错误回调
   - 闲置阶段(idle, prepare)：仅系统内部使用。
   - 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
   - 检查阶段(check)：setImmediate() 回调函数在这里执行
   - 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。


- 输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...
- 通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，**直到队列用尽或最大回调数已执行**。当该队列已用尽或达到回调限制，执行该阶段产生的微任务，然后事件循环移动到下一阶段。【node11版本之前】

2. 三大重点阶段

- （1）timer
    - timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。

- （2）poll
   ![](./images/node事件循环.jpg)

    - 进入poll阶段会先去看当前是否存在到时间的定时器，如果存在则进入timer阶段执行timer队列
    - 如果没有定时器, 会去看回调函数队列。

       - 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
       - 如果 poll 队列为空时，会有两件事发生

         - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
         - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。

- （3）check 
   - check阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。

3. process.nextTick

- process.nextTick 是一个独立于 eventLoop 的任务队列。
- 在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。

		setImmediate(() => {
		    console.log('timeout1')
		    Promise.resolve().then(() => console.log('promise resolve'))
		    process.nextTick(() => console.log('next tick1'))
		});
		setImmediate(() => {
		    console.log('timeout2')
		    process.nextTick(() => console.log('next tick2'))
		});
		setImmediate(() => console.log('timeout3'));
		setImmediate(() => console.log('timeout4'));


    - 在 node11 之前，因为每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行，因此上述代码是先进入 check 阶段，执行所有 setImmediate，完成之后执行 nextTick 队列，最后执行微任务队列，因此输出为timeout1=>timeout2=>timeout3=>timeout4=>next tick1=>next tick2=>promise resolve
    - 在 node11 之后，process.nextTick 是微任务的一种,因此上述代码是先进入 check 阶段，执行一个 setImmediate 宏任务，然后执行其微任务队列，再执行下一个宏任务及其微任务,因此输出为timeout1=>next tick1=>promise resolve=>timeout2=>next tick2=>timeout3=>timeout

4. node版本差异

    - node11版本之前：当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，**直到队列用尽或最大回调数已执行**。当该队列已用尽或达到回调限制，执行该阶段产生的微任务，然后事件循环移动到下一阶段。
    - node11版本之后：一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行对应的微任务队列

			setTimeout(()=>{
			    console.log('timer1')
			    Promise.resolve().then(function() {
			        console.log('promise1')
			    })
			}, 0)
			setTimeout(()=>{
			    console.log('timer2')
			    Promise.resolve().then(function() {
			        console.log('promise2')
			    })
			}, 0)
		
		
        - 如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=>promise1=>timer2=>promise2
        - 如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.
        
           - 如果是第二个定时器还未在完成队列中，最后的结果为timer1=>promise1=>timer2=>promise2
           - 如果是第二个定时器已经在完成队列中，则最后的结果为timer1=>timer2=>promise1=>promise2


<h3 id='十二、观察者模式和发布订阅模式'>十二、观察者模式和发布订阅模式</h3>

#### 一、观察者模式 ####

1. 概念

   - 观察者模式中有两个角色观察者和被观察者，它定义了对象间的一对多的依赖关系，当一个被观察者对象的状态发生改变时，依赖于它的所有观察者对象都会收到通知

2. 观察者模式的简单流程

   - 将观察者注册到目标对象的观察者列表中
   - 目标对象进行 通知（notify） 操作
   - 目标对象调用观察者的 更新（update） 方法，将通知的信息传递给观察者

3. 联系实际

   - 报纸期刊的订阅。当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。

4. 简单实现

       //被观察者
		class Subject{
		    constructor() {
		      this.subs = []
		    }
		
		    add(sub) {
		        this.subs.push(sub)
		    }
		
		    remove(sub) {
		        this.subs.filter(item=>{
		            return item!==sub
		        })
		    }
		    
            //当被观察者状态改变时，通知每个观察者进行相应操作
		    notify() {
		        this.subs.forEach(sub=>{
		            sub.update.apply(sub)
		        })
		    }
		}
		
 
        //观察者
		class Observer{
		    constructor(name) {
		        this.name = name
		    }
		    update() {
		        console.log(this.name)
		    }
		}

		let sub = new Subject()
		let obj1 = new Observer('小明')
		let obj2 = new Observer('小红')
  
        //改变了obj2的update函数，被观察者只是在自己状态发生改变时，通知观察者，观察者具体要干什么由观察者自己决定，所以update函数可以任意改变
		obj2.update=function(){
		    console.log('666')
		}
		sub.add(obj1)
		sub.add(obj2)
		sub.notify()

    - 观察者模式中，被观察者自己维护了一个观察者列表，观察者和被观察者都知道对方的存在

#### 二、发布订阅模式 ####

1. 概念

     - 在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。
     - 在发布者和订阅者之间存在第三个组件，称为事件中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。
     - 发布订阅模式有三个角色：发布者、订阅者、事件中心

2. 发布-订阅模式的简单流程：

   - 订阅者需要向事件中心订阅指定的事件
   - 发布者需要向事件中心发布指定的事件
   - 事件中心通知订阅者

3. 简单实现

		 class event {
		    constructor() {
                // 订阅者集合
               // 集合的每个对象里都包含了订阅者类型 type，及要做的事情 callback
		        this.subs = {}
		    }
		
           //订阅者订阅
		    on(key,fn) {
		        if(!this.subs[key]){
		            this.subs[key] = []
		        }
		        this.subs[key].push(fn)
		    }
		
          //发布者发布
		    emit(key,...args) {
		      if(!this.subs[key] || this.subs[key].length===0){
		          return false
		      }
		
		      this.subs[key].forEach((fn)=>{
		          fn(...args)
		      })
		
		    }
		
		    remove(key,fn) {
		        if(!this.subs[key]){
		            return false
		        }
		        if(!fn){
		            this.subs[key].length=0
		        }
		
		        this.subs[key]=this.subs[key].filter((sub)=>{
		            return sub!==fn
		        })
		    }
		}
		
		function dog(name){
		   this.name = name
		   console.log(this.name)
		}
		
		function cat(){
		   console.log('喵喵喵')
		}
		
		let obj = new event()
		obj.on('pet',dog)
		obj.on('pet',cat)
		obj.remove('pet',dog)
		obj.emit('pet','花花')

#### 三、区别 ####

1. 观察者模式中的目标和观察者是直接联系的，而发布-订阅模式中的订阅者和发布者中间是由事件中心来联系的。

   - 观察者模式：目标和观察者是低耦合的，有很强的依赖关系。
   - 发布-订阅模式：由于事件中心的存在使得订阅者和发布者是完全解耦的。

2. 观察者要想订阅目标事件，由于没有事件中心，因此必须将自己添加到目标(Subject) 中进行管理；
   目标在触发事件的时候，也无法将通知操作(notify) 委托给事件中心，因此只能亲自去通知所有的观察者。

3. 从代码实现的角度，
 
   - 观察者模式是面向目标和观察者编程的。
   - 发布-订阅模式是面向调度中心编程的。

#### 四、注意 ####

- 在给出的实例中，观察者模式中在观察者列表中添加的是观察者对象；而发布-订阅模式在事件中心中添加的是回调函数。个人理解观察者模式中可能更倾向于将通知信息返回到观察者自身，而发布-订阅模式可能更倾向于对相应发布事件的处理（通过回调函数）。



<h3 id='十三、判断js数据类型的方法' >十三、判断js数据类型的方法）</h3>

一、typeof

  - typeof对于基本类型的值可以判断出其类型（对于null返回object），对于引用类型的值，除了function都会返回object

二、instanceof

  - instanceof运算符是用来判断一个构造函数的prototype属性所指向的对象是否存在在另一个要检测的对象的原型链上，表达式为A instanceof B，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。
  - instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

三、toString

  - toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

  - 对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。


	Object.prototype.toString.call('') ;   // [object String]
	Object.prototype.toString.call(1) ;    // [object Number]
	Object.prototype.toString.call(true) ; // [object Boolean]
	Object.prototype.toString.call(Symbol()); //[object Symbol]
	Object.prototype.toString.call(undefined) ; // [object Undefined]
	Object.prototype.toString.call(null) ; // [object Null]
	Object.prototype.toString.call(newFunction()) ; // [object Function]
	Object.prototype.toString.call(newDate()) ; // [object Date]
	Object.prototype.toString.call([]) ; // [object Array]
	Object.prototype.toString.call(newRegExp()) ; // [object RegExp]
	Object.prototype.toString.call(newError()) ; // [object Error]
	Object.prototype.toString.call(document) ; // [object HTMLDocument]
	Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用




<h3 id='十四、js数据类型转换' >十四、js数据类型转换）</h3>

https://juejin.cn/post/6844903854882947080
#### 一、类型转换规则 ####
![](./images/类型转换.jpg)

1. 转换为布尔值false的有：0，NaN，""，undefined，null
2. 转换为数值为0的有：false，""，null，[]（undefined转换为数值为NaN）
3. 转换为字符串为空串的有：[]

#### 二、if语句和逻辑语句 ####

- 在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true：

    - null，undefined，''，NaN，0，false

#### 三、各种运数学算符 ####

- 我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型

		1 - true // 0             true=>1
		1 - null //  1            null=>0
		1 * undefined //  NaN     undefined=>NaN
		2 * ['5'] //  10          ['5']=>5

- 注意+是个例外，执行+操作符时：

  1. 只要有一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。
  2. 当一侧为Number类型，另一侧为除String之外的原始类型，则将原始类型转换为Number类型。
  3. 当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。

			123 + '123' // 123123   （规则1）
			123 + null  // 123    （规则2）
			123 + true // 124    （规则2）
			123 + {}  // 123[object Object]    （规则3）


#### 四、== ####

- 使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：

1. NaN

- NaN和其他任何类型比较永远返回false(包括和他自己)

2. Boolean

- Boolean和其他任何类型比较，Boolean首先被转换为Number类型

		true == 1  // true 
		true == '2'  // false
		true == ['1']  // true
		true == ['2']  // false

- 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0：

		undefined == false // false
		null == false // false

3. String和Number

- String和Number比较，先将String转换为Number类型。

		123 == '123' // true
		'' == 0 // true

4. null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false

		null == undefined // true
		null == '' // false
		null == 0 // false
		null == false // false
		undefined == '' // false
		undefined == 0 // false
		undefined == false // false

5. 原始类型和引用类型

- 当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型:
- 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。

     - Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。

         - Number：该场合需要转成数值
         - String：该场合需要转成字符串
         - Default：该场合可以转成数值，也可以转成字符串

- 从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循ECMAScript规范规定的toPrimitive原则，一般会调用引用类型的valueOf和toString方法，你也可以直接重写toPeimitive方法。一般转换成不同类型的值遵循的原则不同，例如：

    - 引用类型转换为Number类型，先调用valueOf，再调用toString
    - 引用类型转换为String类型，先调用toString，再调用valueOf
    - 若valueOf和toString都不存在，或者没有返回基本类型，则抛出TypeError异常。

- 来看看下面这个比较：

     [] == ![] // true

     !的优先级高于==，![]首先会被转换为false，然后根据上面第二点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。

     [null] == false // true
     [undefined] == false // true

     根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。		

#### 五、一道有意思的面试题 ####

- 一道经典的面试题，如何让：a == 1 && a == 2 && a == 3。
- 根据上面的==的隐式转换，我们可以轻松写出答案：

		const a = {
		   value:[3,2,1],
		   valueOf: function () {return this.value.pop(); },
		} 



#### 六、判断JavaScript数据类型的方式 ####

1. typeof

- 适用场景

  - typeof操作符可以准确判断一个变量是否为下面几个原始类型：
		
        typeof 'ConardLi'  // string
		typeof 123  // number
		typeof true  // boolean
		typeof Symbol()  // symbol
		typeof undefined  // undefined

  - 你还可以用它来判断函数类型：
  
		typeof function(){}  // function

- 不适用场景

  - 当你用typeof来判断引用类型时似乎显得有些乏力了,除函数外所有的引用类型都会被判定为object:

		typeof [] // object
		typeof {} // object
		typeof new Date() // object
		typeof /^\d*$/; // object
     
    
  - 另外typeof null === 'object'也会让人感到头痛，这是在JavaScript初版就流传下来的bug，后面由于修改会造成大量的兼容问题就一直没有被修复...

2. instanceof

- instanceof操作符可以帮助我们判断引用类型具体是什么类型的对象：

		[] instanceof Array // true
		new Date() instanceof Date // true
		new RegExp() instanceof RegExp // true

- 我们先来回顾下原型链的几条规则：

	- 所有引用类型都具有对象特性，即可以自由扩展属性
	- 所有引用类型都具有一个__proto__（隐式原型）属性，是一个普通对象
	- 所有的函数都具有prototype（显式原型）属性，也是一个普通对象
	- 所有引用类型__proto__值指向它构造函数的prototype
	- 当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的__proto__中去找

- [] instanceof Array实际上是判断Array.prototype是否在[]的原型链上。所以，使用instanceof来检测数据类型，不会很准确，这不是它设计的初衷：

		[] instanceof Object // true
		function(){}  instanceof Object // true

- 另外，使用instanceof也不能检测基本数据类型，所以instanceof并不是一个很好的选择。

3. toString

- 上面我们提到了toString函数，我们可以调用它实现从引用类型的转换。每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中type是对象的类型。

		const obj = {};
		obj.toString() // [object Object]

- 注意，上面提到了如果此方法在自定义对象中未被覆盖，toString才会达到预想的效果，事实上，大部分引用类型比如Array、Date、RegExp等都重写了toString方法。

        let a = [1,2,3]
        a.toString() // 1,2,3

        let a = true
        a.toString() // true

- 我们可以直接调用Object原型上未被覆盖的toString()方法，使用call来改变this指向来达到我们想要的效果。
![](./images/类型转换2.jpg)

        Object.prototype.toString.call(true)        		[object Boolean]
		Object.prototype.toString.call(123)          		[object Number]
		Object.prototype.toString.call('sss')        		[object String]
		Object.prototype.toString.call(null)         		[object Null]
		Object.prototype.toString.call(undefined)    		[object Symbol]
		Object.prototype.toString.call(Symbol())     		[object Boolean]
		Object.prototype.toString.call({})                  [object Object]
		Object.prototype.toString.call(function fn(){})     [object Function]
		Object.prototype.toString.call([])    				[object Array]
		Object.prototype.toString.call(new Error)    		[object Error]
		Object.prototype.toString.call(new Regexp())    	[object Regexp]
		Object.prototype.toString.call(Math)    			[object Math]
		Object.prototype.toString.call(JSON)    			[object JSON]
		Object.prototype.toString.call(window)    			[object Window]



<h3 id='十五、深拷贝与浅拷贝' >十五、深拷贝与浅拷贝</h3>

#### 一、前言 ####

- js的数据类型分为基本类型和引用类型，深拷贝和浅拷贝是针对引用类型来说的
- 浅拷贝：浅拷贝是创建一个新对象，这个对象有着原始对象的属性值的一份精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个属性就会对另一个产生影响
- 深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象

#### 二、浅拷贝的实现方式 ####

1. Object.assign()

- Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。
		
		let obj1 = { person: {name: "kobe", age: 41},sports:'basketball' };
		let obj2 = Object.assign({}, obj1);
		obj2.person.name = "wade";
		obj2.sports = 'football'
		console.log(obj1); // { person: { name: 'wade', age: 41 }, sports: 'basketball' }

2. 展开运算符...

- 展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。

		let obj1 = { name: 'Kobe', address:{x:100,y:100}}
		let obj2= {... obj1}
		obj1.address.x = 200;
		obj1.name = 'wade'
		console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }

3. Array.prototype.concat()

		let arr = [1, 3, {
		    username: 'kobe'
		    }];
		let arr2 = arr.concat();    
		arr2[2].username = 'wade';
		console.log(arr); //[ 1, 3, { username: 'wade' } ]
		
4. Array.prototype.slice()

		let arr = [1, 3, {
		    username: ' kobe'
		    }];
		let arr3 = arr.slice();
		arr3[2].username = 'wade'
		console.log(arr); // [ 1, 3, { username: 'wade' } ]
		

#### 三、深拷贝的实现 ####

1. JSON.parse(JSON.stringify())

		let arr = [1, 3, {
		    username: ' kobe'
		}];
		let arr4 = JSON.parse(JSON.stringify(arr));
		arr4[2].username = 'duncan'; 
		console.log(arr, arr4) //[ 1, 3, { username: ' kobe' } ] [ 1, 3, { username: 'duncan' } ]

- 这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。
- 但是这种方法存在一些缺点，由于它是依赖于JSON，因此它不支持JSON不支持的其他格式，通过JSON的官网可知，JSON只支持object,array,string,number,true,false,null这几种数据或者值，其他的比如函数，undefined，Date，RegExp等数据类型都不支持。对于它不支持的数据都会直接忽略该属性。
- 注意的就是：

	- 会忽略undefined Symbol    =>忽略
	- 不能序列化函数             =>忽略
	- 不能解决循环引用的对象
	- 不能正确处理 new Date()   =>如果对象中存在Date类型的数据，会被转换成字符串，从而丢失Date的一些特性，比如时间格式化等方法。
	- 不能处理正则              =>{}

		let obj = {
		    h1:undefined,
		    h2:null,
		    h3:function (){},
		    h4:Symbol(),
		    h5:2,
		    h6:new RegExp('ss'),
		    h7:new Date()
		};
		let obj1 = JSON.parse(JSON.stringify(obj));
		obj1.h5 = 'aaa'
		console.log(obj, obj1,typeof obj.h7,typeof obj1.h7)

		//  {
			  h1: undefined,
			  h2: null,
			  h3: [Function: h3],
			  h4: Symbol(),
			  h5: 2,
			  h6: /ss/,
			  h7: 2021-09-16T10:32:32.540Z
			} 

            { h2: null, h5: 'aaa', h6: {}, h7: '2021-09-16T10:32:32.540Z' }
            Object
            String

       循环引用情况下，会报错。
       所谓循环引用的对象，就是对象的属性又指向了自身，window就是最常见的一个环状对象。

       let obj = {name:'hello'}
       obj.self = obj   // self属性又指向了obj对象，形成了一个换
		
       let obj1 = JSON.parse(JSON.stringify(obj));
	   // Uncaught TypeError: Converting circular structure to JSON

2. 递归实现

https://juejin.cn/post/6889327058158092302#heading-7

- 拷贝简单数据类型

   - 如果是简单的数据类型，由于保存的是值，因此只需要返回这个值就行，不存在相互影响的问题。实现如下：
		
        function deepClone(target){
		  return target
		}
		
- 拷贝简单的对象

   - 所谓简单的对象，是指这些对象是由上卖弄的简单数据类型组成的，不存在Array,Function,Date等子类型的数据。比如这种：

		let obj1 = {
		  name:"hello",
		  child:{
		    name:"小明"
		  }
		}

   - 实现思路就是创建一个新的对象，然后把每个对象上的属性拷贝到新对象上。如果这个属性是简单类型的那么就直接返回这个属性值。如果是Object类型，那么就通过for...in遍历讲对象上的每个属性一个一个地添加到新的对象身上。因为无法区分对象的层级，因此使用递归，每次赋值时都是调用自己，反正如果时简单类型就递归一次直接返回值，如果是Object类型，那么就往下递归查找赋值。

		function deepClone(target){
		  if(target instanceof Object){
		      let dist = {};
		      for(let key in target){
		        // 递归调用自己获取到每个值
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}


- 拷贝复杂对象——数组

   - 使用上面的方法我们能够实现拷贝简单的对象，但是对于一些包含子类型的对象，比如数组无法实现。我们看下代码：
   
	    const a = [[11,12],[21,22]];
	    const a2 = deepClone(a);
	    console.log('........:',a2); //{ '0': { '0': 11, '1': 12 }, '1': { '0': 21, '1': 22 } }

   - 我们发现拷贝后的数组，得到的是一个特殊的对象。这个对象以数组的下标作为key值，数组的每一项作为value值，这是因为for in 在遍历数组时由于找不到key值会默认以数组的下表作为key值，数组的每一项作为value值。这样的话最终克隆后得到的数据类型就跟数组不一致了（实际上这就是数组本身的特殊造成的）。最终由数组拷贝后变成了对象。
   - 我们发现问题出在我们把所有的东西都定义成一个{}了，而数组是不能用{}来描述的，因此我们需要根据对象的类型来区分一下最终返回的数据类型。实现代码如下：

		// 先不优化代码
		function deepClone(target){
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 如果是数组，就创建一个[]
		        dist = []
		      }else{
		        dist = {};
		      }
		      for(let key in target){
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

   - 由于数组也可以通过for in进行遍历，因此实际上我们要修改的就是在克隆时，先判断要克隆的对象是不是数组即可。

- 拷贝复杂对象——函数

   - 拷贝函数这个其实有点争议，因为在很多人看来函数是无法拷贝的。在我看来函数实际上不应该有深拷贝的，如果真的要有，那么也就是实现函数的功能，同时函数的对象也必须是符合深拷贝的逻辑(引用属性不等，简单类型属性相等)：
   - 函数实现的功能要相同——返回的值相同
   - 函数身上的引用类型的属性要不相同，直接类型的属性的值要相同。

   - 如下代码所示：
    
		    const fn = function(){return 1};
		    fn.xxx = {yyy:{zzz:1}};
		    const fn2 = deepClone(fn);
		    console.log(fn !== fn2);                 // 函数不相同
		    console.log(fn.xxx!== fn2.xxx);          // 函数引用类型的属性不相同
		    console.log(fn.xxx.yyy!== fn2.xxx.yyy);  // 函数引用类型的属性不相同
		    console.log(fn.xxx.yyy.zzz === fn2.xxx.yyy.zzz);// 函数简单类型的属性值相同
		    console.log(fn() === fn2());            //  函数执行后相等

   - 那么应该如何实现一个函数的拷贝了？

      - 首先需要返回一个新的函数
      - 新的函数执行结果必须与原函数相同。

			function deepClone(target){
			  if(target instanceof Object){
			      let dist ;
			      if(target instanceof Array){
			        dist = []
			      }else if(target instanceof Function){
			        dist = function(){
			            // 在函数中去执行原来的函数，确保返回的值相同
			            return target.call(this, ...arguments);
			        }
			      }else{
			        dist = {};
			      }
			      for(let key in target){
			          dist[key] = deepClone(target[key]);
			      }
			      return dist;
			  }else{
			      return target;
			  }
			}


- 拷贝复杂对象——正则表达式

    - 如何拷贝一个正则了？以一个简单的正则为例：

        const a = /hi\d/ig;

     - 一个正则，其实由两部分组成，正则的模式（斜杠之间的内容）hi\d,以及参数ig。因此，只要能够拿到这两部分就可以得到一个正则表达式。从而实现克隆这个正则。通过正则的source属性就能够拿到正则模式，通过正则的flags属性就能够拿到正则的参数。
   
		const a = /hi\d/ig;
		console.log(a.source);   //   hi\d
		console.log(a.flags)    // ig

     - 因此，我们深拷贝一个正则实际上就是拿到这两部分，然后重新创建一个新的正则，从而实现跟原来的正则相同的功能即可。

		function deepClone(target){
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      for(let key in target){
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}


- 拷贝复杂对象——日期

  - 如果拷贝的是一个日期，在通过我们上面的方法拷贝后，返回的是一个字符串。这个字符串不是Date类型的，它无法调用Date的任何方法。因此，我们需要支持日期格式的拷贝。事实上，通过上面的Array,Function,RexExp复杂对象类型的拷贝，我们可以发现，实际上这些拷贝都是通过new XXX()，相当于创建一个新的对象返回回去。因此，日期的拷贝也是一样：
  
        dist = new Date(source);

  - 将要拷贝的日期，作为参数然后生成一个新的Date。最终实现如下：

		function deepClone(target){
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      for(let key in target){
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

- 好了，到目前为止我们的深拷贝已经支持了简答数据类型，普通对象，数组，函数，正则，日期这些最常见的数据了。虽然我们的代码中有很多if else结构，但是我觉得这是最容易让大家理解的写法。

- 进一步优化

- 到目前为止，我们虽然写出了一个可使用的深拷贝函数，但是这个函数仍然存在着许多可优化的地方。（这些优化的地方也是面试官容易问到的地方）。

   - 忽略原型上的属性

      - 我们在遍历对象的属性的时候，使用的是for in，for in 会遍历包括原型上的所有可迭代的属性。

			比如：
			let a = Object.create({name:'hello'});
			a.age = 14;

            那么使用遍历时，会遍历name和age属性。而不仅仅是a自身身上的age属性。但是，事实上我们不应该去遍历原型上的属性，因为这样会导致对象属性非常深。因此，使用for in遍历时我们最好把原型上的属性和自身属性区分开来，通过hasOwnProperty筛选出自身的属性进行遍历。
		    
		    for (let key in source) {
		      // 只遍历本身的属性
		      if(source.hasOwnProperty(key)){
		        dist[key] = deepClone(source[key]);
		      }
		    }

      - 因此，优化后的代码如下：

			function deepClone(target){
			  if(target instanceof Object){
			      let dist ;
			      if(target instanceof Array){
			        // 拷贝数组
			        dist = [];
			      }else if(target instanceof Function){
			        // 拷贝函数
			        dist = function () {
			          return target.call(this, ...arguments);
			        };
			      }else if(target instanceof RegExp){
			        // 拷贝正则表达式
			       dist = new RegExp(target.source,target.flags);
			      }else if(target instanceof Date){
			          dist = new Date(target);
			      }else{
			        // 拷贝普通对象
			        dist = {};
			      }
			      for(let key in target){
			          // 过滤掉原型身上的属性
			        if (target.hasOwnProperty(key)) {
			            dist[key] = deepClone(target[key]);
			        }
			      }
			      return dist;
			  }else{
			      return target;
			  }
			}


   - 环状对象的爆栈问题
   
     - 我们在之前使用JSON.parse(JSON.stringify())拷贝对象时，就遇到过如果出现环状对象，会导致报错问题。那么使用我们自己的深拷贝函数同样会遇到问题。这是由于我们在deepClone函数中使用了递归，按理来说每一个递归应该有一个终止条件的，但是由于对象树结构一般会有终点，因此会自动在终点结束递归。但是如果一个对象有属性指向自身，那么就会形成一个环，比如：

			let a = {name:"小明"};
			a.self = a;   // a的self属性指向a

     - 这样的话，在进行递归调用的过程中会无限循环，最终爆栈。因此，我们需要添加递归终止条件。所谓的递归终止条件，就是判断一个对象是否已经被克隆过了，如果被克隆过了那么就直接使用克隆后的对象，不再进行递归。因此，我们需要一个东西来保存可能重复的属性以及它的克隆地址。最好的方式就是map。

		let cache = new Map();
		function deepClone(target){
		  if(cache.get(target)){
		      return cache.get(target)
		  }
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      // 将属性和拷贝后的值作为一个map
		      cache.set(target, dist);
		      for(let key in target){
		          // 过滤掉原型身上的属性
		        if (target.hasOwnProperty(key)) {
		            dist[key] = deepClone(target[key]);
		        }
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}


    - 共用缓存导致的互相影响问题
    
       - 在上面的deepClone函数中，我们通过新增了一个缓存cache来保存已经克隆过的对象和它对应的克隆地址。但是这种方式会带来一个新的问题：由于每次克隆创建一个对象都会使用这个cache，这样的话会导致克隆一个新的对象受到上一个克隆对象的影响。示例：
       
		  let a = {
		    name:"hello",
		  }     
		  let a1 = deepClone(a);
		  console.log(map);  //{ name: 'hello' } => { name: 'hello' }
		  let b = {
		    age:24
		  }
		  let b1 = deepClone(b);
		  console.log(map);  //   { name: 'hello' } => { name: 'hello' },{ age: 24 } => { age: 24 } }

      - 我们发现在深拷贝对象b的时候，map中已经有值了{ name: 'hello' }。而事实上这些值不是b身上已经拷贝过的属性。也就是说b的拷贝受到了a的拷贝的影响，这会导致问题。因此，我们不能让所有的深拷贝共用同一个缓存，而是让每一个深拷贝使用自己的属性。

      - 解决办法是：在调用函数时，每次都创建一个新的map（默认参数），然后如果需要递归，就把这个map往下传。
      
		function deepClone(target,cache = new Map()){
		  if(cache.get(target)){
		      return cache.get(target)
		  }
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      // 将属性和拷贝后的值作为一个map
		      cache.set(target, dist);
		      for(let key in target){
		          // 过滤掉原型身上的属性
		        if (target.hasOwnProperty(key)) {
		            dist[key] = deepClone(target[key], cache);
		        }
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

   - 对象过长导致的爆栈问题
   
      - 我们知道我们深拷贝中使用了递归，而递归是有递归栈的，递归栈的深度是有限的，一旦对象的递归深度超过了递归栈的深度，那么就可能出现爆栈。
      - 比如，下面的对象a的对象深度有20000个属性。这样的话基本上递归到5000时就出现爆栈了，导致报错。
      
	     let a = {
	        child:null 
	      }
	      let b = a;
	      for(let i = 0;i < 20000;i++){
	        b.child = {
	          child:null
	        }
	        b = b.child;
	      }
	      console.log(a);

    - 这种由于对象过深导致的爆栈问题，暂时没有什么解决办法，而且也很少会有这么深的对象。

  - 好了，到目前为止，我们基本上实现了一个功能较为完整的深拷贝。最终的实现函数如下：
  
		function deepClone(target,cache = new Map()){
		  if(cache.get(target)){
		      return cache.get(target)
		  }
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);

		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      // 将属性和拷贝后的值作为一个map
		      cache.set(target, dist);
		      for(let key in target){
		          // 过滤掉原型身上的属性
		        if (target.hasOwnProperty(key)) {
		            dist[key] = deepClone(target[key], cache);
		        }
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

  - 接下来我们就写一个复杂的对象，使用这个对象进行深拷贝，测试我们的函数性能。
  
          const a = {
            i: Infinity,
            s: "",
            bool: false,
            n: null,
            u: undefined,
            sym: Symbol(),
            obj: {
              i: Infinity,
              s: "",
              bool: false,
              n: null,
              u: undefined,
              sym: Symbol(),
            },
            array: [
              {
                nan: NaN,
                i: Infinity,
                s: "",
                bool: false,
                n: null,
                u: undefined,
                sym: Symbol(),
              },
              123,
            ],
            fn: function () {
              return "fn";
            },
            date: new Date(),
            re: /hi\d/gi,
          };
          let a2 = deepClone(a);


<h3 id='十六、跨域的几种方式' >十六、跨域的几种方式</h3>

#### 一、为什么要跨域 ####

- 受浏览器同源策略(所谓同源是指域名、协议和端口号都相同)的限制，本域的js不能操作其他域的页面对象（比如DOM），安全限制的同时也给注入iframe或是ajax应用带来了不少麻烦。所以我们要通过一些方法使得本域的js能够操作其他域的页面对象，或者其他域的js能操作本域的页面对象（iframe之间）

#### 二、跨域理解 ####

* 跨域是浏览器本身施加的安全限制，并不是人为的给某一个特定的网站设置的

* 其次，跨域是浏览器上的概念，服务端不存在跨域的说法

* 本质，浏览器的同源策略决定了一个网站不可以执行非本网站下的脚本

* 只要协议，域名，端口有任意一个不同，都被当做不同的域，js不能在不同的域之间进行通信和传输数据

#### 三、跨域的情况 ####

* 通过Ajax向不同域请求数据
* 通过js获取页面中不同域的框架中的数据

#### 四、同源策略 ####

1. 定义

- 两个页面地址中的协议，域名，端口号一致，则表示同源

2. 为什么有同源策略

- 设置同源策略的主要目的是为了安全，如果没有同源限制，在浏览器中的cookie等其他数据可以任意读取，不同域下的DOM任意操作，ajax任意请求其他网站的数据，包括隐私数据

3. 同源策略的限制

  * 无法用js读取非同源的Cookie、LocalStorage 和 IndexDB 无法读取

  * 无法用js获取非同源的DOM 

  * 无法用js发送非同源的AJAX请求 

#### 五、跨域的方法 ####

1. CORS（Cross-Origin Resource Sharing）跨域资源共享

   - 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制
	
   - 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉
	
   - CORS需要浏览器和服务器同时支持，目前所有的浏览器都支持(IE浏览器不能低于IE10)，所以，要支持CORS，服务端都需要做好相应的配置,只要服务器实现了CORS接口，就可以跨源通信

   - 浏览器将CORS请求分为两类:

     - (1)简单请求

        - 同时满足以下两个条件就叫简单请求：

           - 请求方法是以下三种之一：

              - GET
              - POST
              - HEAD

           - HTTP的头信息不超过以下几种字段：

             - Accept
             - Accept-Language
             - Content-Language
             - Last-Event-ID
             - Content-Type：只限于三个值application/x-www-form-urlencoded（form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式））、multipart/form-data（ 需要在表单中进行文件上传时，就需要使用该格式）、text/plain（纯文本格式）

        - 基本流程

          - 对于简单请求，浏览器直接发出CORS请求，即就是在头信息之中，增加一个origin字段

            - 如下面的例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段
	
						GET /cors HTTP/1.1
						Origin: http://api.bob.com
						Host: api.alice.com
						Accept-Language: en-US
						Connection: keep-alive
						User-Agent: Mozilla/5.0...

             - origin字段用来说明本次请求来自那个源(协议+域名+端口)，服务器会根据这个值决定是否同意这次请求
                
                - 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200
                - 如果origin指定的域名在许可范围之内，服务器返回的响应会多出几个头信息字段

             - Access-Control-Allow-Origin: http://api.bob.com

               - 该字段是必须的，它的值要么是请求时origin字段的值，要么是一个*，表示接受任意域名的请求

             - Access-Control-Allow-Credentials: true

               - 该字段可选，它的值是一个布尔值，表示是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可
                 
             - Access-Control-Expose-Headers: FooBar

               - 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。
           

             - withCredentials属性

                - CORS默认不发送Cookie和HTTP认证信息，如果要把Cookie发送到服务器，一方面服务器同意，指定Access-Control-Allow-Credentials字段，另一方面，开发者必须在Ajax请求中打开withCredentials属性

				          var xhr = new XMLHttpRequest();
				          xhr.withCredentials = true;

                 - 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。
                 - 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials

         				  xhr.withCredentials = false

                 - 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie



- (2)非简单请求

  * 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段类型是application/json

  * 非简单请求的CORS请求会在正式通信之前，增加一次HTTP查询请求，称为预检请求

  * 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错

  * 预检请求

     * 如下面是一段浏览器的js脚本

		    var url = 'http://api.alice.com/cors';
		    var xhr = new XMLHttpRequest();
		    xhr.open('PUT', url, true);
		    xhr.setRequestHeader('X-Custom-Header', 'value');
		    xhr.send();

	       上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header
	
    * 浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息


		    OPTIONS /cors HTTP/1.1
		    Origin: http://api.bob.com
		    Access-Control-Request-Method: PUT
		    Access-Control-Request-Headers: X-Custom-Header
		    Host: api.alice.com
		    Accept-Language: en-US
		    Connection: keep-alive
		    User-Agent: Mozilla/5.0...

            预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源


   * 除了Origin字段，"预检"请求的头信息包括两个特殊字段。
	
       * Access-Control-Request-Method
	
	      该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT
	
       * Access-Control-Request-Headers
	
	      该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header

* 预检请求回应

    * 服务器收到了预检请求以后，检查了Origin，Access-Control-Request-Method，Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以作出回应

			HTTP/1.1 200 OK
			Date: Mon, 01 Dec 2008 01:15:39 GMT
			Server: Apache/2.0.61 (Unix)
			Access-Control-Allow-Origin: http://api.bob.com
			Access-Control-Allow-Methods: GET, POST, PUT
			Access-Control-Allow-Headers: X-Custom-Header
			Content-Type: text/html; charset=utf-8
			Content-Encoding: gzip
			Content-Length: 0
			Keep-Alive: timeout=2, max=100
			Connection: Keep-Alive
			Content-Type: text/plain

   * 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

   * 如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息

   * 服务器回应的其他CORS相关字段如下：


	    Access-Control-Allow-Methods: GET, POST, PUT
	    Access-Control-Allow-Headers: X-Custom-Header
	    Access-Control-Allow-Credentials: true
	    Access-Control-Max-Age: 1728000

       * Access-Control-Allow-Methods

           * 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

       * Access-Control-Allow-Headers

           * 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

       * Access-Control-Allow-Credentials

           * 该字段与简单请求时的含义相同。

       * Access-Control-Max-Age

           * 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

* 浏览器的正常请求和回应

      * 一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。
	
      * 下面是"预检"请求之后，浏览器的正常CORS请求。
	
	
		    PUT /cors HTTP/1.1
		    Origin: http://api.bob.com
		    Host: api.alice.com
		    X-Custom-Header: value
		    Accept-Language: en-US
		    Connection: keep-alive
		    User-Agent: Mozilla/5.0...
	
	     上面头信息的Origin字段是浏览器自动添加的。
	
      * 下面是服务器正常的回应。
	
		    Access-Control-Allow-Origin: http://api.bob.com
		    Content-Type: text/html; charset=utf-8
	
	    上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的

* 完整的例子：ajax.html在http://localhost:8080服务器上运行，点击提交按钮，将数据提交到http://localhost:8081服务器上，端口不同跨域

          * ajax.js

              function ajax(url,fuSucc,fnFaild){
				    var oAjax=null;
				    if(window.XMLHttpRequest){
				        oAjax=new XMLHttpRequest();
				    }else{
				        oAjax=new ActiveXObject("Microsoft.XMLHTTP");
				    }
				    
				    oAjax.open("get",url,true);
				    oAjax.send();
				    oAjax.onreadystatechange=function(){
				      
				          if(oAjax.readyState==4){
				              
				              if(oAjax.status==200){
				                fuSucc(oAjax.responseText);
				              }else{
				                if(fnFaild){
				                    fnFaild();
				                }
				                
				              }
				          }
				    };
				}
             

          * ajax.html

              <!DOCTYPE html>
				<html>
				    <head>
				        <meta charset="UTF-8">
				        <title>ajax</title>
				    </head>
				    <body>
				        <input id="butn1" type="button" value="提交">
				        <script src='ajax.js'></script>
				        <script >
				       
				            var oBtn=document.getElementById("butn1");
				            oBtn.onclick=function(){
				                ajax("http://localhost:8081?name=milk",function(){
				                  alert('suss')
				                },function(){
				                    alert("faild");
				                })
				            }
				        </script>
				    </body>
				</html>

          * server.js

                var express = require('express');
				var fs = require('fs');  //用于读取ajax.html文件
				var server = new express();
				server.use('/',function(req,res){
	
				    fs.readFile('.'+req.url,function(err,data){
				        if(err){
				            res.write('404');
				        }else{
				            res.write(data);
				        }
				        res.end();
				    })
				  
				})
				server.listen(8080);
          
          * server1.js

                var express = require('express');
				var server = new express();
				server.use('/',function(req,res){
				    console.log(req.url)
				    res.header("Access-Control-Allow-Origin", "http://localhost:8080"); //设置请求来源不受限制
				    res.header("Access-Control-Allow-Headers", "X-Requested-With");  
				    res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS"); //请求方式
				    res.header("Content-Type", "application/json;charset=utf-8");
				    res.end()
				})
				server.listen(8081);


2. JSONP

	* 在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，我们知道img,script,这种标签如果有相应的src，那么便会发起一个http请求来请求相应的资源,如果有script标签对应的路径是一个js文件，那么在下载完毕这个js之后会马上执行，jsonp正是利用这个特性来实现的
	
	* 怎么使用script来发送请求
	
	       * 我们使用动态标签来实现
	
	            如：let script = document.createElement('script');
					srcipt.src = 'www.somewhere.com/getdata';
					document.querySelector('head').appendChild(script);
	
	* 请求得到的数据应该怎么在前端页面上接收并处理
	
	
	       * 我们使用callback回调函数来实现，因为有可能是多个不同站点都要访问这个服务端，那么各个站点要调用的方法可能是各不相同的，如果把方法名写死的话，就会很不和谐。所以解决的办法是各个站点来访问服务端时，在url中带一个参数（callback）过来，服务端获取到这个参数，就会在生成js代码时，以这个callback参数作为方法名，再把数据放到这个方法里。这样各个站点就可以调用各自的方法了。这也是jsonp的一个要点
	
	           <script>
	
				    var script = document.createElement('script');
				    script.type = 'text/javascript';
				
				    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
				    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
				    document.head.appendChild(script);
				
				    // 回调执行函数
				    function handleCallback(res) {
				        alert(JSON.stringify(res));
				    }
	
			 </script>
	
	
	* 缺点
	
	    * 只能发送get请求，因为script只能处理get请求
	    * 需要后台配合
	
	          * 服务端接收到url时，获取到callback参数，在后端进行了一次拼接返回
	
	            node.js
	
					var querystring = require('querystring');
					var http = require('http');
					var server = http.createServer();
					
					server.on('request', function(req, res) {
					    var params = qs.parse(req.url.split('?')[1]);
					    var fn = params.callback;
					
					    // jsonp返回设置
					    res.writeHead(200, { 'Content-Type': 'text/javascript' });
					    res.write(fn + '(' + JSON.stringify(params) + ')');
					
					    res.end();
					});
					
					server.listen('8080');
					console.log('Server is running at port 8080...')
	
	
	* 完整的例子：ajax.html在http://localhost:8080服务器上运行，点击提交按钮，将数据提交到http://localhost:8081服务器上，端口不同跨域
	
	
	       * jsonp.html
	
	               <!DOCTYPE html>
						<html lang="en">
						<head>
						    <meta charset="UTF-8">
						    <meta name="viewport" content="width=device-width, initial-scale=1.0">
						    <meta http-equiv="X-UA-Compatible" content="ie=edge">
						    <title>jsonp</title>
						</head>
						<body>
						    <input id="butn1" type="button" value="提交">
						    <script>
						        var btn = document.getElementById('butn1')
						        btn.onclick = function(){
						            var script = document.createElement('script')
						            script.type = 'text/javascript'
						            script.src = 'http://localhost:8081/jsonp?user=admin&callback=handleCallback'
						            document.body.appendChild(script);
						        }
						
						        function handleCallback(res){
						           console.log(JSON.stringify(res))
						        }
						    </script>
						</body>
						</html>
	
	       * jsonp-server.js
	
	            var express = require('express');
				var fs = require('fs'); //读取jsonp.html文件
				var server = new express();
				server.use('/',function(req,res){
				    fs.readFile('.'+req.url,function(err,data){
				        if(err){
				            res.write('404');
				        }else{
				            res.write(data);
				        }
				        res.end();
				    })
				  
				})
				server.listen(8080);
	
	
	     * jsonp-server1.js
	
	          	var express = require('express');
				var fs = require('fs'); //读取ajax.html文件
				var server = new express();
				server.use('/jsonp',function(req,res){
				    var name = req.query.user
				    var callback = req.query.callback
				    var back = `${callback}(${JSON.stringify(name)})`
				    res.send(back)
				    res.end()
				})
				server.listen(8081);
	

3. window.name

	* 从一个页面跳转到另一个页面,window.name的值是不会改变的，基于这个思想我们可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了
	
	* 完整的例子：a页面在80端口的服务器上运行，b页面在81端口的服务器上运行，在a页面上点击链接跳转到b页面，端口不同跨域
	
	   * a.html
	
		    <!DOCTYPE html>
				<html>
				    <head>
				        <meta charset="UTF-8">
				        <title>a.html</title>
				    </head>
				    <body>
				       
				       <a href='http://localhost:8081/b.html'>点击跳转到b页面</a>
				       <script>
				       
				           window.name = '222'
				       
		               </script>
				        
				</body>
				</html>
	
	   * b.html
	
	 		
			<!DOCTYPE html>
				<html>
				    <head>
				        <meta charset="UTF-8">
				        <title>b.html</title>
				    </head>
				    <body>
				       
				       <script>
				       
				           console.log(window.name) // 222
				       
		               </script>
				        
				</body>
				</html>
	
	
	* 由于安全原因，浏览器始终会保持 window.name 是 string 类型
	
	* 这个方法也可以用到与<iframe>的交互上来
	
	   * 完整的例子：iframe页面在80端口的服务器上运行，iframe-content页面在81端口的服务器上运行，在iframe-content页面设置window.name，在iframe页面可以获取到
		
	       * iframe-content
		
					<!DOCTYPE html>
					<html>
					    <head>
					        <meta charset="UTF-8">
					        <title>iframe-content</title>
					       
					    </head>
					    <body>
					        <p>蒹葭苍苍，白露为霜。所谓伊人，在水一方。</p>
					
					        <p>溯洄从之，道阻且长。溯游从之，宛在水中央。</p>
					          
					        <p>蒹葭萋萋，白露未晞。所谓伊人，在水之湄。</p>
					          
					        <p>溯洄从之，道阻且跻。溯游从之，宛在水中坻。</p>
					        <script>
					          
					            window.name = '222'
					           
					           </script>
					    </body>
					</html>
			
	       * iframe
		
					<!DOCTYPE html>
					<html>
					    <head>
					        <meta charset="UTF-8">
					        <title>iframe</title>
					    </head>
					    <body>
					        <iframe src="iframe-content.html" width="400px" height="150px" frameborder="1"
					
					           scrolling="auto" id="frame1" name="ifr1">
					     
					       </iframe> 
					       <div>hello</div>
					       
							<script>
							       
							    var iframe = document.getElementById("frame1"); 
							    
							   
							    iframe.onload=function(){
							        
							        console.log(window.name) //222
							    }
							   
							 
							 </script>
					        
					    </body>
					</html>
	
	
	* 这个方法非常适合单向的数据请求
	
4. 使用HTML5的postMessage方法
	 
   * 向外界窗口发送消息
	
     - 语法：otherWindow.postMessage(message, targetOrigin)
	
        * otherWindow:指目标窗口，也就是给哪个window发消息,比如iframe的contentWindow属性,执行window.open返回的窗口对象,或者是命名过(有name属性)的或数值索引的window.frames[]
	   
          * window.parent 获取上一级的window对象
          * window.self 返回自身window的引用
          * iframe.contentWindow, 获取iframe的window对象 
          * iframe.contentDocument, 获取iframe的document对象 
          * window.frames[]:frames[]是窗口中所有命名的框架组成的数组。这个数组的每个元素都是一个Window对象，对应于窗口中的一个框架
	                             
             - 方括号里面可以填该框架的name属性或者索引，都可以取到该框架的window对象
          * message：将要发送到其他window的数据（可以不受限制的将数据对象安全的传送给目标窗口而无需自己序列化，原因是因为采用了结构化克隆算法）
          * targetOrigin：目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写。如果要传递给所有窗口，值可以为"*"。如果传给当前窗口同源的话，值可以为"/"
	             
	
	* 目标窗口接收消息
	
      - 语法：监听message方法
	
	         window.addEventListener('message',function(e){
				  console.log(e.data);
				 })
	
         * event对象有三个属性，分别是origin，data和source
	                 
           * event.data表示接收到的消息
           * event.origin表示postMessage的发送来源，包括协议，域名和端口
           *  event.source表示发送消息的窗口对象的引用
	           
	
	* 完整的例子：
	
       * iframe + postMessage
	
		             //主页面：
					      
						<script>
						      var iframe = document.createElement("iframe");
						      iframe.src = "http://localhost:3000";
						      iframe.id = "myFrame";
						      iframe.width = "100%";
						      iframe.height = "100%";
						
						      iframe.onload = function () {
						        document.getElementById('myFrame').contentWindow.postMessage('主页面消息', 'http://localhost:3000');
						      };
						      document.body.appendChild(iframe);
					     </script>
		
		            //iframe页 http://localhost:3000
					  
		               <script>
						    window.addEventListener('message', function (event) {
						      if(event.origin !== "主页面域名") return;
						      console.log(event);
						    }, false);
					   </script>
	       
      *  window.open() + postMessage
	
				      //主页面：http://192.168.xxx.xxx:5000
		              
						<script>
						      let newWin = window.open("http://localhost:3000");
						      let timer = setInterval(() => {
						        newWin.postMessage('testtest', 'http://localhost:3000');
						      }, 500);
						      window.addEventListener('message', function (event) {
						        if (event.origin !== 'http://localhost:3000') return;
						        if (event.data === 'Received') clearInterval(timer)
						      }, false);
			             </script>
		
		                 // window.open 页  http://localhost:3000
		
		                    <script>
							    window.addEventListener('message', function (event) {
							      if(event.origin !== "http://192.168.xxx.xxx:5000") return;
							      event.source.postMessage('Received',event.origin);
							    }, false);
		                   </script> 

5. document.domain(只适用于两个iframe之间跨域)

   * (1)document.domain介绍

      * 用来得到当前网页的域名
      * 我们也可以给document.domain属性赋值，不过是有限制的，你只能赋成当前的域名或者基础域名(二级域名)

		      如：若当前域名为www.baidu.com
		
		      document.domain = 'www.baidu.com'  //当前域名
			  document.domain = 'baidu.com'  //基础域名

  - (2)利用document.domain实现跨域

     * 条件：
	
       * 二级域名相同
       * 协议相同
       * 端口相同

      - 如：两个子域名aaa.xxx.com和bbb.xxx.com

         - aaa里的一个网页（a.html）引入了bbb 里的一个网页（b.html），这时a.html里同样是不能操作b.html里面的内容的，因为document.domain不一样，一个是aaa.xxx.com，另一个是bbb.xxx.com。这时我们就可以通过Javascript，将两个页面的domain改成一样的，需要在a.html里与b.html里都加入：

           - document.domain = "xxx.com"

      - 这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的"跨域

6. location.hash(两个iframe之间)

* 原理：

      * 用location.hash解决域名完全不同的跨域，例如，http://www.baidu.com#helloworld中的"#helloworld"就是location.hash，改变hash值不会刷新页面，因此可以利用hash值来传递数据

* 前提准备：

    * a.html,起在localhost:8080上
    * b.html,起在localhost:8080上
    * c.html,起在localhost:8081上

- 可见a和b是同域的，c是独立的

* 需求：

      * 在a页面获取c页面发送的数据

* 思路:

      * a给c传一个hash值，c收到hash值后，c把hash值传递给b，b把结果放到a的hash中


* 完整例子：

	   //a.html

	    <!DOCTYPE html>
		  <html>
		  <head>
		   <title></title>
		  </head>
		  <body>
		   <iframe src="http://localhost:4000/c.html#yuhua"></iframe>
		    <script type="text/javascript">
		     //hash一变化，就获取变化后的hash值，这个hash值就是a传给c，c得到后响应，返回给b，b传递给a的
		     window.onhashchange = function(){
		      console.log(location.hash);
		     }
		    </script>
		  </body>
		  </html>
	
	    //b.html

	    <!DOCTYPE html>
		  <html>
		  <head>
		   <title></title>
		  </head>
		  <body>
		   <!-- 
		    window 当前b的window
		    window.parent b的父级，也就是c
		    window.parent.parent b的爷爷，也就是c的爸爸，也就是a
		
		    -->
		   <script type="text/javascript">
		    window.parent.parent.location.hash = location.hash;
		   </script>
		  </body>
		  </html>
	
	    //c.html

	    <!DOCTYPE html>
		  <html>
		  <head>
		   <title></title>
		  </head>
		  <body>
		   <script type="text/javascript">
		    let iframe = document.createElement("iframe");
		    iframe.src = 'http://localhost:3000/b.html#18';
		    document.body.appendChild(iframe);
		   </script>
		  </body>
		  </html>

* 缺点：数据直接暴露在了url中，数据容量和类型都有限

7. websocket

* 简介:WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了

* WebSocket通信是点对点：

     * 一是建立WebSocket链接的URL加上时间戳保证通信会话是唯一的

     * 二是在服务端保证父子页面WebSocket一一对应关系。父子页面的WebSocket在Open时都会向服务端发出消息进行注册，建立Senssion之间的对应关系。然后父子页面就可通过双方约束的通信协议进行通信了
     
* 原理：利用webSocket的API，可以直接new一个socket实例，然后通过open方法内send要传输到后台的值，也可以利用message方法接收后台传来的数据。后台是通过new WebSocket.Server({port:3000})实例，利用message接收数据，利用send向客户端发送数据

* 代码解析：websocket.html运行在8080端口上，向3000端口发送数据，跨域了

* 代码演示

    //websocket.html

	 <!DOCTYPE html>
	 <html>
	 <head>
	  <title></title>
	 </head>
	 <body>
	
	   <script type="text/javascript">

	    let socket = new WebSocket("ws://localhost:3000");//ws协议是webSocket自己创造的
	    socket.onopen = function(){
	     socket.send("我叫俞华");
	    }
	    socket.onmessage = function(e){
	     console.log(e.data);//你好,我叫俞华！
         setTimeout(function(){
              socket.close()  // 关闭连接   

            },3000)
	    }

        //关闭连接后的回调函数
         
         socket.onclose=function(){
                alert('client关闭连接')
            }
         
         socket.onerror=function(err){
                alert('出错了')
            }

	   </script>
	 </body>
	 </html>

    //服务端

     // websocket_server1.js

        express= require('express')
		var fs = require('fs')
		var server = express()
		
		server.use('/',function(req,res){
		
		    fs.readFile('.'+req.url,function(err,data){
		        if(err){
		            res.write('404')
		        }else{
		            res.write(data)
		        }
		
		        res.end()
		    })
		})
		
		server.listen(8080)

     //websocket_server2.js
      
     一般起的服务是http服务，但是websocket需要起ws服务，ws是webSocket自己定义的

         /*
		  要使用ws协议，那么就要装一个ws的包 使用 npm install ws --save安装
		 */

         var express = require('express')
         var server = express()
		 let WebSocket = require("ws");
		 let wss = new WebSocket.Server({port:3000});
		 wss.on("connection",function(ws){//先连接

			  ws.on("message",function(data){//用message来监听客户端发来的消息

				   console.log(data);//俞华
				   ws.send("你好,"+data+"！");
			  })
		 })

         server.use('/',function(req,res){

              })


* 如何保证websocket的通信会话是唯一的？

  * 建立WebSocket链接的url上加上时间戳

* 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容

    * 代码演示

           //前端代码
 
            <div>user input：<input type="text"></div>
			<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
			<script>
			var socket = io('http://www.domain2.com:8080');
			
			// 连接成功处理
			socket.on('connect', function() {
			    // 监听服务端消息
			    socket.on('message', function(msg) {
			        console.log('data from server: ---> ' + msg); 
			    });
			
			    // 监听服务端关闭
			    socket.on('disconnect', function() { 
			        console.log('Server socket has closed.'); 
			    });
			});
			
			document.getElementsByTagName('input')[0].onblur = function() {
			    socket.send(this.value);
			};
			</script>
        
          //后台代码

            var http = require('http');
			var socket = require('socket.io');
			
			// 启http服务
			var server = http.createServer(function(req, res) {
			    res.writeHead(200, {
			        'Content-type': 'text/html'
			    });
			    res.end();
			});
			
			server.listen('8080');

			
			// 监听socket连接
			socket.listen(server).on('connection', function(client) {
			    // 接收信息
			    client.on('message', function(msg) {
			        client.send('hello：' + msg);
			        console.log('data from client: ---> ' + msg);
			    });
			
			    // 断开处理
			    client.on('disconnect', function() {
			        console.log('Client socket has closed.'); 
			    });
			});
			

8. node代理跨域

* node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证


(1)非vue框架的跨域（2次跨域）

* 利用node + express + http-proxy-middleware搭建一个proxy服务器

* 代码演示

	//前端代码
	
		var xhr = new XMLHttpRequest();
		
		// 前端开关：浏览器是否读写cookie
		xhr.withCredentials = true;
		
		// 访问http-proxy-middleware代理服务器
		xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
		xhr.send();

	//后台代码
	
		var express = require('express');
		var proxy = require('http-proxy-middleware');
		var app = express();
		
		app.use('/', proxy({
		    // 代理跨域目标接口
		    target: 'http://www.domain2.com:8080',
		    changeOrigin: true,
		
		    // 修改响应头信息，实现跨域并允许带cookie
		    onProxyRes: function(proxyRes, req, res) {
		        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
		        res.header('Access-Control-Allow-Credentials', 'true');
		    },
		
		    // 修改响应信息中的cookie域名
		    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
		}));
		
		app.listen(3000);
		console.log('Proxy server is listen at port 3000...');
	
(2)vue框架的跨域(1次跨域)

* 利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了

* webpack.config.js部分配置：

	module.exports = {
	    entry: {},
	    module: {},
	    ...
	    devServer: {
	        historyApiFallback: true,
	        proxy: [{
	            context: '/login',
	            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
	            changeOrigin: true,
	            secure: false,  // 当代理某些https服务报错时用
	            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
	        }],
	        noInfo: true
	    }
	}


9. nginx代理跨域

https://www.cnblogs.com/BoatGina/p/8409549.html


<h3 id='十七、jsonp的安全问题' >十七、jsonp的安全问题</h3>

#### 一、callback参数可自定义导致的安全问题 (防止callback参数恶意添加标签（如script），造成XSS漏洞) ####

1. Content-type与XSS漏洞 

- http://127.0.0.1/getUsers.php?callback=<script>alert(/xss/)</script>

- 输出时没有对callback进行过滤，再加上如果没有严格设置Content-type的值为application/json,会使得浏览器将返回数据当成HTML解析，就会造成XSS漏洞

- 解决方案：
  * 严格定义输出的 Content-Type: application/json，浏览器不解析恶意插入的 XSS 代码
  * 限制callback函数名长度，严格过滤callback函数名
  * 过滤JSON里数据的输出

#### 二、jsonp劫持(属于CSRF范畴) ####

- jsonp劫持属于CSRF范畴，也可以说，jsonp可能会引起CSRF攻击，如果服务器的某个接口使用的是jsonp跨域，传递用户的敏感信息，那么攻击者可以构造一个恶意的jsonp调用页面，在用户登陆了目标网站之后，诱导用户访问恶意页面，利用用户的敏感信息去访问目标服务器，来达到攻击者的一些非法操作的目的

- 解决方案：CSRF攻击的解决方案

 






























   
<h1 id='css总结' style='background-color:darkgrey;'>css总结<h1>

<h3 id='一、BFC（块级格式化上下文）' >一、BFC（块级格式化上下文）</h3>

- 我们看到的页面是由一个一个的盒子组成的，元素的类型和display属性决定了这个盒子的类型，不同类型的盒子会参与不同的格式化上下文。格式化上下文就是页面中一块独立的渲染区域，并且有一套自己的渲染规则，它规定了其内部的子元素如何布局，而BFC就是display属性为block（此元素将显示为块级），list-item（此元素将显示为列表），table（此元素会作为块级表格来显示）的元素参与的格式化上下文，直译为块级格式化上下文。
 - 它的布局规则是：
       - 内部的盒子会在垂直方向上一个接一个的排列
       - 盒子垂直方向上的距离由margin决定，属于同一个BFC的相邻的两个盒子的margin会发生重叠
       - 对于从左往右的格式来说，盒子的左外边缘（margin-left）会触碰到容器的左边缘（border-left）
       - BFC区域和浮动区域不会重叠（自适应两栏布局）
       - BFC区域就是页面中的一块独立的区域，容器里面的子元素不会影响到外面的元素
       - 计算BFC时浮动元素也会参与计算（解决高度塌陷）        

 - 开启BFC:
       
       - 根元素（html）
       - float属性不为none
       - position属性为absolute,fixed
       - overflow属性不为visible
       - display属性为inline-block,table-cell,table-caption,flex,inline-flex

 - 应用

    - 解决高度塌陷

         - 高度塌陷是由于父元素没有设置高度，高度是由子元素撑起来的，当子元素设置了浮动脱离文档流之后，父元素就会塌陷，这时候我们可以给父元素开启BFC,因为计算BFC时浮动元素也会参与计算，所以就解决了父元素的高度塌陷问题

    - 实现自适应两栏布局BFC

         - 设置两个div，第一个div宽度固定，设置左浮动，第二个div就会自动填满剩余的宽度，正常情况下，第一个div会覆盖一部分第二个div。这时候我们可以给第二个div开启BFC，由于BFC和浮动元素不会重叠，这样就实现了两栏布局

    - 解决margin重叠

         - 由于属于同一个BFC相邻的两个块级元素会发生margin重叠，所以我们可以给其中一个盒子包一层div，然后激活它的BFC，这样它俩就不属于同一个BFC了，就不会margin重叠了


<h3 id='二、清除浮动'>二、清除浮动（https://blog.csdn.net/u012207345/article/details/78279961）</h3>

- 清除浮动的方法主要分为两类，一类是使用clear属性，一类是使用BFC
  - clear属性只能影响使用该属性的元素本身，不能影响其他元素。clear属性规定元素盒子的边不能和浮动元素相邻，所以我们使用clear清除浮动的原理就是，在父元素的最后加一个具有clear属性的块级元素，由于该块级元素不能和浮动元素相邻，而浮动元素的位置我们已经确定了，所以为了满足该元素的需求，将该元素渲染在了浮动元素的下面，由于该元素在父元素的边界内，所以父元素必须增加高度将它包含在内，这样就达到了清除浮动的目的
  - BFC原理是由于开启了BFC的元素在计算其高度时，是要包含浮动元素的，所以给父元素开启BFC就能清除浮动

<h3 id='三、css3动画'>三、css3动画</h3>

- css动画主要有transform，translation，animation。transform可以理解为元素的几何变形，它不会产生动画效果。translation和animation都可以实现过渡动画，不同的是translation只能定义开始状态和结束状态，不能定义中间状态，并且translation动画是需要事件触发的（：hover,:focus,js触发），不能在网页加载时自动执行，并且动画是不能循环的。

<h3 id='四、box-sizing'>四、box-sizing</h3>

- box-sizing 是用于告诉浏览器如何计算一个元素是总宽度和总高度
  - 标准盒模型 box-sizing: content-box

       - width = content width
       - height = content height

  - IE盒模型 box-sizing: border-box

       - width = border + padding + content width
       - heigth = border + padding + content heigth

<h3 id='五、min/max-width/height'>五、min/max-width/height</h3>

#### 一、min-width/height ####

- min-width/height默认值是auto。
- 给元素设置最小宽度，当width小于 min-width ，min-width会覆盖width的值。

		div{
		    min-width: 100px;
		    height: 100px;
		    width:20px;
		    border: 1px solid #000;
		}


- 针对这个div我们设置了width为20px,min-widthn:1000px。此时宽度是小于最小宽度的，导致最小宽度生效，最后div的宽度为100px。

- 给元素设置最小高度，当height小于 min-height ，min-height会覆盖height的值。

		.parent {
		  height: 200px;
		}
		.child {
		  min-height: 50%;
		  height: 50px;
		}

- 针对这个div我们设置了height为50px,min-height:50%(100px)。此时高度度是小于min-height的，导致min-height生效，最后div的高度为100px。

#### 二、max-width/height ####

- max-width/height默认值是none。
- 给元素设置最大宽度，当width大于 max-width ，max-width会覆盖width的值。
- 给元素设置最大高度，当height大于 max-height ，max-heighth会覆盖height的值。

#### 三、min-width与max-width的优先级 ####

- min-width和 都max-width用于一个元素时，它们中的哪一个会覆盖另一个？换句话说，哪一个具有更高的优先级？

   - 如果min-width的值 大于max-width，则该min-width值将被视为元素的宽度

		.parent {
		  width: 500px;
		}
		.child {
		  min-width:100%;(500px)
		  max-width: 50%;(250px)
		}

   - 当设定了width ,并且min-width大于width,min-width小于max-width时，这个时候min-width 生效。

       .child {
		  min-width: 50%;(250px)
		  max-width: 100%;（500px）
		  width: 200px;
		}


#### 四、应用场景 ####

1. flex布局 内部元素overflow:hidden;失效。

		.parent {
		  width: 250px;
		  display: flex;
		  background: rgb(182, 67, 67);
		}
		.child {
		  border: 1px solid #000;
		}
		p {
		  white-space: nowrap;
		  overflow: hidden;
		  text-overflow: ellipsis;
		}
		<div class="parent">
		  <div class="child">
		    <p>
		      我说道：“爸爸，你走吧。”他往车外看了看，说：“我买几个橘子去。你就在此地，不要走动。”我看那边月台的栅栏外有几个卖东西的等着顾客。
		    </p>
		  </div>
		</div>

- 如图所示，最终的效果：文字并没有隐藏显示省略号，这是因为啥呢？？？
- div.parent在设定为flex的时候,其子元素div.child的min-width自动设置为auto,导致浏览器按照p标签的宽度来自动设置宽度了。则min-width大于width，就覆盖了min-width，也就是：

		.child {
		  border: 1px solid #000;
		  min-width:auto;
		}

- 所以我们只要设置min-width:0；覆盖掉auto。 

2. 高度未知的元素动画

- 场景：一个下拉菜单，菜单项未知，导致无法设置高度，当鼠标放在上面可以缓慢的（动画）展开菜单。
- 当然你也可以使用js解决，直接获取高度，然后设置动画，这样也是ok的，但是max-height也可以解决。

      #menu #list {
        max-height: 0;
        transition: max-height 0.15s ease-out;
        overflow: hidden;
        background: #d5d5d5;
      }

      #menu:hover #list {
        max-height: 500px;
        transition: max-height 5s ease-in;
      }
    <div id="menu">
      <a>菜单</a>
      <ul id="list">
        <li>item</li>
        <li>item</li>
      </ul>
    </div>

3. 高度为 100% 的 HTML/Body

- 这个场景真的是经常遇到，比如说侧边栏的高度要铺满。

		html {
		  height: 100%;
		}
		
		body {
		  min-height: 100%;
		}

4. 最小宽的button

- 因为公司有自己的组件库，在设计button的时候，领导要求buttonBun不能太小。 像下面着两个按钮，当文字只有一个的时候，会显得特别小，所以这个时候领导为了统一样式，设定最小宽度。

5. 多列布局

- 比如常见的三栏布局，我们可以设定左侧和右侧布局的最大最小宽度，这样可以保证在不同设备下主栏的宽度，同时也保证左右两栏不会太小。
比较常见的应用应该是网站首页的三栏布局类型，一般是两边的侧边栏会设定一个最大最小宽度，中间为主栏，这样不管如何缩放都能突出主栏，且侧边栏也不会缩太小影响观感

<h3 id='六、css选择器'>六、css选择器</h3>

#### 一、选择器简介 ####

1. id选择器   #id名{属性名：属性值}
2. 类选择器   .class名{属性名：属性值}
3. 标签选择器 标签名{属性名：属性值}
4. 关系选择器
	
	- （1）包含选择器(后代选择器)（E F）
	
        - 选择所有被E包含的F元素，中间用空格隔开，更深一层也能检测到
	
	             如：ul li{color:red}
	
	                <ul>
	
	                   <li>web</li>
	                   <li>java</li>
	
	                </ul>
	
	- (2)子选择器（E > F）
	
       - 选择所有作为E元素的直接子元素F，对更深一层的元素不起作用，用>表示
	
	             如：div > a{color:red}
	
	                  <div>
	
	                     <a href="#">子元素1</a>
	                     <p>
	
	                        <a href='#'>孙元素</a>
	 
	                     </p>
	                     <a href="#">子元素2</a>
	
	                 </div>
	
	- (3)相邻选择器（E + F)
	
       - 选择紧跟E元素后的F元素，用加号表示，选择相邻的第一个兄弟元素，对更深一层的元素不起作用
	
	               如：h1 + p{color:red}
	
					  <h1>h1元素</h1>
					  <p>第一个元素<p>不起作用</p></p>
					  <p>第二个元素</p>
	
	- (4)兄弟选择器（E~F）
	
       - 选择E元素之后的所有兄弟元素F，作用于多个元素，用~隔开，对更深一层的元素也起作用
	
	             如：h1~p{color:red;}
	
					<h1>h1元素</h1>
					<p>第一个元素<p>起作用</p></p>
					<p>第二个元素</p>
	
5. 伪类选择器

    - 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素
    - 链接伪类选择器

       - :link      /* 未访问的链接 */  
       - :visited   /* 已访问的链接 */
       - :hover     /* 鼠标移动到链接上 */
       - :active    /* 选定的链接 */

       - a:hover 必须在 CSS 定义中的 a:link 和 a:visited 之后，才能生效！a:active 必须在 CSS 定义中的 a:hover 之后才能生效！伪类名称对大小写不敏感。
       
     - 结构(位置)伪类选择器（CSS3)

        - :first-child :选取属于其父元素的首个子元素的指定选择器
        - :last-child :选取属于其父元素的最后一个子元素的指定选择器
        - :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型，odd:奇数，even：偶数，3的倍数行：tr:nth-child(3n){}
        - :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。
        -  n 可以是数字、关键词或公式

6. 伪元素选择器

    - ::first-letter文本的第一个单词或字（如中文、日文、韩文等）
    - ::first-line 文本第一行；
    - ::selection 可改变选中文本的样式；
    - E::before和E::after

      - 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用

7. 属性选择器

   - 属性选择器可以根据元素的属性及属性值来选择元素

   - (1)简单属性选择

      - 如果希望选择有某个属性的元素，而不论属性值是什么，可以使用简单属性选择器

         - 例1：如果您希望把包含标题（title）的所有元素变为红色，可以写作：

					*[title] {color:red;}

         - 例2：与上面类似，可以只对有 href 属性的锚（a 元素）应用样式：

					a[href] {color:red;}

         - 例3：还可以根据多个属性进行选择，只需将属性选择器链接在一起即可。
          
         - 例如，为了将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色，可以这样写：
				
				   a[href][title] {color:red;}
   
   - (2)根据具体属性值选择

      - 除了选择拥有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素

        - 例1：例如，假设希望将指向 Web 服务器上某个指定文档的超链接变成红色，可以这样写：

				 a[href="http://www.w3school.com.cn/about_us.asp"] {color: red;}
             
         - 例2：与简单属性选择器类似，可以把多个属性-值选择器链接在一起来选择一个文档。

                 a[href="http://www.w3school.com.cn/"][title="W3School"] {color: red;}

   - (3)属性与属性值必须完全匹配

         - 请注意，这种格式要求必须与属性值完全匹配

                  例1：<p class="important warning">This paragraph is a very important warning.</p>

            - 如果写成 p[class="important"]，那么这个规则不能匹配示例标记

   - (4)根据部分属性值选择

         - 如果需要根据属性值中的词列表的某个词进行选择，则需要使用波浪号（~）

            - 例1：假设您想选择 class 属性中包含 important 的元素，可以用下面这个选择器做到这一点：

                 p[class~="important"] {color: red;}

         - 如果忽略了波浪号，则说明需要完成完全值匹配

   - (5)子串匹配属性选择器

      - 它是 CSS2 完成之后发布的，其中包含了更多的部分值属性选择器。按照规范的说法，应该称之为“子串匹配属性选择器”
      - [abc^="def"] 	选择 abc 属性值以 "def" 开头的所有元素
      - [abc$="def"] 	选择 abc 属性值以 "def" 结尾的所有元素
      - [abc*="def"] 	选择 abc 属性值中包含子串 "def" 的所有元素

        - 例1：如果希望对指向 W3School 的所有链接应用样式，不必为所有这些链接指定 class，再根据这个类编写样式，而只需编写以下规则：

				 a[href*="w3school.com.cn"] {color: red;}

   - (6)特定属性选择类型

         		例：*[lang|="en"] {color: red;}

      - 上面这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素。因此，以下示例标记中的前三个元素将被选中，而不会选择后两个元素：
			
				<p lang="en">Hello!</p>
				<p lang="en-us">Greetings!</p>
				<p lang="en-au">G'day!</p>
				<p lang="fr">Bonjour!</p>
				<p lang="cy-en">Jrooana!</p>

8. 通配符选择器
	
	     例：*{
	            color:red
	           }


#### 二、选择器优先顺序 ####

- 内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 元素选择器 = 关系选择器 = 伪元素选择器 > 通配符选择器
- 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。
- 注意：
 
  1. 使用！important 标记的CSS属性总是最优先的

           .class { color: yellow !important } 
  
  2. 优先级相同时，则采用就近原则，选择最后出现的样式
  3. 继承得来的属性，其优先级最低
                 

<h3 id='七、css选择器权重的计算以及性能优化'>七、css选择器权重的计算以及性能优化</h3>

#### 一、css优先级规则 ####

- 同一样式表：

   1. 权值相同

      - 就近原则（离被设置元素越近优先级越高）

   2. 权值不同

      - 根据权值来判断css样式
      - 那种css样式权值高，就使用那种样式


#### 二、权值等级划分 ####

- 第一等：行内样式，权值为1000
- 第二等：ID选择器，权值为100
- 第三等：类选择器、伪类、属性选择器，权值为10
- 第四等：标签选择器、伪元素选择器，权值为1
- 通配符选择器，关系选择器：权值为0
- 继承的样式没有权值，通配选择器定义的规则优先级高于元素继承过来的规则的优先级
- 最后比较特殊的一个标志!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0

#### 三、权值计算公式 ####

- 权值 = 第一等级选择器*个数，第二等级选择器*个数，第三等级选择器*个数，第四等级选择器*个数

#### 四、权值比较规则 ####

- 当两个权值进行比较的时候，是从高到低逐级将等级位上的权重值（如 权值 1,0,0,0 对应--> 第一等级权重值，第二等级权重值，第三等级权重值，第四等级权重值）来进行比较的，而不是简单的
 1000 x 个数 + 100 x 个数 + 10 x 个数 + 1 x 个数 的总和来进行比较的，**换句话说，低等级的选择器个数再多也不会越等级超过高等级的选择器的优先级的;比如十一个class的优先级没有一个Id的优先级高**

#### 五、权值规则 ####

- 先从高等级进行比较，高等级相同时，再比较低等级的，以此类推；
- 完全相同的话，就采用 后者优先原则（也就是样式覆盖）；
- css属性后面加 !important 时，无条件绝对优先（比内联样式还要优先）；

#### 六、回答 ####

- 判断优先级时，首先先看某一条属性上有没有加！important，一条属性（宽高有例外情况，由于宽高会被max-width/min-width覆盖，所以!important会失效。）上如果加上了！important，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的权重。

			<div class='box' id='box'></div>
	
			例一：.box{
			      background-color: chocolate;
			      width:100px !important;
			      height:100px !important;
			      max-width:60px;
			      max-height:60px;
			     }

           - div显示为60x60

		   例二：.box{
			     background-color: chocolate;
			     width:100px !important;
				 height:100px
		        }
		
				#box{
				background-color: chocolate;
				width:80px !important;
			    height:100px
				}
		

        - div显示为80x100，两套匹配规则里同一个元素上的同一个属性都使用了!important，这个时候就会比较匹配规则的权重，id大于class所以显示下面的

- 一条匹配规则一般是由多个选择器组成的，选择器的权重分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，
第四个等级是元素选择器和伪元素选择器，为0001。在比较权重的时候，是分等级比较的，将相同等级上的选择器个数叠加，所以等级低的选择器个数再多优先级都不会超过等级高的选择器，比如十一个class的优先级没有一个Id的优先级高。如果两个匹配规则的权重值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。

<h3 id='八、css可继承属性和不可继承属性'>八、css可继承属性和不可继承属性</h3>

#### 一、无继承性的属性 ####

1. display：规定元素应该生成的框的类型
文本属性：
2. vertical-align：垂直文本对齐
3. text-decoration：规定添加到文本的装饰
4. text-shadow：文本阴影效果
5. white-space：空白符的处理
6. unicode-bidi：设置文本的方向
7. 盒子模型的属性：width、height、margin、border、padding
8. 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment
9. 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index
10. 生成内容属性：content、counter-reset、counter-increment
11. 轮廓样式属性：outline-style、outline-width、outline-color、outline
12. 页面样式属性：size、page-break-before、page-break-after
13. 声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during

#### 二、有继承性的属性 ####

1. 字体系列属性

   - font-family：字体系列
   - font-weight：字体的粗细
   - font-size：字体的大小
   - font-style：字体的风格

2. 文本系列属性

   - text-indent：文本缩进
   - text-align：文本水平对齐
   - line-height：行高
   - word-spacing：单词之间的间距
   - letter-spacing：中文或者字母之间的间距
   - text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）
   - color：文本颜色


3. 元素可见性

    - visibility：控制元素显示隐藏


4. 列表布局属性

   - list-style：列表风格，包括list-style-type、list-style-image等


5. 光标属性

   - cursor：光标显示为何种形态


#### 三、回答 ####

- 每一个属性在定义中都给出了该属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值
- 一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。
- 当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。


<h3 id='九、隐藏元素的方法'>九、隐藏元素的方法</h3>

#### 一、隐藏元素的方法 ####

1. display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
2. visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。
3. opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
4. transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
5. position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
6. z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。
7. clip/clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

#### 二、display：none和visibility：hidden区别

1. 在渲染树中

- display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；
- visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。

2. 是否是继承属性

- display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；
- visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；

3. 修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；
4. 如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。


<h3 id='十、引入css样式的方式以及优先级'>十、引入css样式的方式以及优先级</h3>

#### 一、引入css样式的方式 ####

- CSS可以通过三种方式引入样式表，三种方式分别是行内样式表，内部样式表和外部样式表

  1. 行内样式表

     - 通过给标签设定style属性

	         <body>
				<div style="background-color: pink;width:200px;height:200px"></div>
			</body>

  2. 内部样式表

      - 通过在head标签中的style标签中编写样式

	        <head>
				<style type="text/css">
						div{
							width: 200px;
							height: 200px;
							background-color: pink;
						}
				</style>
			</head>

  3. 外部样式表

     - 通过创建外部的css样式表文件，然后在html文件中引入，引入的方式有两种，分别是链接引入css样式表文件和导入css样式表文件

     - html文件中的head标签下插入：

       - (1)链接引入css样式表

            	 <link rel="stylesheet" type="text/css" href="index.css"> //ref规定当前文档与被链接文档之间的关系

       - (2)导入css样式表文件
	
	              <style type="text/css">
						法一：@import url(index.css) //css样式表的路径
	                    法二：@import "index.css" //css样式表的路径
				  </style>

       - link和@import的区别：

          - link是html的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；而@import是css的语法，只有导入样式表的作用。
          - link引入属于html的标签语法，在加载页面时，就会同时加载css样式表。@import导入css样式表，属于css中的语法，在加载页面时，加载页面完成之后才会加载css样式表
          - 兼容性：@import是 CSS2.1 才有的语法，所以只能在 IE5以上 才能识别；而link是 HTML 标签，所以不存在兼容性问题。
          - DOM：javascript只能控制dom去改变link标签引入的样式，而@import的样式不是dom可以控制的。


#### 二、引入样式方式比较 ####

   类别                    引入方法                      位置                               加载

 行内样式                开始标签内style               html文件内                            同时

 内部样式              <head>中的<style>内            html文件内                             同时

 链入外部样式          <head>中的<link>引用       css样式文件与html文件分离           页面加载时，同时加载css样式

 导入式@import           样式代码最开始处         css样式文件与html文件分离             在读取完html文件之后加载



#### 三、css样式引入的优先级 ####

- 行内样式 > 内部样式 > 外部样式

- 说明：- 链入外部样式表与内部样式表之间的优先级取决于所处位置的先后

          <link></link>           <style></style>
          <style></style>         <link></link>
 
- 最后定义的优先级最高（就近原则）

<h3 id='十一、requestAnimationframe动画'>十一、requestAnimationframe动画</h3>

#### 一、前言 ####

- 实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。

#### 二、window.requestAnimationFrame()是什么？ ####

- 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。
- 我们先初步认识一下它，根据文档。我们给它传递一个回调函数 test 。

		   let test = document.querySelector('#test')
		   let i=100
		   function animation(){
		     test.style.marginLeft = i+'px'
		   }
		
		   window.requestAnimationFrame(animation)

           可以看到，div向右移动了100px

- 但是它只执行了一次，怎么做动画呢？别急，再看看 MDN 怎么说。
- 注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()

		   let test = document.querySelector('#test')
		   let i=0
		   function animation(){

		     test.style.marginLeft = i+'px'
		     i++
		     window.requestAnimationFrame(animation)
		   }
		
		   window.requestAnimationFrame(animation)

           这个div会一直移动下去

#### 三、执行频率 ####

- 这时候有小伙伴就要问了，我没有像 setTimeout 和 setInterval 那样设置时间，它为什么会间隔执行呢？
- 它根本就不用手动设置执行间隔时间，而是根据浏览器屏幕刷新次数自动调整了,也就是说浏览器屏幕刷新多少次，它就执行多少次。
- 屏幕刷新频率（次数）： 屏幕每秒出现图像的次数。普通笔记本为60Hz，也就是 1s 大约执行 60 次，然后每执行一次大约是 16.6ms。

#### 四、回调参数 ####

- 回调函数会有一个参数指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。

		   let test = document.querySelector('#test')
		   let i=0
		   function animation(time){
		     if(i>300){
		       return
		     }
		     console.log(time)
		     test.style.marginLeft = i+'px'
		     i++
		     window.requestAnimationFrame(animation)
		   }
		
		   window.requestAnimationFrame(animation)

- 在同一个帧中的 多个回调函数 ，它们每一个都会接受到一个 相同的时间戳

		(() => {
		  function test1(timestamp) {
		    console.log(`🚀🚀hello ~ requestAnimationFrame1 ${timestamp}`);
		    requestAnimationFrame(test1)
		  }
		  function test2(timestamp) {
		    console.log(`🚀🚀hello ~ requestAnimationFrame2 ${timestamp}`);
		    requestAnimationFrame(test2)
		  }
		  requestAnimationFrame(test1)
		  requestAnimationFrame(test2)
		
		})()

- 可以看到，两个 requestAnimationFrame 在控制台输出的时间戳是一样的。也就是浏览器刷新一次的时候，执行所有的 requestAnimationFrame ，并且它们的回调参数是一模一样的。

#### 五、浏览器的自我拯救 ####

- 为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的<iframe> 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。
- 这个就厉害了，你要是当时没有浏览页面，并且也没关掉，那么 requestAnimationFrame() 一直在这跑，多消耗性能啊。

		   let test = document.querySelector('#test')
		   let i=0
		   function animation(){
		     if(i>300){
		       return
		     }
		     test.style.marginLeft = i+'px'
		     console.log(i)
		     i++
		     window.requestAnimationFrame(animation)
		   }
		
		   window.requestAnimationFrame(animation)


- 可以看到，控制台打印i，我切到另一个页面，几秒钟后我切回来的时候，依然是接着刚才的位置进行输出。

#### 六、返回值 ####

- requestAnimationFrame 会返回一个请求 ID，是回调函数列表中的一个唯一值，可以使用 cancelAnimationFrame 通过传入该请求 ID 取消回调函数。

		   let test = document.querySelector('#test')
		   let i=0
		   let requestId = null
		   function animation(){
		     test.style.marginLeft = i+'px'
		     console.log(i)
		     i++
		     requestId = window.requestAnimationFrame(animation)
		     if(i>300){
		      cancelAnimationFrame(requestId);
		     }
		   }
		
		   animation()

#### 七、优势 ####

- requestAnimationFrame采用系统时间间隔，保持最佳绘制效率。不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间过长，使动画卡顿。
- 从实现的功能和使用方法上，requestAnimationFrame与定时器setTimeout都相似，所以说其优势是同setTimeout实现的动画相比。

1. 提升性能，防止掉帧

- 浏览器 UI 线程：浏览器让执行 JavaScript 和更新用户界面（包括重绘和回流）共用同一个单线程，称为“浏览器 UI 线程”
- 浏览器 UI 线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是运行 JavaScript 代码，要么执行 UI 更新。

- 通过setTimeout实现动画

   - setTimeout通过设置一个间隔时间不断改变图像，达到动画效果。该方法在一些低端机上会出现卡顿、抖动现象。这种现象一般有两个原因：
     - setTimeout的执行时间并不是确定的。

        - 在 JavaScript 中，setTimeout任务被放进异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列的任务是否需要开始执行。所以，setTimeout的实际执行时间一般比其设定的时间晚一些。这种运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到【浏览器 UI 线程队列】中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行
        
			let startTime = performance.now();
			setTimeout(() => {
			  let endTime = performance.now();
			  console.log(endTime - startTime);
			}, 50);
			/* 一个非常耗时的任务 */
			for (let i = 0; i < 20000; i++) {
			  console.log(0);
			}




 - 刷新频率受屏幕分辨率和屏幕尺寸影响，不同设备的屏幕刷新率可能不同，setTimeout只能设置固定的时间间隔，这个时间和屏幕刷新间隔可能不同
 - 以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。
 - setTimeout的执行只是在内存中对图像属性进行改变，这个改变必须要等到下次浏览器重绘时才会被更新到屏幕上。如果和屏幕刷新步调不一致，就可能导致中间某些帧的操作被跨越过去，直接更新下下一帧的图像。
   
    - 假如使用定时器设置间隔 10ms 执行一个帧，而浏览器刷新间隔是 16.6ms（即 60FPS）
    - 在 20ms 时，setTimeout调用回调函数在内存中将图像的属性进行了修改，但是此时浏览器下次刷新是在 33.2ms 的时候，所以 20ms 修改的图像没有更新到屏幕上。
而到了 30ms 的时候，setTimeout又一次调用回调函数并改变了内存中图像的属性，之后浏览器就刷新了，20ms 更新的状态被 30ms 的图像覆盖了，屏幕上展示的是 30ms 时的图像，所以 20ms 的这一帧就丢失了。丢失的帧多了，画面就卡顿了。
使用 requestAnimationFrame 执行动画，最大优势是能保证回调函数在屏幕每一次刷新间隔中只被执行一次，这样就不会引起丢帧，动画也就不会卡顿


2. 节约资源，节省电源

- 使用 setTimeout 实现的动画，当页面被隐藏或最小化时，定时器setTimeout仍在后台执行动画任务，此时刷新动画是完全没有意义的（实际上 FireFox/Chrome 浏览器对定时器做了优化：页面闲置时，如果时间间隔小于 1000ms，则停止定时器，与requestAnimationFrame行为类似。如果时间间隔>=1000ms，定时器依然在后台执行）

		// 当开始输出count后，切换浏览器tab页，再切换回来，可以发现打印的值没有停止，甚至可能已经执行完了
		let count = 0;
		let timer = setInterval(() => {
		  if (count < 20) {
		    count++;
		    console.log(count);
		  } else {
		    clearInterval(timer);
		    timer = null;
		  }
		}, 2000);


- 使用requestAnimationFrame，当页面处于未激活的状态下，该页面的屏幕刷新任务会被系统暂停，由于requestAnimationFrame保持和屏幕刷新同步执行，所以也会被暂停。当页面被激活时，动画从上次停留的地方继续执行，节约 CPU 开销。

		// 当开始输出count后，切换浏览器tab页，再切换回来，可以发现打印的值从离开前的值继续输出
		let count = 0;
		function requestAnimation() {
		  if (count < 500) {
		    count++;
		    console.log(count);
		    requestAnimationFrame(requestAnimation);
		  }
		}
		requestAnimationFrame(requestAnimation);



3. 函数节流

- 一个刷新间隔内函数执行多次时没有意义的，因为显示器每 16.7ms 刷新一次，多次绘制并不会在屏幕上体现出来
- 在高频事件（resize，scroll等）中，使用requestAnimationFrame可以防止在一个刷新间隔内发生多次函数执行，这样保证了流畅性，也节省了函数执行的开销
- 某些情况下可以直接使用requestAnimationFrame替代 Throttle 函数，都是限制回调函数执行的频率

4. 减少DOM操作

- requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。


<h3 id='十二、盒模型'>十二、盒模型</h3>

#### 一、css盒模型 ####

* 主要属性：width,height,padding,border,margin
* 标准盒模型与IE盒模型的区别
     
   * 在标准盒模型中，width和height指的是内容区域的宽度和高度
   * 在IE盒模型中，width和height指的是内容区域的宽度和高度+padding+border

#### 二、box-sizing属性 ####

* 用来控制元素的盒子模型的解析模式，默认为content-box

  * content-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽
  * border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽
  * inherit:规定应从父元素继承 box-sizing 属性的值。

#### 三、回答 ####

- 盒模型一般由content、padding、border、margin四部分组成。
- 标准盒模型盒IE盒模型的区别在于设置width和height所对应的范围不同，标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content
- 一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。content-box表示以标准盒模型解析，border-box表示以IE盒模型解析


<h3 id='十三、css3新特性'>十三、css3新特性</h3>

https://juejin.cn/post/6844903518520901639#heading-24
#### 一、动画 ####

- transform(变形)、transition、animation

#### 二、选择器 ####

- element1~element2 ：选择element1元素之后的所有兄弟元素element2。兄弟选择器
- [attribute^=value]: 选择某元素attribute属性是以value开头的。属性选择器 
- [attribute$=value]: 选择某元素attribute属性是以value结尾的。属性选择器
- [attribute*=value]: 选择某元素attribute属性包含value字符串的。属性选择器
- E:first-of-type: 选择属于其父元素的首个E元素的每个E元素。
- E:last-of-type: 选择属于其父元素的最后E元素的每个E元素。
- E:only-of-type: 选择属于其父元素唯一的E元素的每个E元素。
- E:only-child: 选择属于其父元素的唯一子元素的每个E元素。
- E:nth-child(n): 选择属于其父元素的第n个子元素的每个E元素。
- E:nth-last-child(n): 选择属于其父元素的倒数第n个子元素的每个E元素。
- E:nth-of-type(n): 选择属于其父元素第n个E元素的每个E元素。
- E:nth-last-of-type(n): 选择属于其父元素倒数第n个E元素的每个E元素。
- E:last-child: 选择属于其父元素最后一个子元素每个E元素。
- :root: 选择文档的根元素。
- E:empty: 选择没有子元素的每个E元素（包括文本节点)。
- E:target: 选择当前活动的E元素。
- E:enabled: 选择每个启用的E元素。
- E:disabled: 选择每个禁用的E元素。
- E:checked: 选择每个被选中的E元素。
- E:not(selector): 选择非selector元素的每个元素。
- E::selection: 选择被用户选取的元素部分。

#### 三、边框 ####

- CSS3新增了三个边框属性，分别是border-radius、box-shadow和border-image。border-radius可以创建圆角边框，box-shadow可以为元素添加阴影，border-image可以使用图片来绘制边框。IE9+支持border-radius和box-shadow属性。Firefox、Chrome以及Safari支持所有新的边框属性。

#### 四、背景 ####

- CSS3新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break。

1. background-clip

   - background-clip属性用于确定背景画区，有以下几种可能的属性：

     - background-clip: border-box; 背景从border开始显示
     - background-clip: padding-box; 背景从padding开始显示
     - background-clip: content-box; 背景显content区域开始显示
     - background-clip: no-clip; 默认属性，等同于border-box

   - 通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。

2. background-origin

   - background-clip属性用于确定背景的位置，它通常与background-position联合使用，可以从 border、padding、content来计算background-position（就像background-clip）。

     - background-origin: border-box; 从border开始计算background-position
     - background-origin: padding-box; 从padding开始计算background-position
     - background-origin: content-box; 从content开始计算background-position

3. background-size

   - background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：

     - background-size: contain; 缩小图片以适合元素（维持像素长宽比）
     - background-size: cover; 扩展元素以填补元素（维持像素长宽比）
     - background-size: 100px 100px; 缩小图片至指定的大小
     - background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸

4. background-break

   - CSS3中，元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。

     - background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）
     - background-break: bounding-box; 把盒之间的距离计算在内；
     - background-break: each-box; 为每个盒子单独重绘背景。

#### 五、反射 ####

- 这个也可以说是倒影，用起来也挺有趣的。
- 语法

  -webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片

#### 六、文字效果 ####

1. word-wrap

   - word-wrap: normal|break-word; break-word：允许在长单词或url地址换行

2. text-overflow

  - 它与word-wrap是协同工作的，word-wrap设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。

3. text-shadow

  - CSS3中，text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。

		h1{
		    text-shadow: 5px 5px 5px #FF0000;
		}

4. text-decoration

- CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：

   - text-fill-color: 设置文字内部填充颜色
   - text-stroke-color: 设置文字边界填充颜色
   - text-stroke-width: 设置文字边界宽度

#### 七、颜色 ####

1. rgba

   - rgb为颜色值，a为透明度
   
		color: rgba(255,00,00,1);
		background: rgba(00,00,00,.5);

2. hsla

   - h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”

		color: hsla( 112, 72%, 33%, 0.68);
		background-color: hsla( 49, 65%, 60%, 0.68);

#### 八、渐变 ####

- CSS3新增了渐变效果，包括linear-gradient(线性渐变)和radial-gradient(径向渐变)。

#### 九、滤镜 #### 

#### 十、弹性布局 ####

- flex
- https://link.juejin.cn/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html
- https://link.juejin.cn/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-examples.html

#### 十一、栅格布局 ####

- grid
- https://link.juejin.cn/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2Fd183265a8dad

#### 十二、多列布局 ####

	<div class="newspaper">
	当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。
	</div>
	
	.newspaper
	{
	    column-count: 3;
	    -webkit-column-count: 3;
	    -moz-column-count: 3;
	    column-rule:2px solid #000;
	    -webkit-column-rule:2px solid #000;
	    -mox-column-rule:2px solid #000;
	}    

#### 十三、盒模型定义 ####

#### 十二、媒体查询 ####

- 媒体查询，就在监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式

			<!DOCTYPE html>
			<html>
			<head>
			<meta charset="utf-8"> 
			<title></title> 
			<style>
			body {
			    background-color: pink;
			}
			@media screen and (max-width: 960px) {
			    body {
			        background-color: darkgoldenrod;
			    }
			}
			@media screen and (max-width: 480px) {
			    body {
			        background-color: lightgreen;
			    }
			}
			</style>
			</head>
			<body>
			
			<h1>重置浏览器窗口查看效果！</h1>
			<p>如果媒体类型屏幕的可视窗口宽度小于 960 px ，背景颜色将改变。</p>
			<p>如果媒体类型屏幕的可视窗口宽度小于 480 px ，背景颜色将改变。</p>
			
			</body>
			</html>



<h3 id='十四、替换元素的概念及计算规则'>十四、替换元素的概念及计算规则</h3>

#### 一、概念 ####

- 可替换元素的展现不是由css控制的，这是一类外观渲染独立于css的外部对象。浏览器会根据元素的标签和属性，来决定元素的具体显示内容。

#### 二、特性 ####

- 内容的外观不受页面上的CSS的影响：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。
- 有自己的尺寸：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如
- 在很多CSS属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。
- 所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block

#### 三、尺寸 ####

1. 固有尺寸

  - 即替换元素本身的尺寸，例如，一张图片，它的尺寸是900*383px，这个就是它的固有尺寸
  - 当一个替换元素单独存在，没有设置任何尺寸时，它就会保持它原有的尺寸

2. HTML尺寸

   - 所谡HTML尺寸，就是在HTML标签中指定替换元素的大小
   
		例如：在<img>标签中设置了width = 450px
		<img width="450px" src="" />

   - 当你设置HTML尺寸时，替换元素将不再使用固有尺寸，而是变成你设置的尺寸
   - HTML尺寸的设置也分为两种情况：

     - 只设置宽度或高度

        - 当只设置一个宽度或高度时，替换元素的尺寸将会成比例进行变化。

           - 当只设置宽度时，设置的宽度是原有的宽度的一半，为了保持图片成比例，图片的高度也减小一半
           - 当只设置高度时,为了保持图片成比例，浏览器进行计算得出宽度应该成比例的变为多少

     - 同时设置宽度和高度

        - 如果同时设置宽度和高度，如果你设置的宽度和高度刚好和原图成比例，那么图片还是成比例进行缩放。但是如果设置的不成比例，图片就会变形


3. CSS尺寸

- CSS尺寸就是指通过CSS样式设置的尺寸。当你设置了CSS样式后，替换元素的尺寸将会覆盖掉HTML尺寸（当然，也会覆盖掉固有尺寸）

<h3 id='十五、常见的图片格式及使用场景'>十五、常见的图片格式及使用场景</h3>

#### 一、前置知识 ####

- 无压缩。无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP格式就是其中之一。
- 无损压缩。压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。
- 有损压缩。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg。
- 索引色(Indexed color)和直接色(Direct color)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。
- 光栅格式(raster)和矢量格式(vector)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 Photoshop 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。

#### 二、图片格式分类  ####

1. BMP

   - 是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。

2. gif

   - 采用LZW压缩算法进行编码，是一种无损的基于索引色的图片格式。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8=256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。

3. jpg

   - jpg是一种有损的基于直接色的图片格式。由于采用直接色，jpg可使用的颜色有1600w之多（2^24），而人眼识别的颜色数量大约只有1w多种，因此jpg非常适合色彩丰富图片、渐变色。jpg有损压缩移除肉眼无法识别的图片细节后，可以将图片的尺寸大幅度地减小。JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。

4. png-8

  - png-8采用无损压缩，是基于8位索引色的位图格式。png-8相比gif对透明的支持更好，同等质量下，尺寸也更小。非常适合作为gif的替代品。但png-8也一个明显的不足就是不支持动画。这也是png-8没办法完全替代gif的重要原因。如果没有动画需求推荐使用png-8来替代gif。

5. png-24

    - png-24采用无损压缩，是基于直接色的位图格式。png-24的图片质量堪比bmp，但是却有bmp不具备的尺寸优势。当然相比于jpg，gif，png-8，尺寸上还是要大。正是因为其高品质，无损压缩，非常适合用于源文件或需要二次编辑的图片格式的保存。
    - png-24与jpg一样能表达丰富的图片细节，但并不能替代jpg。图片存储为png-24比存储为jpg，文件大小至少是jpg的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用jpg。
   - png-24与png-8一样也支持透明。

6. SVG 

   -  SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。

7. WebP

   - WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。
   - 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
   - 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
   - WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。

<h3 id='十六、雪碧图'>十六、雪碧图</h3>

#### 一、background-position属性

1. background-position属性的定义

- background-position 属性设置背景图像的起始位置

2. background-position的属性值

- background-position有两个属性值， background-position：x | y，用法上可以对其一个属性单独使用 background-position-x 和 background-position-y。
- background-position属性值有三种情况:

  - 方向值：x轴方向：left|center|right，y轴方向：top|center|bottom
  - 百分比：x轴方向：x%，y轴方向：x%
  - 数值：x轴方向：xpx，y轴方向：xpx

- background-position两个属性值可以混用，例如：方向值和数值、数值和百分比，并非x轴和y轴需要设置为同一类型的属性值，这点也正是说明了background-position属性可以衍生单独设置background-position-x 或 background-position-y。

3. background-position的属性值分析

- 我们都知道background-position 属性的作用：设置背景图像的起始位置。这里的起始位置是相对于自身容器而言，如果属性值为数值，大家可能很好理解，例如：background-position：100px 50px 这个属性值意味着图片在距离自身容器x轴为100px、y轴为50px的位置作为图片显示的起点位置。

#### 二、雪碧图 ####

- CSS雪碧图即CSS Sprites，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用CSS的背景定位来显示需要显示的图片部分。

<img src='../images/雪碧图1.awebp' />

- 上面这张图片是由多个小图片合成的，前端成它为CSS雪碧图。

1. background-position属性在雪碧图中的用法

- 了解了background-position属性的用法，那么对于如何使用雪碧图的学习就相对简单了很多。使用雪碧图之前，我们需要知道雪碧图中各个图标的位置。

![image](https://github.com/zxsmile/knowledge-notes/blob/master/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/images/%E9%9B%AA%E7%A2%A7%E5%9B%BE1.jpg)

- 从上面的图片不难看出雪碧图中各个小图标（icon）在整张雪碧图的起始位置，例如第一个图标（裙子）在雪碧图的起始位置为 x：0，y：0，第二个图标（鞋子）在雪碧图的起始位置为 x：0，y：50px，第三个图标（足球）在雪碧图的起始位置为x：0，y：100px，依次类推可以得出各个图片相对于雪碧图的起始位置。

- 以上面的雪碧图为例，用一个Demo来阐述它的使用方法。

		<style>
		    .box{width: 600px; height:300px; border: 3px solid #ccc; background-color: #8064A2; }
		    span{display: inline-block; width: 25px; height: 25px; border: 3px solid #ccc;
		    background-image: url(css/img/sidebar.png); background-repeat: no-repeat; margin: 5px;}
		    .icon1{background-position: 0 0;}
		    .icon2{background-position: -50px 0;}
		    .icon3{background-position: 0 -50px;}
		    .icon4{background-position: -50px -50px;}
		</style>

		<div class="box">
		    <span class="icon1"></span>
		    <span class="icon2"></span>
		    <span class="icon3"></span>
		    <span class="icon4"></span>
		</div>


<img src='../images/雪碧图3.awebp />

2. 为什么使用雪碧图时background-position属性值为负数

- 上面的span标签是一个50px长宽的容器，在使用背景图时，背景图的初始位置会从容器的左上角的开始铺满整个容器，然而容器的大小限制了背景图呈现的大小，超出容器部分被隐藏起来。假如设置background-position: 0 0 那么意味着，背景图相对于容器（span标签）x轴=0；y轴=0的位置作为背景图的起始位置来显示图片。所以如果需要在容器中显示第二个图标，意味着雪碧图x轴方向要左移动，左移动雪碧图即它的值会设置为负数，同理y轴方向也一样。

#### 三、雪碧图优缺点 ####

1. 优点

- 利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；
- CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。

2. 缺点：

- 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；
- CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置
- 维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。


<h3 id='十七、对line-height 的理解及其赋值方式'>十七、对line-height 的理解及其赋值方式</h3>

#### 一、line-height的概念 ####

- line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；
- 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；
- 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；
- 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；
- line-height 和 height 都能撑开一个高度；

#### 二、line-height 的赋值方式 ####

- 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高
- 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px
- 百分比：将计算后的值传递给后代


<h3 id='十八、CSS 优化和提高性能的方法有哪些？'>十八、CSS 优化和提高性能的方法有哪些？</h3>

#### 一、加载性能 ####

1. css压缩：将写好的css进行打包压缩，可以减小文件体积。
2. css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。
3. 减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

#### 二、选择器性能 ####

1. 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；
2. 如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。
3. 避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。
4. 尽量少的去对标签进行选择，而是用class。
5. 尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。
6. 了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。

#### 三、渲染性能 ####

1. 慎重使用高性能属性：浮动、定位。
2. 尽量减少页面重排、重绘。
3. 去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。
4. 属性值为0时，不加单位。
5. 属性值为浮动小数0.**，可以省略小数点之前的0。
6. 标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。
7. 不使用@import前缀，它会影响css的加载速度。
8. 选择器优化嵌套，尽量避免层级过深。
9. css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。
10. 正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。
11. 不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。

#### 四、可维护性、健壮性 ####

1. 将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。
2. 样式与内容分离：将css代码定义到外部css中。

<h3 id='十九、单行、多行文本溢出隐藏'>十九、单行、多行文本溢出隐藏</h3>

1. 单行文本溢出

		overflow: hidden;            // 溢出隐藏
		text-overflow: ellipsis;      // 溢出用省略号显示
		white-space: nowrap;         // 规定段落中的文本不进行换行

2. 多行文本溢出

		overflow: hidden;            // 溢出隐藏
		text-overflow: ellipsis;     // 溢出用省略号显示
		display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
		-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
		-webkit-line-clamp:3;        // 显示的行数

- 注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。

<h3 id='二十、对 CSS 工程化的理解'>二十、对 CSS 工程化的理解</h3>

#### 一、CSS 工程化是为了解决以下问题 ####

- 宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？
- 编码优化：怎样写出更好的 CSS？
- 构建：如何处理我的 CSS，才能让它的打包结果最优？
- 可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？

#### 二、方向 ####

- 以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：

  - 预处理器：Less、 Sass 等；
  - 重要的工程化插件： PostCss；
  - Webpack loader 等 。

- 基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：

  -（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？

    - 预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：
    - 那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：

      - 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；
      - 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；
      - 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。
    - 这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：

       - 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；
       - 支持定义 css 变量；
       - 提供计算函数；
       - 允许对代码片段进行 extend 和 mixin；
       - 支持循环语句的使用；
       - 支持将 CSS 文件模块化，实现复用。

  - （2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？

      - 它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。

      - PostCss 在业务中的使用场景非常多：

        - 提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；
        - 当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 Autoprefixer 插件可以帮助我们自动增加浏览器前缀；
        - 允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；

  - （3）Webpack 能处理 CSS 吗？如何实现？

      - Webpack 在裸奔的状态下，是不能处理 CSS 的，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；
      - Webpack 在 loader 的辅助下，是可以处理 CSS 的。

      - 如何用 Webpack 实现对 CSS 的处理：
        - Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader

          - css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；
          - style-loader：创建style标签，把 CSS 内容写入标签。
          - 在实际使用中，css-loader 的执行顺序一定要安排在 style-loader 的前面。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。



<h3 id='二十一、 z-index属性在什么情况下会失效'>二十一、 z-index属性在什么情况下会失效</h3>

#### 一、简介 ####

- 通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。

#### 二、失效 ####

- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；
- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；
- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；

<h3 id='二十二、css单位'>二十二、css单位</h3>

#### 一、em ####

* 子元素的font-size使用em单位，则1em = 父元素的单位为px时的font-size值。若父元素没有设置font-size,则一直向上寻找祖先元素，body的font-size默认为16px
* 根据父元素算出子元素的font-size之后，如果这个值小于浏览器默认的最小font-size:12px,则font-size会被设置为12px
* 子元素的除了font-size属性之外的其他属性(如：width，height)的单位使用em为单位时，1em=自己本身的单位为px时的font-size值。若该子元素(自己本身)没有设置font-size值或者font-size值小于最小值12px则根据最小font-size：12px来取值

	如：<div class='parent'>
	          <div class='child'>ddd</div>
	    </div>

	 	.parent{
	              font-size:10px;
	            }
	
	    .child{
	              font-size:2em;
	              width:2em;
	           }

- 则上例中ddd的font-size为2*10=20px,width为2*20=40px

#### 二、rem ####

* rem是根据根元素html的font-size来确定的值的
* 子元素的font-size使用rem单位，则1rem=html的单位为px时的font-size值，html默认font-size为16px
* 根据html计算出的子元素的font-size之后，如果这个值小于浏览器默认的最小font-size:12px,则font-size会被设置为12px
* 子元素的除了font-size属性之外的其他属性(如：width，height)的单位使用rem为单位时，也是根据html的font-size值来计算，1rem=html的单位为px时的font-size值,若html的font-size值小于12px,则1rem=12px
	
		如：<div class='parent'>
		          <div class='child'>ddd</div>
		    </div>
	
		 	.html{
		              font-size:10px;
		            }
		
		    .child{
		              font-size:2rem;
		              width:2rem;
		           }

- 上例中child中的font-size的实际值为20px,width实际值为24px,因为html的font-size值为10px小于12px,所以width是根据1rem=12px来计算的

#### 三、px ####

* px是pixel缩写，是基于像素的单位。在浏览网页过程中，屏幕上的文字、图片等会随屏幕的分辨率变化而变化，一个100px宽度大小的图片，在800×600分辨率下，要占屏幕宽度的1/8，但在1024×768下，则只占约1/10。所以如果在定义字体大小时，使用px作为单位，那一旦用户改变显示器分辨率从800到1024，用户实际看到的文字就要变“小”（自然长度单位），甚至会看不清，影响浏览

#### 四、vw和vh ####

* vw和vh是相对窗口大小的
* vw等于窗口宽度的1/100，vh等于窗口高度的1/100
* 元素的font-size属性有最小限制12px,若按照窗口大小计算下来的font-size值小于12px，则font-size值为12px

		     如：<div class='parent'>
			          <div class='child'>ddd</div>
			    </div>
			
			    .child{
			              font-size:1vw;
			              width:1vw;
			           }


- 上例中，设此时窗口大小为700px,则font-size的实际值为12px,width的实际值为7px

#### 五、vmin 和 vmax ####

* vmin 和 vmax与窗口宽度的最大值最小值有关
* vmax取视口宽和高中的最大值的1/100，vmin取视口宽和高的最小值的1/100

    	如，如果浏览器设置为1100px宽、700px高，1vmin会是7px，1vmax为11px。然而，如果宽度设置为800px，高度设置为1080px，1vmin将会等于8px而1vmax将会是10.8px

#### 六、突破浏览器的最小字体限制12px ####

- 利用transform: scale(0.5)可以满足要求，具体使用时，发现把整个div宽高都缩放了

	         比如设置font-size：10px
	
	           p{
	
	             font-size:20px;
	             transform:scale(0.5)
            }
   - transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;

#### 八、百分比 ####

1. width,max-width,min-width,height,max-height,min-height

   - width,max-width,min-width基于包含块的宽度
   - height,max-height,min-height基于包含块的高度

2. margin

   - 基于包含块的宽度，与包含块高度无关

3. padding

   - 基于包含块的宽度，与包含块高度无关
  
4. top,left,bottom,right

    - top和bottom基于包含块的高度
    - left和right基于包含块的宽度

5. line-height

   - 基于元素自身的font-size

6. vertical-align
 
   - 基于line-height


<h3 id='二十三、flex布局'>二十三、flex布局</h3>

#### 一、概述 ####

- Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。
- 任何一个容器都可以指定为Flex布局，设置方法为：

		.box{
		    display: flex;
		}

- 行内元素也可以使用Flex布局。

		.box{
		  display: inline-flex;
		}

- Webkit内核的浏览器，必须加上-webkit前缀。

		.box{
		  display: -webkit-flex; /* Safari */
		  display: flex;
		}

- **注意**：使用Flex布局之后，里面的float、clear、vertical-align属性将失效。
 
#### 二、flex布局基本概念 ####
 
- 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。
1. 容器的属性

   - （1）flex-driection设置项目的排列方向，默认属性row, flex-driection的值：

       * row :主轴为水平方向，起点在左端。
       * row-reverse: 主轴为水平方向，起点在右端。
       * column :主轴为垂直方向，起点在上沿。
       * column-revers:主轴为垂直方向，起点在下沿。

				.box{
				    display: flex;
				    display: -webkit-flex;
				    flex-direction: row;
				    }

   - （2）flex-wrap设置项目是否在一条线上，默认nowrap,flex-wrap的值：

      * wrap :换行，第一行在上方。
      * nowrap: 不换行。
      *  wrap-reverse:换行，第一行在下方。

				.box{
				    display: flex;
				    display: -webkit-flex;
				    flex-wrap: wrap;
				    }

  - （3）flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
  - （4）justify-content属性定义项目在主轴上的对齐方式，默认值为flex-start,justify-content的值:

      *  flex-start ：左对齐
      *  flex-end  ：右对齐
      * center  ：居中
      *  space-between  ：两端对齐，项目之间的间隔都相等。
      * space-around ：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

				.box{
				    display: flex;
				    display: -webkit-flex;
				    justify-content: flex-start;

  - （5）align-items属性定义项目在纵轴上的对齐方式，默认值为stretch,align-items的值：
  
      * flex-start： 交叉轴的起点对齐。
      * flex-end ： 交叉轴的终点对齐。
      * center ： 交叉轴的中点对齐。
      * baseline ：  项目的第一行文字的基线对齐。
      * stretch： 如果项目未设置高度或设为auto，将占满整个容器的高度。

				.box{
				    display: flex;
				    display: -webkit-flex;
				     align-items: flex-start;
				     }

   - （6）align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。align-content的值：
   
       * flex-start：与交叉轴的起点对齐。
       * flex-end：与交叉轴的终点对齐。
       * center：与交叉轴的中点对齐。
       * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
       * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
       * stretch（默认值）：轴线占满整个交叉轴。

				.box{
				    display: flex;
				    display: -webkit-flex;
				    flex-wrap: wrap;
				    }

2. 项目的属性

    - （1）order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

				.item {
				  order: <integer>;
				}

    - （2）flex-grow属性定义项目的放大比例，主要在父元素的宽度大于子元素的宽度之和时候起作用，它定义子元素如何分配父元素的剩余宽度，默认为0，这个时候不索取父元素的宽度。

				.item {
				  flex-grow: <number>;  /* default 0 */
				}

    - （3）flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果项目没设置flex-shrink属性，则项目的默认flex-shrink值为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时flex-shrink属性为0的项目不缩小。

				.item {
				  flex-shrink: <number>; /* default 1 */
				}

    - （4）flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间(默认值为auto，即项目的本来大小)

        - 注意：如果同时给项目设置flex-basis和width属性值，则flex-basis会覆盖width的值。例如同时给项目设置属性，flex-basis：80px;width:100px;则项目的实际宽度是80px;

				.item {
				  flex-basis: <length> | auto; /* default auto */
				}

    - （5）flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。

				.item {
				  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
				}

    - （6）align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

				.item {
				  align-self: auto | flex-start | flex-end | center | baseline | stretch;
				}



#### 三、回答 ####

- flex是css3新增的一种布局方式，我们可以通过将一个元素的display属性设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。容器默认有两条轴，一条是水平的主轴，一条是与主轴垂直的交叉轴
- 容器的属性有：flex-direction(指定主轴方向)、flex-wrap(指定是否换行)、flex-flow(前面两个的缩写)、justify-content(指定主轴的如何排列)、align-items(指定交叉轴如何排列)、align-content(多根轴线对齐方式)
- 项目的属性有：order(指定项目的排列顺序)、flex-grow(放大比例)、flex-shrink(缩小比例)、flex-basis(分配空间之前所占比例)、flex(前面三个的缩写)、align-self(设置单个项目的对齐方式)


<h3 id='二十四、flex1详解'>二十四、flex1详解</h3>

https://www.cnblogs.com/ceceliahappycoding/p/10791191.html

#### 一、概述 ####
 
- flex 是 flex-grow（放大）、flex-shrink（缩小）、flex-basis（分配之前占主轴的大小）的缩写

- flex 的默认值是以上三个属性值的组合，flex 的默认值是 0 1 auto

#### 二、取值

1. 当 flex 取值为 none，则计算值为 0 0 auto；
2. 当 flex 取值为 auto，则计算值为 1 1 auto；
3. 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：

		.item {flex: 1;}
		.item {
		    flex-grow: 1;
		    flex-shrink: 1;
		    flex-basis: 0%;
		   }

4. 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况


			.item-1 {flex: 0%;}
			.item-1 {
			    flex-grow: 1;
			    flex-shrink: 1;
			    flex-basis: 0%;
			   }
			.item-2 {flex: 24px;}
			.item-1 {
			    flex-grow: 1;
			    flex-shrink: 1;
			    flex-basis: 24px;
			   }


5. 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：

			.item {flex: 2 3;}
			.item {
			    flex-grow: 2;
			    flex-shrink: 3;
			    flex-basis: 0%;
			   }

6. 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：

			.item {flex: 2333 3222px;}
			.item {
			    flex-grow: 2333;
			    flex-shrink: 1;
			    flex-basis: 3222px;
			   }





<h3 id='二十五、两栏布局'>二十五、两栏布局</h3>

#### 一、概念 ####

- 两栏布局：整体高度已知，左边宽度固定，右边内容宽度自适应。

#### 二、实现 ####

1. 浮动+margin-left

		<style>
		       body{
		            margin:0;
		            padding:0;
		        }
		        .left{
		           width:100px;
		           height:100px;
		           background-color: aqua;
		           float:left;
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          margin-left: 100px;
		        }
		    </style>
		
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>


2. 浮动+ BFC

            <style>
		       body{
		            margin:0;
		            padding:0;
		        }
		        .left{
		           width:100px;
		           height:100px;
		           background-color: aqua;
		           float:left;
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          overflow:hidden;
		        }
		    </style>
		
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>


3. 绝对定位+margin-left

		<style>
		        body{
		            margin:0;
		            padding:0;
		        }
		        .box{
		            border: 1px solid black;
		            position:relative;
		        }
		        .left{
		           width:100px;
		           height:100px;
		           background-color: aqua;
		           position:absolute;
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          margin-left:100px;
		        }
		    </style>
		
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>


4. 绝对定位

		<style>
		        body{
		            margin:0;
		            padding:0;
		        }
		        .box{
		            border: 1px solid gold;
		            position:relative;
		        }
		        .left{
		           width:100px;
		           height:100px;
		           background-color: aqua;
		           position:absolute;
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          position: absolute;
		          left:100px;
		          right:0;
		        }
		    </style>
		</head>
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>


5. flex布局

		<style>
		        body{
		            margin:0;
		            padding:0;
		        }
		        .box{
		            border: 1px solid black;
		            display:flex;
		        }
		        .left{
		           height:100px;
		           background-color: aqua;
		           flex:0 0 100px;
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          flex:1;
		        }
		    </style>
		
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>

6. table-cell布局

		<style>
		        body{
		            margin:0;
		            padding:0;
		        }
		        .box{
		            border: 1px solid black;
		            
		        }
		        .left{
		           height:100px;
		           min-width: 100px;
		           background-color: aqua;
		           display:table-cell; 
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          display:table-cell; 
		          width:100%;
		        }
		    </style>
		
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>


7. float + calc()

		<style>
		        body{
		            margin:0;
		            padding:0;
		        }
		        .box{
		            border: 1px solid black;
		            overflow: hidden;
		        }
		        .left{
		           height:100px;
		           width: 100px;
		           background-color: aqua;
		           float:left;
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          float:left;
		          width:calc(100% - 100px);
		        }
		    </style>
		
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>

8. inline-block + calc()函数

		 <style>
		        body{
		            margin:0;
		            padding:0;
		        }
		        .box{
		            border: 1px solid black;
		            overflow: hidden;
		            font-size: 0;
		        }
		        .left{
		           height:100px;
		           width: 100px;
		           background-color: aqua;
		           display: inline-block;
		           font-size: 5px;
		        }
		        .right{
		          height:100px;
		          background-color: brown;
		          display: inline-block;
		          width:calc(100% - 100px);
		          font-size: 5px;
		        }
		    </style>
		</head>
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>

- 使用inline-block时，元素间的空格或者回车会导致元素之间有距离，可以给父元素加font-size:0来消除，然后在子元素里重新设置font-size来显示文字。

9. 网格布局

		 <style>
		        body{
		            margin:0;
		            padding:0;
		        }
		        .box{
		            border: 1px solid black;
		            display:grid;
		            grid-template-columns: 100px auto;
		            grid-template-rows: auto;
		        }
		        .left{
		           background-color: aqua;
		        }
		        .right{
		          background-color: brown;
		        }
		    </style>
		</head>
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>




<h3 id='二十六、三栏布局'>二十六、三栏布局</h3>

#### 一、概念 ####

- 三栏布局：整体高度已知，左右两边宽度固定，中间内容宽度自适应。

#### 二、实现 ####

1. 绝对定位
 
		<style>
		        body{
		            margin:0;
		            padding: 0;
		        }
		        .box{
		            border: 1px solid goldenrod;
		            position:relative;
		         }
		         .left{
		             background-color: green;
		             left:0;
		             width: 100px;
		             height:200px;
		             position: absolute;
		         }
		         .middle{
		             background-color: aqua;
		             height:200px;
		             left: 100px;
		             right: 100px;
		             position: absolute;
		         }
		         .right{
		            background-color: red;
		            right:0;
		            width: 100px;
		            height:200px;
		            position: absolute;
		         }
		    </style>
		</head>
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		        <div class='middle'></div>
		    </div>
		</body>

- 缺点：三个栏高度不统一。

2. 浮动

		<style>
		        body{
		            margin:0;
		            padding: 0;
		        }
		         .left{
		             background-color: green;
		             width: 100px;
		             height:200px;
		             float:left;
		         }
		         .middle{
		             background-color: aqua;
		             height:200px;
		             margin-left: 100px;
		             margin-right: 100px;
		         }
		         .right{
		            background-color: red;
		            right:0;
		            width: 100px;
		            height:200px;
		            float:right;
		         }
		         .box{
		            border: 1px solid goldenrod;
		         }
		    </style>
		</head>
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		        <div class='middle'></div>
		    </div>
		</body>

- 缺点：三个栏高度不统一。

3. flex布局
 
		<style>
		        body{
		            margin:0;
		            padding: 0;
		        }
		        .box{
		            border: 1px solid goldenrod;
		            display: flex;
		         }
		         .left{
		             background-color: green;
		             order:1;
		             width:100px;
		         }
		         .middle{
		             background-color: aqua;
		             flex:1;
		             order:2;
		         }
		         .right{
		            background-color: red;
		            width:100px;
		            order:3;
		         
		         }
		    </style>
		</head>
		<body>
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		        <div class='middle'></div>
		    </div>
		</body>

- order表示排列顺序，值越小排列越靠前。
- 实际高度会根据内容自适应，三栏高度统一。

4. 圣杯布局
 
   - 圣杯：父盒子包含三个子盒子（左，中，右）
   * 父盒子设置左右的 padding 来为左右盒子留位置；
   * 中间盒子的宽度设置为 width: 100%; 独占一行；
   * 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行；
   * .left {margin-left:-100%;} 把左边的盒子拉上去
   * .right {margin-left：-右边盒子宽度px;} 把右边的盒子拉上去
   * 对左右盒子使用相对布局来占据 padding 的空白，避免中间盒子的内容被左右盒子覆盖；

 
		     <style>
		        body{
		            margin:0;
		            padding: 0;
		        }
		        .box{
		            border: 1px solid goldenrod;
		            overflow: hidden;
		            padding:0 100px;
		        }
		        .left{
		            background-color: green;
		            width:100px;
		            height:100px;
		            float:left;
		            margin-left:-100%;
		            position:relative;
		            left:-100px;
		        }
		        .center{
		            background-color: aqua;
		            width:100%;
		            height:100px;
		            float:left;
		        }
		        .right{
		            background-color: red;
		            width:100px;
		            height:100px;
		            float:left;
		            margin-left:-100px;
		            position:relative;
		            right:-100px;
		        }
		</style>
		</head>
		<body>
		    <div class='box'>
		        <div class='center'>center</div>
		        <div class='left'>left</div>
		        <div class='right'>right</div>
		    </div>
		</body>


5. 双飞翼布局

   - 双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。
   * 中间盒子的宽度设置为 width: 100%; 独占一行；
   * 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行；
   * 在中间盒子里面再添加一个 div，然后对这个 div 设置 margin-left 和 margin-right来为左右盒子留位置；

			 
			     <style>
			        body{
			            margin:0;
			            padding: 0;
			        }
			        .box{
			            border: 1px solid goldenrod;
			            overflow: hidden;
			            padding:0 100px;
			        }
			        .left{
			            background-color: green;
			            width:100px;
			            height:100px;
			            float:left;
			            margin-left:-100%;
			            position:relative;
			            left:-100px;
			        }
			        .center{
			            background-color: aqua;
			            width:100%;
			            height:100px;
			            float:left;
			        }
			        .right{
			            background-color: red;
			            width:100px;
			            height:100px;
			            float:left;
			            margin-left:-100px;
			            position:relative;
			            right:-100px;
			        }
			</style>
			</head>
			<body>
			    <div class='box'>
			        <div class='center'>center</div>
			        <div class='left'>left</div>
			        <div class='right'>right</div>
			    </div>
			</body>


  - 双飞翼布局和圣杯布局异同

    - 圣杯布局和双飞翼布局解决的问题是一样的，都是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。

    * 两种方法基本思路都相同：首先让中间盒子 100% 宽度占满同一高度的空间，在左右两个盒子被挤出中间盒子所在区域时，使用 margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间。接下来进行一些调整避免中间盒子的内容被左右盒子遮挡。
    * 主要区别在于如何使中间盒子的内容不被左右盒子遮挡：
      * 圣杯布局的方法：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位；
      * 双飞翼布局的方法：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子,这样实现的三栏布局中间栏会被两边遮挡。
      * 简单说起来就是双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了，少设置几个属性。

6.table-cell布局

			 <style>
			        body{
			            margin:0;
			            padding: 0;
			        }
			        .box{
			            border: 1px solid goldenrod;
			        }
			        .left{
			            background-color: green;
			            min-width:100px;
			            height:100px;
			            display:table-cell;
			        }
			        .center{
			            background-color: aqua;
			            height:100px;
			            width: 100%;
			            display:table-cell;
			        }
			        .right{
			            background-color: red;
			            min-width:100px;
			            height:100px;
			            display:table-cell;
			        }
			</style>
			</head>
			<body>
			    <div class='box'>
			        <div class='left'>left</div>
			        <div class='center'>center</div>
			        <div class='right'>right</div>
			    </div>
			</body>
			```
7. BFC规则
			```php
			  <style>
			        body{
			            margin:0;
			            padding: 0;
			        }
			        .box{
			            border: 1px solid goldenrod;
			        }
			        .left{
			            background-color: green;
			            width:100px;
			            height:100px;
			            float:left;
			        }
			        .center{
			            background-color: aqua;
			            overflow: hidden;
			            height:100px;
			        }
			        .right{
			            background-color: red;
			            width:100px;
			            height:100px;
			            float:right;
			        }
			</style>
			</head>
			<body>
			    <div class='box'>
			        <div class='left'>left</div>
			        <div class='right'>right</div>
			        <div class='center'></div>
			    </div>
			</body>


- BFC不会和浮动元素重叠。所以如果将main元素设定为BFC元素即可

8. 网格布局

			 <style>
			        body{
			            margin:0;
			            padding: 0;
			        }
			        .box{
			            border: 1px solid goldenrod;
			            display:grid;
			            grid-template-columns: 100px auto 100px;
			            grid-template-rows: auto;
			        }
			        .left{
			            background-color: green;
			        }
			        .center{
			            background-color: aqua;
			        }
			        .right{
			            background-color: red;
			        }
			</style>
			</head>
			<body>
			    <div class='box'>
			        <div class='left'></div>
			        <div class='right'>right</div>
			        <div class='center'></div>
			    </div>
			</body>


<h3 id='二十七、水平垂直居中'>二十七、水平垂直居中</h3>

#### 一、方法 ####

1. 仅居中元素定宽高适用

   * absolute+负margin
   * absolute+ margin auto
   * absolute+calc

2. 居中元素不定宽高

   * absolute + transform
   * flex
   * line-height
   * table
   * css-table
   * grid
   * writing-mode


#### 二、实现 ####

1. position+负margin

		<style>
		   .box{
		       height: 500px;
		       background: green;
		       position:relative;
		   }
		   .item{
		       width:300px;
		       height:300px;
		       background: red;
		       position: absolute;
		       left:50%;
		       top:50%;
		       margin-top:-150px;
		       margin-left:-150px;
		   }
		</style>
		<body>
		    <div class='box'>
		        <div class='item'>1111</div>
		    </div>
		</body>

2. absolute + margin auto

			<style>
			   .box{
			       height: 500px;
			       background: green;
			       position:relative;
			   }
			
			   .item{
			       width:300px;
			       height:300px;
			       background: red;
			       position: absolute;
			       left:0;
			       right:0;
			       top:0;
			       bottom:0;
			       margin:auto;
			   }
			   
			</style>
			<body>
			    <div class='box'>
			        <div class='item'>1111</div>
			    </div>
			</body>


3. position+calc

			<style>
			   .box{
			       height: 500px;
			       background: green;
			       position:relative;
			   }
			   .item{
			       width:300px;
			       height:300px;
			       background: red;
			       position: absolute;
			       left:calc(50% - 150px);
			       top:calc(50% - 150px);
			   }
			</style>
			<body>
			    <div class='box'>
			        <div class='item'>1111</div>
			    </div>
			</body>

4. position+transform

			<style>
			   .box{
			       height: 500px;
			       background: green;
			       position:relative;
			   }
			   .item{
			       width:300px;
			       height:300px;
			       background: red;
			       position: absolute;
			       left:50%;
			       top:50%;
			       transform:translate(-50%,-50%)
			   }
			</style>
			<body>
			    <div class='box'>
			        <div class='item'>1111</div>
			    </div>
			</body>

5. flex

			<style>
			   .box{
			       height: 500px;
			       background: green;
			       display:flex;
			       justify-content:center;
			       align-items:center;
			   }
			</style>
			<body>
			    <div class='box'>
			        <div class='item'>1111</div>
			    </div>
			</body>


6. line-height

把box设置为行内块元素，通过text-align就可以做到水平居中，通过vertical-align在垂直方向做到居中

			.box{
			       line-height: 500px;
			       background: green;
			       text-align:center;
			   }
			
			   .item{
			       width:300px;
			       height:300px;
			       background: rgb(248, 242, 242);
			       display: inline-block;
			       vertical-align: middle;
			   }
			   
			</style>
			<body>
			    <div class='box'>
			        <div class='item'></div>
			    </div>
			</body>

7. table

- tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了

			<style>
			    .box{
			        width:500px;
			        height:500px;
			        background: green;
			        text-align:center;
			   }
			
			   .item{
			     width: 300px;
			     height: 300px;
			     background-color: brown;
			     display:inline-block;
			   }
			   
			</style>
			<body>
			    <table>
			        <tbody>
			            <tr>
			                <td class="box">
			                    <div class="item">123123</div>
			                </td>
			            </tr>
			        </tbody>
			    </table>
			</body>

8. css-table属性

- css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中

			<style>
			    .box{
			        width:500px;
			        height:500px;
			        background: green;
			        display:table-cell;
			        text-align:center;
			        vertical-align: middle;
			   }
			
			   .item{
			     width: 300px;
			     height: 300px;
			     background-color: brown;
			     display:inline-block;
			   }
			   
			</style>
			<body>
			   
			    <div class="box">
			        <div class="item"></div>
			    </div>
			          
			</body>

9. grid

- css新出的网格布局

			<style>
			    .box{
			        display:grid;
			   }
			
			   .item{
			     align-self: center;
			    justify-self: center;
			   }
			   
			</style>
			<body>
	   
		    <div class="box">
		        <div class="item"></div>
		    </div>
	          
			</body>

10. writing-mode

		<style>
		   .box{
		       height:500px;
		       width: 100%;
		       background-color: aqua;
		       writing-mode:vertical-lr;
		       text-align:center;
		   }
		.box-inner{
		    display:inline-block;
		    writing-mode:horizontal-tb;
		    text-align: center;
		    width:100%;
		}
		.item{
		    width: 300px;
		    height: 300px;
		    background-color: brown;
		    display: inline-block;
		    margin: auto;
		    text-align: left;
		}
		</style>
		<body>
		   <div class='box'>
		       <div class='box-inner'>
		           <div class='item'>123</div>
		        </div>
		   </div>
		</body>


<h3 id='二十八、移动端适配'>二十八、移动端适配</h3>

#### 一、了解移动端适配之前，需要知道的概念 ####

1. 视口(viewport)

- 我们在设置html、body的width：100%，height：100%的时候，我们都知道100%这种百分数都是是继承父元素的，可在这里是继承哪里的呢?
- 在PC浏览器中，有一个用来约束CSS布局视口的东西，又叫做初始包含块。这也就是所有宽高继承的由来。除去 margin、 padding，布局视口和浏览器可视窗口宽度是一致的，同时也和浏览器本身的宽度一致。
- 但是在移动端，就大不一样了
- 假如我们现在做一个二八分的左右布局，那么如果在PC端上面的话，显示的效果非常完美，这没什么好说的
- 那如果是在手机端呢，这里以iphone6为例子来讲解：

  - 将浏览器切换到手机端，iphone6 375*667,然后点开控制台，我们会看到，为什么 body的宽度是 980px，而浏览器的宽度只有 375px，那么这个 980px到底是从哪里来的呢？
  - 其实，这里的 980px就是移动端所谓的布局视口了


  - (1)布局视口（layout viewport）

    - 在移动端，默认的情况下，布局视口的宽度是要远远大于浏览器的宽度的。这两个视口不同于PC端，是相互独立存在的。为什么呢？试想一下，如果一个网页不对移动端进行适配，用户进行阅读的时候，如果默认情况下布局视口的宽度等于浏览器宽度，那是不是展示起来更加的不友好。也就是说，如果一个 div的宽度为20%，那么它在布局视口宽度为980px的时候，展示给用户的像素还有196px，而如果宽度只有 375px的情况下，宽度只有 75px，展示的大小相差特别大。

    - 所以，浏览器厂商为了让用户在小屏幕下网页也能够显示地很好，所以把布局视口宽度设置地很大，一般在 768px~1024px之间，最常见的宽度是 980px。这个宽度可以通过document.documentElement.clientWidth得到

  - (2)视觉视口（visual viewport）

    - 对于视觉视口来说，这个东西是呈现给用户的，它是用户看到网页区域内CSS像素的数量。布局视口的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小。这个viewport视口就叫做虚拟视口，由于用户可以自行进行缩放控制，所以这个视口并不是开发者需要重点关注的，宽度可以通过window.innerWidth来获取，宽度继承布局视口的宽度。

	- 注意：值得注意的是，在移动端缩放不会改变布局视口的宽度，当缩小的时候，屏幕覆盖的css像素变多，视觉视口变大，反之亦然。
	
      -  而在PC端，缩放对应布局宽度和视觉窗口宽度都是联动的。而浏览器宽度本身是固定的，无论怎么缩放都不受影响。

		          以浏览器窗口的宽度作为基准的对比表格：
		
		              对于pc端：
		
		                  状态    布局视口    视觉视口
		
		                  默认      相等       相等
		
		                  放大      变小       变小
		
		                  缩小      变大       变大
		
		              对于移动端：
		
		                  状态    布局视口    视觉视口
		
		                  默认      偏大      相等
		
		                  放大      不变       变小
		
		                  缩小      不变       变大
		                   

   - (3)理想视口（ideal viewport）

      - 以上，布局视口很明显对用户十分的不友好，完全忽略了手机本来的尺寸，所以苹果引入了理想视口的概念，它是对设备来说最理想的布局视口尺寸。理想视口中的网页用户最理想的宽度，用户进入页面的时候不需要缩放。那么很明显，所谓的理想宽度就是浏览器（屏幕）的宽度了

      - 设置理想视口

         			<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

          * 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条

          * 可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成理想视口的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时理想视口的宽度

    				<meta name="viewport" content="initial-scale=1">

          * 这句代码可以把当前的的viewport变为 ideal viewport，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大

          * 这里的initial-scale=1，缩放值为1，表示没有缩放，但却达到了 ideal viewport 的效果，说明了缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport，小瑕疵windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度

    				<meta name="viewport" content="width=device-width, initial-scale=1">

          * 这句代码<meta name="viewport" content="width=400, initial-scale=1">，width=400表示把当前viewport的宽度设为400px，initial-scale=1则表示把当前viewport的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度）

          * 要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病


- 我们在进行媒体查询的时候，查询的宽度值其实也是布局视口的宽度值
        
2. 像素

- 像素是网页布局的基础，一个像素表示了计算机屏幕所能显示的最小区域
- 像素分为三种类型：物理像素(设备像素)，设备独立像素，css像素

  - (1)物理像素

     * 物理像素也叫做设备像素，它表示显示设备的真实像素，此像素是设备的固有属性，也就是说，从出厂的那一刻，设备像素已经固定，不会再发生改变
     * 分辨率：通常使用分辨率来描述设备像素，例如1920*1080，表示设备横向有1920像素点，纵向有1080个像素点
     * 屏幕尺寸：购买电视或者手机等设备的显示器都有一个屏幕尺寸参数，比如55英寸，它既不是显示器的宽度也不是高度，而是对角线的长度
     * 屏幕像素密度：屏幕像素密度（Pibel Per Inch）简称 ppi ，单位是 dpi（dot per inch），理论上，ppi越高越好，图像会更加细腻清晰，计算方式：勾股定理算出对角线的分辨率，对角线分辨率除以屏幕尺寸：2203/5≈440dpi

  - (2)设备独立像素

     * 与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素
     * 为什莫会出现设备独立像素呢

          * iPhone 3GS 和 iPhone 4/4s 的尺寸都是 3.5 寸，但 iPhone 3GS 的分辨率是 320x480，iPhone 4/4s 的分辨率是 640x960，这也就是意味着同样长度的屏幕，iPhone 3GS 有 320 个物理像素，iPhone 4/4s 有 640 个物理像素。如果我们按照真实的物理像素进行布局，比如说我们按照 320 物理像素进行布局，到了 640 物理像素的手机上就会有一半的空白，为了避免这种问题，就产生了虚拟像素单位即设备独立像素，我们统一 iPhone 3GS 和 iPhone 4/4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像素换算成 1 个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素，至于 1 个虚拟像素被换算成几个物理像素，这个数值我们称之为设备像素比

  - (3)css像素

     * 在web中我们所设置的像素都是CSS像素
     * 在没有缩放的情况下，1个css像素等同于一个设备独立像素！！！注意是没有缩放的情况下
     * CSS像素在视觉上是很容易改变大小的，比如缩放浏览器页面，就是改变的CSS像素，当放大一倍，那么一个CSS像素在横向或者纵向上会覆盖两个设备独立像素。例如宽度100px像素，当页面放大一倍，它会在横向上由原本占据100个设备独立像素，变成占据200个设备独立像素；如果缩小，则恰好相反，只能占据50个设备独立像素
     * 无论CSS像素是缩小还是放大，它是像素数目是不变的，比如100px，无论缩放，它依然是100px，只不过它占据的设备独立像素发生了变化（体积发生了变化，视觉大小上发生了变化而已）

  - (4)设备像素比(dpr)

     * 设备像素比 ＝ 物理像素 / 设备独立像素

     * 在没有缩放情况下，1个css像素等同于一个设备独立像素，所以

        * 设备像素比 ＝ 物理像素 / css像素
    
    			如：物理像素 ／分辨率 = 750 ／ 375 = 2 px，一个CSS像素表示了2个物理像素

    * window.devicePixelRatio可以获取设备像素比

  - (5)px与自适应

     - 由上面我们可以知道，1个CSS像素可以表示的物理像素是不同的，因此如果在css中仅仅通过px作为长度和宽度的单位，造成的结果就是无法通过一套样式，实现不同分辨率的自适应


#### 二、移动端适配实现方式 ####

1. 媒体查询

   * 在前面我们说到，不同端的设备下，在css文件中，1px所表示的物理像素的大小是不同的，因此通过一套样式，是无法实现各端的自适应，那么我们可以给每一种设备各一套不同的样式来实现自适应的效果

   * 使用@media媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果

		    如： <style>
			        @media screen and (max-width: 960px){
			            body{
			            background-color:#FF6699
			            }
			        }
			
			        @media screen and (max-width: 768px){
			            body{
			            background-color:#00FF66;
			            }
			        }
			
			        @media screen and (max-width: 550px){
			            body{
			            background-color:#6633FF;
			            }
			        }
			
			        @media screen and (max-width: 320px){
			            body{
			            background-color:#FFFF00;
			            }
			        }
			    </style>
			
				<body>
				    
				</body>

      上述的代码通过媒体查询定义了几套样式，通过max-width设置样式生效时的最大分辨率，上述的代码分别对分辨率在0～320px，320px～550px，550px～768px以及768px～960px的屏幕设置了不同的背景颜色

  * 通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局
  * 但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐

2. 百分比

   * 除了用px结合媒体查询实现响应式布局外，我们也可以通过百分比单位 " % " 来实现响应式的效果。比如当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果

  - (1) 理解不同属性的百分比是相对谁来说的

     * 子元素height和width的百分比

        * 子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height

     * top和bottom 、left和right

        * 子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度

     * padding

        * 子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关

     * margin

       * 跟padding一样，margin也是如此，子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width

     * border-radius

       * border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度

       * 除了border-radius外，还有比如translate、background-size等都是相对于自身的

  - (2)  百分比单位布局应用

     * 比如要实现一个长宽比为4:3的长方形,我们可以根据padding属性来实现，因为padding不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置padding-top为百分比来实现，长宽自适应的长方形

			<div class="trangle"></div>
			
			.trangle{
			  height:0;
			  width:100%;
			  padding-top:75%;
			}
		
		    通过设置padding-top：75%,相对比宽度的75%，因此这样就设置了一个长宽高恒定比例的长方形

  - (3) 百分比单位的缺点

     * 计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。

     * 各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂

3. rem单位

   - rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可

   - (1)网易做法（通过改变font-size的值来达到无论设备的理想视口怎么变，布局里的div占理想视口的比例都不变）

      - 将布局视口设置为理想视口，根据不同的理想视口设置html的font-size值

          * 设置理想视口：<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">

          * 以750px的视觉稿，网易这样处理的：

			    以 iphone 6 的设计稿为基准，即设计稿横向分辨率为 750px，取 100 为参照数（即在使用 rem 时与使用 px 时相差 100 的倍数），则我们可以知道 html 的宽度为 7.5rem（750 / 100），而我们知道 iphone 6 的逻辑宽度是 375px，所以 html 的宽度也为 375px，那么此时 7.5 * html(font-size) = 375px，所以可以得出 html(font-size) = 375 / 7.5，即
			 
			      html(font-size) = deviceWidth / 7.5

         * 在750px设计稿上：

                 75px 对应 0.75rem, 距离占设计稿的10%；

        * 在ipone6上：
    
				width = document.documentElement.clientWidth = 375px；
				rem = 375px / 7.5 = 50px;
				0.75rem = 37.5px;   (37.5/375=10%；占屏幕10%)

	   * 在ipone5上：
	
				width = document.documentElement.clientWidth = 320px；
				rem = 320px / 7.5 = 42.667px;
				0.75rem = 32px; (32/320=10%；占屏幕10%)

    - 相当于把屏幕分为7.5份，每一分所表示的px是不同的，不同的视口宽度下同样都是0.75rem，但是由于rem表示的px不同，所以0.75表示的px也是不同的，但是0.75rem所占的视口宽度的比例都是一样的

    * 通过js代码操作

				var deviceWidth = document.documentElement.clientWidth;
				if(deviceWidth > 750) deviceWidth = 750;
				document.documentElement.style.fontSize = deviceWidth / 7.5 + 'px';
			
				这里if(deviceWidth > 750) deviceWidth = 750; 是因为当deviceWidth大于750时物理分辨率已经大于1500（取决于dpr），应该去访问pc的网站

    * 页面中的字体大小使用media和px来适应，不用rem

       - 首先，用过rem单位的小伙伴都会发现，使用rem后由于不同的尺寸，换算之后出现各种奇奇怪怪的数值，最为明显的就是更多的小数位，比如 13.755px之类的数值。在浏览器中，各浏览器中对小数点的计算存在偏差，而且有些带小数的 font-size值在特定的浏览器显示并不够清晰。
       - 其次，我们并不希望在小屏幕下面显示跟大屏幕同等量的字体。并且如果使用rem的话，那么由于等比例的存在，在小屏幕下就会存在小屏幕字体更小的情况，不利于我们更好的去阅读，违背了适配的初衷。所以，对于字体的适配，更好的做法就是使用px和媒体查询来进行适配。

  - (2)淘宝的做法

     * 淘宝的效果跟网易的效果其实是类似的，随着分辨率的变化，页面元素的尺寸和间距都相应变化，这是因为淘宝的尺寸也是使用了rem的原因，在介绍它的做法之前，先来了解一点关于viewport的知识，通常我们采用如下代码设置viewport:

			<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	
     - 这样整个网页在设备内显示时的页面宽度就会等于设备逻辑像素大小，也就是device-width。这个device-width的计算公式为：设备的物理分辨率/(devicePixelRatio * scale)，在scale为1的情况下，device-width = 设备的物理分辨率/devicePixelRatio 。devicePixelRatio称为设备像素比，每款设备的devicePixelRatio都是已知，并且不变的。

     * 淘宝触屏版布局的前提就是viewport的scale根据devicePixelRatio动态设置：
	
        - 在devicePixelRatio为2的时候，scale为0.5，在devicePixelRatio为3的时候，scale为0.3333，这么做目的当然是为了保证页面的大小与设计稿保持一致了，比如设计稿如果是750的横向分辨率，那么实际页面的device-width，以iphone6来说，也等于750，这样的话设计稿上标注的尺寸只要除以某一个值就能够转换为rem了。通过js设置viewport的方法如下：
	
				var scale = 1 / devicePixelRatio;
				document.querySelector('meta[name="viewport"]').setAttribute('content','initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');

     * 淘宝布局的第二个要点，就是html元素的font-size的计算公式，font-size = deviceWidth / 10：

     - 接下来要解决的问题是，元素的尺寸该如何计算，比如说设计稿上某一个元素的宽为150px，换算成rem应该怎么算呢？这个值等于设计稿标注尺寸/该设计稿对应的html的font-size。拿淘宝来说的，他们用的设计稿是750的，所以html的font-size就是75，如果某个元素时150px的宽，换算成rem就是150 / 75 = 2rem

     * 总结下淘宝的这些做法：

        * 动态设置viewport的scale 

			var scale = 1 / devicePixelRatio;
			document.querySelector('meta[name="viewport"]').setAttribute('content','initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');

        * 动态计算html的font-size 

	        document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';

        * 布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10

        * font-size可能需要额外的媒介查询，并且font-size不使用rem，这一点跟网易是一样的
   
       * 最后还有一个情况要说明，跟网易一样，淘宝也设置了一个临界点，当设备竖着时横向物理分辨率大于1080时，html的font-size就不会变化了，原因也是一样的，分辨率已经可以去访问电脑版页面了


    - (3)比较网易与淘宝的做法

       * 共同点：

          * 都能适配所有的手机设备，对于pad，网易与淘宝都会跳转到pc页面，不再使用触屏版的页面
          * 都需要动态设置html的font-size
          * 布局时各元素的尺寸值都是根据设计稿标注的尺寸计算出来，由于html的font-size是动态调整的，所以能够做到不同分辨率下页面布局呈现等比变化
          * 容器元素的font-size都不用rem，需要额外地对font-size做媒介查询
          * 都能应用于尺寸不同的设计稿，只要按以上总结的方法去用就可以了

       * 不同点:

         * 淘宝的设计稿是基于750的横向分辨率，网易的设计稿是基于640的横向分辨率，还要强调的是，虽然设计稿不同，但是最终的结果是一致的，设计稿的尺寸一个公司设计人员的工作标准，每个公司不一样而已
         * 淘宝还需要动态设置viewport的scale，网易不用
         * 最重要的区别就是：网易的做法，rem值很好计算，淘宝的做法肯定得用计算器才能用好了 。不过要是你使用了less和sass这样的css处理器，就好办多了，以淘宝跟less举例，我们可以这样编写less：

	              	//定义一个变量和一个mixin
	
					@baseFontSize: 75;//基于视觉稿横屏尺寸/100得出的基准font-size
					.px2rem(@name, @px){
					    @{name}: @px / @baseFontSize * 1rem;
					}
					
					//使用示例：
					
					.container {
					    .px2rem(height, 240);
					}
					
					//less翻译结果：
					.container {
					    height: 3.2rem;



<h3 id='二十九、清除浮动'>二十九、清除浮动</h3>

#### 一、概述 ####

- 清除浮动的方法主要分为两类，一类是使用clear属性，一类是使用BFC

  1. clear属性只能影响使用该属性的元素本身，不能影响其他元素。clear属性规定元素盒子的边不能和浮动元素相邻，所以我们使用clear清除浮动的原理就是，在父元素的最后加一个具有clear属性的块级元素，由于该块级元素不能和浮动元素相邻，而浮动元素的位置我们已经确定了，所以为了满足该元素的需求，将该元素渲染在了浮动元素的下面，由于该元素在父元素的边界内，所以父元素必须增加高度将它包含在内，这样就达到了清除浮动的目的
  2. BFC原理是由于开启了BFC的元素在计算其高度时，是要包含浮动元素的，所以给父元素开启BFC就能清除浮动
  
		    例一：
		         <style>
			        .fatherBox{
			            border:1px solid black;
			        }
		            .floatBox{
			            width: 100px;
			            height: 100px;
			            background-color: azure;
			            float: left;
			        }
			        .box{
			            width:100px;
			            height: 100px;
			            background-color:cornflowerblue;
			        }
			    </style>
			     <body>
				    <div class='fatherBox'>
			            <div class='floatBox'>float</div>
				        <div class='box'></div>
				    </div>
				</body>


     - 对于以上的代码，页面展示的效果为，fatherBox的高度为100px,并且floatBox覆盖了box,因为floatBox设置了浮动，脱离了文档流，所以box上移，floatBox就覆盖住了box

     - 清除浮动的方法：
     
       - （1）就直接给box添加一行代码：clear:left,意思就是box元素不允许自己的左边有浮动元素，但浮动元素的位置已经确定了，浏览器在计算.box的位置时，为满足其需求，将.box渲染在浮动元素下方，保证了.box左边没有浮动元素。同时可以看出，父元素的高度也被撑起来了，这是因为.box仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的，可以说是一个意外收获。(clear的值为both也有相同的效果，通俗理解就是，哪边不允许有浮动元素，clear就是对应方向的值，两边都不允许就是both)
                 
        - （2）给父元素开启BFC

		    例二：将box和floatBox调换位置
		
		          <style>
			        .fatherBox{
			            border:1px solid black;
			        }
			        .box{
			            width:100px;
			            height: 100px;
			            background-color:cornflowerblue;
			        }
			        .floatBox{
			            width: 100px;
			            height: 100px;
			            background-color: azure;
			            float: left;
			        }
			    </style>
		
		         <body>
				    <div class='fatherBox'>
				        <div class='box'></div>
				        <div class='floatBox'>float</div>
				    </div>
				</body>

     - 清除浮动：

        - （1）父元素结束标签之前插入清除浮动的块级元素（原理和例一一样，就是使用clear的原理）

	                  <body>
					    <div class='fatherBox'>
					        <div class='box'></div>
					        <div class='floatBox'>float</div>
					        <div style="clear: left;"></div>
					    </div>
					</body>

         - （2）利用伪元素（原理也是利用clear）

              - 在.fatherBox的div上再添加一个clearFloat类：

		              <body>
					    <div class='fatherBox clearFloat'>
					        <div class='box'></div>
					        <div class='floatBox'>float</div>
					    </div>
					</body>
		
		             .clearFloat::after{
			            content:'';
			            display: block;
			            clear: both;
			        }

         - （3）开启BFC

		             .fatherBox{
			            border:1px solid black;
		                overflow:hidden;
			        }

    
#### 二、回答 ####

- 浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。
- 除浮动的方法主要分为两类，一类是使用clear属性，一类是使用BFC

  1. clear属性只能影响使用该属性的元素本身，不能影响其他元素。clear属性规定元素盒子的边不能和浮动元素相邻，所以我们使用clear清除浮动的原理就是，在父元素的最后加一个具有clear属性的块级元素，由于该块级元素不能和浮动元素相邻，而浮动元素的位置我们已经确定了，所以为了满足该元素的需求，将该元素渲染在了浮动元素的下面，由于该元素在父元素的边界内，所以父元素必须增加高度将它包含在内，这样就达到了清除浮动的目的
  2. BFC原理是由于开启了BFC的元素在计算其高度时，是要包含浮动元素的，所以给父元素开启BFC就能清除浮动


<h3 id='三十、margin塌陷和重叠'>三十、margin塌陷和重叠</h3>   

#### 一、发生的条件 ####

* 首先，会发生margin重叠和塌陷的肯定是普通文档流中同一个BFC内的块级元素，例如div、ul等，不是块级元素不会发生重叠。（内联元素是不能设置高、行高、内外边距的，而且内联元素只能容纳文本或者其他内联元素。），也就是说普通文档流中属于同一个BFC的两个相邻块级元素的margin会发生重叠

* 只发生在垂直方向上

#### 二、margin塌陷 ####

1. 原理

- 普通文档流中父子块级元素，如果父元素没有设置上内边距或上边框，子元素的上边距就会和父元素的上边距重合，以他们两个中间最大上边距为准，与距离他们最近的盒子隔开

2. 案例

		如：<style>
		
		        body{
		            margin:0;
		            padding:0;
		        }
		       .father{
		           width:200px;
		           height:200px;
		           background-color: aqua;
		           margin-top:20px;
		       }
		
		       .son{
		           width:100px;
		           height:100px;
		           background-color: red;
		           margin-top:40px;
		       }
		   </style>
		
			<body>
			    
			    <div class='father'>
			       <div class='son'></div>
			    </div>
			
			</body>

- father和son的上边距重合，值取决于它们俩中上边距的最大值，当两个的margin-top都为20px的时候，一起向下移20px,将子元素的margin-top修改为40px，父元素和子元素一起向下移40px

3. 解决方法

   - (1)给父元素设置内边距或者边框(改变结构了，不建议使用)
  
   - (2)触发bfc，改变父元素的渲染规则

      * 解决原理：

         * 使用BFC的特性来将父级元素设置为一个独立的BFC，子级元素的margin值就不会溢出父级，而是将父级作为一个独立区域去计算margin值

         * bfc的三个特性：
 
           * 阻止外边距折叠
           * 可以包含浮动的元素
           * 可以阻止元素被浮动元素覆盖

         * 开启bfc:

           * 浮动元素：float 除 none 以外的值
           * 绝对定位元素：position (absolute、fixed)
           * display 为 inline-block、table-cell、flex
           * overflow 除了 visible 以外的值 (hidden、auto、scroll)

#### 三、margin重叠 ####

1. 原理

   * 垂直相邻的普通元素margin，不是两者相加之和，而是取最大值，这个现象叫做margin重叠
   * 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。如果这个外边距遇到另一个元素的外边距，它还会发生合并
   * 普通元素才会发生margin重叠，如果是float元素，就不会发生，margin是两者相加之和

2. 折叠规则

   * 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值
   * 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值
   * 两个外边距一正一负时，折叠结果是两者的相加的和


3. 案例

			如：<style>
			
			        body{
			            margin:0;
			            padding:0;
			        }
			       .father{
			           width:200px;
			           height:200px;
			           background-color: aqua;
			           margin-bottom:20px;
			       }
			
			       .son{
			           width:100px;
			           height:100px;
			           background-color: red;
			           margin-top:50px;
			       }
			   </style>
			
				<body>
				    
				    <div class='father'><div>
				    <div class='son'></div>
				
				</body>


- 两盒子之间的距离仅是50px，两盒子之间的margin出现了重叠部分

4. 外边距重叠的意义

- 外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。

5. 解决办法

   - (1)推荐也是常用的:如果要上下间距为40px,只需要son盒子上边距设为40px,father盒子不用设下边距，这样就可以了，意思是不需要强行解决这个bug,只需要将一边的边距设为两个盒子边距的和就可以了

   - (2) 不推荐也是不常用的（这样会改变html结构）：在son和father盒子外面在加一个盒子，让这个加的外层盒子的渲染规则改为BFC

      * 解决原理：利用BFC阻止margin溢出，我们可以将两个div套上一个BFC的外壳，这样两个BFC的内部元素就不会互相影响了

            
<h3 id='三十一、元素的层叠顺序'>三十一、元素的层叠顺序</h3>   

- 层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：
<img src='../images/元素层叠顺序.awebp' />
- 上图，由上到下分别是：
  - （1）背景和边框：建立当前层叠上下文元素的背景和边框。
  - （2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。
  - （3）块级盒：文档流内非行内级非定位后代元素。
  - （4）浮动盒：非定位浮动元素。
  - （5）行内盒：文档流内行内级非定位后代元素。
  - （6）z-index:0：层叠级数为0的定位元素。
  - （7）正z-index：z-index属性值为正的定位元素。

- 注意: 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。


<h3 id='三十二、position'>三十二、position</h3>   

#### 一、position属性值 ####

1. static：默认值默认布局。
   * 元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。
2. relative：相对定位。
   * 不影响元素本身特性（无论区块元素还是内联元素会保留其原本特性）
   * 不会使元素脱离文档流（元素原本位置会被保留，即改变位置也不会占用新位置
   * 没有定位偏移量时对元素无影响（相对于自身原本位置进行偏移）
   * 提升层级（用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值越大越在上面，z-index只能在position属性值为relative或absolute或fixed的元素上有效。） （两个都为定位元素，后面的会覆盖前面的定位）
3. absolute：绝对定位。
   * 使元素完全脱离文档流（在文档流中不再占位）
   * 使内联元素在设置宽高的时候支持宽高（改变内联元素的特性）
   * 使区块元素在未设置宽度时由内容撑开宽度（改变区块元素的特性）
   * 相对于最近一个有定位的父元素偏移（若其父元素没有定位则逐层上找，直到document——页面文档对象）
   * 相对定位一般配合绝对定位使用（将父元素设置相对定位，使其相对于父元素偏移）
   * 提升层级（同相对定位）
4. fixed：固定定位。
   * fixed生成固定定位的元素，相对于浏览器窗口进行定位。
5. sticky：粘性定位
   * 该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。注意: Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix 。
6. inherit规定应该从父元素继承 position 属性的值。
   - initial：设置该属性为默认值。

#### 二、主要属性值详解####

1. 首先说一下什么文档流

  - 所谓文档流就是HTML文档中可显示元素在排列时所占用的位置。HTML文档流中的标签元素遵循“从左到右、从上到下”的排列次序，有如现代汉字的书写顺序一样。
  - 比如说我们有多个div，根据网页的默认样式他是一个块极元素。所以他就会单独占一行。就会从上到下的排列。
  - 又比如说有多个span标签，根据网页的默认的样式他是一个行级元素，就会从左到右的排列。
  - 其实我简单的理解就相当于我们网页就像我们写作业的纸，我们的元素就写到上面。成为我们元素的内容。我们写东西的时候是不是将文字从左到右的写，写完啦一排再写另外一排呢。其实这个就叫做文档流。

2. 脱离文档流

  - 也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。
  * 一个元素脱离文档流后，其他的元素在定位时候会当做没看见他，两者位置重叠都是可以的。 
  * 脱离文档流不是从dom树中脱离，用浏览器的审查元素可以看到脱离文档流的元素，依然会出现在dom树里 
  * 实质：脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。而对于使用absolute position脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。

   - 脱离文档流的三种方式：浮动，绝对定位，固定定位

3. 默认情况下，所有元素都在z-index:0这一层，元素的top,left,right,bottom,z-index属性都没有被激活，设置了也没有用。position:relative/ablolute/fixed/sticky,都可以让元素激活top,left,right,bottom,z-index属性。如果使用absolute/relative/sticky定位的话，必须指定top,left,right,bottom属性中的至少一个，否则top,left,right,bottom属性会使用它们的默认值auto,这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递，简单讲就是都变成relative。如果top和bottom一同存在的话，那么只有top生效。如果left和right一同存在的话，那么只有left生效。
4. static
 
   - 默认值，一般元素不设置定位属性就属于静态定位，元素处于标准流中。

5. relative

   - 相对定位的元素不会脱离文档流，还处于标准流中,但它会让元素浮起来(即：z-index的值大于0)。相对定位是相对它原来处于文档流的位置而进行偏移的，可以说它是static到absoulte的一个中间过渡属性。虽然它的实际位置可能因为设置了top,left,right,bottom属性值而偏离原来的位置，但对于其他仍然在z-index:0层的元素位置不会造成影响(<font color='red'>即：它还占着文档空间，而且占据的文档空间不会随top,left,right,bottom等属性的偏移而发生变动。。

![](relative1.PNG)

    - 没有设置top,left,right,bottom时，如下图：

![](relative2.jpg)

    - 设置了top:20px;left:20px后，如下图：

![](relative3.jpg)

    - 证明了它还占着文档空间，而且占据的文档空间不会随top,left,right,bottom等属性的偏移而发生变动。
    - 虽然top,left,right,bottom属性不会对relative定位的元素所占据的文档空间产生偏移，但margin，padding会让该文档空间产生偏移。

6. absolute

   - 绝对定位会使元素脱离文档流，它会让元素浮起来(即：z-index的值大于0)，它在文档流中的位置会被删除。它只能根据祖先类元素(父类以上)进行定位，而这个祖先类还必须是以postion非static方式定位的
   - 举个例子，a元素使用absoulte定位，它会从父类开始找起，寻找以position非static方式定位的祖先类元素(注意，一定要是直系祖先才算哦~），直到<html>标签为止，这里还需要注意的是，relative和static方式在最外层时是以<body>标签为定位原点的，而absoulte方式在无父级是position非static定位时是以<html>作为原点定位。<html>和<body>元素相差9px左右。
   
![](absolute1.jpg)

![](absolute2.jpg)

   - 祖先类的margin会让子类的absoulte跟着偏移，而padding却不会让子类的absoulte发生偏移。总结一下，就是absoulte是根据祖先类的border进行的定位。

   - position：absolute和float会隐式的改变display类型，不论之前什么类型的元素（display：none除外），只要设置了position：absolute、float：left或float：right中任意一个，都会让元素以display：inline-block的方式显示：可以设置长宽，默认宽度并不占满父元素

7. fixed<br/>

   - 固定定位会使元素脱离文档流，和绝对定位类似，相对于浏览器窗口进行定位。

8. sticky<br/>

   - 粘性布局不会使元素脱离文档流，可以说是相对定位relative和固定定位fixed的结合。
   - 使用条件：

      * 父元素不能overflow:hidden或者overflow:auto属性。
      * 必须指定top、bottom、left、right4个值之一，否则只会处于相对定位
      * 父元素的高度不能低于sticky元素的高度
      * sticky元素仅在其父元素内生效

9. display、float、position的关系

  - （1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。
  - （2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。
  - （3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。
  - （4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。
总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。

10. absolute与fixed共同点与不同点

   - 共同点：

      - 改变行内元素的呈现方式，将display置为inline-block  
      - 使元素脱离普通文档流，不再占据文档物理空间
      - 覆盖非定位文档元素
 
   - 不同点：

     - abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。
     - 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。

<h3 id='三十三、移动端点透现象'>三十三、移动端点透现象</h3>  

#### 一、移动端click事件300ms延迟问题 ####

- 移动端的click事件300ms延迟是因为浏览器为了判断当前事件是否双击(在移动端浏览器刚开始的时候，为了提升用户体验感，开发了双击缩放和双击滚动等默认行为)而在touchend事件后等待用户约300ms，若用户没有再次点击则默认触发click事件
- 用户点击触发事件的过程：touchstart －> touchmove(没有移动则不触发) －> touchend －>(300ms后) click

1. 添加meta标签,阻止用户双击缩放，并限制视口宽度

  			<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"/>

  - 表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟,虽然禁止缩放可以解决300ms点击延时， 但是禁止缩放不是我们初衷。

2. 更改默认的视口宽度

  			<meta name="viewport" content="width=device-width">

  - 因为双击缩放主要是用来改善桌面站点在移动端浏览体验的，而随着响应式设计的普及，很多站点都已经对移动端坐过适配和优化了，这个时候就不需要双击缩放了，如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了
  - 这个方案相比方案二的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面


3. 设置CSStouch-action

    * CSS属性 touch-action 用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）
	
			   * {
				  touch-action: none;
				}

4. fastclick.js(https://github.com/ftlabs/fastclick)

   * 移动端事件触发顺序：在移动端，手指点击一个元素，会经过：touchstart=> touchmove => touchend =>click
   
   * fastclick.js的原理是：FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即触发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉

        * 在原生js中可以如下使用：
		
		        if ('addEventListener' in document) {
				    document.addEventListener('DOMContentLoaded', function() {
				        FastClick.attach(document.body);
				    }, false);
				}
		
        * 在jquery或zpeto中可以如下使用：

				$(function() {
				    FastClick.attach(document.body);
				});
				     

        * 在cli工具中(require或者import)

		        const FastClick = require('fastclick');
				// import FastClick = require('fastclick');
				FastClick.attach(document.body, options);
		
#### 二、移动端点透问题 ####

1. 点透问题出现的场景

- 当A/B两个层上下z轴重叠且A和B不是后代继承关系，上层的A点击后消失或移开（这一点很重要），并且B元素本身有默认click事件（如a标签）或绑定了click事件。在这种情况下，点击A/B重叠的部分，A消失或移开后，B会执行click事件，这就是点透的现象

- 总结如下：

    * A/B两个层上下z轴重叠（上下重叠，A盖着B）且A和B不是后代继承关系
    * 上层的A点击后消失或移开。（这一点很重要）
    * B元素本身有默认click事件（如a标签） 或 B绑定了click事件

2. 点透问题的出现原因

- 点透问题出现的原因就是由于在移动端触摸屏幕进行点击动作的时候，其实是有2个事件触发的一个是touch,另一个则是click，因为我们上边说过的移动端click事件300ms延迟问题，当点击上层元素时，先触发touchstart事件，然后在300ms后会触发click事件，而此时上层元素已经消失，所以下边的元素会触发click事件，这就是点透

3. 点透问题的解决方案

   - (1)解决了300毫秒延迟问题即解决了点透问题

   - (2)给上层元素(A元素)加preventDefault()来阻止后面的click触发

			var div1 = document.getElementById('A')
			var div2 = document.getElementById('B')
			
			div1.ontouchstart = function(ev){
			    let oEvent = ev || event;
			    this.style.display = 'none';
			    oEvent.preventDefault();
			    console.log(1)
			}
			
			div2.onclick = function(){
			    console.log(2)
			}

  - (3)使用一个(透明)遮罩层，屏蔽所有事件，然后400ms(对于IOS来说是个理想值)后自动隐藏
  - (4)下层避开click事件，如a链接改为span等标签，使用js跳转页面
  

<h3 id='三十四、伪类和伪元素'>三十四、伪类和伪元素</h3>  

#### 一、概念 ####

- 伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。

#### 二、伪类 ####

- :link 将样式添加到未被访问过的元素
- :visited 将样式添加到被访问过的元素
- :hover 鼠标悬浮在元素上时，向元素添加样式
- :active 将样式添加到被激活的元素
- :focus 将样式添加到被选中的元素
- :first-child 将样式添加到元素的第一个子元素
- :last-child	将样式添加到元素的最后一个子元素
- :enabled	启用的元素，通常用于表单
- :disabled 未启用的元素，通常用于表单
- :checked	选中的元素，通常用于表单 checkbox 元素
- :lang 允许创作者来定义指定的元素中使用的语言

 - :hover 必须被置于 :link 和 :visited 之后，才是有效的
 - :active 必须被置于 :hover 之后，才是有效的

#### 三、伪元素 ####

- :first-letter 将特殊样式添加到文本的第一个首字母
- :first-line 将样式添加到文本的第一行
- :before 在某元素之前插入某些内容
- :after 在某元素之后插入某些内容
- :selection 选中的内容

#### 四、伪类和伪元素区别 ####

- 这里用伪类 :first-child 和伪元素 :first-letter 来进行比较

    
	//伪类 :first-child 添加样式到第一个子元素

     p > i:first-child {color: red}

	<p>
	    <i>first</i>
	    <i>second</i>
	</p>


- 如果我们不使用伪类，而希望达到上述效果，可以这样做：
	
	.first-child {color: red}

	<p>
	    <i class="first-child">first</i>
	    <i>second</i>
	</p>
	
- 即我们给第一个子元素添加一个类，然后定义这个类的样式

	//伪元素 :first-letter 添加样式到第一个字母
	
	p:first-letter {color: red}
	<p>I am stephen lee.</p>

- 那么如果我们不使用伪元素，要达到上述效果，应该怎么做呢？
	
	.first-letter {color: red}
	<p><span class='first-letter'>I</span> am stephen lee.</p>
	
- 即我们给第一个字母添加一个 span，然后给 span 增加样式。
	
 - 两者的区别已经出来了。那就是：

    - 伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因

-  css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示

#### 五、回答 ####

- 伪类一般匹配的是元素的一些特殊状态，用于当已有的元素处于某个状态时，为其添加对应的样式，比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。
- 伪元素一般匹配的特殊的位置，用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
- 为了区分伪元素和伪类，（css3使用）两个冒号（::）和一个冒号（:）


<h3 id='三十五、用css绘制一个三角形原理'>三十五、用css绘制一个三角形原理</h3>

#### 一、原理以及实现 ####

- 采用的是相邻边框连接处的均分原理
- 实现

  - 将元素的宽和高设置为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下一个就是三角形

		   .box{
		       width:0;
		       height:0;
		       border-style:solid;
		       border-width: 20px;
		       border-color:transparent transparent red transparent;
		     }


<h3 id='三十六、品字布局'>三十六、品字布局</h3>

1. 满屏品字布局

- 简单的方式：上面的div宽100%，下面的两个div分别宽50%，然后用float或者inline使其不换行即可

			.box1{
		       width:100%;
		       height: 100px;
		       background-color: teal;
		     }
		     .box2{
		       width:50%;
		       height: 100px;
		       background-color: red;
		       float:left;
		     }
		     .box3{
		       width:50%;
		       height: 100px;
		       background-color: blueviolet;
		       float:left;
		     }

2. 居中品字布局

		<div class='box'>
		  <div class='box1'></div>
		  <div class='box2'></div>
		  <div class='box3'></div>
		</div>
		
		  <style>
		     .box{
		       position: absolute;
		       left:50%;
		       top:50%;
		       transform:translate(-50%,-50%)
		     }
		     .box1{
		       width:100px;
		       height: 100px;
		       background-color: teal;
		       margin-left:50px;
		     }
		     .box2{
		       width:100px;
		       height: 100px;
		       background-color: red;
		       float:left;
		     }
		     .box3{
		       width:100px;
		       height: 100px;
		       background-color: blueviolet;
		       float:left;
		     }
		     
		  </style>


<h3 id='三十七、多列等高布局'>三十七、多列等高布局</h3>

#### 一、实现 ####

1. flex布局


			<style>
		        body{
		            margin:0;
		            padding: 0;
		        }
		        .box{
		            display: flex;
		         }
		         .left{
		             background-color: green;
		             width:100px;
		         }
		         .middle{
		             background-color: aqua;
		             flex:1
		         }
		         .right{
		            background-color: red;
		            width:100px
		        }
		    </style>
		
		     <body>
		
		           <div class='box'>
		                <div class='left'>left</div>
		                <div class='middle'>center</div>
		                <div class='right'>right</div>
		            </div>
		     </body>


2. table-cell布局

* table本来就具有等高的特性

* display设置为table-cell，则此元素就会作为一个表格单元格显示，类似于使用标签td或th标签
* 利用table-cell所有单元格高度都相等的特性，来实现多列等高。

		     <style>
		        body{
		            margin:0;
		            padding: 0;
		        }
		         .left{
		             background-color: green;
		             width:100px;
		             display:table-cell
		         }
		         .middle{
		             background-color: aqua;
		             width:100px;
		             display:table-cell
		         }
		         .right{
		            background-color: red;
		            width:100px
		            display:table-cell
		        }
		    </style>
		
		     <body>
		
		           <div class='box'>
		                <div class='left'>left</div>
		                <div class='middle'>center</div>
		                <div class='right'>right</div>
		            </div>

3. 假等高列布局 内外边距底部正负值

- 实现：设置父容器的overflow属性为hidden。给每列设置比较大的底内边距，然后用数值相似的负外边距消除这个高度。

- 技术点:

  * background 会填充内边距 padding，而不会填充外边距 margin 。margin具有坍塌性，可以设置负值。

  * float:left。使用float，元素会脱离文档流，使其浮动至最近的文档流元素。在这里的作用是，将三个div元素并排。

  * overflow:hidden; 设置overflow属性为hidden，这样会让父容器产生BFC（Block Fromatting Context块级格式化上下文）效果，消除float带来的影响。同时，根据需要，会截取内容以适应填充框，将超出容器的部分隐藏


		    <style>
		        body{
		            margin:0;
		            padding: 0;
		        }
		        .box{
		            overflow: hidden;
		         }
		         .left{
		             background-color: green;
		             width:200px;
		             float:left;
		             padding-bottom: 9999px;
		             margin-bottom: -9999px;
		         }
		         .middle{
		             background-color: aqua;
		             float:left;
		             padding-bottom: 9999px;
		             margin-bottom: -9999px;
		         }
		         .right{
		            background-color: red;
		            width:200px;
		            float:left;
		            padding-bottom: 9999px;
		            margin-bottom: -9999px;
		        }
		    </style>
		
		
		     <body>
		
		           <div class='box'>
		                <div class='left'>left</div>
		                <div class='middle'>center</div>
		                <div class='right'>right</div>
		            </div>
		     </body>



4. grid网格布局

		   <style>
		
		       .box{
		            display:grid;
		            grid-template-columns: 100px auto 100px;
		            grid-template-rows: auto;
		        }
		        .left{
		            background-color: green;
		        }
		        .center{
		            background-color: aqua;
		        }
		        .right{
		            background-color: red;
		        }
		
		   </style>
		
		<body>
		    
		    <div class='box'>
		        <div class='left'>left</div>
		        <div class='center'>center</div>
		        <div class='right'>right</div>
		    </div>
		
		</body>
		

5. 绝对定位

- 给子元素设置top:0;bottom:0;让所有子元素和父元素高度一致

		    <style>
		
		        .box{
		            position:relative;
		            height: 400px;
		        }
		        .left{
		            position:absolute;
		            background-color: green;
		            width:100px;
		            top:0;
		            bottom:0;
		        }
		        .center{
		            position:absolute;
		            background-color: aqua;
		            left:100px;
		            right:100px;
		            bottom:0;
		            top:0;
		        }
		        .right{
		            position:absolute;
		            background-color: red;
		            width:100px;
		            right:0;
		            bottom:0;
		            top:0;
		        }
		    </style>
		
		    <body>
			    <div class='box'>
			        <div class='left'>left</div>
			        <div class='center'>center</div>
			        <div class='right'>right</div>
			    </div>
		  </body>


#### 二、回答 ####

1. 使用flex
2. 利用table-cell所有单元格高度都相等的特性，来实现多列等高。
3. 利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。

<h3 id='三十八、什么是包含块？'>三十八、什么是包含块？</h3>

#### 一、概念 ####

- 元素盒子的位置和大小有时是相对于某个矩形计算的，称为元素的包含块。许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！
- 包含块分为根元素包含块和其他元素的包含块。

#### 二、根元素包含块 ####

- 根元素html的包含块是一个矩形,叫做初始化包含块(initial containing block)。
- 可以看到html外面还有空间，这个包含html的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物。
- 对于连续媒体设备（continuous media），初始包含块的大小等于视口viewpor的大小，其尺寸等同于浏览器可视窗口的大小基点在画布的原点（视口左上角）；对于分页媒体（paged media），初始包含块是页面区域（page area）。初始包含块的direction属性与根元素的相同。

#### 三、其他元素包含块的确定 ####

- 确定一个元素的包含块的过程完全依赖于这个元素的 position 属性：
 
  - 如果 position 属性为 static 或 relative ，包含块就是由它的最近的祖先块元素(inline-block、block、list-item)，或者 BFC(table、flex、grid) 的**内容区的边缘（content）**组成的。
  - 如果 position 属性为 absolute ，包含块就是由它的最近的 position 的值不是 static （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的**内边距区的边缘**组成。
  - 如果 position 属性是 fixed，可以认为包含块就是视口 viewport也就是初始化包含块。
  - 如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的**内边距区的边缘(包padding)**组成的：
    - 1.transform不为none
    - 2.A will-change value of transform or perspective(翻译：ransform或perspective的will-change值)
    - 3.A filter value other than none or a will-change value of filter (only works on Firefox).(翻译：transform或perspective的will-change值除了none或filter的will-change值(只在Firefox上工作)。)

#### 四、元素包含块的作用？ ####

- 元素的尺寸会经常受到包含块的影响，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性：
   - height, top, bottom 这些属性由包含块的 height 属性的值来计算它的百分值。如果包含块的 height 值依赖于它的内容，且包含块的 position 属性的值被赋予 relative 或 static的话，这些值的计算值为0。也就是说包含块自身能先确定高度才可以让子元素的百分比计算生效。
   - width, left, right, padding, margin, text-indent这些属性由包含块的 width 属性的值来计算它的百分值。

			<body>
			  <section>
			    <p>This is a paragraph!</p>
			  </section>
			</body>
		
      例一：
			body {
			  background: beige;
			}
			
			section {
			  display: block;
			  width: 400px;
			  height: 160px;
			  background: lightgray;
			}
			
			p {
			  width: 50%;   /* == 400px * .5 = 200px */
			  height: 25%;  /* == 160px * .25 = 40px */
			  margin: 5%;   /* == 400px * .05 = 20px */
			  padding: 5%;  /* == 400px * .05 = 20px */
			  background: cyan;
			}

      - 在这里，这个P标签position为默认的static，所以它的包含块为Section标签，通过我们的判断规则一来确定。

		     例二：
		
		         body {
				  background: beige;
				}
				
				section {
				  display: inline;
				  background: lightgray;
				}
				
				p {
				  width: 50%;     /* == half the body's width */
				  height: 200px;  /* Note: a percentage would be 0 */
				  background: cyan;
				}

       - 在这里，这个P标签position为默认的static且它的父标签Section的display为inline，所以P标签的包含块为body标签，通过我们的判断规则一来确定。

             例三：
				body {
				  background: beige;
				}
				
				section {
				  transform: rotate(0deg);
				  width: 400px;
				  height: 160px;
				  background: lightgray;
				}
				
				p {
				  position: absolute;
				  left: 80px;
				  top: 30px;
				  width: 50%;   /* == 200px */
				  height: 25%;  /* == 40px */
				  margin: 5%;   /* == 20px */
				  padding: 5%;  /* == 20px */
				  background: cyan;
				}

            - 在这里，这个P标签position为absolute且它的父标签Section的transform不为none，所以P标签的包含块为Section标签，通过我们的判断规则四来确定。


				例四：
				
				    body {
					  background: beige;
					}
					
					section {
					  position: absolute;
					  left: 30px;
					  top: 30px;
					  width: 400px;
					  height: 160px;
					  padding: 30px 20px;
					  background: lightgray;
					}
					
					p {
					  position: absolute;
					  width: 50%;   /* == (400px + 20px + 20px) * .5 = 220px */
					  height: 25%;  /* == (160px + 30px + 30px) * .25 = 55px */
					  margin: 5%;   /* == (400px + 20px + 20px) * .05 = 22px */
					  padding: 5%;  /* == (400px + 20px + 20px) * .05 = 22px */
					  background: cyan;
					}

            - 在这里，这个P标签position为absolute且它的父标签Section的position不为static，所以P标签的包含块为Section标签的padding边缘算起（前提是不能 box-sizing设置为border-box），通过我们的判断规则二来确定。


					例五：body {
						  background: beige;
						}
						
						section {
						  width: 300px;
						  height: 300px;
						  margin: 30px;
						  padding: 15px;
						  background: lightgray;
						}
						
						p {
						  position: fixed;
						  width: 50%;   /* == (50vw - (width of vertical scrollbar)) */
						  height: 50%;  /* == (50vh - (height of horizontal scrollbar)) */
						  margin: 5%;   /* == (5vw - (width of vertical scrollbar)) */
						  padding: 5%;  /* == (5vw - (width of vertical scrollbar)) */
						  background: cyan;
						}

            - 在这里，这个P标签position为fixed,所以P标签的包含块为初始包含块（viewport），通过我们的判断规则三来确定。

#### 五、回答 ####

- 元素盒子的位置和大小有时是相对于某个矩形计算的，称为元素的包含块，包含块分为根元素包含块和其他元素的包含块。
- 根元素（很多场景下可以看成是<html>）的包含块被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。
- 对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的**块容器**祖先盒的**内容区（content box）**边界形成。
- 如果元素position:fixed，则“包含块”是“初始包含块”。
- 如果元素position:absolute，则“包含块”由它的最近的 position 的值不是 static （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的**内边距区的边缘**组成。
- 元素包含块的作用就是元素的尺寸会经常受到包含块的影响，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。

<h3 id='三十九、css的visibility属性的collapse值'>三十九、css的visibility属性的collapse值</h3>

#### 一、简介 ####

- visibility:visible,hidden,collapse,inherit

- 当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display: none一样，也就是说，它们占用的空间也会释放。

		<table>
		    <tr>
		      <td>111</td>
		      <td>222</td>
		    </tr>
		    <div class='box'>222</div>
		    <div>333</div>
		</table>

       tr{
	       visibility:collapse;
	     }

	     .box{
	      visibility:collapse;
	     }


- 上面例子中，tr会消失，它的表现和display：none一样不会占据空间，第一个div会占据它的位置，因为第一个div也设置了visibility:collapse，第一个div也消失了，但他的表现和visible一样，会占据空间，所以第二个div显示在第一个div下边。

#### 二、回答 ####

- 对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。
- 但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。

<h3 id='四十、width是auto和width是100%的区别'>四十、width是auto和width是100%的区别</h3>

#### 一、理解 ####

- width:100%会使元素box的宽度等于父元素的content box的宽度。
- width:auto会使元素撑满整个父元素也是content box宽度，并且margin、border、padding、content区域会自动分配水平空间。
- 可以理解为100%的话，子元素宽度始终为父元素宽度100%，假如子元素设置margin或border，padding这些属性的话，会超出父元素。
- 但auto的话，子元素设置margin或border，padding这些属性的时候会重新根据值分配子元素width的值，使子元素不超出父元素盒子

		<div class='box'>
		  <div class='inner'></div>
		</div>

		.box{
	       width:200px;
	       height:200px;
	       padding: 10px;
	       background-color: brown;
	     }
	     .inner{
	       width:100%;
	       height: 100px;
	       background-color: chartreuse;
	       padding: 20px;
	       margin: 20px;
	     }

        - 上面例子使用了100%，子元素有padding和margin会超出父盒子，子元素的width仍然为200px

		<div class='box'>
		  <div class='inner'></div>
		</div>

		.box{
	       width:200px;
	       height:200px;
	       padding: 10px;
	       background-color: brown;
	     }
	     .inner{
	       width:auto;
	       height: 100px;
	       background-color: chartreuse;
	       padding: 20px;
	       margin: 20px;
	     }

        - 上面例子使用了auto，子元素有padding和margin不会超出父盒子，子元素的width为120px


#### 二、回答 ####

- width:100%会使元素box的宽度等于父元素的content box的宽度。
- width:auto会使元素撑满整个父元素（也是content box的宽度），但margin、border、padding、content区域会自动分配水平空间。

<h3 id='四一、图片base64编码的优点和缺点'>四一、图片base64编码的优点和缺点</h3>
 
#### 一、什么是base64编码？

- 图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址。
- 这样做有什么意义呢？我们知道，我们所看到的网页上的每一个图片，都是需要消耗一个 http 请求下载而来的（所有才有了 csssprites 技术的应运而生，但是 csssprites 有自身的局限性，下文会提到）。
没错，不管如何，图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，而可以随着 HTML 的下载同时下载到本地那就太好了，而 base64 正好能解决这个问题。

#### 二、回答 ####

- base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片url属性。

- 使用base64的优点是：

 - （1）减少一个图片的HTTP请求

- 使用base64的缺点是：

 - （1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。
 - （2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。
 - （3）兼容性的问题，ie8以前的浏览器不支持。一般一些网站的小图标可以使用base64图片来引入。

<h3 id='四十二、'display'、'position'和'float'的相互关系？'>四十二、'display'、'position'和'float'的相互关系？</h3>

#### 一、回答 ####

- （1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。
- （2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。
- （3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。
- （4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。

- 总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。

<h3 id='四十三、margin重叠>四十三、margin重叠</h3>

#### 一、margin重叠理解 ####

- 块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。
- 产生折叠的必备条件：

  - margin必须是邻接的
  - 必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。
  - 没有线盒，没有空隙，没有padding和border将他们分隔开
  - 都属于垂直方向上相邻的外边距

- 折叠规则

   * 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值
   * 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值
   * 两个外边距一正一负时，折叠结果是两者的相加的和
   
- margin重叠的情况：

  - （1）相邻兄弟元素margin合并。

      - 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top
      - 解决办法：

        - 设置块状格式化上下文元素（BFC）

  - （2）父级和第一个子元素margin-top合并。
   
      - 解决办法：

          - 父元素设置为块状格式化上下文元素；
          - 父元素设置border-top值；
          - 父元素设置padding-top值；
          - 父元素和第一个子元素之间添加内联元素进行分隔。

  - （3）height为auto父级和最后一个子元素margin-bottom合并。

      - height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom
      -  解决办法：
      
         - 父元素设置为块状格式化上下文元素；
         - 父元素设置border-bottom值；
         - 父元素设置padding-bottom值；
         - 父元素和最后一个子元素之间添加内联元素进行分隔；
         - 父元素设置height、min-height或max-height。 
         
  - （4）空块级元素的margin合并。

      - 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top

      - 解决办法：

        - 设置垂直方向的border；
        - 设置垂直方向的padding；
        - 里面添加内联元素（直接Space键空格是没用的）；
        - 设置height或者min-height。


#### 二、回答 ####

- margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。
- 一般来说可以分为四种情形：

  - 第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。
  - 第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。
  - 第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。
  - 第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。

<h3 id='四十四、IFC是什么？>四十四、IFC是什么？</h3>

#### 一、回答 ####

- FC指的是行级格式化上下文，它有这样的一些布局规则：

 - （1）行级上下文内部的盒子会在水平方向，一个接一个地放置。
 - （2）当一行不够的时候会自动切换到下一行。
 - （3）行级上下文的高度由内部最高的内联盒子的高度决定。


<h3 id='四十五、zoom和transform的scale'>四十五、zoom和transform的scale</h3>

#### 一、zoom取值 ####

- 它的取值可以为：

  - 百分比值：如，zoom:50%，表示缩小到原来的一半
  - 数值：zoom:0.5，表示缩小到原来的一半
  - normal：zoom:normal等同于zoom:1
  - 注意点：zoom的取值不能为负数

#### 二、transform：scale ####

- tranform:scale，IE9+以及其他主流浏览器都支持，取值为transform: scale(<x> [<y>]),y值为可选值省略表示x和y缩放相同的倍数或者可以用transform:scaleX()、transform:scaleY()来单独对x轴或者y进行缩放。此外，里面的数值可以为负数，当为负数时，页面整个倒过来了,类似transform: rotate(180deg)的效果

#### 三、两者比较 ####

- 相同点

  - 可以对页面缩放

- 不同点

  - a. 兼容性方面：
  
    - zoom可用于所有IE、chrome、手机浏览器
    - scale在IE9+都可兼容

  - b. 取值方面

    - scale可以只控制一个方向的缩放，比如X轴，并且可以为负数，zoom则不行

  - c. 缩放效果

    - zoom相对于页面左上角缩放，它可以改变元素缩放后所占据的空间，比如100X100的页面，缩小一倍后，占据的空间为50X50，
    - zoom缩放后的最小字号为12像素，也就是说，即使你把页面做小了100倍，字体最小也会是12px，也由于这个原因，会影响页面缩放后的布局错乱，会导致缩放后的页面进行重新渲染。
    - scale的缩放相对于页面居中缩放，它不会改变元素所占据的空间，也即是说，100X100的页面，缩小一倍后，占据的空间，还是为100X100。
    - scale的文字可以等比缩放，比如你缩小100倍，文字也会缩小100倍，它相当于页面的整体缩放，因此不会导致布局的变化，页面也不会重新渲染

<h3 id='四十六、浏览器是怎样解析CSS选择器的？'>四十六、浏览器是怎样解析CSS选择器的？</h3>

#### 一、回答 ####

- 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。
试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。

<h3 id='四十七、在网页中应该使用奇数还是偶数的字体？为什么呢？'>四十七、在网页中应该使用奇数还是偶数的字体？为什么呢？</h3>

- （1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。
- （2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。
- （3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。

<h3 id='四十八、margin 和 padding 分别适合什么场景使用？'>四十八、margin 和 padding 分别适合什么场景使用？</h3>

#### 一、回答 ####

- margin是用来隔开元素与元素的间距；
- padding是用来隔开元素与内容的间隔。
- margin用于布局分开元素使元素与元素互不相干。
- padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。

- 何时应当使用margin：
 
  - 需要在border外侧添加空白时。
  - 空白处不需要背景（色）时。
  - 上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。

- 何时应当时用padding：

  - 需要在border内测添加空白时。
  - 空白处需要背景（色）时。
  - 上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。

<h3 id='四十九、抽离样式模块怎么写？'>四十八、抽离样式模块怎么写？</h3>

- http://nec.netease.com/standard/css-sort.html

- 把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。

<h3 id='五十、简单说一下css3的all属性'>五十、简单说一下css3的all属性</h3>

- all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。

   - initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。
   - inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。
   - unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。

<h3 id='五十一、hasLayout'>五十一、hasLayout</h3>

https://segmentfault.com/a/1190000004632071

#### 一、hasLayout到底是何方神圣？ ####

- hasLayout可以简单看作是IE5.5/6/7中的BFC(Block Formatting Context)。也就是一个元素要么自己对自身内容进行组织和尺寸计算(即可通过width/height来设置自身的宽高)，要么由其containing block来组织和尺寸计算。而IFC（即没有拥有布局）而言，则是元素无法对自身内容进行组织和尺寸计算，而是由自身内容来决定其尺寸（即仅能通过line-height设置内容行距，通过行距来支撑元素的高度；也无法通过width设置元素宽度，仅能由内容来决定而已）
- 当hasLayout为true时(就是所谓的"拥有布局")，相当于元素产生新BFC，元素自己对自身内容进行组织和尺寸计算;
- 当hasLayout为false时(就是所谓的"不拥有布局")，相当于元素不产生新BFC，元素由其所属的containing block进行组织和尺寸计算。
- 和产生新BFC的特性一样，hasLayout无法通过CSS属性直接设置，而是通过某些CSS属性间接开启这一特性。不同的是某些CSS属性是以不可逆方式间接开启hasLayout为true。并且默认产生新BFC的只有html元素，而默认hasLayout为true的元素就不只有html元素了。
- 另外我们可以通过object.currentStyle.hasLayout属性来判断元素是否开启了hasLayout特性。

#### 二、默认hasLayout==true的元素 ####

		<html>, <body>
		<table>, <tr>, <th>, <td>
		<img>,<hr>
		<input>, <button>, <select>, <textarea>, <fieldset>, <legend>
		<iframe>, <embed>, <object>, <applet>,<marquee>

#### 三、触发hasLayout==true的方式 ####

		display: inline-block
		height: (除 auto 外任何值)
		width: (除 auto 外任何值)
		float: (left 或 right)
		position: absolute
		writing-mode: tb-rl
		zoom: (除 normal 外任意值)

- IE7 还有一些额外的属性(不完全列表)可以触发 hasLayout ：

		min-height: (任意值)
		min-width: (任意值)
		max-height: (除 none 外任意值)
		max-width: (除 none 外任意值)
		overflow: (除 visible 外任意值，仅用于块级元素)
		overflow-x: (除 visible 外任意值，仅用于块级元素)
		overflow-y: (除 visible 外任意值，仅用于块级元素)
		position: fixed

- IE6 以前的版本（也包括 IE6 及以后所有版本的混杂模式，其实这种混杂模式在渲染方面就相当于 IE 5.5）， 通过设置任何元素的 'width' 或 'height'（非auto）都可以触发 hasLayout ； 但在 IE6 和 IE7 的标准模式中的行内元素上却不行，设置 'display:inline-block' 才可以。
- 其中通过display:inline-block或min-width:0或min-height:0将不可逆地启用hasLayout特性。而在没有其他属性启用hasLayout时，可通过以下方式关闭hasLayout

		max-width, max-height (设为 "none")(在IE7中)
		position (设为 "static")
		float (设为 "none")
		overflow (设为 "visible") (在IE7中)
		zoom (设为 "normal")
		writing-mode (从 "tb-rl" 设为 "lr-t")


<h3 id='五十二、'>五十二、</h3>


















      

<h1 id='vue总结'>vue总结</font><h1>

<h3 id='一、MVVM'>一、MVVM</h3>

#### 一、什么是MVVM？ ####

- MVVM是Module-View-ViewModule的缩写，Module层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI展现出来，ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作
- Module和View并无直接联系，而是通过ViewModule来联系的，Module和ViewModule是双向数据绑定关系，因此当Module层的数据发生改变时会触发View层刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步
- 这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom

#### 二、MVVM优缺点 ####

- 优点：
   
  - 自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放
  - 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变
  - 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑
  - 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
  - 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写

- 缺点：

  - 数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了
  - 对于过大的项目，数据绑定需要花费更多的内存

#### 三、mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？ ####

- mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。
- mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
- 区别：
 
    - vue数据驱动，通过数据来显示视图层而不是节点操作
    - 数据操作比较多的场景，更加便捷


<h3 id='二、vue双向绑定原理'>二、vue双向绑定原理</h3>

- https://www.cnblogs.com/wangjiachen666/p/9883916.html
- https://www.cnblogs.com/canfoo/p/6891868.html
#### 一、原理 ####

- vue数据双向绑定是通过数据劫持结合发布订阅者模式的方式来实现的

#### 二、实现过程分析 ####

1. 实现mvvm主要包括两方面，数据变化更新视图，视图变化更新数据
 
   - 视图变化更新数据可以通过事件监听来实现
   - 主要来分析一下数据改变如何来更新视图

2. 数据改变更新视图分析

   - （1）如何知道数据发生变化了

       - 我们可以通过Object.definePrototype(obj,prop,descriptor)方法为属性设置一个set函数，当数据改变了就会触发这个函数，所以我们只要将更新视图的方法写进这个函数里面就好了

          - obj:要定义属性的对象
          - prop:要定义会修改的属性
          - descriptor:要定义或修改的属性的描述符
                  
             - 数据描述符
                  
               - configurable 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认值false
               - enumerable 表示属性是否可枚举,默认值false
               - value 属性值，默认值为undefined
               - writable 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变，默认为 false。
     
             - 存取描述符

                - get:属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值,默认为 undefined。
                - set:属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。

   - (2)实现过程

      - 实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要一个监听器Observer，来监听所有属性。当属性发生变化了就告诉订阅者Watcher看是否需要更新。由于订阅者是很多个的，所以需要一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间统一管理。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：

        - 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
        - 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
        - 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

        1. 实现一个Observer，使数据对象变得可观测

	           function defineReactive（obj,key,val）{
	                 
	               Object.definePrototype(obj,key,{
	 
	                  enumerable: true,
	                  configurable: true,
	
	                  get() {
	                    console.log(`${key}属性被读取了`)
	                    return val    
	                  },
	
	                  set(newVal) {
	                     console.log(`我监测到${key}属性被修改了`)
	                     val = newVal
	                  }
	
	                })
	             }


	           function observable(obj){
	               if(!obj || typeof obj !== 'object'){
	                  return
	               }
	               
	               Object.keys(obj).forEach((key)=>{
	                   defineReactive(obj,key,obj[key])
	               })
	               
	               return obj
	           }


       2. 创建消息订阅器Dep
      
       - 完成了数据的'可观测'，即我们知道了数据在什么时候被读或写了，那么，我们就可以在数据被读或写的时候通知那些依赖该数据的视图更新了，为了方便，我们需要先将所有依赖收集起来，一旦数据发生变化，就统一通知更新。其实，这就是典型的“发布订阅者”模式，数据变化为“发布者”，依赖对象为“订阅者”。现在，我们需要创建一个依赖收集容器，也就是消息订阅器Dep，用来容纳所有的“订阅者”。订阅器Dep主要负责收集订阅者，然后当数据变化的时候后执行对应订阅者的更新函数。

		         class Dep{
		
		           constructor() {
		              this.subs=[]
		            },
		
		           addSub(sub) {
		             this.subs.push(sub) 
		           }
		
		           depend() {
		             if(Dep.target){
		                this.addSub(Dep.target) //保证初始化时，添加订阅者（我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要
		                                                                 做一个判断操作，所以这里的Dep.target指的就是订阅者Watcher）
		             }
		           }
		
		           notify() {
		            this.subs.forEach(sub)=>{
		               sub.update()              //遍历所有订阅者，去执行更新函数(每个订阅者都有一个update函数)
		            })
		           }
		         }
		
		         Dep.target=null

    3. 有了订阅器之后再改造一下defineReactive函数，在defineReactive函数里边加入订阅器

		        function defineReactive(obj,key,val){
		            dep=new Dep()
		           Object.definePrototype(obj,key,{
		               enumerable: true,
		               configurable: true,
		
		               get() {
		                 dep.depend()
		                 console.log(`${key}属性被读取了`);
		                 return val
		               }
		
		               set(newVal) {
		                 val=newVal
		                 console.log(`${key}属性被修改了`);
		                 this.notify() //数据变化通知所有的订阅者
		               }
		           })
		        }


   4. 订阅者Watcher

      - 订阅者在初始化vue实例的时候，需要将自己添加进订阅器Dep中，以便后面数据变化的时候，能够通知到该订阅者，如何添加呢？

        - 我们知道上面我们的监听器Observer是在get函数中执行了，添加订阅者Watcher的操作的，所以我们只需要在初始化vue实例的时候，去执行get方法就好了，而执行get方法就是去获取属性值就好了
        - 我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在Dep.target上缓存下订阅者，添加成功后再将其去掉就可以了

            class Watcher{
              constructor(vm,exp.cb){
                this.vm = vm   // vue实例
                this.exp = exp // 是node节点的v-model或v-on：click等指令的属性值。如v-model="name"，exp就是name
                this.cb = cb   // 是Watcher绑定的更新函数;
                this.value = this.get() //执行自己的get方法，在get方法中会将自己缓存在Dep.target中，并获取vm的属性值，从而触
                                           发监听器Observer的get方法，从而达到将自己添加到订阅器的目的
              },
              
              update() {
               let value = this.vm.data[this.exp] //修改属性值的时候，触发监听器中的set函数,然后执行该方法，获取修改之后的新值
               let oldVal = this.value  //该this.value值是在初始化实例的时候，在get方法中获取到的
               if(value !== oldVal){
                 this.value = value
                 this.cb.call(this.vm,value,oldVal)
               }
              },
              
              get() {
                Dep.target=this //缓存自己
                let value = this.vm.data[this.exp] //获取vm中的属性值，执行Observer中的get函数，把自己添加到订阅器
                Dep.target = null //添加完之后，释放自己
                return value
              }
           	 }


    过程分析：当我们去实例化一个构造函数时(new Watcher),会发生new的四个过程，其中一步是执行我们的构造函数的逻辑，所以我们就会执行它
             的this.get()方法 ，进入get方法，首先会执行：
                                     
                                           Dep.target=this //缓存自己

             实际上就是把 Dep.target 赋值为当前的渲染 watcher ,接着又执行了：

                                           let value = this.vm.data[this.exp]  // 强制执行监听器Observer里的get函数

             在这个过程中会对vm上的数据访问，其实就是为了触发数据对象的getter，每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 this.addSub(Dep.target),即把当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。
             这样实际上已经完成了一个依赖收集的过程。那么到这里就结束了吗？其实并没有，完成依赖收集后，还需要把 Dep.target 恢复成上一个状态，即：
                                           Dep.target = null;  // 释放自己

             因为当前vm的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变。

			 而update()函数是用来当数据发生变化时调用Watcher自身的更新函数进行更新的操作。先通过let value = this.vm.dat[this.exp];获取到最新的数据,然后将其与之前get()获得的旧数据进行比较，如果不一样，则调用更新函数cb进行更新。
			
    5. 将Observer和Watcher关联起来

	         function myVue(data,el,exp){
	            this.data=data
	            observable(data) //将数据变得可观测
	            el.innerHtml = this.data[exp] //初始化模板数据的值
	            new Watcher(this,exp,function(value){
	                 el.innerHtml = value
	           })                        //初始化将订阅者添加到订阅器
	
	           return this
	         }


    6. 测试使用

	       <body>
			<h1 id="name"></h1>
			<input type="text">
			<input type="button" value="改变data内容" onclick="changeInput()">
			
			<script src="observer.js"></script>
			<script src="watcher.js"></script>
			<script>
				var ele = document.querySelector('#name');
				var input = document.querySelector('input');
				
			    var myVue = new myVue({
					name: 'hello world'
				}, ele, 'name');
			 	
				//改变输入框内容
			    input.oninput = function (e) {
			    	myVue.data.name = e.target.value
			    }
				//改变data内容
				function changeInput(){
					myVue.data.name = "难凉热血"
				
				}
			</script>
		</body>
	


     - observer.js

       - 把一个对象的每一项都转化成可观测对象
	

			function observable (obj) {
				if (!obj || typeof obj !== 'object') {
		        	return;
		    	}
				let keys = Object.keys(obj);
				keys.forEach((key) =>{
					defineReactive(obj,key,obj[key])
				})
				return obj;
			}

	
      - 使一个对象转化成可观测对象

			function defineReactive (obj,key,val) {
				let dep = new Dep();
				Object.defineProperty(obj, key, {
					get(){
						dep.depend();
						console.log(`${key}属性被读取了`);
						return val;
					},
					set(newVal){
						val = newVal;
						console.log(`${key}属性被修改了`);
						dep.notify()                    //数据变化通知所有订阅者
					}
				})
			}
		
			class Dep {
				
				constructor(){
					this.subs = []
				}
				//增加订阅者
				addSub(sub){
					this.subs.push(sub);
				}
		        //判断是否增加订阅者
				depend () {
				    if (Dep.target) {
				     	this.addSub(Dep.target)
				    }
				}
		
				//通知订阅者更新
				notify(){
					this.subs.forEach((sub) =>{
						sub.update()
					})
				}
				
			}
		
			Dep.target = null;

   - watcher.js

		    class Watcher {
				constructor(vm,exp,cb){
				    this.vm = vm;
				    this.exp = exp;
				    this.cb = cb;
				    this.value = this.get();  // 将自己添加到订阅器的操作
				}
				get(){
					Dep.target = this;  // 缓存自己
		        	let value = this.vm.data[this.exp]  // 强制执行监听器里的get函数
		        	Dep.target = null;  // 释放自己
		        	return value;
				}
				update(){
					let value = this.vm.data[this.exp];
		        	let oldVal = this.value;
		        	if (value !== oldVal) {
		                this.value = value;
		                this.cb.call(this.vm, value, oldVal);
					}
			    }
		     }


   7. 还有一个细节问题就是我们在赋值的时候是这样的，myVue.data.name = "难凉热血"，而我们的理想形式是myVue.name = '难凉热血'，为了实现这样的形式，我们需要在new SelfVue的时候做一个代理处理，让访问selfVue的属性代理为访问selfVue.data的属性，实现原理还是使用Object.defineProperty( )对属性值再包一层：

	        function myVue (data, el, exp) {
			    var self = this;
			    this.data = data;
			 
			    Object.keys(data).forEach(function(key) {
			        self.proxyKeys(key);  // 绑定代理属性
			    });
			 
			    observe(data);
			    el.innerHTML = this.data[exp];  // 初始化模板数据的值
			    new Watcher(this, exp, function (value) {
			        el.innerHTML = value;
			    });
			    return this;
			}
			 
			myVue.prototype = {
			    proxyKeys: function (key) {
			        var self = this;
			        Object.defineProperty(this, key, {
			            enumerable: false,
			            configurable: true,
			            get: function proxyGetter() {
			                return self.data[key];
			            },
			            set: function proxySetter(newVal) {
			                self.data[key] = newVal;
			            }
			        });
			    }
			}

     	这下我们就可以直接通过myVue.name = '难凉热血'改变属性值了

    8. 实现Compile

       - (1) 为了解析模板，首先需要获取到dom元素，然后对含有dom元素上含有指令的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理
       - (2)接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理,这里通过if(node.nodeType == 1)来判断该节点是否为元素节点，可以分为两种情况：元素节点(v-model,v-bind,v-html,class,v-on)和文本节点且匹配{{}}这种形式，分别处理
	
             - 在每个元素节点中又分为事件指令和普通指令分别处理，因为事件指令比其他的要多传一个参数(事件类型如click）
             
               - 事件指令通过addEventListener来添加事件
               - 文本节点且匹配{{}}这种形式，直接处理
	
     - https://github.com/DMQ/mvvm/blob/master/js/compile.js


<h3 id='三、vue双向绑定原理再理解'>三、vue双向绑定原理再理解</h3>

#### 一、代理的作用 ####

- vue响应式原理依赖Object.definePrototype，通过setter/getter监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。
- 第一步将数据变为响应式的

		 class Vue{
		  constructor(options) {
		     this.data = options.data
		     this.observe(this.data,options.render)
		  }

		  observe(obj,render) {
		    Object.keys(obj).forEach(key => {
		      this.defineReactive(obj,key,obj[key],render) 
		    })
		  }
		
		  defineReactive(obj,key,value,render) {
		     Object.defineProperty(obj,key,{
		       configurable:true,
		       enumerable:true,
		       get:() =>{
		         return value
		       },
		       set:newValue => {
		        value = newValue
		         render(value)
		       }
		
		     })
		  }
		}

		
		let app = new Vue({
		  data:{
		    text1:1,
		    text2:2,
		    text3:3
		  },
		  render(data) {
		    console.log(data)
		  }
		})
		
		app.data.text1 = 6


- 第二步代理

   - 由第一步可以看出来，必须这样调用app.data.text1才能触发setter，因为上面实现中，Object.definePrototype绑定的是obj，也就是data对象，所以必须调用data才能触发setter。现在我们想要实现直接app.text1这样调用，按上面的的分析思路，我们应该让Object.definePrototype绑定app对象，这样改变它的属性就能触发setter，我们可以在Vue的构造函数constructor中为data执行一个代理proxy。这样我们就把data上面的属性代理到了vm实例上。

		class Vue{
		  constructor(options) {
		     this.data = options.data
		     this.proxy.call(this,this.data,options.render)
		  }
		  proxy(obj,render) {
		    let that = this
		    Object.keys(obj).forEach(key => {
		
		      Object.defineProperty(that,key,{
		        configurable:true,
		        enumerable:true,
		        get:() =>{
		          return that.data[key]
		        },
		        set:newValue => {
		         that.data[key] = newValue
		          render(that.data[key])
		        }
		      })
		    })
		  }
		}
		
		let app = new Vue({
		  data:{
		    text1:1,
		    text2:2,
		    text3:3
		  },
		  render(data) {
		    console.log(data)
		  }
		})
		
		app.text1 = 6


#### 二、全部实现过程 ####

https://juejin.cn/post/6989106100582744072#heading-14

			class Vue{
			  constructor(options) {
			    // 获取到传入的对象 没有默认为空对象
			     this.$options = options || {}
			
			     // 获取 el
			     this.$el = options.el === 'string'?document.querySelector(options.el):options.el
			
			     // 获取 data
			     this.$data = options.data || {}
			
			     // 调用 proxyData 处理data中的属性，将data属性代理给Vue实例
			     this.proxyData(this.$data)
			
			     //使用 Obsever 把data中的数据转为响应式
			     new Observer(this.$data)
			
			     //编译模板
			     new Compiler(this)
			    }
			     proxyData(data) {
			       Object.keys(data).forEach(key => {
			          // 进行数据劫持
			          // 把每个data的属性 到添加到 Vue 转化为 getter setter方法
			          Object.defineProperty(this,key,{
			            // 设置可以枚举
			            enumerable:true,
			            // 设置可以配置
			            configurable:true,
			             // 获取数据
			            get:() => {
			              return data[key]
			            },
			            // 设置数据
			            set:newVal => {
			               // 判断新值和旧值是否相等
			              if(newVal === data[key]){
			                return
			              }
			              // 设置新值
			              newVal = data[key]
			            }
			          })
			       })
			     }
			
			}
			
			class Observer{
			
			  constructor(data){
			    //用来遍历data
			    this.walk(data)
			  }
			
			  // 遍历 data 转为响应式
			  walk() {
			    // 判断 data是否为空 和 对象
			    if(!data || typeof data !== 'object'){
			      return
			    }
			    // 遍历 data
			    Object.keys(data).forEach(key => {
			      // 转为响应式
			      this.defineReactive(data,key,data[key])
			    })
			  }
			
			  // 转为响应式
			  // 要注意的 和vue.js 写的不同的是
			  // vue.js中是将 属性给了 Vue 转为 getter setter
			  // 这里是 将data中的属性转为getter setter
			
			  defineReactive(obj,key,value) {
			
			    // 如果是对象类型的 也调用walk 变成响应式，不是对象类型的直接在walk会被return
			    this.walk(value)
			    // 保存一下 this
			    let self = this
			   // 创建 Dep 对象
			    let dep = new Dep()
			    Object.defineProperty(obj,key,{
			      enumerable:true,
			      configurable:true,
			
			      get:() => {
			        // 在这里添加观察者对象 Dep.target 表示观察者
			        if(Dep.target){
			          dep.addSub(Dep.target)
			        }
			        return value
			      },
			
			      set:newVal => {
			         if(value === newVal){
			           return
			         }
			         
			         // 赋值的话如果是newValue是对象，对象里面的属性也应该设置为响应式的
			         self.walk(newVal)
			          // 触发通知 更新视图
			         dep.notify()
			      }
			    })
			  }
			} 
			
			class Dep{
			  constructor() {
			    // 存储观察者
			    this.subs = []
			  }
			
			  // 添加观察者
			  addSub(sub) {
			    // 判断观察者是否存在 和 是否拥有update方法
			     if(sub && sub.updata){
			       this.subs.push(sub)
			     }
			  }
			
			  notify() {
			    // 通知方法
			    this.subs.forEach(sub => {
			      // 触发每个观察者的更新方法
			      sub.updata()
			    })
			  }
			}
			
			
			
			class Compiler {
			  // vm 指 Vue 实例
			  constructor(vm) {
			    // 拿到 vm
			    this.vm = vm
			    // 拿到 el
			    this.el = vm.$el
			    // 编译模板
			    this.compile(this.el)
			  }
			  // 编译模板
			  compile(el) {
			    // 获取子节点 如果使用 forEach遍历就把伪数组转为真的数组
			    let childNodes = [...el.childNodes]
			    childNodes.forEach((node) => {
			      // 根据不同的节点类型进行编译
			      // 文本类型的节点
			      if (this.isTextNode(node)) {
			        // 编译文本节点
			        this.compileText(node)
			      } else if (this.isElementNode(node)) {
			        //元素节点
			        this.compileElement(node)
			      }
			      // 判断是否还存在子节点考虑递归
			      if (node.childNodes && node.childNodes.length) {
			        // 继续递归编译模板
			        this.compile(node)
			      }
			    })
			  }
			  // 编译文本节点(简单的实现)
			  compileText(node) {
			    // 核心思想利用把正则表达式把{{}}去掉找到里面的变量
			    // 再去Vue找这个变量赋值给node.textContent
			    let reg = /\{\{(.+?)\}\}/
			    // 获取节点的文本内容
			    let val = node.textContent
			    // 判断是否有 {{}}
			    if (reg.test(val)) {
			      // 获取分组一  也就是 {{}} 里面的内容 去除前后空格
			      let key = RegExp.$1.trim()
			      // 进行替换再赋值给node
			      node.textContent = val.replace(reg, this.vm[key])
			      // 创建观察者
			      new Watcher(this.vm, key, (newValue) => {
			        node.textContent = newValue
			      })
			    }
			  }
			  // 编译元素节点这里只处理指令
			  compileElement(node) {
			    // 获取到元素节点上面的所有属性进行遍历
			    ![...node.attributes].forEach((attr) => {
			      // 获取属性名
			      let attrName = attr.name
			      // 判断是否是 v- 开头的指令
			      if (this.isDirective(attrName)) {
			        // 除去 v- 方便操作
			        attrName = attrName.substr(2)
			        // 获取 指令的值就是  v-text = "msg"  中msg
			        // msg 作为 key 去Vue 找这个变量
			        let key = attr.value
			        // 指令操作 执行指令方法
			        // vue指令很多为了避免大量个 if判断这里就写个 uapdate 方法
			        this.update(node, key, attrName)
			      }
			    })
			  }
			  // 添加指令方法 并且执行
			  update(node, key, attrName) {
			    // 比如添加 textUpdater 就是用来处理 v-text 方法
			    // 我们应该就内置一个 textUpdater 方法进行调用
			    // 加个后缀加什么无所谓但是要定义相应的方法
			    let updateFn = this[attrName + 'Updater']
			    // 如果存在这个内置方法 就可以调用了
			    updateFn && updateFn.call(this, node, key, this.vm[key])
			  }
			  // 提前写好 相应的指定方法比如这个 v-text
			  // 使用的时候 和 Vue 的一样
			  textUpdater(node, key, value) {
			    node.textContent = value
			    // 创建观察者
			    new Watcher(this.vm, key, (newValue) => {
			      node.textContent = newValue
			    })
			  }
			  // v-model
			  modelUpdater(node, key, value) {
			    node.value = value
			    // 创建观察者
			    new Watcher(this.vm, key, (newValue) => {
			      node.value = newValue
			    })
			    // 这里实现双向绑定
			    node.addEventListener('input', () => {
			      this.vm[key] = node.value
			    })
			  }
			
			  // 判断元素的属性是否是 vue 指令
			  isDirective(attr) {
			    return attr.startsWith('v-')
			  }
			  // 判断是否是元素节点
			  isElementNode(node) {
			    return node.nodeType === 1
			  }
			  // 判断是否是 文本 节点
			  isTextNode(node) {
			    return node.nodeType === 3
			  }
			}
			
			
			class watcher{
			  constructor(vm,key,cb){
			    // vm 是 Vue 实例
			    this.vm = vm
			    // key 是 data 中的属性
			    this.key = key
			    // cb 回调函数 更新视图的具体方法
			    this.cb = cb
			    // 把观察者的存放在 Dep.target
			    Dep.target = this
			    // 旧数据 更新视图的时候要进行比较
			    // 还有一点就是 vm[key] 这个时候就触发了 get 方法
			    // 之前在 get 把 观察者 通过dep.addSub(Dep.target) 添加到了 dep.subs中
			    this.oldVal = vm[key]
			    // Dep.target 就不用存在了 因为上面的操作已经存好了
			    Dep.target = null
			  }
			  // 观察者中的必备方法 用来更新视图
			  update() {
			    // 获取新值
			    let newVal = this.vm[this.key]
			    // 比较旧值和新值
			    if(newVal === this.oldVal){
			      return
			    }
			    // 调用具体的更新方法
			    this.cb(newVal)
			  }
			}
			
			     
<h3 id='四、diff算法' >四、diff算法</h3>

https://juejin.cn/post/6994959998283907102
#### 一、虚拟DOM ####

1. 什么是虚拟DOM？

- 虚拟DOM是一个对象，一个什么样的对象呢？一个用来表示真实DOM的对象，即虚拟DOM就是将真实的DOM的数据抽离出来，以对象的形式模拟树形结构，看下面例子：

		<ul id="list">
		    <li class="item">哈哈</li>
		    <li class="item">呵呵</li>
		    <li class="item">嘿嘿</li>
		</ul>

对应的虚拟DOM为：

        // 旧虚拟DOM

		let oldVDOM = { 
		        tagName: 'ul', // 标签名
		        props: { // 标签属性
		            id: 'list'
		        },
		        children: [ // 标签子节点
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['哈哈']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['呵呵']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['嘿嘿']
		            },
		        ]
		    }


这时候，我修改一个li标签的文本：

		<ul id="list">
		    <li class="item">哈哈</li>
		    <li class="item">呵呵</li>
		    <li class="item">林三心哈哈哈哈哈</li> // 修改
		</ul>

这时候生成的新虚拟DOM为：

        // 新虚拟DOM

		let newVDOM = { 
		        tagName: 'ul', // 标签名
		        props: { // 标签属性
		            id: 'list'
		        },
		        children: [ // 标签子节点
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['哈哈']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['呵呵']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['林三心哈哈哈哈哈']
		            },
		        ]
		    }


这就是咱们平常说的新旧两个虚拟DOM，这个时候的新虚拟DOM是数据的最新状态，那么我们直接拿新虚拟DOM去渲染成真实DOM的话，效率真的会比直接操作真实DOM高吗？那肯定是不会的，看下图：

![](./images/diff1.jpg)

示例1是创建一个DOMB然后替换掉DOMA;示例2去创建虚拟DOM+DIFF算法比对发现DOMB跟DOMA不是相同的节点,最后还是创建一个DOMB然后替换掉DOMA;可以明显看出1是更快的。同样的结果,2还要去创建虚拟DOM+DIFF算法对比，所以说使用虚拟DOM比直接操作真实DOM就一定要快这个说法是错误的，不严谨的。

#### 二、什么是diff算法 ####

![](./images/diff2.jpg)

上图中，其实只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。

- 所以，当一些复杂的节点,比如说一个父节点里面有多个子节点,当只是一个子节点的内容发生了改变,那么我们没有必要像示例1重新去渲染这个DOM树,这个时候虚拟DOM+DIFF算法就能够得到很好的体现,我们通过示例2使用**虚拟DOM+Diff算法**去找出改变了的子节点更新它的内容就可以了。
- diff 算法首先要明确一个概念就是 Diff 的对象是虚拟DOM（virtual dom），更新真实 DOM 是 Diff 算法的结果。Diff算法是一种对比算法，对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。

#### 三、为什么要使用虚拟DOM ####

- 当然是前端优化方面，避免频繁操作DOM，频繁操作DOM会可能让浏览器回流和重绘，性能也会非常低，还有就是手动操作 DOM 还是比较麻烦的，要考虑浏览器兼容性问题，当前jQuery等库简化了 DOM操作，但是项目复杂了，DOM操作还是会变得复杂，数据操作也变得复杂
- 并不是所有情况使用虚拟DOM 都提高性能，是针对在复杂的的项目使用。如果简单的操作，使用虚拟DOM,要创建虚拟DOM对象等等一系列操作，还不如普通的DOM 操作
- 虚拟DOM 可以实现跨平台渲染，服务器渲染 、小程序、原生应用都使用了虚拟DOM
- 使用虚拟DOM改变了当前的状态不需要立即的去更新DOM 而且更新的内容进行更新，对于没有改变的内容不做任何操作，通过前后两次差异进行比较
- 虚拟 DOM 可以维护程序的状态，跟踪上一次的状态

#### 四、diff算法原理 ####

1. Diff同层对比

-  传统的计算两颗树的差异时间复杂度为O(n^3),显然成本比较高（老树的每一个节点都去遍历新树的节点，直到找到新树对应的节点。那么这个流程就是 O(n^2)，再紧接着找到不同之后，再计算最短修改距离然后修改节点，这里是 O(n^3)。）

- 新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:深度优先算法。 时间复杂度:O(n)

![](./images/diff3.jpg)

2. diff的对比流程

- 当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图
- newVnode和oldVnode：同层的新旧虚拟节点

![](./images/diff4.jpg)

- （1）patch方法

    - patch函数是diff流程的入口函数，这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签(同一类型的标准，下面会讲)：

      - 是：继续执行patchVnode方法进行深层比对
      - 否：没必要比对了，直接整个节点替换成新虚拟节点

    - 来看看patch的核心原理代码

		       function patch(oldVnode, newVnode) {
		
				  // 比较是否为一个类型的节点
				  if (sameVnode(oldVnode, newVnode)) {
		
				    // 是：继续进行深层比较
				    patchVnode(oldVnode, newVnode)
		
				  } else {
				    // 否
		
				    const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点
		
				    const parentEle = api.parentNode(oldEl) // 获取父节点
		
				    createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点
		
				    if (parentEle !== null) {
		
				      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素
		
				      api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点
		
				      // 设置null，释放内存
				      oldVnode = null
				    }
				  }
				
				  return newVnode
				}

- （2）sameVnode方法

    - patch关键的一步就是sameVnode方法判断是否为同一类型节点，那问题来了，怎么才算是同一类型节点呢？这个类型的标准是什么呢？
    - 咱们来看看sameVnode方法的核心原理代码，就一目了然了

				function sameVnode(oldVnode, newVnode) {
		
				  return (
				    oldVnode.key === newVnode.key && // key值是否一样
				    oldVnode.tagName === newVnode.tagName && // 标签名是否一样
				    oldVnode.isComment === newVnode.isComment && // 是否都为注释节点
				    isDef(oldVnode.data) === isDef(newVnode.data) && // 是否都定义了data
				    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同
				  )
		       }

- （3）patchVnode方法

    - 这个函数做了以下事情：

         - 找到对应的真实DOM，称为el
         - 判断newVnode和oldVnode是否指向同一个对象，如果是，那么直接return
         - 如果他们都有文本节点并且不相等，那么将el的文本节点设置为newVnode的文本节点。
         - 如果oldVnode有子节点而newVnode没有，则删除el的子节点
         - 如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el
         - 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要

					function patchVnode(oldVnode, newVnode) {
		
		              // 获取真实DOM对象
					  const el = newVnode.el = oldVnode.el 
		
					  // 获取新旧虚拟节点的子节点数组
					  const oldCh = oldVnode.children, newCh = newVnode.children
		
					  // 如果新旧虚拟节点是同一个对象，则终止
					  if (oldVnode === newVnode) return
		
					  // 如果新旧虚拟节点是文本节点，且文本不一样
					  if (oldVnode.text !== null && newVnode.text !== null && oldVnode.text !== newVnode.text) {
		
					    // 则直接将真实DOM中文本更新为新虚拟节点的文本
					    api.setTextContent(el, newVnode.text)
		
					  } else {
					    // 否则
					
					    if (oldCh && newCh && oldCh !== newCh) {
					      // 新旧虚拟节点都有子节点，且子节点不一样
					
					      // 对比子节点，并更新
					      updateChildren(el, oldCh, newCh)
		
					    } else if (newCh) {
					      // 新虚拟节点有子节点，旧虚拟节点没有
					
					      // 创建新虚拟节点的子节点，并更新到真实DOM上去
					      createEle(newVnode)
		
					    } else if (oldCh) {
					      // 旧虚拟节点有子节点，新虚拟节点没有
					
					      //直接删除真实DOM里对应的子节点
					      api.removeChild(el)
					    }
					  }
					}


- （4）updateChildren方法

    - 这是patchVnode里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在updateChildren方法中，是怎么样一个对比方法呢？就是首尾指针法，新的子节点集合和旧的子节点集合，各有首尾两个指针，举个例子：

				<ul>
				    <li>a</li>
				    <li>b</li>
				    <li>c</li>
				</ul>
				
				修改数据后
				
				<ul>
				    <li>b</li>
				    <li>c</li>
				    <li>e</li>
				    <li>a</li>
				</ul>

     - 那么新旧两个子节点集合以及其首尾指针为：
     
   ![](./images/diff5.jpg)

     - 然后会进行互相进行比较，总共有五种比较情况：

        - oldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - oldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - oldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - oldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - 如果以上逻辑都匹配不到
        
            - 分为两种情况

               - 如果新旧节点都有key，那么会根据oldChild的key生成一张hash表（旧子节点的 key 做一个映射到旧节点下标的 key -> index 表），用newStartVnode的key与hash表做匹配，匹配成功，就通过sameVnode()比对

                   - 比对成功：在真实dom中将成功的节点移到newStartVnode对应的位置
                   - 比对失败：(虽然他们具有相同的key,但不是同一个元素)，当新元素对待，直接创建
                
                   https://juejin.cn/post/6990582632270528525#heading-13
                   
		                  // 当四种策略都没有命中
					      // keyMap 为缓存，这样就不用每次都遍历老对象
					      if (!keyMap) {
					        // 初始化 keyMap
					        keyMap = {}
					        // 从oldStartIdx到oldEndIdx进行遍历
					        for (let i = oldStartIdx; i < oldEndIdx; i++) {
					          // 拿个每个子对象 的 key
					          const key = oldCh[i].data.key
					          // 如果 key 不为 undefined 添加到缓存中
					          if (!key) keyMap[key] = i
					        }
					      }


                - 如果没有key,则认为newStartVnode是一个新元素，则直接将newStartVnode生成新的节点插入真实DOM（ps：这下可以解释为什么v-for的时候需要设置key了，如果没有key那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了）

           - 执行过程是一个循环,在每次循环里,只要执行了上述的情况的五种之一就会结束一次循环
           
    - 接下来就以上面代码为例，分析一下比较的过程

       - 分析之前，请大家记住一点，最终的渲染结果都要以newVDOM为准，这也解释了为什么之后的节点移动需要移动到newVDOM所对应的位置

   ![](./images/diff6.jpg)

          - 第一步

			oldS = a, oldE = c
			newS = b, newE = a

            - 比较结果：oldS 和 newE 相等，需要把节点a移动到newE所对应的位置，也就是末尾，同时oldS++，newE--

   ![](./images/diff7.jpg)

         - 第二步

           oldS = b, oldE = c
		   newS = b, newE = e

           - 比较结果：oldS 和 newS相等，需要把节点b移动到newS所对应的位置，同时oldS++,newS++

   ![](./images/diff8.jpg)

        - 第三步

		  oldS = c, oldE = c
		  newS = c, newE = e

          - 比较结果：oldS、oldE 和 newS相等，需要把节点c移动到newS所对应的位置，同时oldS++,newS++

   ![](./image/diff9.jpg)

        - 第四步

          oldS > oldE

          - 则oldCh先遍历完成了，而newCh还没遍历完，说明newCh比oldCh多，所以需要将多出来的节点，插入到真实DOM上对应的位置上

   ![](./images/diff10.jpg)


        - updateChildren的核心原理代码

			function updateChildren(parentElm, oldCh, newCh) {
			  let oldStartIdx = 0, newStartIdx = 0
			  let oldEndIdx = oldCh.length - 1
			  let oldStartVnode = oldCh[0]
			  let oldEndVnode = oldCh[oldEndIdx]
			  let newEndIdx = newCh.length - 1
			  let newStartVnode = newCh[0]
			  let newEndVnode = newCh[newEndIdx]
			  let oldKeyToIdx
			  let idxInOld
			  let elmToMove
			  let before
			  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
			    if (oldStartVnode == null) {
			      oldStartVnode = oldCh[++oldStartIdx]
			    } else if (oldEndVnode == null) {
			      oldEndVnode = oldCh[--oldEndIdx]
			    } else if (newStartVnode == null) {
			      newStartVnode = newCh[++newStartIdx]
			    } else if (newEndVnode == null) {
			      newEndVnode = newCh[--newEndIdx]
			    } else if (sameVnode(oldStartVnode, newStartVnode)) {
			      patchVnode(oldStartVnode, newStartVnode)
			      oldStartVnode = oldCh[++oldStartIdx]
			      newStartVnode = newCh[++newStartIdx]
			    } else if (sameVnode(oldEndVnode, newEndVnode)) {
			      patchVnode(oldEndVnode, newEndVnode)
			      oldEndVnode = oldCh[--oldEndIdx]
			      newEndVnode = newCh[--newEndIdx]
			    } else if (sameVnode(oldStartVnode, newEndVnode)) {
			      patchVnode(oldStartVnode, newEndVnode)
			      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))
			      oldStartVnode = oldCh[++oldStartIdx]
			      newEndVnode = newCh[--newEndIdx]

			    } else if (sameVnode(oldEndVnode, newStartVnode)) {

			      patchVnode(oldEndVnode, newStartVnode)
			      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
			      oldEndVnode = oldCh[--oldEndIdx]
			      newStartVnode = newCh[++newStartIdx]

			    } else {
			      // 使用key时的比较
			      if (oldKeyToIdx === undefined) {
			        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表
			      }
			      idxInOld = oldKeyToIdx[newStartVnode.key]
			      if (!idxInOld) {
			        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
			        newStartVnode = newCh[++newStartIdx]
			      }
			      else {
			        elmToMove = oldCh[idxInOld]
			        if (elmToMove.sel !== newStartVnode.sel) {
			          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
			        } else {
			          patchVnode(elmToMove, newStartVnode)
			          oldCh[idxInOld] = null
			          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)
			        }
			        newStartVnode = newCh[++newStartIdx]
			      }
			    }
			  }
			  if (oldStartIdx > oldEndIdx) {
			    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el
			    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
			  } else if (newStartIdx > newEndIdx) {
			    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
			  }
			}



#### 五、key的作用 ####

1. key的作用主要是为了高效的更新虚拟dom，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少dom操作量，提高性能。

![](./images/diff13.jpg)

- 上图中，没有key值时，在a、b、c的c前面加了一个z，新旧节点的a进行sameVnode（key都为undefined相同）返回true，然后进行pathVnode，新旧虚拟节点是同一个对象，直接return。b同a一样判断。重点看下c和z进行sameVnode（key都为undefined相同，标签什么都相同）返回true，然后进行pathVnode，只有text不相同，所以只是将真实DOM的text的c改为z。然后，新建一个节点c插入。

- 上图中，有key值时，每个节点都有自己的key值，则c和z进行sameVnode返回false，则新节点c又继续和旧节点c比较返回true，最后只需要新建一个z节点插入。

- 当没有key的时候，会认为永远是相同的节点，会一直走patchVnode。上面两种情况，dom操作次数不同。前面的遍历a,b过程dom一样，没有操作，但是从c开始后面两次是进行了DOM的操作的，一次dom更新和一次创建插入。


2. 为什么不建议使用index做key值 

- 平常v-for循环渲染的时候，为什么不建议用index作为循环项的key呢？我们举个例子，左边是初始数据，然后我在数据前插入一个新数据，变成右边的列表：

		<ul>                      <ul>
		    <li key="0">a</li>        <li key="0">林三心</li>
		    <li key="1">b</li>        <li key="1">a</li>
		    <li key="2">c</li>        <li key="2">b</li>
		                              <li key="3">c</li>
		</ul>                     </ul>


- 理说，最理想的结果是：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。但是我们这里用了index来当key的话，真的会实现我们的理想结果吗？可是实践发现，添加这一个li，所有li标签都更新了，为什么会这样呢？还是通过图来解释

- 按理说，a，b，c三个li标签都是复用之前的，因为他们三个根本没改变，改变的只是前面新增了一个林三心

![](./images/diff11.jpg)

- 但是我们前面说了，在进行子节点的 diff算法 过程中，会进行 旧首节点和新首节点的sameNode对比，这一步命中了逻辑，因为现在新旧两次首部节点 的 key 都是 0了，同理，key为1和2的也是命中了逻辑，导致相同key的节点会去进行patchVnode更新文本，而原本就有的c节点，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行patchVnode更新文本，最后一个进行了新增，那就解释了为什么所有li标签都更新了。

- 那我们可以怎么解决呢？其实我们只要使用一个独一无二的值来当做key就行了

		<ul>
		   <li v-for="item in list" :key="item.id">{{ item.title }}</li>
		</ul>

- 为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，a，b，c节点的key就会是永远不变的，更新前后key都是一样的，并且又由于a，b，c节点的内容本来就没变，所以就算是进行了patchVnode，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。

![](./images/diff12.jpg)

<h3 id='五、vue的nextTick' >五、vue的nextTick</h3>

#### 一、vue异步更新DOM策略 ####

- 为什么vue更新dom采用的是异步更新呢？

	   例：<template>
		  <div>
		    <div>{{test}}</div>
		  </div>
		</template>

		export default {
		    data () {
		        return {
		            test: 0
		        };
		    },
		    mounted () {
		      for(let i = 0; i < 1000; i++) {
		        this.test++;
		      }
		    }
		}
		
- 上面的例子中，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter->Dep->Watcher->update->patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。


#### 二、watcher队列 ####

- 我们看下Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。

		update () {
		    /* istanbul ignore else */
		    if (this.lazy) {
		        this.dirty = true
		    } else if (this.sync) {
		        /*同步则执行run直接渲染视图*/
		        this.run()
		    } else {
		        /*异步推送到观察者队列中，下一个tick时调用。*/
		        queueWatcher(this)
		    }
		}

- Vue.js默认是使用异步执行DOM更新。 当异步执行update的时候，会调用queueWatcher函数。

		 /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/
		export function queueWatcher (watcher: Watcher) {
		  /*获取watcher的id*/
		  const id = watcher.id
		  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/
		  if (has[id] == null) {
		    has[id] = true
		    if (!flushing) {
		      /*如果没有flush掉，直接push到队列中即可*/
		      queue.push(watcher)
		    } else {

		      let i = queue.length - 1
		      while (i >= 0 && queue[i].id > watcher.id) {
		        i--
		      }

              //找到该watcher的位置，将新的watcher替换进去
		      queue.splice(Math.max(i, index) + 1, 0, watcher)
		    }

		    // queue the flush
		    if (!waiting) {
		      waiting = true
		      nextTick(flushSchedulerQueue)
		    }
		  }
		}

- 从queueWatcher代码中看出Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等到下一个tick运行时将这个队列queue全部拿出来run一遍，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去。这也解释了同一个watcher被多次触发，只会被推入到队列中一次。

#### 三、nextTick ####

nextTick的实现比较简单，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。执行的目的是在microtask或者task中推入一个function，在当前栈执行完毕（也许还会有一些排在前面的需要执行的任务）以后执行nextTick传入的function，看一下源码：'


 
    - 延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个queueNextTick函数，该函数接受回调函数和执行回调函数的上下文环境
    - 在立即执行nextTick函数的时候，会定义一个timerFunc函数，这个函数是表示了用那个方式（Promise、MutationObserver、setTimeout）执行nextTick队列的回调函数
    - 在当前调用栈执行完以后，执行timerFunc
    
			export const nextTick = (function () {
			  /*存放异步执行的回调*/
			  const callbacks = []
			  /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/
			  let pending = false
			  /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/
			  let timerFunc
			
			  /*下一个tick时的回调*/
			  function nextTickHandler () {
			    /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/
			    pending = false
			    /*执行所有callback*/
			    const copies = callbacks.slice(0)
			    callbacks.length = 0
			    for (let i = 0; i < copies.length; i++) {
			      copies[i]()
			    }
			  }
			
			  
			  /*
			    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法
			    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
			    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
			    参考：https://www.zhihu.com/question/55364497
			  */
			  if (typeof Promise !== 'undefined' && isNative(Promise)) {

			    /*使用Promise*/
			    var p = Promise.resolve()
			    var logError = err => { console.error(err) }
			    timerFunc = () => {
			      p.then(nextTickHandler).catch(logError)
			      if (isIOS) setTimeout(noop)
			    }

                 /*使用MutationObserver*/
			  } else if (typeof MutationObserver !== 'undefined' && (
			    isNative(MutationObserver) ||
			    // PhantomJS and iOS 7.x
			    MutationObserver.toString() === '[object MutationObserverConstructor]'
			  )) {
			    
			    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/
			    var counter = 1
			    var observer = new MutationObserver(nextTickHandler)
			    var textNode = document.createTextNode(String(counter))
			    observer.observe(textNode, {
			      characterData: true
			    })
			    timerFunc = () => {
			      counter = (counter + 1) % 2
			      textNode.data = String(counter)
			    }

               /*使用setTimeout*/
			  } else

			    /*使用setTimeout将回调推入任务队列尾部*/
			    timerFunc = () => {
			      setTimeout(nextTickHandler, 0)
			    }
			  }
			
			  /*
			    推送到队列中下一个tick时执行
			    cb 回调函数
			    ctx 上下文
			  */
			  return function queueNextTick (cb?: Function, ctx?: Object) {
			    let _resolve
			    /*cb存到callbacks中*/
			    callbacks.push(() => {
			      if (cb) {
			        try {
			          cb.call(ctx)
			        } catch (e) {
			          handleError(e, ctx, 'nextTick')
			        }
			      } else if (_resolve) {
			        _resolve(ctx)
			      }
			    })
			    if (!pending) {
			      pending = true
			      timerFunc()
			    }
			    if (!cb && typeof Promise !== 'undefined') {
			      return new Promise((resolve, reject) => {
			        _resolve = resolve
			      })
			    }
			  }
			})()


- 从上面的介绍，可以得知timeFunc()一共有三种实现方式。

  - Promise
  - MutationObserver
  - setTimeout

- 系统中会优先用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
- 在主线程上，如果再遇到macrotask，就把它放到macrotask任务队列末尾，由于一次event loop只能取一个macrotask，所以遇到的宏任务就需要等待其它轮次的事件循环了；如果遇到microtask，则放到本次循环的microtask队列中去。这样就能明白为什么microtask会比macrotask先处理了。这也是nextTick总是要比setTimeout先要执行。

- 下面着重介绍一下MutationObserver。
	
	- MutationObserver是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。
	- 调用过程很简单，但是有点不太寻常：你需要先给他绑回调：
	
    		var mo = new MutationObserver(callback)
	
    - 通过给MutationObserver的构造函数传入一个回调，能得到一个MutationObserver实例，这个回调就会在MutationObserver实例监听到变动时触发。
	- 这个时候你只是给MutationObserver实例绑定好了回调，他具体监听哪个DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的observer方法就可以完成这一步:
		
	        var domTarget = 你想要监听的dom节点
			mo.observe(domTarget, {
			      characterData: true //说明监听文本内容的修改。
			})

#### 四、总结 ####

1. nextTick是Vue提供的一个全局API由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法
2. Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发
生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。
3. 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。
4. 比如，我在干什么的时候就会使用nextTick传一个回调函数进去，在里面执行dom操作即可。
5. 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。

<h3 id='六、vue2.0为什么不能检查数组的变化'>六、vue2.0为什么不能检查数组的变化</h3>

https://www.jb51.net/article/171869.htm
https://juejin.cn/post/6844903614096343047
#### 一、前言 ####

- Vue2.0对于响应式数据的实现有一些不足：

   - 无法检测数组/对象的新增
   - 无法检测通过索引改变数组的操作。
   - 修改数组长度

- 无法检测数组/对象的新增，原因很简单，对象的属性只有先用Object.defineProperty 方法添加属性描述符的 get 和 set 属性才能被监听，新添加的属性肯定没先用 Object.defineProperty 方法，故无法被监听。删除的属性，其 set 属性监听不到，故无法监听。


#### 二、无法检测数组的索引变化？ ####

- 我们来测试一下看看。以下例子，对遍历数组中的每一项，用Object.defineProperty对其进行监测

			function defineReactive(data, key, value) {
				 Object.defineProperty(data, key, {
					 enumerable: true,
					 configurable: true,
					 get: function defineGet() {
						 console.log(`get key: ${key} value: ${value}`)
						 return value
					 },
					 set: function defineSet(newVal) {
						 console.log(`set key: ${key} value: ${newVal}`)
						 value = newVal
					 }
				 })
			}
			 
			function observe(data) {
				Object.keys(data).forEach(function(key) {
					defineReactive(data, key, data[key])
				})
			}
			 
			let arr = [1, 2, 3]
			observe(arr)

- 通过索引改变arr[1]，可以发现触发了set，也就是Object.defineProperty是可以检测到通过索引改变数组的操作的，那Vue2.0为什么没有实现呢？

  - 原来是出于对性能原因的考虑，没有去实现它。而不是不能实现。对于对象而言，每一次的数据变更都会对对象的属性进行一次枚举，一般对象本身的属性数量有限，所以对于遍历枚举等方式产生的性能损耗可以忽略不计，但是对于数组而言呢？数组包含的元素量是可能达到成千上万，假设对于每一次数组元素的更新都触发了枚举/遍历，其带来的性能损耗将与获得的用户体验不成正比，故vue无法检测数组的变动。
不过Vue3.0用proxy代替了defineProperty之后就解决了这个问题。

#### 三、解决方案 ####

1. 数组

	- this.$set(array, index, data)
      - 这是个深度的修改，某些情况下可能导致你不希望的结果，因此最好还是慎用
      
			this.dataArr = this.originArr
			this.$set(this.dataArr, 0, {data: '修改第一个元素'})
			console.log(this.dataArr)        
			console.log(this.originArr)  //同样的 源数组也会被修改 在某些情况下会导致你不希望的结果 



    - splice
      - Vue对数组的7个变异方法（push、pop、shift、unshift、splice、sort、reverse）实现了响应式
      - 所以splice会被监听有响应式，而splice又可以做到增删改。
      - this.items.splice(newLength) 可解决修改数组长度（减小数组长度）

        

   - 利用临时变量进行中转
			
			let tempArr = [...this.targetArr]
			tempArr[0] = {data: 'test'}
			this.targetArr = tempArr

2. 对象

   - this.$set(obj, key ,value) - 可实现增、改
   
   - 对于对象的属性的删除可以用 this.$delete(obj,key) 来解决，this.$delete 是个实例方法，该方法是全局方法 Vue.delete 的一个别名。

   - watch时添加deep：true深度监听，只能监听到属性值的变化，新增、删除属性无法监听

			this.$watch('blog', this.getCatalog, {
			    deep: true
			    // immediate: true // 是否第一次触发
			  });


   - watch时直接监听某个key

			watch: {
			  'obj.name'(curVal, oldVal) {
			    // TODO
			  }
			}



#### 四、vue对数组的observe做了哪些处理？####
- https://juejin.cn/post/6883365724228681742#heading-6

        var Observer = function Observer(value) {
		    this.value = value;
		    this.dep = new Dep();
		    this.vmCount = 0;
		    def(value, '__ob__', this);
		    if (Array.isArray(value)) {
		        if (hasProto) {
		            protoAugment(value, arrayMethods);
		        } else {
		            copyAugment(value, arrayMethods, arrayKeys);
		        }
		        this.observeArray(value);
		    } else {
		        this.walk(value);
		    }
		}

- 执行 this.value = value ，把要监听的数据 value 赋值到 Observer 类的实例对象上。
- 执行 this.dep = new Dep() ，创建一个订阅者收集器，并把赋值到 Observer 类的实例对象上。
- 执行 this.vmCount = 0 ，把 vmCount 赋值到 Observer 类的实例对象上。
- 这样 Observer 类的实例对象就有三个实例属性：value、dep、vmCount。
- 执行 def(value, '__ob__', this) ，把自身的实例对象添加到数据 value 的 __ob__ 属性上，使value 的 __ob__ 属性上保存 Observer 类的一些实例对象和实例方法，在后续逻辑中会经常用到。另外一个对象上若有 __ob__ 属性，则代表这个对象已经被监听过。
- def 方法是对 Object.defineProperty 方法的封装。这就是用 console.log 打印 data 的数据时会发现多了一个 __ob__ 属性的原因。

		function def(obj, key, val, enumerable) {
		    Object.defineProperty(obj, key, {
		        value: val,
		        enumerable: !!enumerable,
		        writable: true,
		        configurable: true
		    });
		}

- 执行 if (Array.isArray(value)) 判断 value 是否是数组类型，若不是执行 this.walk(value) ，若是执行以下代码。

		if (hasProto) {
		    protoAugment(value, arrayMethods);
		} else {
		    copyAugment(value, arrayMethods, arrayKeys);
		}
		this.observeArray(value);


- 可见在 Vue 中对数组类型的数据和对象类型的数据监听的处理方式是不同的，下面分别来介绍各自的处理方式。

#### 四、监听对象类型的数据 ####

- 在 Observer 构造函数中，对于对象类型的数据，执行 this.walk(value) 来监听。来看一下 this.walk 实例方法。

		Observer.prototype.walk = function walk(obj) {
		    var keys = Object.keys(obj);
		    for (var i = 0; i < keys.length; i++) {
		        defineReactive(obj, keys[i]);
		    }
		};


- 监听对象类型的数据 value 过程，是先把 value 作为参数传入 observe(value) 函数，在其中执行 new Observer(value) ，然后在 Observer 构造函数中，调用 this.walk 实例方法，在 this.walk 方法中用 Object.keys() 获取 value 的键集合 keys ，然后遍历 keys 在其中执行 defineReactive(value, keys[i]) ，在 defineReactive 函数中在 value 自身的属性描述符上定义 get 和 set 属性用来监听，再通过 value[keys[i]] 获取 value 每个子属性 val ，如果 val 是对象或数组就会执行 observe(val) 来监听子属性 val，重复开始的流程，这样形成了一个递归调用，这样数据 value不管本身还是它的所有子属性都会被监听到。

#### 五、监听数组类型的数据 ####

- 在 Observer 构造函数中，对于数组类型的数据，执行以下逻辑来监听。

		if (hasProto) {
		    protoAugment(value, arrayMethods);
		} else {
		    copyAugment(value, arrayMethods, arrayKeys);
		}
		this.observeArray(value);

- 先不管上面的 if 逻辑，来看一下 this.observeArray 实例方法。

		Observer.prototype.observeArray = function observeArray (items) {
		    for (var i = 0, l = items.length; i < l; i++) {
		        observe(items[i]);
		    }
		}

- 试想一下，为什么在遍历中不直接调用 defineReactive 函数来把数据变成响应式对象来监听，而是调用 observe 函数。这是因为数组的元素可以是对象、数组等，在 Vue 中对数组类型和对象类型的数据监听流程是不同的，在 defineReactive 函数是直接把对象类型的数据变成响应式对象来监听，只有在 observe 函数中才有做区分。

- 执行 if (hasProto)，其中 hasProto 是这么定义的 var hasProto = '__proto__' in {}，变量 in 对象，判断变量是否是对象的属性。

- 来看一下 protoAugment 函数和 copyAugment 函数。

		function protoAugment(target, src) {
		    target.__proto__ = src;
		}
		function copyAugment(target, src, keys) {
		    for (var i = 0, l = keys.length; i < l; i++) {
		        var key = keys[i];
		        def(target, key, src[key]);
		    }
		}

- 在 protoAugment 函数中把参数 src 赋值到参数 target 的 __proto__。对象的 __proto__ 属性的值就是它所对应的原型对象，在JS中，数组也是一个对象。那么 protoAugment 函数的作用就是把参数 target 的原型对象改成参数 src。
- 但 __proto__ 这个属性在一些版本的浏览器不支持，比如IE9，故要用 '__proto__' in {} 做一下兼容判断。
- 若是浏览器不支持 __proto__ 这个属性，则调用 copyAugment 函数，在其中通过 def方法，把参数 target 的原型对象中的值更改，def 方法已经在上面介绍过。
- 执行protoAugment(value, arrayMethods)，其中 value 是一个数组，要把 value 的原型对象修改成 arrayMethods，那为什么要数组的原型对象修改成 arrayMethods，先来看一下 arrayMethods 是如何定义的。

			var arrayProto = Array.prototype;
			var arrayMethods = Object.create(arrayProto);
			var methodsToPatch = [
			    'push',
			    'pop',
			    'shift',
			    'unshift',
			    'splice',
			    'sort',
			    'reverse'
			];
			methodsToPatch.forEach(function(method) {
			    var original = arrayProto[method];
			    def(arrayMethods, method, function mutator() {
			        var args = [],
			            len = arguments.length;
			        while (len--) args[len] = arguments[len];
			        var result = original.apply(this, args);
			        var ob = this.__ob__;
			        var inserted;
			        switch (method) {

                        //对于push，unshift会新增索引，所以需要手动observe
			            case 'push':
			            case 'unshift':
			                inserted = args;
			                break
                        //splice方法，如果传入了第三个参数，也会有新增索引，所以也需要手动observe
			            case 'splice':
			                inserted = args.slice(2);
			                break
			        }
                    
                    // push，unshift，splice三个方法触发后，在这里手动observe，其他方法的变更会在当前的索引上进行更新，所以不需要再执行ob.observeArray
			        if (inserted) {
			            ob.observeArray(inserted);
			        }
			        ob.dep.notify();
			        return result
			    });
			});
			var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

- 执行 var arrayProto = Array.prototype 获取数组的原型对象并赋值给 arrayProto 。
- 执行 var arrayMethods = Object.create(arrayProto) 创建一个新对象 arrayMethods ，其拥有数组的原型对象。
- 变量 methodsToPatch 中定义了一些常见的数组实例方法，遍历 methodsToPatch 在其中调用 def 函数修改 arrayMethods 上和 methodsToPatch 中同名的实例方法，这叫作函数劫持。
- 执行 var original = arrayProto[method] 把数组的原实例方法缓存到常量 original，然后调用 def 函数，在 def 函数的第三个参数传入重新定义的数组实例方法。
- 在重新定义的数组实例方法中，执行

		var args = [],len = arguments.length;
		while (len--) args[len] = arguments[len];

- 定义一个变量 args，然后把调用数组实例方法时的参数赋值给变量 args，然后执行 var result = original.apply(this, args)，把参数传入 original 该数组原先的实例方法执行，并把执行结果赋值给常量 result 。
- 执行 var ob = this.__ob__，获取属于要被监听数组的 Observer 类实例化的对象赋值给常量 ob。
- 通过 push 或 unshift 会增加索引，对于新增加的属性，需要再手动初始化才能被 observe ，splice方法，如果传入了第三个参数，也会有新增索引，所以也需要手动observe
- 执行 var ob = this.__ob__，获取属于要被监听数组的 Observer 类实例化的对象赋值给常量 ob。


#### 六、vue的 set 方法实现 ####

- Vue.set 是在 initGlobalAPI 函数中定义。initGlobalAPI 函数在定义构造函数 Vue 后马上执行。

		function initGlobalAPI(Vue) {
		    Vue.set = set;
		}
		initGlobalAPI(Vue);

- 其中 Vue.set 是 set 函数赋值的，来看一下 set 函数。

		function set (target: Array<any> | Object, key: any, val: any): any {
		 // 如果target是数组，且key是有效的数组索引，会调用数组的splice方法，
		 // 我们上面说过，数组的splice方法会被重写，重写的方法中会手动Observe
		 // 所以vue的set方法，对于数组，就是直接调用重写splice方法
		 if (Array.isArray(target) && isValidArrayIndex(key)) {
		 target.length = Math.max(target.length, key)
		 target.splice(key, 1, val)
		 return val
		 }
		 // 对于对象，如果key本来就是对象中的属性，直接修改值就可以触发更新
		 if (key in target && !(key in Object.prototype)) {
		 target[key] = val
		 return val
		 }
		 // vue的响应式对象中都会添加了__ob__属性，所以可以根据是否有__ob__属性判断是否为响应式对象
		 const ob = (target: any).__ob__

	    if (target._isVue || (ob && ob.vmCount)) {
	        warn(
	            'Avoid adding reactive properties to a Vue instance or its root $data ' +
	            'at runtime - declare it upfront in the data option.'
	        );
	        return val
	    }

		 // 如果不是响应式对象，直接赋值
		 if (!ob) {
		 target[key] = val
		 return val
		 }
		 // 调用defineReactive给数据添加了 getter 和 setter，
		 // 所以vue的set方法，对于响应式的对象，就会调用defineReactive重新定义响应式对象，defineReactive 函数
		 defineReactive(ob.value, key, val)
		 ob.dep.notify()
		 return val
		}

- 执行 if (isUndef(target) || isPrimitive(target)) 判断参数 target 是否为 undefined、null、字符串、布尔值、数字。若是在控制台打出警告，无法对未定义、null或基础类型数据设置属性，其中 isPrimitive 方法代码如下。

		function isPrimitive(value) {
		    return (
		        typeof value === 'string' ||
		        typeof value === 'number' ||
		        typeof value === 'symbol' ||
		        typeof value === 'boolean'
		    )
		}

- 执行 if (Array.isArray(target) && isValidArrayIndex(key)) 判断参数 target 是否为数组，若是则参数 key 应该为数组下标，用 来判断参数 key 是不是正确的数组下标，
		
		function isValidArrayIndex(val) {
		    var n = parseFloat(String(val));
		    return n >= 0 && Math.floor(n) === n && isFinite(val)
		}

- 数组下标应该是个大于零的整数，且不是无穷大。在 isValidArrayIndex 函数先用 parseFloat 把参数 val，因为 parseFloat 的接收的参数是字符串格式，所以用 String 处理一下参数 val。这里很巧妙利用 Math.floor(n) === n 来判断参数 val 是不是整数，最后用 isFinite 判断参数 val 是不是无穷大。
- 若参数 key 是个正确的数组下标，执行以下逻辑

		target.length = Math.max(target.length, key);
		target.splice(key, 1, val);

- 此时 target 是个数组，这里巧妙的应用 splice 这个数组实例方法，实现通过数组下标来添加一个数组项的功能，同时 splice 这个数组实例方法在 Vue 中被劫持过，故会被监听到。
那为什么还要重新设置一下 target 的长度。是因为 splice 方法有个缺陷，下面用一个例子说明。

		let a = [1,2]
		a[3]=3;
		console.log(a) //[1, 2, empty, 3] 
		let b = [1,2]
		b.splice(3,1,3) //[1, 2, 3]
		console.log(b)

- 说明 splice 实例方法中的参数 key 只要超过数组的长度，那么只会在数组尾部添加上所要的数组元素。为了避免这个缺陷，执行 target.length = Math.max(target.length, key) ，当 key 比target.length 大，就把 key 赋值给 target.length 先扩充一下数组的长度，保证通过 splice 添加数组元素和通过数组下标添加数组元素的结果是一致的。

- 执行 if (key in target && !(key in Object.prototype))，判断参数 key 是否是参数 target 的属性，且不是其原型对象的属性。若是，则 target[key] 已被监听，直接把参数 val 赋值给 target[key] 即可。
- 执行if (target._isVue || (ob && ob.vmCount)) ，用 target._isVue 来判断参数 target 是否为 Vue 实例对象.
- 用 ob && ob.vmCount 来判断参数 target 是否为根数据对象（即 data 选项返回的对象），其中 ob 为参数 target.__ob__，__ob__ 为 Observer 类的实例化对象，在 Observer 构造函数中 只有
- data 为根数据，才会给 vmCount 实例对象赋值。若是在控制台打出警告注意参数 target 不能是 Vue 实例，或者 Vue 实例的根数据对象。
- 执行 if (!ob) 判断参数 target 是否是被监听，如果不是，那么也必要去监听其子属性，执行target[key] = val 直接赋值即可。
- 如果是，执行 defineReactive(ob.value, key, val) 在新增属性的描述符属性上定义 get 和 set 属性来监听新增属性，其中 ob.value 是参数target变成的响应式对象，如果直接用参数 target ，会导致参数 target 本身及其子属性都无法被监听。
- 执行 ob.dep.notify() ，因为参数 target 新增属性了，那么本身也改变了，故触发其订阅者的更新。
- 最后返回新增的值 `val 。

#### 七、Vue.delete的内部逻辑 ####

- Vue.delete 是在 initGlobalAPI 函数中定义。initGlobalAPI 函数在定义构造函数 Vue 后马上执行。

		function initGlobalAPI(Vue) {
		    Vue.delete = del;
		}
		initGlobalAPI(Vue);

- 其中 Vue.delete 是 del 函数赋值的，来看一下 del 函数。

		function del(target, key) {
		    if (isUndef(target) || isPrimitive(target)) {
		        warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
		    }
		    if (Array.isArray(target) && isValidArrayIndex(key)) {
		        target.splice(key, 1);
		        return
		    }
		    var ob = (target).__ob__;
		    if (target._isVue || (ob && ob.vmCount)) {
		        warn(
		            'Avoid deleting properties on a Vue instance or its root $data ' +
		            '- just set it to null.'
		        );
		        return
		    }
		    if (!hasOwn(target, key)) {
		        return
		    }
		    delete target[key];
		    if (!ob) {
		        return
		    }
		    ob.dep.notify();
		}

- 里面部分逻辑和 set 函数是一模一样的，在上面已经介绍过了。来介绍一下不一样的逻辑。
- 当参数 target 为数组时，且参数 key 为正确的数组下标，执行 target.splice(key, 1) ，这里巧妙的应用 splice 这个数组实例方法，实现删除数组中某个元素的功能，同时 splice 这个数组实例方法在 Vue 中被劫持过，故会被监听到。
- 执行 if (!hasOwn(target, key)) ，判断参数 key 是否是参数 target 的属性，若不是，则直接 return 。
- 若不是，执行delete target[key]删除这个对象属性。
- 执行 var ob = (target).__ob__; if(!ob) 判断参数 target 是否被监听，若不是，则直接 return 。
- 若是，执行 ob.dep.notify() ，触发参数 target 本身的订阅者更新。

#### 八、监听数组类型数据的边界场景 ####

- 在上小节讲到只有用push 、pop 、 shift 、unshift 、 splice 、 sort 、 reverse 这些在 Vue 内部重新定义的数组实例方法，去操作数组才能被监听到。其实这些数组实例方法都会去变更原始数组，称为变更方法。那还有一些数组实例方法如 filter 、concat 和 slice ，这些方法不会去变更原始数组，会返回一个新数组，称为替换方法。filter 、concat 和 slice 这些替换方法来操作数组会被监听到。

<h3 id='七、computed原理'>七、computed原理</h3>

- https://juejin.cn/post/6897934019942744077
- https://juejin.cn/post/6974293549135167495#heading-22
- https://juejin.cn/post/6844903873925087239#heading-0
#### 一、vue构造函数 ####

		import { initMixin } from './init'
		import { stateMixin } from './state'
		import { renderMixin } from './render'
		import { eventsMixin } from './events'
		import { lifecycleMixin } from './lifecycle'
		
		function Vue(options) {
		  ...
		  this._init(options)
		}
		
		initMixin(Vue)       //定义_init方法。
		stateMixin(Vue)     //定义数据相关的方法$set,$delete,$watch方法。
		eventsMixin(Vue)    //定义事件相关的方法$on，$once，$off，$emit。
		lifecycleMixin(Vue) //定义_update，及生命周期相关的$forceUpdate和$destroy。
		renderMixin(Vue)    //定义$nextTick，_render将render函数转为vnode。


#### 二、computed 的初始化部分 ####

		export function initMixin(Vue) {
		  Vue.prototype._init = function(options) {
		    ...当执行new Vue时，进行一系列初始化并挂载
		  }
		}


- computed 的初始化发生在 Vue 实例化（源码：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Fblob%2Fv2.5.21%2Fsrc%2Fcore%2Finstance%2Finit.js）时执行的 initState 方法.

		// vue/src/core/instance/init.js
		...
		export function initMixin (Vue: Class<Component>) {
		  Vue.prototype._init = function (options?: Object) {

            const vm: Component = this
		    ...
		    initLifecycle(vm)
		    initEvents(vm)
		    initRender(vm)
		    callHook(vm, 'beforeCreate')
		    initInjections(vm)
		    initState(vm) // 初始化 state，包括 data/props/computed/methods/watch
		    initProvide(vm)
		    callHook(vm, 'created')
		    ...
		  }
		}
		...

- 接下来再看一下 initState（源码：https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Fblob%2Fv2.5.21%2Fsrc%2Fcore%2Finstance%2Fstate.js）做了什么：

		// vue/src/core/instance/state.js
		...
		export function initState (vm: Component) {
		  vm._watchers = []
		  const opts = vm.$options
		  if (opts.props) initProps(vm, opts.props)
		  if (opts.methods) initMethods(vm, opts.methods)
		  if (opts.data) {
		    initData(vm)
		  } else {
		    observe(vm._data = {}, true /* asRootData */)
		  }
		  if (opts.computed) initComputed(vm, opts.computed) // 初始化 computed，并传入 vm 实例和用户自定义 computed 对象
		  if (opts.watch && opts.watch !== nativeWatch) {
		    initWatch(vm, opts.watch)
		  }
		}
		...


- 从源码中可以看到，initState 里面执行了一些状态(data/props/methods/computed/watch)相关的初始化操作，然后我们找到 initComputed(源码位置同 initState)，再去看看 computed 的初始化都做了什么。

- 先看下computed的使用：

		<body>
		    <div id="app" style="color:red;background:green">{{fullName}}</div>
		    <script src="./dist/vue.js"></script>
		    <script>
		        const vm=new Vue({
		            el:'#app',
		            data:{
		                firstName:'zhang',
		                lastName:'san'
		            },
		            computed:{
                       //函数
		                fullName(){
		                    console.log('get')
		                    return this.firstName+this.lastName;
		                }
 
                        //对象

		                fullName:{
		                   get(){
		                        console.log('get')
		                       return this.firstName+this.lastName;
		                    },
		                   set(newVal){
		                      console.log('set',newVal)
		                   }
		                }
		            }
		        })
		        setTimeout(() => {
		            vm.firstName='li'
		        }, 2000);
		    </script>
		</body>

- Computed实现

		// vue/src/core/instance/state.js
		...
		const computedWatcherOptions = { lazy: true } // computedWatcher 的配置对象
		
		function initComputed (vm: Component, computed: Object) {
		 
          // 声明一个watchers且同时挂载到vm实例上
		  const watchers = vm._computedWatchers = Object.create(null)
		 
          // 在SSR模式下computed属性只能触发getter方法
		  const isSSR = isServerRendering()
		
          // 遍历computed
		  for (const key in computed) {
            // 取出computed对象中的每个方法并赋值给userDef
		    const userDef = computed[key]
		    const getter = typeof userDef === 'function' ? userDef : userDef.get
		    if (process.env.NODE_ENV !== 'production' && getter == null) {
		      warn(
		        `Getter is missing for computed property "${key}".`,
		        vm
		      )
		    }
		
            // 如果不是SSR服务端渲染，则创建一个watcher实例
		    if (!isSSR) {
		      // create internal watcher for the computed property.
		      watchers[key] = new Watcher(
		        vm,
		        getter || noop,
		        noop,
		        computedWatcherOptions
		      )
		    }
		
		    
		    if (!(key in vm)) {
               // 如果computed中的key没有设置到vm中，通过defineComputed函数挂载上去 
		      defineComputed(vm, key, userDef)
		    } else if (process.env.NODE_ENV !== 'production') {
               // 如果data和props有和computed中的key重名的，会产生warning
		      if (key in vm.$data) {
		        warn(`The computed property "${key}" is already defined in data.`, vm)
		      } else if (vm.$options.props && key in vm.$options.props) {
		        warn(`The computed property "${key}" is already defined as a prop.`, vm)
		      }
		    }
		  }
		}
		...


- Watcher

	
		import { pushTarget, popTarget } from './Dep'
		
		class Watcher {
		  constructor(vm, exprOrFn, cb, options) {
		    this.vm = vm
		    if (typeof exprOrFn === 'function') {
		      this.getter = exprOrFn
		    }
		    if (options) {
		      this.lazy = !!options.lazy // 为computed 设计的
		    } else {
		      this.lazy = false
		    }
		    this.dirty = this.lazy
		    this.options = options
		    this.id = wId++
		    this.deps = []
		    this.cb = cb
		    this.depsId = new Set() // dep 已经收集过相同的watcher 就不要重复收集了
		    this.value = this.lazy ? undefined : this.get()
		  }
		  get() {
		    const vm = this.vm
		    pushTarget(this)
		    // 执行函数
		    let value = this.getter.call(vm, vm)
		    popTarget()
		    return value
		  }
		  addDep(dep) {
		    let id = dep.id
		    if (!this.depsId.has(id)) {
		      this.depsId.add(id)
		      this.deps.push(dep)
		      dep.addSub(this);
		    }
		  }
		  update(){
		    if (this.lazy) {
		      this.dirty = true
		    } else {
		      this.get()
		    }
		  }
		  // 执行get，并且 this.dirty = false
		  evaluate() {
		    this.value = this.get()
		    this.dirty = false
		  }
		  // 所有的属性收集当前的watcer
		  depend() {
		    let i = this.deps.length
		    while(i--) {
		      this.deps[i].depend()
		    }
		  }
		}



- 从上面这句this.value = this.lazy ? undefined : this.get()代码可以看到，computed创建watcher的时候是不会指向this.get的。假设html模板中用到了computed中的值。在Vue实例init的最后，会调用vm.$mount方法，进而执行到mountComponent函数，mountComponent会生成一个渲染watcher实例。当render watcher执行时，会访问到计算属性的值，进而会触发计算属性的get。计算属性的get在defineComputed中已经定义过了，上面defineComputed(vm, key, userDef)这个函数功能就是让computed挂载到vm上面。下面我们实现一下。


		function defineComputed(vm, key, userDef) {
		  let getter = null
		  // 判断是函数还是对象
		  if (typeof userDef === 'function') {
		    getter = createComputedGetter(key)
		  } else {
		    getter = userDef.get
		  }
		  Object.defineProperty(vm, key, {
		    enumerable: true,
		    configurable: true,
		    get: getter,
		    set: function() {} // 又偷懒，先不考虑set情况哈，自己去看源码实现一番也是可以的
		  })
		}
		// 创建computed函数
		function createComputedGetter(key) {
		  return function computedGetter() {
		    const watcher = this._computedWatchers[key]
		    if (watcher) {
		      if (watcher.dirty) {// 给computed的属性添加订阅watchers
		        watcher.evaluate()
		      }
		      // 把渲染watcher 添加到属性的订阅里面去，这很关键
		      if (Dep.target) {
		        watcher.depend()
		      }
		      return watcher.value
		    }
		  }
		}

- 从 watcher 源码里看到，dirty 属性默认是 true，所以当计算属性第一次被访问时，先执行了一次 evaluate 方法，方法内会执行 get 方法，并将 get 方法得到的值保存到 value 属性中，最后修改 dirty 的值为 false。
- 到这里我们就说到计算属性的第一个特性了 - 缓存值。试想一下，如果没有其他的地方修改 dirty 属性的值，那么是不是就意味着，当一个计算属性被访问一次之后，再访问该计算属性时，它的 watcher.dirty 都是 false，也就意味着 evaluate 不再执行，也就不会去重新求值，那么在计算属性 getter 函数的最后返回的 watcher.value 也就是之前保存的结果。就这样一个缓存特性就实现了。

- 我们紧接着先看一下计算属性的值是怎么计算的。上 get 方法

       get() {
		    const vm = this.vm
		    pushTarget(this)
		    // 执行函数
		    let value = this.getter.call(vm, vm)
		    popTarget()
		    return value
		  }


// Dep.js(源码：https://github.com/vuejs/vue/blob/v2.5.21/src/core/observer/dep.js#L58)
		const targetStack = []
		
		export function pushTarget (target: ?Watcher) {
		  targetStack.push(target)
		  Dep.target = target
		}
		
		export function popTarget () {
		  targetStack.pop()
		  Dep.target = targetStack[targetStack.length - 1]
		}

- get 方法主要是用来求值的，当 get 方法执行的时候，先把当前的 watcher 压入到活动的 watcher 栈（源码位置）里，然后执行 watcher 实例创建时传入的 getter 方法，取得计算属性的结果。那么在执行 getter 方法时，会访问到计算属性中依赖的 data，触发 data 的依赖收集，将计算属性的 watcher 保存到自己的 dep.subs 里，计算属性的 watcher成为了该data属性的一个依赖，当该属性变化时就会通知该watcher属性。到这里计算属性依赖 data 的特性也就实现了。由下面代码可以看出来。

		defineReactive(obj,key,value) {
		  
		      // 如果是对象类型的 也调用walk 变成响应式，不是对象类型的直接在walk会被return
		      this.walk(value)
		      // 保存一下 this
		      let self = this
		     // 创建 Dep 对象
		      let dep = new Dep()
		      Object.defineProperty(obj,key,{
		        enumerable:true,
		        configurable:true,
		  
		        get:() => {
		          // 在这里添加观察者对象 Dep.target 表示观察者
		          if(Dep.target){
		            dep.addSub(Dep.target)
		          }
		          return value
		        },
		  
		        set:newVal => {
		           if(value === newVal){
		             return
		           }
		           
		           // 赋值的话如果是newValue是对象，对象里面的属性也应该设置为响应式的
		           self.walk(newVal)
		            // 触发通知 更新视图
		           dep.notify()
		        }
		      })
		    }
		  } 

- 当 getter 执行完之后，把当前的计算属性 watcher 弹出活动的 watcher 栈，同时通过修改 Dep.target 为当前栈里的第一个 watcher。当computed watcher的evaluate执行完后，Dep.target会变成render watcher
- 现在我们再回到上边计算属性的 getter 函数，，watcher.evaluate()执行完毕之后，就会判断Dep.target 是不是true，如果有就代表还有render watcher，就执行watcher.depend()

		  depend () {
		    let i = this.deps.length
		    while (i--) {
		      this.deps[i].depend()
		    }
		  }

- watcher.depend 方法其实很简单，遍历存储的 dep，分别执行每个 dep 的 depend 方法，源码（源码位置）如下：

			depend () {
			  if (Dep.target) {
			    Dep.target.addDep(this)
			  }
			}
 
- 这个Dep.target指的是render watcher，这段代码就是把刚才computed watcher添加的deps也添加到render watcher中去，使得vm[a]的dep和render watcher也能互相添加到彼此。这样，当vm[a]发生变化时，render watcher也会执行。
- 当watcher.depend执行完后，返回watcher.value。此时，computed watcher就完成了一次计算过程。

- 当vm[a]发生变化时，会触发其dep的set。进而触发dep.notify。此时，dep.subs中有两个watcher实例。一个是computed watcher，另一个是render watcher。首先执行computed watcher的update，然后执行render watcher的update。
      update () {
 
	  if (this.lazy) {
        // computed watcher会走到这里
	    this.dirty = true
	  } else if (this.sync) {
	    this.run()
	  } else {
        // render watcher会走到这里
	    queueWatcher(this)
	  }
	}

- computed watcher的update只是简单地把dirty置为了true，以便在下次访问到计算属性时，通过执行evaluate来计算最新的值。
- render watcher会被放入执行队列中。将当前主线程代码执行完毕后，在下一次事件循环中执行。
- 最终，随着render watcher.get的执行，计算属性会被重新获取，进而触发计算属性的getter，然后通过执行computed watcher的evaluate重新获取计算属性的最新值并返回。





























<h1 id='网络总结'><font color='darkgrey'>网络总结</font><h1>

<h3 id='一、http请求和响应'>一、http请求和响应</h3>

1.http请求报文

   - 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。

![](./images/http1.JPG)

 (1)请求行

  - 请求行由请求方法字段，URL字段和HTTP协议版本等3个字段组成，它们用空格分隔
    
     例如：GET /index.html HTTP/1.1

 (2)请求头部

  - 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息。
  - 请求头都有：

      - Accept：
      
			例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8

			表示客户端支持的数据格式，或者说客户端“希望”接受到的内容类型。这里只是希望，但是服务器具体返回什么样的内容类型，还是由服务器自己决定，但是无论服务器返回什么样的内容类型，客户端都会接收响应报文，不可能说因为内容类型不同，接收不到服务器响应报文，这不符合http协议规范。

			我们通过浏览器发起get或post请求，该字段都是浏览器自动添加的，同样在服务器端也不会解析该字段的值；
			通过ajax请求或其他手段，我们可以设置该字段的值，但是通常也不进行设置。
			
			该字段的应用场景可以是这样的，有两个终端，比如一个是纯文本阅读器，如Kinder（不能显示图片），另一个是移动终端（可以播放图片和视频），均向服务器请求有关“斑马”的信息，那么这时候服务器端就需要判断什么样的终端应该返回什么样的信息，那么它就可以根据Accept的信息来进行判断，如果解析到的Accept的值为“text/plain”，那么就表示客户端只支持文本类型；如果向上面例子中的那样，则表示客户端文本图片视频都可以。如果我们不加判断，当返回给文本阅读器一张图片时，可能它显示的就是乱码。

      - Accept-Encoding:
      
			例：Accept-Encoding:gzip, deflate, br
			
			表示客户端所支持的解码（解压缩）格式。网络数据的传输都是占据带宽的，而将文件数据压缩能够降低数据量，减少传输时间。所以服务器在返回数据给客户端时，常常对数据进行压缩（对用户透明，通常由服务器或代理来做），而压缩的方式有多种，到底采用哪一种则需要看客户端支持哪种解码方式，这时候就可以根据header中Accept-Encoding的值。
			
			文件或数据的压缩，由服务器或代理来做，一般不需要程序员干预；客户端接收到数据时解压缩，通常由浏览器自动完成，对用户透明。
			对于我们主动发起的ajax请求，一般数据量较少，不需要设置该字段。

     - Accept-Language:
     
			例：Accept-Language:zh-CN,zh;q=0.9
			
			表示客户端支持的语言格式（不是编码格式），如中文/英文，通常浏览器直接发起请求时，浏览器会根据被设置的语言环境（默认语言），来附加上该字段。
			
			一般我们服务器解析报文时，是不理会该字段的。
			
			他的使用场景可以是这样的，假如有个文件，有各种语言的版本，这样当不同请求发来时，我们可以根据Accept-Language的值来判断到底返回哪种语言版本给客户端。
			（其实这种应用场景也一般不采用判断Accept-Language字段的方法，不靠谱，还不如直接在url中体现语言版本呢）

    - Accept-Charset：
    
			例：Accept-Charset:gbk,utf-8;q=0.8
			
			表示客户端支持编码格式。服务器在返回报文时，需要将字符按照一定的编码格式转换为字节序列发送给客户端，那么该采用哪种编码格式呢？
			当然作为服务器端，他可以采用任何一种编码方式，客户端都得完完整整的接收响应报文。因为目前客户端几乎都支持常见编码类型，所以服务器在返回数据时，只需要按照既定的编码方式编码，然后在响应报文中告知客户端所使用的编码方式。这样客户端在接收到报文后按照该方式进行解码，就就不会出现乱码问题。
			
			但是，如果客户端已经定了就使用某种解码方式，那么这时候服务器端就不能那么任性了，他就需要解析Accept-Charset字段，根据这个值，来设定采用的编码方式。
			如上例中，以逗号分隔，客户端支持两种编码方式，gbk和utf-8（gbk优先级高于utf8），其中utf-8后的q值，表示utf-8占的“权重”。
			
            - 题外话：

			服务器端怎么通知浏览器所采用的编码格式呢？
			如果不通知浏览器，那么浏览器会采用什么样的格式解码呢？
			
			服务器端以原生的Servlet & JSP为例：

			  1）当返回的是HTML页面，那么页面meta charset就指定了编码格式
			  2）当返回的是JSP页面，那么页面pageEncoding就指定了编码格式
			  3）当通过resp的Outputstream返回原生内容时，我们可以通过设置响应头content-type/content-charset字段来指定编码格式
			
			那么如果服务器不指定编码格式呢？

			  我的测试环境为win10中文操作系统，浏览器：Chrome 64.0.3282.186（正式版本）
				
				1）返回的html页面不设置meta标签，但是文件本身是utf-8或gbk编码，中文不乱码，服务器会将html页面转换为字节流写给浏览器，浏览器读取字节流，由于找不到meta标签设置的文件格式，就会按照默认的格式解码。这时出现的情况是，当原页面是gbk编码时，浏览器能正常显示页面；当原页面是utf-8编码时，浏览器显示中文乱码。这说明当前Chrome浏览器的默认编码格式为gbk。使用微软自带的Microsoft Edge测试结果一样 。
				
				2）返回JSP页面时，必须指定pageEncoding。
				
				3）通过response的输入流，直接返回生成的字节流。
 
                     当服务器使用gbk编码返回字节流时，地址栏的http请求不乱码，但是ajax请求响应乱码；
			         当服务器使用utf-8返回字节流时，地址栏的http请求乱码，但是ajax不乱码。
			
			
			这说明同一个浏览器，在不同的地方采用的编码格式不同，当浏览器解析页面时，它默认使用的是gbk编码（可能因为我们的中文操作系统，同时是中文版的软件，所以浏览器默认使用gbk格式来解析页面）；当浏览器使用内核XMLHttpRequest对象来解析响应时，默认采用的是utf-8（这个应该跟操作系统语言没关系，内核层面的应该在哪个国家都一样）。所以，如果为了确保在各种情况下都不乱码，服务器一定要通知客户端所采用的编码格式


    - Referer：
    
			例：Referer:http://localhost:8080/test/11.html
			
			表示当前请求是从哪个资源发起的；或者是请求的上一步的地址。
			
			我在11.html页面发起一个请求，这时候浏览器封装的请求头就有上例中的referer字段，表示当前请求是这个资源链接中发起的。
			
			Referer是常用于网站的访问统计，比如我在很多地方都做了广告链接到我网站的主页，这时候我就可以通过Referer来查看哪些地方跳转过来的人多，就说广告的效果好。
			另外，Referer还经常用于防盗链。
			
			   1.防盗链：所谓防盗链是指防止其他web站点页面通过连接本站点的页面来访问本站点内容，这样对于本站点来说侵犯了本站点的版权
               
               2.非法用户： 

                  常访问本站点页面的链接有三种出处:

					  (1) 地址栏输入链接地址。如地址栏上输入www.csdn.net/a.jsp；
					
					  (2)其他站点上的应用程序的页面上通过链接本站点页面资源。如(www.b.com/index.jsp页面上有一链接指向www.csdn.net/a.jsp)；
					
					  (3)本站点上的页面资源连接到本站点的另外的页面资源。如(www.csdn.net/index.jsp页面上有一链接指向www.csdn.net/a.jsp)；
					
				  这三类用户中第一类和第二类通常是非法用户。

               3.如何防盗链

                  通过调用request.getHeader("Referer");判断访问本页面的链接来自哪里。
                  Refer代表网页的来源，及上一页的地址，如果是直接在浏览器上输入地址，回车进来，则没有Refer头。


   - If-Modified-Since：
   
            例：If-Modified-Since:Thu, 29 Mar 2018 08:37:45 GMT

			表示客户端缓存文件的时间。字面翻译的意思是，“如果从…时间改变了”（就请再发送给我一遍新的文件）。
			
			当客户端访问服务器的静态文件时，通常会将资源结果缓存下来，并标记一下文件的缓存时间（根据响应头中的Last-Modified字段）；当接下来再发送同样的请求时，会在请求头中添加上这个字段If-Modified-Since；
			
			服务器端读取字段值，判断服务器端文件的最后修改时间，如果如果不晚于该值，说明浏览器缓存的文件是最新的，然后就不会重新发送文件内容，而是将相应报文的状态设置为304，表示你读取缓存的文件就可以了，这就很大程度上节省了带宽。
			第一次请求头：
			
			GET /mvctest/11.html HTTP/1.1
			Host: localhost:8080
			Connection: keep-alive
			Upgrade-Insecure-Requests: 1
			User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
			Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
			Accept-Encoding: gzip, deflate, br
			Accept-Language: zh-CN,zh;q=0.9
			1
			2
			3
			4
			5
			6
			7
			8
			第一次响应头：
			这里写图片描述
			
			第二次请求头：
			这里写图片描述
			第二次响应头：
			这里写图片描述
			
			需要说明的是，If-Modified-Since字段的值，为服务器端文件最后修改的时间，不是请求的访问时间，时间值为GMT格林尼治时间，不是本地时间。
			浏览器一般只对.html,.jpg,.css,.js等这些静态资源进行缓存，对于jsp页面以及ajax请求的动态结果，不缓存。服务器如Tomcat会自动给静态文件的响应报文添加“Last-Modified”字段，同时解析请求报文中的If-Modified-Since字段，这些都是对我们透明的。
			
			例如，我们将11.html改为11.jsp，那么浏览器将不会缓存页面内容，服务器每次都响应一个完整的页面内容给客户端，也不会在响应报文中添加“Last-Modified”字段。
			每次对于JSP请求的响应结果：
			这里写图片描述
		
		If-None-Match:
		例：
		If-None-Match:W/”607-1522312665174”
		该字段同If-Modified-Since字段一样，都是用来表示资源文件是否是最新的。只不过If-Modified-Since的值为文件的最后修改时间，而该值为资源实体的哈希值，同样是由服务器生成的。
		从上面的截图中我们可以看到：
		第一次请求时，服务器的响应报文中有字段Etag，这就是实体的哈希值，浏览器会缓存文件并记录该值。
		第二次请求时，请求头字段中就有If-None-Match，值为Etag的值，而服务器会判断该值与服务器中文件的哈希值是否相同，如果相同，就返回304，让浏览器读取缓存；否则会返回新的资源文件，并在响应头中设置新的Etag值。
		
		Last-Modified/If-Modified-Since 和 Etag/If-None-Match这两对头字段都是来标记缓存资源的，但是后者的优先级要高于前者。

  - Cache-Control:

		例：Cache-Control:no-cache
	
		字段的字面意思为“缓存-控制”，前面我们将了几个字段表面客户端/服务器如何使用缓存机制，而这个字段就是用来控制缓存的。
		Cache-Control在请求/响应报文头中均可设置，分别表明不同的意思，下面我们以响应报文为例：cache-control在响应报文的的取值可以为：public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。
		所代表的意思为：
		这里写图片描述
		其中，no-cache、no-store、max-age为常用的取值。
		比如，服务器在响应报文中添加Cache-Control：no-store，表示浏览器或各级代理，不要缓存本次的相应内容（即使响应报文中有Etag和Last-Modified）;
		
		比如，响应报文中有Cache-Control：no-cache，表示浏览器可以缓存响应文件，但是在使用缓存之前，必须通过令牌（Etag）来与服务器进行沟通确认缓存有效。
		
		比如，响应报文中有Cache-Control：max-age=500，表示在接下来的500秒内，浏览器可以自主使用缓存内容，不需要向服务器发送同样的请求。
		
		在请求报文中，也可以添加cache-control字段，其取值可以为no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached。
		客户端在发送请求到服务器时，可能会经过很多层代理，而这些代理可能就缓存了本次请求想要的文件，而请求中的cache-control就可以控制，是否使用代理中的缓存文件。
		
		比如，请求报文头中有cache-control：no-cache，那就表示，代理如果返回给我缓存文件时，需要到服务器端进行确认，缓存是不是最新的。
		
		比如，请求报文头中有cache-control：no-store，那就表示，我不需要代理中的缓存文件，我需要直接请求服务器。
		
		所以我们可以看到，cache-control就是用来控制缓存使用的，如是否缓存，是否使用缓存，缓存到期时间等，而Last-Modified/If-Modified-Since 和 Etag/If-None-Match是标识C/S之间怎么使用缓存。
		缓存的使用都是服务器和客户端的默认行为，对用户和程序员的透明的，当然我们可以通过配置文件或程序修改他们的行为规则。
		附：http协议中对缓存的说明

  - User-Agent:

		例：User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
		表示客户端的软件环境。如上可以看出使用的是Window10 64位操作系统，Chrome浏览器等信息。服务器可以根据该字段评估客户端的环境从而给出不同的响应。（比如根据请求是从手机端或是电脑端发起的，返回不同版本的页面）

  - Host：

		例：Host:localhost:8080
		表示请求者的主机地址（IP地址）和端口号。
		服务器端可以根据该字段进行ip过滤等操作。

(3)响应头

    - Etag、Last-Modified、cache-control在前文中已经说明。

    - Content-Length:

		例：Content-Length:607
		表示接收到的响应报文的总长度为607。
		根据这个长度，客户端可以更准确的接收和解析报文内容。或者可以根据当前接收/解析的长度占总长度的百分比，做出进度条的效果。

   - Accept-Ranges:

		例：Accept-Ranges:bytes
		表示服务器支持http中的Range功能，能够分段请求客户端能够分段请求服务器。
		我们上网时常用的“断点续传”，或者服务器所谓的“多线程下载”就是靠的服务器端的Range技术。
		Range功能的请求-响应流程如此：
		客户端发起带range的请求：
		
		GET  /test.rar  HTTP/1.1
		Connection:  close
		Host:  116.1.219.219
		Range:  bytes=0-100
		1
		2
		3
		4
		在头中添加Range字段，表示我要请求[0-100]这101个字节的数据。
		此处Range的值，可以添加多个片段，如 Range：bytes=0-100,200-300等。
		
		服务器响应报文：
		
		HTTP/1.1 206 OK
		Content-Length:  801     
		Content-Type:  application/octet-stream 
		Content-Location: http://www.onlinedown.net/hj_index.htm
		Content-Range:  bytes  0-100/2350        //2350:文件总大小
		Last-Modified: Mon, 16 Feb 2009 16:10:12 GMT
		Accept-Ranges: bytes
		ETag: "d67a4bc5190c91:512"
		Date: Wed, 18 Feb 2009 07:55:26 GMT
		1
		2
		3
		4
		5
		6
		7
		8
		9
		响应报文中有Content-Range字段，表示响应的报文片段内容范围，已经总的数据大小。
		同时Range请求的正常的返回码是206，不是200。
		
		而即使我们请求的不是Range功能请求，那么服务器的返回字段中会有Accept-Range，表示服务器支持Range功能。

  - Server:
  
		例：Server: Apache/2.4.1 (Unix)
		表示服务器的名称，是Unix下的Apache服务器

<h3 id='二、http的请求方法'><font color='#ccc'>二、http的请求方法</font></h3>

  - HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。
  - HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

   1. GET - 默认的请求方式，返回页面具体内容，参数会显示在地址栏中
   2. POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
   3. HEAD - 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
   4. PUT - 从客户端向服务器传送的数据取代指定的文档的内容。
   5. DELETE	- 请求服务器删除指定的页面。
   6. CONNECT - HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
   7. OPTIONS - 允许客户端查看服务器的性能。
   8. TRACE - 回显服务器收到的请求，主要用于测试或诊断。

<h3 id='三、http常用状态码'>三、http常用状态码</h3>

1.1xx - 信息提示：这类状态码表示一个临时的响应信息，并需要请求者继续执行操作的一个状态码

   - 100：继续，客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收,且仍未被拒绝.客户端应当继续发送请求的剩余部分,或者如果请求已经完成,忽略这个响应.服务器必须在请求完成后向客户端发送一个最终响应。（http1.1可用）
   - 101：切换协议，服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 在Upgrade消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特 性的资源。（http1.1可用）

 2.2xx - 成功：这类状态代码表明服务器成功地接受了客户端请求

   - 200:成功,服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
   - 201:已创建,请求成功且服务器已创建了新的资源。 
   - 202:已接受,服务器已接受了请求，但尚未对其进行处理。 
   - 203:非授权信息,服务器已成功处理了请求，但返回了可能来自另一来源的信息。 
   - 204:无内容,服务器成功处理了请求，但未返回任何内容。 
   - 205:重置内容,服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 
   - 206:部分内容,服务器成功处理了部分 GET 请求。

 3.3xx - 重定向：客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。

   - 301：永久重定向，请求的网页已永久移动到新位置，返回信息的location头中会包含新的url，服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
   - 302：暂时重定向
   - 304：使用缓存（协商缓存）
   - 301，302，303，307详解

         - 302

              - HTTP1.0中，在 POST 请求方式上，客户端收到服务端的301或302状态码，那么不能自动的向新的URI发送重复请求，必须跟用户确认是否该重发，因为第二次 POST 时，POST 方法不是幂等，（也就是请求时服务器的资源有可能已经发生了变化），POST 操作会不符合用户预期。但是很多浏览器（user agent）在这种情况下都会把 POST 请求变为 GET 请求。

              - HTTP1.1中，如果客户端发出非 GET、HEAD 请求后，收到服务端的301或302状态码，那么就不能自动的向新URI发送重复请求，除非得到用户的确认。但是，很多浏览器都把301或302当作303 处理了（注意，303 是 HTTP1.1 才加进来的，其实从 HTTP1.0 进化到 HTTP1.1，浏览器什么都没动），它们获取到 HTTP 响应报文头部的 Location 字段信息，并发起一个 GET 请求。

         - 303和307

              - 从上面的介绍可以知道，HTTP1.1和HTTP1.0的302或301状态码意义是一样的，浏览器对它的处理也是一样的，POST方法的重定向在未询问用户的情况下就变成GET，HTTP1.1新加入303和307状态码。
              - 文档中规定303状态码的响应，也就是上边提到的现在浏览器对302状态码的处理：POST重定向为GET。
              - HTTP1.1文档中307状态码则相当于HTTP1.0文档中的302状态码，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。
              - 文档也说到，为兼容很多HTTP1.1之前的浏览器，服务端在需要发出303状态码时，会选择用302状态码替代；而对于307的处理，则需要在响应实体中包含信息，以便不能处理307状态码的用户有能力在新URI中发起重复请求，也就是说，把重定向的页面展示给用户，让用户去点重定向URI链接。
              - 303和307的存在，归根结底是由于POST方法的非幂等属性引起的。


 4.4xx - 客户端错误/请求错误

   - 400：错误请求，客户端请求语法出现错误，服务器无法理解请求的语法。
   - 401：未授权， 请求要求身份验证。 需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过.对于需要登录的网页，服务器可能返回此响应。
   - 403：禁止，客户端没有权利访问所请求内容,服务器拒绝本次请求。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。
   - 404：未找到，服务器找不到所请求的资源。


 5.5xx - 服务器错误:这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

   - 500:服务器内部错误,服务器遇到错误，无法完成请求。 
   - 501:尚未实施,服务器不具备完成请求的功能。 例如，服务器不支持该请求中使用的方法,比如POST 和 PUT.只有GET 和 HEAD 是RFC2616规范中规定服务器必须实现的方法.
   - 502:错误网关,服务器作为网关或代理，从上游服务器收到无效响应。 
   - 503:服务不可用,由于临时的服务器维护或者过载,服务器当前无法处理请求.这个状况是临时的,并且将在一段时间以后恢复.如果能够预计延迟时间,那么响应中可以包含一个Retry-After:头用以标明这个
         延迟时间.如果没有给出这个Retry-After:信息，那么客户端应当以处理500响应的方式处理它.同时,这种情况下,一个友好的用于解释服务器出现问题的页面应当被返回,并且,缓存相关的HTTP头信息
         也应该包含,因为通常这种错误提示网页不应当被客户端缓存. 
   - 504:网关超时,服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
   - 505:HTTP 版本不受支持,服务器不支持请求中所用的 HTTP 协议版本。





<h1 id='es6总结'><font color='darkgrey'>es6总结</font><h1>

<h3 id='一、promise'>一、promise</h3>

1.Promise.all()

   - Promise.all()接受一个数组作为参数，数组成员都是promise对象，当数组中的所有promise对象的状态变为resloved的时候，Promise.all()的状态就会变为resloved；当有一个状态变为rejected的时候，Promise.all()的状态就会变为rejected；
   - 调用then方法时，结果成功的回调函数的参数也是一个数组，按照顺序保存着每一个promise对象reslove执行的值；结果失败的回调函数的参数是第一个变为rejected的promise对象的reject执行的值；
   - Promise.all()可以解决异步并行的问题

     例1：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       resolve(1);
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      resolve(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       resolve(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) // 进入成功的回调，输出[1,2,3]
		},(err)=>{
		    console.log(err)
		})

    - 上例也表明，与哪个promise的状态先变成resolved无关

    例2：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reject(1);
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      reject(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reslove(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) // 进入失败的回调，promise2先进入rejected，所以输出2
		})

    
    例3：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(1)
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      reslove(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) 
		})

    - 上例中只会输出1，3但不会执行then里面的回调，是因为promise里面的代码是同步执行的所以里面的console.log会输出，但promise.all()的状态是pedding，所以不会执行then

    例4：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reject(1)
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      console.log(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) 
		})

    - 上例会输出2，1，3，是因为promise1的状态变为rejected，所以会执行then里面的失败回调，而两个console是同步的依然会执行


 - 由例3和例4可以看出，只要有一个状态为rejected，Promise.all()的状态就会变为rejected，当所有状态为resloved的时候Promise.all()的状态才会变为resloved

2.Promise.race()

   - Promise.race()也是接受一个数组，数组里面的成员为promise对象，它就相当于竞赛一样，第一个promise对象的状态变为resloved的时候，Promise.race()的状态就变为resloved,第一个promise的状态变为rejectd的时候，Promise.race()的状态就变为rejected
   

    例1：
        let promise1 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(1);
			},10000)
		});
		let promise2 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(2);
			},9000)
		});
		let promise3 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(3);
			},11000)
		});
		
		let promiseRace = Promise.race([promise1,promise2,promise3])
		
		promiseRace.then((res)=>{
		    console.log(res) // promise2的状态先发生变化，变为resloved,所以Promise.race的状态变为resloved，输出2
		},(err)=>{
		    console.log(err)
		})
		

    例2：
        let promise1 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(1);
			},10000)
		});
		let promise2 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(2)
			},9000)
		});
		let promise3 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(3);
			},11000)
		});
		
		let promiseRace = Promise.race([promise1,promise2,promise3])
		
		promiseRace.then((res)=>{
		    console.log(res) // promise2的状态先发生变化，变为rejectd,所以Promise.race的状态变为rejected，输出2
		},(err)=>{
		    console.log(err)
		})

3.使用Promise.race()实现超时处理

	let promise1 = new Promise((reslove,reject)=>{
	    setTimeout(()=>{
	       reslove(1)
	    },3000)
	})
	
	let promise2 = new Promise((reslove,reject)=>{
	   setTimeout(()=>{
	      reject(2);
	   },2000)
	})
	
	let promise3 = new Promise((reslove,reject)=>{
	    setTimeout(()=>{
	      reslove(3);
	    },5000)
	})
	
	let promiseAll = Promise.all([promise1,promise2,promise3])
	
   // 超时处理

	function timeoutPromise(promise,delay){
	
	    let timeout = new Promise((reslove,reject)=>{
	        setTimeout(()=>{
	            reject('异步处理超时')
	        },delay)
	    })
	    
	    let promiseRace = Promise.race([promise,timeout])
	    return promiseRace
	}
	


	timeoutPromise(promiseAll,1000).then((res)=>{
	    console.log(res) 
	},(err)=>{
	    console.log(err) 
	})
	
	


<h3 id='二、promise实现原理'>二、promise实现原理</h3>

#### 一、Promise基本结构 ####

- 构造函数Promise必须接受一个函数作为参数，我们称该函数为handle，handle又包含resolve和reject两个参数，它们是两个函数。
- 定义一个判断一个变量是否为函数的方法，后面会用到

		// 判断变量否为function
		const isFunction = variable => typeof variable === 'function'

- 首先，我们定义一个名为 MyPromise 的 Class，它接受一个函数 handle 作为参数

		class MyPromise {
		  constructor (handle) {
		    if (!isFunction(handle)) {
		      throw new Error('MyPromise must accept a function as a parameter')
		    }
		  }
		}


#### 二、Promise状态和值 ####

1. 状态

- Promise存在以下三种状态：

   - Pending(进行中)
   - Fulfilled(已成功)
   - Rejected(已失败)

- 状态只能由 Pending 变为 Fulfilled 或由 Pending 变为 Rejected ，且状态改变之后不会在发生变化，会一直保持这个状态。

2. 值

- Promise的值是指状态改变时传递给回调函数的值
- 上文中handle函数包含 resolve 和 reject 两个参数，它们是两个函数，可以用于改变 Promise 的状态和传入 Promise 的值

		new Promise((resolve, reject) => {
		  setTimeout(() => {
		    resolve('FULFILLED')
		  }, 1000)
		})

       这里 resolve 传入的 "FULFILLED" 就是 Promise 的值

3. resolve 和 reject

- resolve : 将Promise对象的状态从 Pending(进行中) 变为 Fulfilled(已成功)
- reject : 将Promise对象的状态从 Pending(进行中) 变为 Rejected(已失败)
- resolve 和 reject 都可以传入任意类型的值作为实参，表示 Promise 对象成功（Fulfilled）和失败（Rejected）的值

4. 了解了 Promise 的状态和值，接下来，我们为 MyPromise 添加状态属性和值

    - 首先定义三个常量，用于标记Promise对象的三种状态

		// 定义Promise的三种状态常量
		const PENDING = 'PENDING'
		const FULFILLED = 'FULFILLED'
		const REJECTED = 'REJECTED'

    - 再为 MyPromise 添加状态和值，并添加状态改变的执行逻辑

			class MyPromise {
			   constructor (handle) {
			    if (!isFunction(handle)) {
			      throw new Error('MyPromise must accept a function as a parameter')
			    }
			    // 添加状态
			    this._status = PENDING
			    // 添加状态
			    this._value = undefined
			    // 执行handle
			    try {
			      handle(this._resolve.bind(this), this._reject.bind(this)) //这里相当于调用handle函数，并传入了两个实参，handle函数中可能会出错，所以放入try...catch...里面
			    } catch (err) {
			      this._reject(err)
			    }
			  }
	
			  // 添加resovle时执行的函数
			  _resolve (val) {
	            //如果状态已经改变，就直接返回，之后就再改变状态了，也证明了一个promise只执行一次resolve
			    if (this._status !== PENDING) return
			    this._status = FULFILLED
			    this._value = val
			  }
	
			  // 添加reject时执行的函数
			  _reject (err) { 
	           //如果状态已经改变，就直接返回，之后就再改变状态了，也证明了一个promise只执行一次resolve
			    if (this._status !== PENDING) return
			    this._status = REJECTED
			    this._value = err
			  }
			}
	

#### 三、Promise的then方法 ####

- Promise的then方法接收两个可选的参数，promise.then(onFulfilled, onRejected)
1. 参数

   - 如果onFulfilled为函数，当 promise 状态变为成功时必须被调用，其第一个参数为 promise 成功状态传入的值（ resolve 执行时传入的值）
   - 如果onFulfilled不为函数，当promise状态变为成功时，捕获不到resolve中的值，所以这时候resolve中的值会穿透，promise.then的状态一定是成功的，并且会resolve promise中的值

	        let promise1 = new Promise((resolve, reject) => {
			    setTimeout(() => {
			     resolve('success')
			   }, 1000)
			})

			promise2 = promise1.then('这里的onFulfilled本来是一个函数，但现在不是')
			promise2.then(res => {
			  console.log(res) // 1秒后打印出：success
			}, err => {
			  console.log(err)
			})


   - 如果 onRejected 是函数，当 promise 状态变为失败时必须被调用，其第一个参数为 promise 失败状态传入的值（ reject 执行时传入的值）
   - 如果onRejected不为函数，当promise状态变为失败时，捕获不到reject中的值，所以这时候reject中的值会穿透，promise.then的状态一定是失败的，并且会reject promise中的值

			let promise1 = new Promise((resolve, reject) => {
			    setTimeout(() => {
			     reject('fail')
			   }, 1000)
			})
			promise2 = promise1.then(res => res, '这里的onRejected本来是一个函数，但现在不是')
			promise2.then(res => {
			  console.log(res)
			}, err => {
			  console.log(err)  // 1秒后打印出：fail
			})



   - 多次调用

      - then 方法可以被同一个 promise 对象调用多次

        - 当 promise 成功状态时，所有 onFulfilled 需按照其注册顺序依次回调
        - 当 promise 失败状态时，所有 onRejected 需按照其注册顺序依次回调

2. 返回

   - then 方法必须返回一个新的 promise 对象，因此 promise 支持链式调用
   - 这里涉及到 Promise 的执行规则，包括“值的传递”和“错误捕获”机制：

      - 如果 onFulfilled 或者 onRejected 返回一个值 x 

         - 若 x 不为 Promise ，则使 x 直接作为新返回的 Promise 对象的值， 即新的onFulfilled 或者 onRejected 函数的参数.
         - 若 x 为 Promise ，这时后一个回调函数，就会等待该 Promise 对象(即 x )的状态发生变化，才会被调用，并且新的 Promise 状态和 x 的状态相同。

					let promise1 = new Promise((resolve, reject) => {
					    setTimeout(() => {
					      resolve()
					    }, 1000)
					})

					promise2 = promise1.then(res => {
					  // 返回一个普通值
					  return '这里返回一个普通值'
					})

					promise2.then(res => {
					  console.log(res) //1秒后打印出：这里返回一个普通值
					})
		
		
					let promise1 = new Promise((resolve, reject) => {
					  setTimeout(() => {
					    resolve()
					  }, 1000)
					})

					promise2 = promise1.then(res => {
					  // 返回一个Promise对象
					  return new Promise((resolve, reject) => {
					    setTimeout(() => {
					     resolve('这里返回一个Promise')
					    }, 2000)
					  })
					})

					promise2.then(res => {
					  console.log(res) //3秒后打印出：这里返回一个Promise
					})

    - 如果 onFulfilled 或者onRejected 抛出一个异常 e ，则 promise2 必须变为失败（Rejected），并返回失败的值 e
     
	       let promise1 = new Promise((resolve, reject) => {
			  setTimeout(() => {
			    resolve('success')
			  }, 1000)
			})
			promise2 = promise1.then(res => {
			  throw new Error('这里抛出一个异常e')
			})
			promise2.then(res => {
			  console.log(res)
			}, err => {
			  console.log(err) //1秒后打印出：这里抛出一个异常e
			})


- 根据上面的规则，我们来为 完善 MyPromise

   - 修改 constructor : 增加执行队列
      - 由于 then 方法支持多次调用，我们可以维护两个数组，将每次 then 方法注册时的回调函数添加到数组中，等待执行

			constructor (handle) {
			  if (!isFunction(handle)) {
			    throw new Error('MyPromise must accept a function as a parameter')
			  }
			  // 添加状态
			  this._status = PENDING
			  // 添加状态
			  this._value = undefined
			  // 添加成功回调函数队列
			  this._fulfilledQueues = []
			  // 添加失败回调函数队列
			  this._rejectedQueues = []
			  // 执行handle
			  try {
			    handle(this._resolve.bind(this), this._reject.bind(this)) 
			  } catch (err) {
			    this._reject(err)
			  }
			}

     - 添加then方法

        - 首先，then 返回一个新的 Promise 对象，并且需要将回调函数加入到执行队列中

				// 添加then方法
				then (onFulfilled, onRejected) {
				  const { _value, _status } = this
				  switch (_status) {
				    // 当状态为pending时，将then方法回调函数加入执行队列等待执行
				    case PENDING:
				      this._fulfilledQueues.push(onFulfilled)
				      this._rejectedQueues.push(onRejected)
				      break
				    // 当状态已经改变时，立即执行对应的回调函数
				    case FULFILLED:
				      onFulfilled(_value)
				      break
				    case REJECTED:
				      onRejected(_value)
				      break
				  }
				  // 返回一个新的Promise对象
				  return new MyPromise((onFulfilledNext, onRejectedNext) => {
				  })
				}

        - 那返回的新的 Promise 对象什么时候改变状态？改变为哪种状态呢？
           
           - 根据上文中 then 方法的规则，我们知道返回的新的 Promise 对象的状态依赖于当前 then 方法回调函数执行的情况以及返回值，例如 then 的参数是否为一个函数、回调函数执行是否出错、返回值是否为 Promise 对象。
           - 我们来进一步完善 then 方法:

					// 添加then方法
					then (onFulfilled, onRejected) {
					  const { _value, _status } = this
					  // 返回一个新的Promise对象
					  return new MyPromise((onFulfilledNext, onRejectedNext) => {
					    // 封装一个成功时执行的函数
					    let fulfilled = value => {
					      try {
					        if (!isFunction(onFulfilled)) {
					          onFulfilledNext(value)
					        } else {
					          let res =  onFulfilled(value);
					          if (res instanceof MyPromise) {
					            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
					            res.then(onFulfilledNext, onRejectedNext)
					          } else {
					            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
					            onFulfilledNext(res)
					          }
					        }
					      } catch (err) {
					        // 如果函数执行出错，新的Promise对象的状态为失败
					        onRejectedNext(err)
					      }
					    }
					    // 封装一个失败时执行的函数
					    let rejected = error => {
					      try {
					        if (!isFunction(onRejected)) {
					          onRejectedNext(error)
					        } else {
					            let res = onRejected(error);
					            if (res instanceof MyPromise) {
					              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
					              res.then(onFulfilledNext, onRejectedNext)
					            } else {
					              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
					              onFulfilledNext(res)
					            }
					        }
					      } catch (err) {
					        // 如果函数执行出错，新的Promise对象的状态为失败
					        onRejectedNext(err)
					      }
					    }
					    switch (_status) {
					      // 当状态为pending时，将then方法回调函数加入执行队列等待执行
					      case PENDING:
					        this._fulfilledQueues.push(fulfilled)
					        this._rejectedQueues.push(rejected)
					        break
					      // 当状态已经改变时，立即执行对应的回调函数
					      case FULFILLED:
					        fulfilled(_value)
					        break
					      case REJECTED:
					        rejected(_value)
					        break
					    }
					  })
					}


- 接着修改 _resolve 和 _reject ：依次执行队列中的函数

  - 当 resolve 或 reject 方法执行时，我们依次提取成功或失败任务队列当中的函数开始执行，并清空队列，从而实现 then 方法的多次调用，实现的代码如下：

			// 添加resovle时执行的函数
			_resolve (val) {
			  if (this._status !== PENDING) return
			  // 依次执行成功队列中的函数，并清空队列
			  const run = () => {
			    this._status = FULFILLED
			    this._value = val
			    let cb;
			    while (cb = this._fulfilledQueues.shift()) {
			      cb(val)
			    }
			  }
			  // 为了支持同步的Promise，这里采用异步调用
			  setTimeout(() => run(), 0)
			}
			// 添加reject时执行的函数
			_reject (err) { 
			  if (this._status !== PENDING) return
			  // 依次执行失败队列中的函数，并清空队列
			  const run = () => {
			    this._status = REJECTED
			    this._value = err
			    let cb;
			    while (cb = this._rejectedQueues.shift()) {
			      cb(err)
			    }
			  }
			  // 为了支持同步的Promise，这里采用异步调用
			  setTimeout(run, 0)
			}


- 这里还有一种特殊的情况，就是当 resolve 方法传入的参数为一个 Promise 对象时，则该 Promise 对象状态决定当前 Promise 对象的状态。

		const p1 = new Promise(function (resolve, reject) {
		  // ...
		});
		
		const p2 = new Promise(function (resolve, reject) {
		  // ...
		  resolve(p1);
		})

    上面代码中，p1 和 p2 都是 Promise 的实例，但是 p2 的resolve方法将 p1 作为参数，即一个异步操作的结果是返回另一个异步操作。
    注意，这时 p1 的状态就会传递给 p2，也就是说，p1 的状态决定了 p2 的状态。如果 p1 的状态是Pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 Fulfilled 或者 Rejected，那么 p2 的回调函数将会立刻执行。

   - 我们来修改_resolve来支持这样的特性

		  // 添加resovle时执行的函数
		  _resolve (val) {
		    const run = () => {
		      if (this._status !== PENDING) return
		      // 依次执行成功队列中的函数，并清空队列
		      const runFulfilled = (value) => {
		        let cb;
		        while (cb = this._fulfilledQueues.shift()) {
		          cb(value)
		        }
		      }
		      // 依次执行失败队列中的函数，并清空队列
		      const runRejected = (error) => {
		        let cb;
		        while (cb = this._rejectedQueues.shift()) {
		          cb(error)
		        }
		      }
		      /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
		        当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
		      */
		      if (val instanceof MyPromise) {
		        val.then(value => {
		          this._value = value
		          this._status = FULFILLED
		          runFulfilled(value)
		        }, err => {
		          this._value = err
		          this._status = REJECTED
		          runRejected(err)
		        })
		      } else {
		        this._value = val
		        this._status = FULFILLED
		        runFulfilled(val)
		      }
		    }
		    // 为了支持同步的Promise，这里采用异步调用
		    setTimeout(run, 0)
		  }

- 这样一个Promise就基本实现了，现在我们来加一些其它的方法

#### 四、catch方法 ####

- 相当于调用 then 方法, 但只传入 Rejected 状态的回调函数

		// 添加catch方法
		catch (onRejected) {
		  return this.then(undefined, onRejected)
		}


#### 五、静态 resolve 方法 ####

		// 添加静态resolve方法
		static resolve (value) {
		  // 如果参数是MyPromise实例，直接返回这个实例
		  if (value instanceof MyPromise) return value
		  return new MyPromise(resolve => resolve(value))
		}

#### 六、静态 reject 方法 ####

		// 添加静态reject方法
		static reject (value) {
		  return new MyPromise((resolve ,reject) => reject(value))
		}


#### 七、静态 all 方法 ####

		// 添加静态all方法
		static all (list) {
		  return new MyPromise((resolve, reject) => {
		    /**
		     * 返回值的集合
		     */
		    let values = []
		    let count = 0
		    for (let [i, p] of list.entries()) {
		      // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
		      this.resolve(p).then(res => {
		        values[i] = res
		        count++
		        // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
		        if (count === list.length) resolve(values)
		      }, err => {
		        // 有一个被rejected时返回的MyPromise状态就变成rejected
		        reject(err)
		      })
		    }
		  })
		}


#### 八、静态 race 方法 ####

		// 添加静态race方法
		static race (list) {
		  return new MyPromise((resolve, reject) => {
		    for (let p of list) {
		      // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
		      this.resolve(p).then(res => {
		        resolve(res)
		      }, err => {
		        reject(err)
		      })
		    }
		  })
		}


#### 九、finally 方法 ####

- finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作

		finally (cb) {
		  return this.then(
		    value  => MyPromise.resolve(cb()).then(() => value),
		    reason => MyPromise.resolve(cb()).then(() => { throw reason })
		  );
		};


#### 十、完整代码 ####

- 这样一个完整的 Promsie 就实现了，大家对 Promise 的原理也有了解，可以让我们在使用Promise的时候更加清晰明了。

			  // 判断变量否为function
			  const isFunction = variable => typeof variable === 'function'
			  // 定义Promise的三种状态常量
			  const PENDING = 'PENDING'
			  const FULFILLED = 'FULFILLED'
			  const REJECTED = 'REJECTED'
			
			  class MyPromise {
			    constructor (handle) {
			      if (!isFunction(handle)) {
			        throw new Error('MyPromise must accept a function as a parameter')
			      }
			      // 添加状态
			      this._status = PENDING
			      // 添加状态
			      this._value = undefined
			      // 添加成功回调函数队列
			      this._fulfilledQueues = []
			      // 添加失败回调函数队列
			      this._rejectedQueues = []
			      // 执行handle
			      try {
			        handle(this._resolve.bind(this), this._reject.bind(this)) 
			      } catch (err) {
			        this._reject(err)
			      }
			    }
			    // 添加resovle时执行的函数
			    _resolve (val) {
			      const run = () => {
			        if (this._status !== PENDING) return
			        // 依次执行成功队列中的函数，并清空队列
			        const runFulfilled = (value) => {
			          let cb;
			          while (cb = this._fulfilledQueues.shift()) {
			            cb(value)
			          }
			        }
			        // 依次执行失败队列中的函数，并清空队列
			        const runRejected = (error) => {
			          let cb;
			          while (cb = this._rejectedQueues.shift()) {
			            cb(error)
			          }
			        }
			        /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
			          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
			        */
			        if (val instanceof MyPromise) {
			          val.then(value => {
			            this._value = value
			            this._status = FULFILLED
			            runFulfilled(value)
			          }, err => {
			            this._value = err
			            this._status = REJECTED
			            runRejected(err)
			          })
			        } else {
			          this._value = val
			          this._status = FULFILLED
			          runFulfilled(val)
			        }
			      }
			      // 为了支持同步的Promise，这里采用异步调用
			      setTimeout(run, 0)
			    }
			    // 添加reject时执行的函数
			    _reject (err) { 
			      if (this._status !== PENDING) return
			      // 依次执行失败队列中的函数，并清空队列
			      const run = () => {
			        this._status = REJECTED
			        this._value = err
			        let cb;
			        while (cb = this._rejectedQueues.shift()) {
			          cb(err)
			        }
			      }
			      // 为了支持同步的Promise，这里采用异步调用
			      setTimeout(run, 0)
			    }
			    // 添加then方法
			    then (onFulfilled, onRejected) {
			      const { _value, _status } = this
			      // 返回一个新的Promise对象
			      return new MyPromise((onFulfilledNext, onRejectedNext) => {
			        // 封装一个成功时执行的函数
			        let fulfilled = value => {
			          try {
			            if (!isFunction(onFulfilled)) {
			              onFulfilledNext(value)
			            } else {
			              let res =  onFulfilled(value);
			              if (res instanceof MyPromise) {
			                // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
			                res.then(onFulfilledNext, onRejectedNext)
			              } else {
			                //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
			                onFulfilledNext(res)
			              }
			            }
			          } catch (err) {
			            // 如果函数执行出错，新的Promise对象的状态为失败
			            onRejectedNext(err)
			          }
			        }
			        // 封装一个失败时执行的函数
			        let rejected = error => {
			          try {
			            if (!isFunction(onRejected)) {
			              onRejectedNext(error)
			            } else {
			                let res = onRejected(error);
			                if (res instanceof MyPromise) {
			                  // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
			                  res.then(onFulfilledNext, onRejectedNext)
			                } else {
			                  //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
			                  onFulfilledNext(res)
			                }
			            }
			          } catch (err) {
			            // 如果函数执行出错，新的Promise对象的状态为失败
			            onRejectedNext(err)
			          }
			        }
			        switch (_status) {
			          // 当状态为pending时，将then方法回调函数加入执行队列等待执行
			          case PENDING:
			            this._fulfilledQueues.push(fulfilled)
			            this._rejectedQueues.push(rejected)
			            break
			          // 当状态已经改变时，立即执行对应的回调函数
			          case FULFILLED:
			            fulfilled(_value)
			            break
			          case REJECTED:
			            rejected(_value)
			            break
			        }
			      })
			    }
			    // 添加catch方法
			    catch (onRejected) {
			      return this.then(undefined, onRejected)
			    }
			    // 添加静态resolve方法
			    static resolve (value) {
			      // 如果参数是MyPromise实例，直接返回这个实例
			      if (value instanceof MyPromise) return value
			      return new MyPromise(resolve => resolve(value))
			    }
			    // 添加静态reject方法
			    static reject (value) {
			      return new MyPromise((resolve ,reject) => reject(value))
			    }
			    // 添加静态all方法
			    static all (list) {
			      return new MyPromise((resolve, reject) => {
			        /**
			         * 返回值的集合
			         */
			        let values = []
			        let count = 0
			        for (let [i, p] of list.entries()) {
			          // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
			          this.resolve(p).then(res => {
			            values[i] = res
			            count++
			            // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
			            if (count === list.length) resolve(values)
			          }, err => {
			            // 有一个被rejected时返回的MyPromise状态就变成rejected
			            reject(err)
			          })
			        }
			      })
			    }
			    // 添加静态race方法
			    static race (list) {
			      return new MyPromise((resolve, reject) => {
			        for (let p of list) {
			          // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
			          this.resolve(p).then(res => {
			            resolve(res)
			          }, err => {
			            reject(err)
			          })
			        }
			      })
			    }
			    finally (cb) {
			      return this.then(
			        value  => MyPromise.resolve(cb()).then(() => value),
			        reason => MyPromise.resolve(cb()).then(() => { throw reason })
			      );
			    }
			  }
			
			

#### 十一、例题 ####

1. /*例1*/

		Promise.resolve().then(() => {
		    console.log(0);
		    return Promise.resolve(4);
		}).then((res) => {
		    console.log(res)
		})
		
		Promise.resolve().then(() => {
		    console.log(1);
		}).then(() => {
		    console.log(2);
		}).then(() => {
		    console.log(3);
		}).then(() => {
		    console.log(5);
		}).then(() =>{
		    console.log(6);
		})
		
		// 输出 0，1，2，3，4，5，6
		// 解释：
		//上面代码相当于
		
		new Promise(reslove=>{
		    reslove()
		}).then(()=>{
		    console.log(0)
		    return new Promise(reslove=>{
		        reslove(4)
		    })
		
		}).then(res=>{
		    console.log(res)
		    return new Promise(reslove=>{
		        reslove(8)
		    })
		}).then((res)=>{
		    console.log(res)
		})
		
		
		new Promise(reslove=>{
		    reslove()
		}).then(() => {
		    console.log(1);
		}).then(() => {
		    console.log(2);
		}).then(() => {
		    console.log(3);
		}).then(() => {
		    console.log(5);
		}).then(() =>{
		    console.log(6);
		}).then(()=>{
		    console.log(7)
		}).then(()=>{
		    console.log(9)
		})

		/*
		 * 1.将上面的promise称为promise1，下面的promise称为promise2
		 * 2.首先先执行宏任务promise1同步代码，遇到then，将其加入微任务队列，继续执行宏任务promise2同步代码，遇到then，将其加入微任务队列
		 *   微任务队列：[0then,1then]
		 * 3.执行完宏任务，开始执行微任务，执行0then输出0，发现0then返回一个promise，由于then如果返回一个promise，则会自动添加一个内层
		 *   then来等待其状态改变才能执行下一个回调，所以执行完这个promise添加一个then到微任务队列
		 *   微任务队列：[1then,隐形内层then]
		 * 4.继续执行微任务1then，执行完之后遇到2then，将其加入微任务队列
		 *   微任务队列：[隐形内层then,2then]
		 * 5.继续执行隐形内层then，执行完之后发现之后没有then了，继续执行2then，执行完之后遇到3then，将其加入微任务队列
		 *   微任务队列：[3then]
		 * 6.这个时候发现0then在执行完隐形内层then之后终于执行完了，将4then添加到微任务队列
		 *   微任务队列：[3then，4then]
		 * 7.执行3then，执行完之后遇到5then，将其加入微任务队列
		 *   微任务队列：[4then，5then]
		 * 8.执行4then，执行5then，执行完之后遇到6then，将其加入微任务队列
		 *   微任务队列：[6then]
		 * 9.执行6then
		 */


2./*例2*/

		 new Promise((resolve, reject) => {
		    console.log("外部promise");
		    resolve();
		  })
		    .then(() => {
		      console.log("外部第一个then");
		      return new Promise((resolve, reject) => {
		        console.log("内部promise");
		        resolve()
		      })
		      .then(() => {
		      console.log("内部第一个then");
		      })
		      .then(() => {
		      console.log("内部第二个then");
		      });
		    })
		    .then(() => {
		      console.log("外部第二个then");
		    });
		
		    new Promise((resolve, reject) => {
		        console.log("新外部promise");
		        resolve();
		      })
		       .then(()=>{
		           console.log('新外部第一个then')
		       })
		       .then(()=>{
		        console.log('新外部第二个then')
		       })
		       .then(()=>{
		        console.log('新外部第三个then')
		       })
		       .then(()=>{
		        console.log('新外部第四个then')
		       })
		       .then(()=>{
		        console.log('新外部第五个then')
		       })
		        
		      //外部promise=>新外部promise=>外部第一个then=>内部promise=>新外部第一个then=>内部第一个then=>新外部第二个then=>
		      //内部第二个then=>新外部第三个then=>新外部第四个then=>外部第二个then=>新外部第五个then
		    
		    /*
		     * 上面的叫promise1，下面叫promise2
		     * 1.执行promise1输出外部promise，遇到外部第一个then添加到微任务队列，继续执行promise2输出新外部promise，遇到新外部第一个
		     *   then添加到微任务队列
		     *   微任务队列：[外部第一个then,新外部第一个then]
		     * 2.执行微任务队列，执行外部第一个then，输出外部第一个then，继续执行return的promise，输出内部promise，由于内部promise后
		     *   有then，所以不会添加隐形then，将内部第一个then添加到微任务队列
		     *   微任务队列：[新外部第一个then,内部第一个then]
		     * 3.继续执行新外部第一个then，遇到新外部第二个then添加至微任务队列
		     *   微任务队列：[内部第一个then，新外部第二个then]
		     * 4.继续执行内部第一个then，遇到内部第二个then添加至微任务队列
		     *   微任务队列：[新外部第二个then，内部第二个then]
		     * 5.继续执行新外部第二个then，遇到新外部第三个then添加至微任务队列
		     *   微任务队列：[内部第二个then，新外部第三个then]
		     * 6.继续执行内部第二then，执行完之后发现没有then了，继续执行新外部第三个then，遇到新外部第四个then
		     *   微任务队列：[新外部第四个then]
		     * 7.这个时候发现外部第一个then终于执行完了，添加外部第二个then到微任务列队
		     *   微任务队列：[新外部第四个then,外部第二个then]
		     * 8.执行新外部第四个then，遇到新外部第五个then，添加至微任务队列
		     *   微任务队列：[外部第二个then,新外部第五个then]
		     * 9.执行外部第二个then，新外部第五个then,
		     */
		  
3. /*例3*/

		    Promise.resolve().then(() => {
		        console.log(0);
		        return Promise.resolve(4);
		    })
		    .then((res) => {
		        console.log(res)
		    })
		  
		    Promise.resolve().then(() => {
		        console.log(1);
		    }).then(() => {
		        console.log(2);
		    }).then(() => {
		        console.log(3);
		    }).then(() => {
		        console.log(5);
		    }).then(() =>{
		        console.log(6);
		    })
		    
		    // 0=>1=>undefined=>2=>3=>5=>6
		    
		    /*
		     * 和例3相比没有0then中没有return promise
		     * 1.将上面的promise称为promise1，下面的promise称为promise2
		     * 2.首先先执行宏任务promise1同步代码，遇到then，将其加入微任务队列，继续执行宏任务promise2同步代码，遇到then，将其加入微任务队列
		     *   微任务队列：[0then,1then]
		     * 3.执行完宏任务，开始执行微任务，执行0then输出0，继续执行0then中的promise，这个时候0then全部执行完，执行完之后遇到resthen
		     *   微任务队列：[1then,resthen]
		     * 4.继续执行微任务1then，执行完之后遇到2then，将其加入微任务队列
		     *   微任务队列：[resthen,2then]
		     * 5.继续执行resthen，resthen输出传给resthen的值，由于上一个then没有return所以没有返回值，所以输出undefined继续执行2then，执行
		     *   完之后遇到3then，将其加入微任务队列
		     *   微任务队列：[3then]
		     * 6.执行3then，执行完之后遇到5then，将其加入微任务队列
		     *   微任务队列：[5then]
		     * 7.执行5then，执行完之后遇到6then，将其加入微任务队列
		     *   微任务队列：[6then]
		     * 8.执行6then
		     */

4. /*例4*/

		     Promise.resolve().then(() => {
		        console.log(0);
		        Promise.resolve(4);
		        return 99
		    })
		    .then((res) => {
		        console.log(res)
		    })
		    
		    Promise.resolve().then(() => {
		        console.log(1);
		    }).then(() => {
		        console.log(2);
		    }).then(() => {
		        console.log(3);
		    }).then(() => {
		        console.log(5);
		    }).then(() =>{
		        console.log(6);
		    })
		    
		    // 0=>1=>99=>2=>3=>5=>6
		    
		    /*
		     * 和例3相比没有0then中return 99
		     * 1.将上面的promise称为promise1，下面的promise称为promise2
		     * 2.首先先执行宏任务promise1同步代码，遇到then，将其加入微任务队列，继续执行宏任务promise2同步代码，遇到then，将其加入微任务队列
		     *   微任务队列：[0then,1then]
		     * 3.执行完宏任务，开始执行微任务，执行0then输出0，继续执行0then中的promise，0then return一个常量99，这个时候0then全部执行完，
		     *   执行完之后遇到resthen
		     *   微任务队列：[1then,resthen]
		     * 4.继续执行微任务1then，执行完之后遇到2then，将其加入微任务队列
		     *   微任务队列：[resthen,2then]
		     * 5.继续执行resthen，resthen输出传给resthen的值，由于上一个0then return一个99，所以输出99继续执行2then，执行
		     *   完之后遇到3then，将其加入微任务队列
		     *   微任务队列：[3then]
		     * 6.执行3then，执行完之后遇到5then，将其加入微任务队列
		     *   微任务队列：[5then]
		     * 7.执行5then，执行完之后遇到6then，将其加入微任务队列
		     *   微任务队列：[6then]
		     * 8.执行6then
		     */



<h3 id='三、async/await'>三、async/await</h3>

#### 一、async ####

- async是异步函数的标识符，说明该函数是个异步函数，返回值是个promise对象。

		function fn1() {
		  return 1
		}
		console.log(fn1()) //1
		
		async function fn2() {
		  return 1
		}
		console.log(fn2()) // Promise{<fulfilled>:1}

- 从上面例子可以看到，async函数的返回值是一个promise对象，既然是一个promise对象，那就自然可以使用其原型上的属性，比如then、catch等等。

		fn2()
		.then(r => {
		  console.log(r) // 1
		})

- fn2报错也能被then的第二个回调函数或者catch捕获

        fn2()
        .then(res=>{
          console.log(res)
        },err=>{
          console.log(err)
        }).catch(err=>{
          console.log(err)
        })


#### 二、await ####

1. 理解

- await是async wait的缩写，它等待返回的是一个表达式，不管是不是promise对象都可以，只是说如果返回的是promise对象执行的状态不一样而已，需要注意的是await只能在async函数中使用，看下面例子：

		function sync() {
		  setTimeout(() => {
		    console.log(666)
		  }, 3000)

		}


	   async function test(){
		  await sync() //undefined
		  console.log(888)
	   }
		
       test() 
       // 888
       // 666
       

		async function async1(){
		  return new Promise(resolve => {
		    setTimeout(() => {
              console.log('666')
		      resolve()
		    }, 2000)
		  })
		}
		
		async function test2() {
		  await async1()
		  console.log(888)
		}
		
		test2()
        //666
        //888

- 可以看出上面例子中，如果await等来的是一个promise对象，它会"阻塞"后面的代码，直到这个promise对象有返回结果，不管这个结果是成功还是失败。如果不是一个promise对象，那await后的表达式就是要等待的东西。
- 就算不是promise对象那么await后面的内容还是相当于在then执行，跟promise的区别在于如果等待的是一个promise对象，那么要等待这个对象解析完成，如果没有resolve或者reject那么后面的内容就不会执行

		// eg1
		
		function fn1() {
		  return new Promise(()=> {
		  
		  })
		}
		
		async function fn2() {
		  await fn1()
		  console.log('wait fn1') // 这里的值永远也不会打印，因为函数fn1这个promise对象的状态没有改变
		}
		fn2()


		// eg2
		
		async function fn2() {
		    await 2
		    console.log(24) 
		}
		
		fn2()
		console.log('this') 
		
		//等同于
		 async function fn2() {
		    Promise.resolve(2)
		    .then(r => {
		      console.log(24)
		    })
		 }
		 fn2()
		 console.log('this')
		
		//this
		//24

2. 关于await返回值

- await后是一个promise对象，如果是resolve状态，值就是resolve参数。如果是reject状态，会将错误抛出

		// resolve
		let p = await Promise.resolve(3)
		console.log(p) // 3

		// reject
		let p = await Promise.reject('error')
		console.log(p) // 控制台报错

- await后不是promise对象，则返回值就是该值的本身

		let p = await 3
		console.log(p) // 3

        let p = await function fn(){}
        console.log(p) // [Function: fn]


#### 三、错误捕获 ####

1. await后面如果跟的是promise

   - 可以使用await后面promise的reject或者catch捕获

		async function fn2() {
		    await Promise.reject(2).catch(e=>{
		        console.log(666)
		    })
		    .then(res=>{
		        
		    },e=>{
		       console.log(777)
		   })
		}
		
		
		
		  fn2().then(res=>{
		      console.log(888)
		  },e=>{
		      console.log(999)
		  }).catch(err=>{
		      console.log('555')
		      //console.log(err)
		  })

         //666
         //888 
         //因为错误被内部的promise捕获了，所以fn2进入了成功的回调

2. await后面无论跟的是promise还是其他值

   - 可以使用try...catch...

		async function fn2() {
		    try{
		        await a
		    }catch(e){
		        console.log(666)
		    }
		    
		}
		
		
		
		  fn2().then(res=>{
		      console.log(888)
		  },e=>{
		      console.log(999)
		  }).catch(err=>{
		      console.log('555')
		  })

         //666
         //888
         //因为错误被try...catch...捕获了，所以fn2进入了成功的回调

    - 可以使用fn2()的then第二个参数或者catch

       async function fn2() {
		   
		        await a
		    
		}
		
		
		
		  fn2().then(res=>{
		      console.log(888)
		  },e=>{
		      console.log(999)
		  }).catch(err=>{
		      console.log('555')
		  })

         //999
         //因为错误没被内部捕获，所以进入fn2的then的第二个回调
         
#### 四、实现async/await ####

- async/await实际上是对Generator（生成器）的封装，是一个语法糖

    - async/await自带执行器，不需要手动调用next()就能自动执行下一步
    - async函数返回值是Promise对象
    - await能够返回Promise的resolve/reject的值

- 我们对async/await的实现，其实也就是对应以上三点封装Generator

1. 自动执行

- 我们先来看一下，对于这样一个Generator，手动执行是怎样一个流程

		function* myGenerator() {
		  yield Promise.resolve(1);
		  yield Promise.resolve(2);
		  yield Promise.resolve(3);
		}
		
		// 手动执行迭代器
		const gen = myGenerator()
		gen.next().value.then(val => {
		  console.log(val)
		  gen.next().value.then(val => {
		    console.log(val)
		    gen.next().value.then(val => {
		      console.log(val)
		    })
		  })
		})
		
		//输出1 2 3

- 我们也可以通过给gen.next()传值的方式，让yield能返回resolve的值

		function* myGenerator() {
		  console.log(yield Promise.resolve(1))   //1
		  console.log(yield Promise.resolve(2))   //2
		  console.log(yield Promise.resolve(3))   //3
		}
		
		// 手动执行迭代器
		const gen = myGenerator()
		gen.next().value.then(val => {
		  // console.log(val)
		  gen.next(val).value.then(val => {
		    // console.log(val)
		    gen.next(val).value.then(val => {
		      // console.log(val)
		      gen.next(val)
		    })
		  })
		})

- 显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且yield能返回resolve的值，基于这两个需求，我们进行一个基本的封装，这里async/await是关键字，不能重写，我们用函数来模拟

		function run(gen) {
		  var g = gen()                     //由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环
		
		  function _next(val) {             //封装一个方法, 递归执行g.next()
		    var res = g.next(val)           //获取迭代器对象，并返回resolve的值
		    if(res.done) return res.value   //递归终止条件
		    res.value.then(val => {         //Promise的then方法是实现自动迭代的前提
		      _next(val)                    //等待Promise完成就自动执行下一个next，并传入resolve的值
		    })
		  }
		  _next()  //第一次执行
		}


- 对于我们之前的例子，我们就能这样执行：

		function* myGenerator() {
		  console.log(yield Promise.resolve(1))   //1
		  console.log(yield Promise.resolve(2))   //2
		  console.log(yield Promise.resolve(3))   //3
		}

		run(myGenerator)

- 这样我们就初步实现了一个async/await。简单来说，我们封装了一个run方法，run方法里我们把执行下一步的操作封装成_next()，每次Promise.then()的时候都去执行_next()，实现自动迭代的效果。在迭代的过程中，我们还把resolve的值传入gen.next()，使得yield得以返回Promise的resolve的值
- 这里插一句，是不是只有.then方法这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield后边除了接Promise，还可以接thunk函数，thunk函数不是一个新东西，所谓thunk函数，就是单参的只接受回调的函数，无论是Promise还是thunk函数，其核心都是通过传入回调的方式来实现Generator的自动执行。

2. 返回Promise & 异常处理

- 虽然我们实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：

   - 需要兼容基本类型：这段代码能自动执行的前提是yield后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(gen().next.value)都用Promise.resolve()转化一遍
   - 缺少错误处理：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用Generator.prototype.throw()，把错误抛出来，才能被外层的try-catch捕获到
   - 返回值是Promise：async/await的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise

- 我们改造一下run方法：

		function run(gen) {
		  //把返回值包装成promise
		  return new Promise((resolve, reject) => {
		    var g = gen()
		
		    function _next(val) {
		      //错误处理
		      try {
		        var res = g.next(val) 
		      } catch(err) {
		        return reject(err); 
		      }
		      if(res.done) {
		        return resolve(res.value);
		      }
		      //res.value包装为promise，以兼容yield后面跟基本类型的情况
		      Promise.resolve(res.value).then(
		        val => {
		          _next(val);
		        }, 
		        err => {
		          //抛出错误
		          g.throw(err)
		        });
		    }
		    _next();
		  });
		}


<h3 id='四、try...catch...'>四、try...catch...</h3>

- try...catch...能捕捉到的异常，必须是线程执行已经进入 try catch 但 try catch 未执行完的时候抛出来的,这个时候才能被捕捉到。

1. 之前

- 代码报错的时候，线程执行未进入 try catch，那么无法捕捉异常。
  
   - 比如语法异常（syntaxError），因为语法异常是在语法检查阶段就报错了，线程执行尚未进入 try catch 代码块，自然就无法捕获到异常。

			try{
			    
			        a.
			  
			}catch(e){
			    console.log('捕获到错误了')
			}

        //报错

2. 之中

- 代码报错的时候，线程执行处于 try catch 之中，则能捕捉到异常。

          try{
			   a
			}catch(e){
			    console.log('捕获的错误了')
			}

         //捕获到错误了

3. 之后

- 代码报错的时候，线程已经执行完 try catch，这种不能捕捉到异常。

		try{
		    setTimeout(res=>{
		        a
		    },1000)
		}catch(e){
		    console.log('捕获到错误了')
		}        

       //报错

- setTimeout 里面报错，实际上是 1s 之后执行的代码报错，此时代码块 try catch 已经执行完成，故无法捕捉异常。

		try{
		    function fn(){
		        a
		    }
		}catch(e){
		    console.log('捕获到错误了')
		}
		
		fn()      

       //报错

- 方法定义在 try catch 代码块里面，但是执行方法在 try catch 外，在执行 fn 方法的时候报错，此时 try catch 已经执行完成，故而无法捕捉异常。
- 所以try...catch...捕获不到异步任务
- 解决方案：
    1. 可以将try...catch...写到异步里面

	        setTimeout(res=>{
			   try{
			      a
			   }catch(e){
			     console.log('捕获到错误了')
			   }
			},1000)

    



4. promise

		try{
		    new Promise((reslove,reject)=>{
		        a
               console.log(666)
		    })
               console.log(333)
		}catch(e){
		    console.log('发生错误了')
		}

        //Uncaught (in promise) ReferenceError: a is not defined
        // 333

- 这里线程在执行 a的时候，事实上属于同步执行，try catch 并未执行完成，按理应该能捕捉到异常，这里为啥无法捕捉呢？
  - 这是因为，promise在执行
  
		  	(reslove,reject)=>{
				        a
		     }
   - 这个回调的时候被包裹在了try...catch...里面，其中所有的异常都被内部捕获到了，并未往上抛异常。try...catch...是不能冒泡的，内部捕获了，外部就捕获不到了。
   - 所以还能输出333
   - Promise 的异常都是由 reject 和 Promise.prototype.catch 来捕获，不管是同步还是异步。

			class MyPromise {
			    constructor (handle) {
			      if (!isFunction(handle)) {
			        throw new Error('MyPromise must accept a function as a parameter')
			      }

			      // 添加状态
			      this._status = PENDING

			      // 添加状态
			      this._value = undefined

			      // 添加成功回调函数队列
			      this._fulfilledQueues = []

			      // 添加失败回调函数队列
			      this._rejectedQueues = []

			      // 执行handle
			      try {
			        handle(this._resolve.bind(this), this._reject.bind(this)) 
			      } catch (err) {
			        this._reject(err)
			      }
			   }
			}

     
5. async/await

- 将try...catch写在async函数最外层并不能捕获async...await的异常，而是会走到Promise的异常抛出。

		async function fn(){
		    await a
		    
		}
		
		try{
		    fn()
		}catch(e){
		    console.log('捕获到错误了')
		}

        //报错

- 因为async返回了一个promise，所以执行它相当于在执行promise

- async...await捕获异常，需要将await函数写在try...catch中

		async function fn(){
		    try{
		        await a
		    }catch(e){
		        console.log('捕获到错误了')
		    }
		    
		}
		fn()

       // 捕获到错误了


<h3 id='五、Object&Map&WeakMap&Set&WeakSet' >五、Object&Map&WeakMap&Set&WeakSet</h3>

#### 一、Map和Object的区别 ####

1. Map和Object都是键值对的集合，但Map的键可以是任意类型，而Object的键只能是字符串和Symbol（非字符串会转换为字符串）

   - Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键
   - 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。

2. Map 默认情况下不包含任何键，所有键都是自己添加进去的。不同于 Object 原型链上有一些默认的键。
3. Map 的键值对个数可以轻易通过size属性获取，Object 需要手动计算


#### 二、Map的属性和方法 ####

1. 属性

   - constructor：构造函数
   - size：返回字典中所包含的元素个数

2. 方法

   - 操作方法：
   
       - set(key, value)：向字典中添加新元素
       - get(key)：通过键查找特定的数值并返回
       - has(key)：判断字典中是否存在键key
       - delete(key)：通过键 key 从字典中移除对应的数据
       - clear()：将这个字典中的所有元素删除
       
   - 遍历方法
  
       - Keys()：将字典中包含的所有键名以迭代器形式返回
       - values()：将字典中包含的所有数值以迭代器形式返回
       - entries()：返回所有成员的迭代器
       - forEach()：遍历字典的所有成员

#### 三、WeakMap ####

1. WeakMap特性

   - （1）只接受对象作为键名，不接受其他类型的值作为键名
   - （2）WeakMap的键名引用的对象是弱引用

        - 什么是强引用？

               例如：let obj = {foo:5}
                    let arr = [obj]
                    obj=null

          - 上面代码中，arr数组对于对象{foo:5}就是一个强引用，当obj不在引用这个对象时，这个对象也不会被垃圾回收机制清除，因为arr仍然存在着对对象的引用，必须手动清除引用才会被垃圾回收机制回收

                        arr[0]=null      

         - 所以Map对**键名**所引用的对象也是强引用

               例如：let map = new Map()
                    let obj = {foo:6}
                    map.set(obj,3)
                    obj=null
 
          - 上面代码中，清除obj对{foo:6}的引用，垃圾回收机制也不会回收这个对象，因为还存在着map对这个对象的引用


        - 什么是弱引用？

           - 弱引用和强引用相对，弱引用是指垃圾回收机制在回收这个对象的时候，不会考虑该引用

	               例如：let map = new WeakMap()
	                    let obj = {foo:6}
	                    map.set(obj,3)
	                    obj=null
 
            - 上面代码中，清除obj对{foo:6}的引用，垃圾回收机制就会回收这个对象，它不考虑WeakMap对该对象的引用，因为WeakMap的引用是弱引用


   - （3）不可遍历

       - 正因为WeakMap对键名所引用的对象是弱引用关系，因此WeakMap内部成员是会取决于垃圾回收机制有没有执行，运行前后成员个数很可能是不一样的，而垃圾回收机制的执行又是不可预测的，因此不可遍历
       - 也因此他没有size属性和那些遍历方法


2. WeakMap的属性和方法

- （1）属性

        - constructor：构造函数

- （2）方法

       - 相比map也没有clear方法

       - set(key, value)：向字典中添加新元素
       - get(key)：通过键查找特定的数值并返回
       - has(key)：判断字典中是否存在键key
       - delete(key)：通过键 key 从字典中移除对应的数据
       

3. WeakMap的应用

- （1） 通过 WeakMap 缓存计算结果

     - 使用 WeakMap，你可以将先前计算的结果与对象相关联，而不必担心内存管理。以下功能 countOwnKeys() 是一个示例：它将以前的结果缓存在 WeakMap 中 cache。

				const cache = new WeakMap();
				
				function countOwnKeys(obj) {
				  if (cache.has(obj)) {
				    return [cache.get(obj), 'cached'];
				  } else {
				    const count = Object.keys(obj).length;
				    cache.set(obj, count);
				    return [count, 'computed'];
				  }
				}

- （2）部署私有属性

     - 利用弱映射，将内部属性设置为实例的弱引用对象，当实例删除时，私有属性也会随之消失，因此不会内存泄漏

			const _counter = new WeakMap();
			const _action = new WeakMap();
			
			class Countdown {
			  constructor(counter, action) {
			    _counter.set(this, counter);
			    _action.set(this, action);
			  }
			  
			  dec() {
			    let counter = _counter.get(this);
			    counter--;
			    _counter.set(this, counter);
			    if (counter === 0) {
			      _action.get(this)();
			    }
			  }
			}
			


			let invoked = false;
			
			const countDown = new Countdown(3, () => invoked = true);
			countDown.dec();
			countDown.dec();
			countDown.dec();
			
			console.log(`invoked status: ${invoked}`)


#### 四、Set ####

- Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。判断类似于全等，但是在Set 中认为 NaN 与 NaN 相等

1. Set的属性和方法

    - 属性：

        - constructor：构造函数
        - size：返回集合所包含的元素个数

   - 方法

      - 操作方法：
   
       - add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。
       - delete(value)：删除某个值，删除成功返回 true，否则返回 false。
       - has(value)：返回一个布尔值，表示该值是否为 Set 的成员。
       - clear()：清除所有成员，没有返回值。
       
      - 遍历方法
  
       - Keys()：返回键名的遍历器。
       - values()：返回键值的遍历器。
       - entries()：返回键值对的遍历器
       - forEach()：使用回调函数遍历每个成员。

       - 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。


#### 五、WeakSet ####

- 成员必须都是对象
- 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。
- WeakSet 不可迭代，因此不能被用在 for-of 等循环中
- WeakSet 没有 size 属性。

1. 属性和方法

- （1）属性

        - constructor：构造函数

- （2）方法

       - 相比Set也没有clear方法

       - add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。
       - delete(value)：删除某个值，删除成功返回 true，否则返回 false。
       - has(value)：返回一个布尔值，表示该值是否为 Set 的成员。
   

























<h1 id='node总结'><font color='darkgrey'>node总结</font><h1>