* [js总结](#js总结)
  * [一、js事件流](#一、js事件流)
  * [二、token、cookie、session](#二、token、cookie、session)
  * [三、深入理解函数执行上下文](#三、深入理解函数执行上下文)
  * [四、闭包](#四、闭包)
  * [五、js函数的参数按值传递](#五、js函数的参数按值传递)
  * [六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？](#六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？)
  * [七、ASI自动分号插入机制](#七、ASI自动分号插入机制)
  * [八、V8如何存储js对象](#八、V8如何存储js对象)
  * [九、垃圾回收机制](#九、垃圾回收机制)
  * [十、V8引擎对垃圾回收的优化](#十、V8引擎对垃圾回收的优化)
  * [十一、浏览器和node事件循环的区别](#十一、浏览器和node事件循环的区别)
  * [十二、观察者模式和发布订阅模式](#十二、观察者模式和发布订阅模式)
  * [十三、判断js的数据类型的方法](#十三、判断js的数据类型的方法)
  * [十四、js数据类型转换](#十四、js数据类型转换)
  * [十五、深拷贝与浅拷贝](#十五、深拷贝与浅拷贝)
  *
  
* [css总结](#css总结)
  * [一、BFC（块级格式化上下文）](#一、BFC（块级格式化上下文）)
  * [二、清除浮动](#二、清除浮动)
  * [三、css3动画](#三、css3动画)
  * [四、box-sizing](#四、box-sizing)
  * [五、](#五、)
  * [六、](#六、)
* [vue总结](#vue总结)
  * [一、MVVM](#一、MVVM)
  * [二、vue双向绑定原理](#二、vue双向绑定原理)
  * [三、vue双向绑定原理再理解](#三、vue双向绑定原理再理解)
  * [四、diff算法](#四、diff算法)
  * [五、vue的nextTick](#五、vue的nextTick)
  * [六、vue2.0为什么不能检查数组变化](#六、vue2.0为什么不能检查数组变化)
* [网络总结](#网络总结)
  * [一、http请求和响应](#一、http请求和响应)
  * [二、http的请求方法](#二、http的请求方法)
  * [三、http常用状态码](#三、http常用状态码)
  * [四、](#四、)
* [es6总结](#es6总结)
  * [一、promise](#一、promise)
  * [二、promise实现原理](#二、promise实现原理)
  * [三、async/await](#三、async/await)
  * [四、try...catch...](#四、try...catch...)
  * [五、Object&Map&WeakMap&Set&WeakSet](#五、Object&Map&WeakMap&Set&WeakSet)
* [node总结](#node总结)

<h1 id='js总结'>js总结<h1>

<h3 id='一、js事件流'>一、js事件流</h3>

1.事件流

   - js事件流就是指，元素触发事件时，事件在页面中的传播过程。它一共分为三个阶段，捕获阶段、处于目标阶段和冒泡阶段。捕获阶段就是由最不具体的节点先接收事件，由上至下依次传播直至目标节
点。冒泡阶段就是目标节点先接收事件，由下至上依次传播直至window。

   - 默认情况下，事件使用冒泡事件流，不使用捕获事件流。addEventListener方法可以显式的指定事件是使用捕获事件流还是冒泡事件流。addEventListener事件接受三个参数，第一个事件名称，第二个是作为事件处理程序的函数，第三个为一个布尔值，true表示捕获阶段，false表示冒泡阶段（btn.addEventListener('click',handler,false)）。addEventListener是DOM2级事件，与DOM0级事件（btn.onclick)不同的是同一事件（如click)它可以添加多个事件处理程序,执行顺序按照添加时的顺序。与之对应的移除事件处理程序的方法是removeEventListener,接收的参数和添加事件处理程序时的参数是相同的，所以这也意味着，添加的匿名事件处理程序函数将无法移除。DOM0级移除（btn.onclick=null）。

   - IE实现了和DOM中类似的两个方法attachEvent和detachEvent,这两个方法接收相同的两个参数，事件名称(注意是onclick)和事件处理程序函数（btn.attachEvent('onclick',handler)）。由于IE8及更早的版本只支持事件冒泡，所以通过attachEvent添加的事件都会被添加到冒泡阶段。attachEvent和addEventListener一样都可以为同一个元素添加相同的事件，不过它俩不同的是，attachEvent添加的事件处理程序不是以添加的顺序执行的，而是以相反的顺序执行的。


   - IE中的attachEvent和DOM中的方法的主要区别还在于，事件处理程序的作用域不同，使用DOM级方法的情况下，事件处理程序会在其所属元素的作用域运行，this执行该元素。使用attachEvent情况下，事件处理程序会在全局作用域中运行，因此this等于window

 2.事件委托（事件代理）

  - 事件委托就是利用了事件冒泡，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。事件委托的好处就是将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a,span,div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历

 
 3.阻止冒泡和默认行为

    event.preventDefault可以阻止默认行为但不阻止冒泡
    event.stoppropagation 可以阻止冒泡但不阻止默认行为
    return false 可以阻止默认行为但不阻止冒泡



<h3 id='二、token、cookie、session'>二、token、cookie、session</h3>

#### 一、产生背景 ####

- 由于http是无状态的，它不会去记录服务器和浏览器的会话信息，对它来说每一次请求都是一个新的请求。随着网络的发展，比如购物车功能就必须知道用户身份才能够执行接下来的一系列操作，所以就产生了cookie、session、token来帮助服务器来记住一些信息。

#### 二、cookie ####

1. 概念

   - cookie是http头部的一个字段，它是由服务器产生的，是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上
   - cookie是存在当前访问服务器的浏览器中的，比如你使用的是chrome浏览器，cookie就会存在chrome浏览器中，如果此时你换成了Firefox等其他的浏览器，因为Cookie刚才是存储在Chrome里面的，所以服务器又蒙圈了，不知道你是谁，就会给Firefox再次发送一个cookie。

2. cookie识别用户身份过程：

   - 浏览器第一次访问服务端时，服务器此时肯定不知道他的身份，所以创建一个独特的身份标识数据，格式为key=value（比如：isLogin=true），放入到Set-Cookie字段里，随着响应报文发给浏览器。
   - 浏览器看到有Set-Cookie字段以后就知道这是服务器给的身份标识，于是就保存起来，下次请求时会自动将此key=value值放入到Cookie字段中发给服务端。
   - 服务端收到请求报文后，发现Cookie字段中有值，就能根据此值识别用户的身份然后提供个性化的服务。

3. cookie的缺点：

   - 用户本人可以通过修改document.cookie="isLogin = true"伪造登陆凭证
   - 如果将账户的一些信息都存入Cookie中的话，一旦信息被拦截，那么我们所有的账户信息都会丢失掉。
   - 能存储的数据量不能超过 4kb
   - 一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie
   - 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token


#### 三、session ####

1. 概念

     - session 是另一种记录服务器和客户端会话状态的机制
     - session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中

2. session认证流程：

     - 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，开辟了一块 Session 空间（创建了Session对象），同时生成一个SessionId
     - 请求返回时将此 Session 的唯一标识信息 SessionId放入到Set-Cookie字段里，随着响应报文发给浏览器
     - 浏览器接收到服务器返回的 SessionId 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionId 属于哪个域名
     - 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionId，再根据SessionId查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

3. 有了 Cookie 为什么还要 Session

     - 使用 session 只需要在客户端保存一个 sessionId，实际上大量数据都是保存在服务端。如果全部用 cookie，数据量大的时候客户端是没有那么多空间的（ 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie）。
     - 全部在客户端保存，服务端无法验证，这样伪造和仿冒会更加容易。（伪造一个随机的id很难，但伪造另一个用户名是很容易的）
     - cookie 只是实现 session 的其中一种方案。虽然是最常用的，但并不是唯一的方法。(禁用cookie后还有其他方法存储，比如放在url中,但放在url中涉及安全性和SEO的影响)
     - 全部保存在客户端，那么一旦被劫持，全部信息都会泄露
     - 客户端数据量变大，网络传输的数据量也会变大

4. session缺点

     - Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。（解决方法：Nginx ip_hash 策略、Session 复制、共享 Session）
     - Session存储在服务器，大量的存储会给服务器带来压力

5. 如何考虑分布式 Session 问题？

      - 在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

      - 分布式 Session 一般会有以下几种解决方案：

         - （1）session 复制

                - 采用 session 复制方案，整体的流程非常简单：假设现在有三台服务器，当一个 session 在其中一台服务器上被创建，则同时把这个 session 复制到其他两台服务器上。这样当用户的请求无论到达哪台服务器，都会有相应的 session 数据。
                - 这种方案的优势在于服务器可以任意水平扩展，每个服务器都保留着所有的 session 信息，当加入一台服务器只需要把所有的 session 信息复制过去即可。
                - 但是劣势更加明显
                     - 每个服务器上都保存着全部的 session 信息，服务器占用的资源大大增加。
                     - session 同步需要占用网络带宽，最重要的是如果采用的异步复制方式，数据会有短暂性的不一致，可能会导致用户访问失败。

         - （2）Nginx ip_hash 策略
         
               - nginx 可以根据“hash_ip”算法将同一个 IP 的请求固定到某台服务器，这样来自于同一个 ip 的 session 请求总是请求到同样的服务器。
               - 这种方式比 session 同步方式要好很多，每台服务器只存储对应的 session 数据，这大大节省了内存资源，而且服务器之间没有数据同步过程。当有新服务器加入的时候，只需要修改负载均衡器的配置即可，这样很方便就支持了服务器水平扩展。
               - 但是，同时也面临着一些不足

                     - 服务器重启意味着对应的 session 信息丢失，这在一些重要的业务场景中是不允许的
                     - 服务器的水平扩展需要修改负载均衡器的配置，修改之后可能会导致之前的 session 重新分布，这样会导致一部分用户路由不到正确的 session

        - （3）共享 Session

               - 现在应用更广泛的分布式 session 技术是把 session 数据彻底从业务服务器中剥离，单独存储在其他外部设备中，而这些外部设备可以采用主备或者主从，甚至集群的模式来达到高可用。比如现在最常用的方案是把 session 数据存储在 redis 中，虽然从 redis 读写 session 数据需要花费一定的网络耗时，但是对于一般的应用来说在可以接受范围之内。
               - 这种方案好处是整体架构更加清晰，也更加灵活，应用的服务器整体扩展能力再也不用考虑 session 的影响，而 session 的问题被转移到外部设备，通常可以利用内存性 NOSql 来解决性能问题，而这些外部设备一般都会有对应的分布式集群方案，例如 redis，可以利用主从或者哨兵模式甚至集群来提供更大规模的数据支撑能力。

  ![](./images/共享session.jpg)


6. 禁用cookies，如何使用session

     - 如果禁用了 Cookies，服务器仍会将 sessionId 以 cookie 的方式发送给浏览器，但是，浏览器不再保存这个cookie (即sessionId) 了。
     - 如果想要继续使用 session，需要采用 URL 重写 的方式来实现

#### 四、Cookie 和 Session 的区别 ####

- 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，session在超过一定的操作时间(通常为30分钟)后会失效，但是当关闭浏览器时，为了保护用户信息，会自动调用session.invalidate()方法，该方法会清除掉session中的信息。
- 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。


#### 五、token ####

1. 概念

     - Token是在服务端将用户信息以及用户信息经过算法生成的签名传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息通过验证签名判断该请求的合法性。
     - 基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

2. token认证流程：

     - 客户端使用用户名跟密码请求登录
     - 服务端收到请求，去验证用户名与密码
     - 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
     - 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
     - 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
     - 服务端收到请求，然后去验证客户端请求里面带着的 token（使用相同加密算法加密，将结果和token中的签名对比） ，如果验证成功，就向客户端返回请求的数据

3. token 的过期

   - 那我们如何控制 token 的有效期呢？很简单，把「过期时间」和数据一起塞进去，验证时判断就好

4. token优点

    - 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
    - token 完全由应用管理，所以它可以避开同源策略

5. access token和refresh token

    - token，作为权限守护者，最重要的就是「安全」。业务接口用来鉴权的 token，我们称之为 access token。越是权限敏感的业务，我们越希望 access token 有效期足够短，以避免被盗用。但过短的有效期会造成 access token 经常过期，过期后怎么办呢？

        - 一种办法是，让用户重新登录获取新 token，显然不够友好，要知道有的 access token 过期时间可能只有几分钟。
        - 另外一种办法是，再来一个 token，一个专门生成 access token 的 token，我们称为 refresh token。

            - access token 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活
            - refresh token 用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理

        - 有了 refresh token 后，几种情况的请求流程变成这样：
   ![](./images/access token&refresh token.jpg)



#### 六、JWT ####

1. 概念

     - JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。它是一种成熟的 token 字符串生成方案,相当于规定了怎样定义一个token

2. JWT由三部分组成：头部、负载和签名

     - Header

         - Header通常由两部分组成：token的类型(即 JWT)和使用的签名算法，例如 HMAC SHA256 或 RSA。
         
			例如：{

				  "alg": "HS256",
				  "typ": "JWT"
				 }

        - 指定类型和签名算法后，Json 块被 Base64Url 编码形成 JWT 的第一部分。


    - Payload
    
        - 负载是Token要存储的信息（比如存储用户姓名和昵称信息）
        - JWT 规定了7个官方字段，供选用。
        
            - iss (issuer)：签发人
            - exp (expiration time)：过期时间
            - sub (subject)：主题
            - aud (audience)：受众
            - nbf (Not Before)：生效时间
            - iat (Issued At)：签发时间
            - jti (JWT ID)：编号
 
       - 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

			例如：{
	
				  "name": "John Doe",
				  "admin": true
				}
        - 然后 payload Json 块会被Base64Url 编码形成 JWT 的第二部分。


    - signature

       - JWT 的第三部分是一个签证信息，这个签证信息由三部分组成
       
         - header (base64后的)
         - payload (base64后的)
         - secret（密钥）

       - 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名形成JWT的第三部分

			HMACSHA256(
			  base64UrlEncode(header) + "." +
			  base64UrlEncode(payload),
			  secret)

    - 最后将这三部分用.号连接，就可以得到了一个Token了。
   ![](./images/JWT.jpg)

3. JWT 的几个特点：

    - JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
    - JWT 不加密的情况下，不能将秘密数据写入 JWT。
    - JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
    - JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
    - JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
    - 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。


#### 七、session和token ####
    
- session 是「种在 cookie 上、数据存在服务端」的认证方案，token 是「客户端存哪都行、数据存在 token 里」的认证方案。
- token保存在客户端，在分布式环境下不需要做额外工作。而session因为保存在服务端，分布式环境下需要实现多机数据共享
- session一般需要结合Cookie实现认证，所以需要浏览器支持cookie，因此移动端无法使用session认证方案
- JWT的payload使用的是base64编码的，因此在JWT中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全
- 经过编码之后JWT将非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以JWT一般放在local storage里面。并且用户在系统中的每一次http请求都会把JWT携带在Header里面，HTTP请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用token的HTTP请求比使用session的开销大得多
- session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 token 是令牌，访问资源接口（API）时所需要的资源凭证。token 使服务端无状态化，不会存储会话信息。
- session 和 Token 并不矛盾，作为身份认证 token 安全性比 session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 session 来在服务器端保存一些状态。

<h3 id='三、深入理解函数执行上下文'>三、深入理解函数执行上下文</h3>

#### 一、词法作用域（静态作用域）和动态作用域 ####

1. 作用域

- 作用域是指程序源代码中定义变量的区域，作用域规定了如何查找变量，也就是当前执行代码对变量的访问权限
- JavaScript采用词法作用域，也叫静态作用域

2. 静态作用域和动态作用域

- 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。
- 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

			var value = 1;
	
			function foo() {
			    console.log(value);
			}
			
			function bar() {
			    var value = 2;
			    foo();
			}
			
			bar();
			
			// 结果是 ???

        上面例子，如果是静态作用域结果就为1，动态作用域结果就为2，原因我们看接下来的分析

3. 作用域链

    - 我们知道在执行一段代码的时候，会创建对应的执行上下文，执行上下文中包含了this、变量对象VO、作用域链。但在创建执行上下文之前，我们还有一个创建作用域链的过程，最后我们的作用域链就是这两个作用域链之和。
    - 上面我们讲到函数的作用域在函数定义的时候就已经决定了，这是因为我们的函数有一个内部属性[[scope]]，当函数创建时，就会保存所有的父变量对象到其中。当执行函数时，创建函数的执行上下文，先创建变量对象，然后复制函数[[scope]]属性创建作用域链，将变量对象加到作用域的最前边形成完整作用域链，开始执行函数，随着函数的执行，修改 AO 的属性值。

         例：
			var value = 1;
		
			function foo() {
			    console.log(value);
			}
			
			function bar() {
			    var value = 2;
			    foo();
			}
			
			bar(); // 1

     - 过程分析：

        - （1）foo函数被创建，保存作用域链到内部属性[[scope]]
        
               foo.[[scope]] = [
				    globalContext.VO
				];
        
        - （2）bar函数被创建，保存作用域链到内部属性[[scope]]

               bar.[[scope]] = [
				    globalContext.VO
				];

        - （3）执行bar函数，创建bar函数执行上下文，bar函数执行上下文被压入执行上下文栈

				ECStack = [
				    barContext,
				    globalContext
				];
		
        - （4）barscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

				barContext = {
				    Scope: barscope.[[scope]],
				}

        - （5）第二步：用 arguments 创建变量对象，随后初始化活动对象，加入形参、函数声明、变量声明

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        value: undefined
				    }，
				    Scope: barscope.[[scope]],
				}

        - （6）第三步：将变量对象压入 barscope 作用域链顶端

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        value: undefined
				    },
				    Scope: [VO, [[Scope]]]
				}

       - （7）准备工作做完，开始执行函数，随着函数的执行，函数执行时，变量对象（VO）变为活动对象AO，修改 AO 的属性值

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        vaule: 2
				    },
				    Scope: [AO, [[Scope]]]
				}

       - （8）执行过程中，遇到foo()，则创建foo的执行上下文将其压入执行上下文栈中，和上边过程一样，复制函数[[scope]]属性创建作用域链

                fooContext = {
				    Scope: fooscope.[[scope]],
				}

       - （9）创建变量对象
 
                fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				    }，
				    Scope: fooscope.[[scope]],
				}

         - （10）将变量对象压入 fooscope 作用域链顶端

				fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        }				   
				    },
				    Scope: [VO, [[Scope]]]
				}

               这块就能看出，foo的作用域链是自己的变量对象+定义foo时的父级作用域链，所以最后结果为1
                
        - （11）准备工作做完，开始执行函数，随着函数的执行，函数执行时，变量对象（VO）变为活动对象AO，修改 AO 的属性值

				fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				    },
				    Scope: [AO, [[Scope]]]
				}


#### 二、函数执行上下文（EC）####
https://segmentfault.com/a/1190000009041008

- 每当控制器转到ECMScript的可执行代码的时候，就会进入一个执行上下文
- 可执行代码包括：

   - 全局代码：例如加载外部js文件或者本地的<script></script>标签内的代码。全局代码不包括任何函数体内的代码，这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。
      
   - 函数代码：任何一个函数体内的代码，需要注意的是，任何一个函数体的代码是不包括内部函数的代码的

   - Eval代码：eval内部的代码

#### 三、执行环境栈（ECS）####

 - 我们知道js引擎是单线程的，也就是说同一时间只能发生一件事情，其他事情将被放在执行栈中排队等待。
 
 - 所以当浏览器首次载入你的脚本的时候，默认进入全局执行上下文，这时全局上下文就会被推入执行环境栈。如果你在你的全局代码中调用一个函数,这时，你的程序时序将进入被调用的函数，并创建一个新的执行上下文，并将该执行上下文推入执行环境栈的顶部。如果你调用的函数内部又调用了一个内部函数，会重复上述过程。

 - 上述是在一层一层的创建执行上下文的过程，并没有执行代码，该过程中会存在一个变量对象（VO）。
 
 - 先创建完所有的执行上下文之后才开始执行上下文，该过程中会存在一个活动对象（AO）。
 
 - 浏览器总会执行位于栈顶的执行上下文，一旦当前执行上下文函数执行结束，它将从栈顶弹出，并将上下文控制权交给当前栈

#### 四、变量对象（VO）和活动对象（AO）####

 1. 变量对象（VO）

    - js的执行上下文都有一个对象用来存放执行上下文可被访问但是不能被delete的函数标识符、形参、变量声明等，这个对象就叫变量对象（VO），它们会被挂在这个对象上。对象的属性名对应它们的名字，对象的属性值对应它们的值，但这个对象是规范上的或者说是引擎实现上的不可在js环境中访问到的活动对象。

 2. 活动对象（AO）

    - 有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文中的变量对象就会被激活，也就是该上下文中的函数标识符、形参、变量声明等就可以被访问到了。

#### 五、执行上下文建立细节分析 ####

1. 创建阶段（当函数被调用，函数所在的执行上下文被推入执行环境栈中，还未执行函数内部代码）

    - 创建作用域链（Scope Chain）
    - 创建参数、函数和变量
    - 求this的值

      - 我们可以将每个执行上下文抽象成一个对象，这个对象具有三个属性

	          ECObj={
	             scopeChain:{/*变量对象+所有腹肌执行上下文的变量对象*/}，
	             variableObject:{/*函数 arguments/参数，内部变量和函数声明*/}，
	             this:{}
	          }

2. 执行阶段

   - 初始化变量的值和函数的引用，执行代码

3. 解释器执行代码流程

   - （1）查找调用函数的代码
      
   - （2）执行代码之前，先进入创建执行上下文阶段

      - 初始化作用域链

         - 进入一个新的执行环境之后就会创建该环境的作用域链。
         - 作用链的作用是保证执行环境有权访问的所有变量和函数的有序访问。
         - 作用链的前端始终都是当前执行环境的活动对象，作用域链的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。

      - 创建变量对象（VO）

         - 创建arguments对象，检查上下文
         - 初始化参数名称和值并创建引用的复制
         - 扫描上下文的函数声明（而非函数表达式）

           - 为发现的每一个函数，在变量对象上创建一个属性，属性名字为函数名字，其有一个指向函数在内存中的引用
           - 如果有和函数名字相同的属性已经存在，则就不用新建函数名字的属性了，直接覆盖该属性
                
         - 扫描上下文的变量声明

           - 为发现的每个变量声明，在变量对象上创建一个属性，属性名字为变量的名字，并且将变量的值初始化为undefined
           - 如果有和变量名字相同的属性已经存在，将不会进行任何操作并继续扫描（注意和函数声明的区别）

         - 求出上下文内部的this值

   - （3）激活/代码执行阶段

       - 在当前上下文上运行/解释函数代码，并随着代码一行行执行为变量赋值

			     例如：function foo(i){
			            var a = 'hello'
			            var b = function(){}
			            function c(){}
			          }
			
			          foo(22)

    
        - 当我们调用foo(22)时，先进入创建执行上下文阶段(VO初始化阶段)

    
			         ECObj={
			           scopeChain:{...},
			           variableObject:{
			             arguments:{
			                0:22,
			                length:1
			             },
			             i:22,
			             c:pointer to function c(),
			             a:undefined,
			             b:undefined
			           },
			           this:{...}
			         }
 
        - 正如上述过程所述：VO的初始化过程是有顺序的：形参->函数声明->变量声明

           - 形参：变量对象的一个属性，其属性名为形参的名字，属性值为实参的值，如果没有传递参数，其值为undefined
           - 函数声明：变量对象的一个属性，其属性名和属性值都是函数对象创建出来的，如果变量对象已经包含了相同名字的属性，则替换它的值

		                例：function foo1(a){
		                     console.log(a)
		                     function a(){}
		                   }
		
		                   foo1(20) //'function a(){}'

           - 变量声明：变量对象的一个属性，其属性名即如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性

		                例1：function foo2(a){
		                      console.log(a)
		                      var a = 10  
		                    }
		              
		                    foo2(20) //'20'
		
		                例2：function foo2(){
		                      console.log(a)
		                      var a = 10  
		                      function a(){}
		                    }
		              
		                    foo2(20) //'function a(){}'

           - 函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值

			                例1：function foo3(a){
			                      var a = 10  
			                      function a(){}
			                      console.log(a)
			                    }
			               
			                    foo3(20) //'10'
			
			                
			                例2：function foo3(a){
			                      var a
			                      function a(){}
			                      console.log(a)
			                    }
			               
			                    foo3(20) //'function a(){}'


       - （4） 然后是执行阶段（AO）

            - 正如上面过程所述，创建的过程仅负责处理定义属性的名字，而并不为他们指派具体的值，当然还有对形参/实参的处理。一旦创建阶段完成，执行流进入函数并且激活/代码执行阶段，看下面函数执行完成后的样子：

                          ECObj={
				           scopeChain:{...},
				           variableObject:{
				             arguments:{
				                0:22,
				                length:1
				             },
				             i:22,
				             c:pointer to function c(),
				             a:'hello',
				             b:pointer to function privateB()
				           },
				           this:{...}
				         }


#### 六、总结 ####

  1. 函数作用域链分为两部分，[[scope]]中的作用域链+变量对象
  1. EC分为两个阶段。创建执行上下文和执行代码
  2. 每个EC都可以抽离成一个对象，这个对象具有三个属性，分别为：作用域链Scope，VO/AO（VO和AO只能有一个）以及this
  3. 函数EC中的AO在进入函数EC时，确定了arguments对象的属性，在执行函数EC时，其他变量属性具体化
  4. EC创建过程是有先后顺序的：参数声明 > 函数声明 > 变量声明
  

<h3 id='四、闭包'>四、闭包</h3>

#### 一、概念 ####

- 闭包是指有权访问另一个函数作用域中的变量的函数
 - 闭包的本质就是当前环境中存在指向父级作用域的引用

         例：function f1() {
			  var a = 2
			  function f2() {
			    console.log(a);//2
			  }
			  return f2;
			}
			var x = f1();
			
- 上面函数如果只执行到这里是没有产生闭包的，因为当js引擎一进入程序的时候，就创建了一个全局执行上下文。然后在全局代码中又调用了函数f1()这时又产生了f1的函数执行上下文，由于没有调用f2函数，所以没有产生f2函数的执行上下文，所以当前环境指的是f1的作用域，所以当前环境中并没有对父级作用域的引用，所以没有产生闭包

- 如果要产生闭包最后加一句 x()就可以了

#### 二、原理理解 ###

1. 理论上的闭包

- 闭包是指那些能够访问自由变量的函数。
- 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
- 由此，我们可以看出闭包共有两部分组成：

   - 闭包 = 函数 + 函数能够访问的自由变量

				举个例子：
				
				var a = 1;
				
				function foo() {
				    console.log(a);
				}
				
				foo();

    - foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。
    - 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……

- 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。

2. 实践上的闭包

- ECMAScript中，闭包指的是：

    - 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
    - 从实践角度：以下函数才算是闭包：
    
       - 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
       - 在代码中引用了自由变量

	     	var scope = "global scope";
			function checkscope(){
			    var scope = "local scope";
			    function f(){
			        return scope;
			    }
			    return f;
			}
			
			var foo = checkscope();
			foo();

         - 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
         - 全局执行上下文初始化
         - 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
         - checkscope 执行上下文初始化，创建变量对象、作用域链、this等
         - checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
         - 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
         - f 执行上下文初始化，创建变量对象、作用域链、this等
         - f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

      - 了解到这个过程，我们应该思考一个问题，那就是：

         - 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

            - 我们知道 f 执行上下文维护了一个作用域链：

					fContext = {
					    Scope: [AO, checkscopeContext.AO, globalContext.VO],
					}

              - 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。

     - 所以，让我们再看一遍实践角度上闭包的定义：

       - 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
       - 在代码中引用了自由变量


					接下来，看这道刷题必刷，面试必考的闭包题：
					
					var data = [];
					
					for (var i = 0; i < 3; i++) {
					  data[i] = function () {
					    console.log(i);
					  };
					}
					
					data[0]();
					data[1]();
					data[2]();
					答案是都是 3，让我们分析一下原因：
					
					当执行到 data[0] 函数之前，此时全局上下文的 VO 为：
					
					globalContext = {
					    VO: {
					        data: [...],
					        i: 3
					    }
					}
					当执行 data[0] 函数的时候，data[0] 函数的作用域链为：
					
					data[0]Context = {
					    Scope: [AO, globalContext.VO]
					}
					data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。
					
					data[1] 和 data[2] 是一样的道理。
					
					所以让我们改成闭包看看：
					
					var data = [];
					
					for (var i = 0; i < 3; i++) {
					  data[i] = (function (i) {
					        return function(){
					            console.log(i);
					        }
					  })(i);
					}
					
					data[0]();
					data[1]();
					data[2]();
					当执行到 data[0] 函数之前，此时全局上下文的 VO 为：
					
					globalContext = {
					    VO: {
					        data: [...],
					        i: 3
					    }
					}
					跟没改之前一模一样。
					
					当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：
					
					data[0]Context = {
					    Scope: [AO, 匿名函数Context.AO globalContext.VO]
					}
					匿名函数执行上下文的AO为：
					
					匿名函数Context = {
					    AO: {
					        arguments: {
					            0: 0,
					            length: 1
					        },
					        i: 0
					    }
					}
					data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。
					
					data[1] 和 data[2] 是一样的道理。


#### 三、闭包的表现形式 ####

 1. 返回一个函数。刚刚已经举例。
 2. 作为函数参数传递

		    var a = 1;
			function foo(){
			  var a = 2;
			  function baz(){
			    console.log(a);
			  }
			  bar(baz);
			}
			function bar(fn){
			  // 这就是闭包
			  fn();
			}
			// 输出2，而不是1
			foo();

#### 四、闭包的用途 ####

* 可以读取内部函数的变量
* 让这些变量的值始终保存在内存中，不会被调用后就被垃圾回收机制收回
* 用来模块化代码（类块级作用域）

#### 五、优点 ####

* 可以将一个变量长期驻扎在内存中
* 避免全局变量的污染
* 私有成员的存在

#### 六、缺点 ####

* 会使函数的变量被保存在内存中，内存消耗极大，会造成网页性能问题，在IE中会导致内存泄漏
* 闭包会在父函数外部改变父函数内部变量的值。所以，如果把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，注意不要随意改变父函数内部的值

<h3 id='五、js函数的参数按值传递'>五、js函数的参数按值传递</h3>

#### 一、概念 ####

- ECMAScript中所有函数的参数都是按值传递的。
- 按值传递：也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。
- 按引用传递：就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。


   - 基本类型值

			var value = 1;
			function foo(v) {
			    v = 2;
			    console.log(v); //2
			}
			foo(value);
			console.log(value) // 1

            很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，
            函数中修改的都是 _value 的值，而不会影响原来的 value 值。


   - 复杂类型

           var obj = {
			    value: 1
			};
			function foo(o) {
			    o.value = 2;
			    console.log(o.value); //2
			}
			foo(obj);
			console.log(obj.value) // 2


- 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按"引用传递"成功呢？而这究竟是不是引用传递呢？

			var obj = {
			    value: 1
			};
			function foo(o) {
			    o = 2;
			    console.log(o); //2
			}
			foo(obj);
			console.log(obj.value) // 1

- 上面例子，如果 JavaScript 采用的是引用传递，就是obj和o两个是绑定在一块的，o指向了新的值，obj必定也指向新的值
- 所以对于引用类型拷贝的是指向堆内存的指针，所以也是值的传递


			
            

<h3 id='六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？'>六、JavaScript是如何运行起来的？解释型语言和编译型语言的差异是什么？</h3>

#### 一、前言 ####

- 我们编写的源代码是人类语言，我们自己能够轻松理解；但是对于计算机硬件（CPU），源代码就是天书，根本无法执行，计算机只能识别某些特定的二进制指令，在程序真正运行之前必须将源代码转换成二进制指令。所谓的二进制指令，也就是机器码，是 CPU 能够识别的硬件层面的“代码”，然而，究竟在什么时候将源代码转换成二进制指令呢？不同的编程语言有不同的规定：

     - 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（Windows 下的 .exe），比如C语言、C++、Golang、Pascal（Delphi）、汇编等，这种编程语言称为编译型语言，使用的转换工具称为编译器。
     - 有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 Python、JavaScript、PHP、Shell、MATLAB 等，这种编程语言称为解释型语言，使用的转换工具称为解释器。

- Java 和 C# 是一种比较奇葩的存在，它们是半编译半解释型的语言，源代码需要先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行。Java 引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率；C# 是后来的跟随者，但是 C# 一直止步于 Windows 平台，在其它平台鲜有作为。

#### 二、编程语言  ####

- 编程语言可以分为机器语言、汇编语言、高级语言。

     - 机器语言：由 0 和 1 组成的二进制码，对于人类来说是很难记忆的，还要考虑不同 CPU 平台的兼容性。
     - 汇编语言：用更容易记忆的英文缩写标识符代替二进制指令，但还是需要开发人员有足够的硬件知识。
     - 高级语言：更简单抽象且不需要考虑硬件，但是需要更复杂、耗时更久的翻译过程才能被执行。

- 高级语言一定要转化为机器语言才能被计算机执行，而且越高级的语言转化的时间越久。高级语言又可以分为解释型语言、编译型语言。


#### 三、编译型语言 ####

- 对于编译型语言，开发完成以后需要将所有的源代码都转换成可执行程序，比如 Windows 下的.exe文件，可执行程序里面包含的就是机器码。只要我们拥有可执行程序，就可以随时运行，不用再重新编译了，也就是“一次编译，无限次运行”。

     - 在运行的时候，我们只需要编译生成的可执行程序，不再需要源代码和编译器了，所以说编译型语言可以脱离开发环境运行。

     - 编译型语言一般是不能跨平台的，也就是不能在不同的操作系统之间随意切换。

     - 编译型语言不能跨平台表现在两个方面：

          1. 可执行程序不能跨平台

              - 可执行程序不能跨平台很容易理解，因为不同操作系统对可执行文件的内部结构有着截然不同的要求，彼此之间也不能兼容。比如，不能将 Windows 下的可执行程序拿到 Linux 下使用，也不能将 Linux 下的可执行程序拿到 Mac OS 下使用（虽然它们都是类 Unix 系统）。另外，相同操作系统的不同版本之间也不一定兼容，比如不能将 x64 程序（Windows 64 位程序）拿到 x86 平台（Windows 32 位平台）下运行。但是反之一般可行，因为 64 位 Windows 对 32 位程序作了很好的兼容性处理。

         2. 源代码不能跨平台

              - 不同平台支持的函数、类型、变量等都可能不同，基于某个平台编写的源代码一般不能拿到另一个平台下编译。我们以C语言为例来说明。

                    在C语言中要想让程序暂停可以使用“睡眠”函数，在 Windows 平台下该函数是 Sleep()，在 Linux 平台下该函数是 sleep()，首字母大小写不同。其次，Sleep() 的参数是毫秒，sleep() 的参数是秒，单位也不一样。
                    以上两个原因导致使用暂停功能的C语言程序不能跨平台，除非在代码层面做出兼容性处理，非常麻烦。

#### 四、解释型语言 ####

- 对于解释型语言，每次执行程序都需要一边转换一边执行，用到哪些源代码就将哪些源代码转换成机器码，用不到的不进行任何处理。每次执行程序时可能使用不同的功能，这个时候需要转换的源代码也不一样。
- 因为每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至存在数量级的差距。计算机的一些底层功能，或者关键算法，一般都使用 C/C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。
- 在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。
- 当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：

   - 对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是闭源的。
   - 对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是开源的。

- 相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真是存在的，而且比比皆是。那么，为什么解释型语言就能跨平台呢？

  - 这一切都要归功于解释器！我们所说的跨平台，是指源代码跨平台，而不是解释器跨平台。解释器用来将源代码转换成机器码，它就是一个可执行程序，是绝对不能跨平台的。官方需要针对不同的平台开发不同的解释器，这些解释器必须要能够遵守同样的语法，识别同样的函数，完成同样的功能，只有这样，同样的代码在不同平台的执行结果才是相同的。    
  - 你看，解释型语言之所以能够跨平台，是因为有了解释器这个中间层。在不同的平台下，解释器会将相同的源代码转换成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异。
 

#### 五、解释型语言和编译型语言对比 ####

- 解释器是一条一条的解释执行源语言(边解释边运行)。比如php，postscritp，javascript就是典型的解释性语言。 运行效率低，所以通常会进行一些预编译的优化。
- 编译器是把源代码整个编译成目标代码，执行时不在需要编译器，直接在支持目标代码的平台上运行，这样执行效率比解释执行快很多。比如C语言代码被编译成二进制代码（exe程序），在windows平台上执行。
- 他们最大的区别是程序运行时需要解释器边解释边执行，而编译器则在运行时是完全不需要的。
- 解释器的优点是比较容易让用户实现自己跨平台的代码，比如java，php等，同一套代码可以在几乎所有的操作系统上执行，而无需根据操作系统做修改；
- 编译器的目的就是生成目标代码再由连接器生成可执行的机器码，这样的话需要根据不同的操作系统编制代码，虽然有像Qt这样的源代码级跨平台的编程工具库，但在不同的平台上仍然需要重新编译连接成可执行文件，但其执行效率要远远高于解释运行的程序。


#### 六、js是怎样运行起来的 ####

- js是由js引擎运行的，Js 引擎有很多种，比如 Chrome 使用的 V8 引擎，Webkit 使用的是 JavaScriptCore，React Native 使用的是 Hermes。
- 着重看下V8引擎

    1. V8引擎内部有许多小的模块组成。这里我们只需要了解其中最常用的四个模块即可。

          - Parser（解析器）
          - Ignition（解释器）
          - TurboFan（编译器）
          - Orinoco（垃圾回收）

	2. V8执行JavaScript的过程
	
          - 初始化基础环境；
          - 解析源码生成 AST 和作用域；
          - 依据 AST 和作用域生成字节码；
          - 解释执行字节码；
          - 监听热点代码，优化热点代码为二进制的机器代码；
          - 反优化生成的二进制机器代码。
             
          - （1）初始化基础环境
              - V8 执行 Js 代码是离不开宿主环境的，V8 的宿主可以是浏览器，也可以是 Node.js。当打开一个渲染进程时，就为 V8 初始化了一个运行时环境
              - 运行时环境为 V8 提供了堆空间，栈空间、全局执行上下文、消息循环系统、宿主对象及宿主 API 等。V8 的核心是实现了 ECMAScript 标准，此外还提供了垃圾回收器等内容。
	
          - （2）解析源码生成AST和作用域
              - 这里有词法分析和语法分析两个过程
              - 词法分析
         
                - V8引擎会扫描所有源代码，将一行行的源码拆解成一个个 token。所谓词法单元 token，指的是语法上不可能再分的、最小的单个字符或字符串。固定 type 表述类型/属性，value 表示对应的值
	
	                           比如：var a = 2;这句代码经过词法分析会被分成以下token
	
	                                [{
	                                   "type":"Keyword",
	                                   "value":"var"
	                                 },
	                                 {
	                                   "type":"Identifier",
	                                   "value":"a"
	                                 },
	                                 {
	                                   "type":"Punctuator",
	                                   "value":"="
	                                 },
	                                 {
	                                   "type":"Numeric",
	                                    "value":"2"
	                                 },
	                                 {
	                                   "type":"Punctuator",
	                                    "value":";"
	                                 }
	                               ]
	    
              - 语法分析
              
                 - 在V8中有两个解析器用于解析 JavaScript 代码，分别是 Parser 和 Pre-Parser 。
                 - Parser解析器又称为 full parser（全量解析） 或者 eager parser（饥饿解析）。它会解析所有立即执行的代码，包括语法检查，生成 AST，以及确定词法作用域。
                               
                   - Parser 是 V8 的解析器，负责根据生成的 Tokens 进行语法分析。Parser 的主要工作包括：
                   - 分析语法错误：遇到错误的语法会抛出异常；
                   - 输出 AST：将词法分析输出的词法单元流（数组）转换为一个由元素逐级嵌套所组成的代表了程序语法结构的树——抽象语法树（Abstract Syntax Tree, AST）；
                   - 确定词法作用域；
                   - 生成执行上下文
                                  
                 - Pre-Parser又称为惰性解析，它只解析未被立即执行的代码（如函数），不生成 AST ，只确定作用域，以此来提高性能。当预解析后的代码开始执行时，才进行 Parser 解析。
                   - Pre-Parser（预解析）

                               function foo () {
								 console.log('function foo')
								}
								
								function bar () {
								  console.log('function bar')
								}
								
								foo()


                           - 上面这段代码中，如果使用 Parser 解析后，会生成 foo 函数 和 bar 函数的 AST。然而 bar 函数并没有被调用，所以生成 bar 函数的 AST 实际上是没有任何意义且浪费时间的。那么有没有办法解决呢？此时就用到了 Pre-Parser 技术。

										我们还是以示例来说明：
										function foo() {
										    console.log('a');
										    function inline() {
										        console.log('b')
										    }
										}
										
										(function bar() {
										    console.log('c')
										})()；
										
										foo();


                           - 当 V8 引擎遇到 foo 函数声明时，发现它未被立即执行，就会采用  Pre-Parser 对其进行解析（inline 函数同）。
                           - 当 V8 遇到(function bar() {console.log(c)})()时，它会知道这是一个立即执行表达式（IIFE），会立即被执行，所以会使用 Parser 对其解析。
                           - 当 foo 函数被调用时，会使用 Parser 对 foo 函数进行解析，此时会对 inline 函数再进行一次预解析，也就是说 inline 函数被预解析了两次。如果嵌套层级较深，那么内层的函数会被预解析多次，所以在写代码时，尽可能避免嵌套多层函数，会影响性能。

              - （3）依据 AST 和作用域生成字节码
             
                   - 在解析器（Parser）将 JS 代码解析成 AST 之后，解释器（Ignition）根据 AST 来生成字节码（也称中间码）。前文提到 CPU 只能识别机器码，对字节码是识别不了的，这里就衍生出一个问题，如果 CPU 识别不了字节码，那为什么还要在中间插一步来耗费资源转字节码呢？效率不是很更低吗？
                   - 在计算机学科里聊效率，都逃避不了时间和空间这两个概念，绝大部分的优化都是空间换时间和时间换空间，两者的平衡，效率如何达到最高，是一个很值得深入研究的问题。拿之前版本的 V8 引擎执行 JS 来说，是没有转字节码这一步骤的，直接从 AST 转成机器码，这个过程称为编译过程，所以每次拿到 JS 文件的时候，首先都会编译，而这个过程还是比较浪费时间的，这是一件比较头疼的事情，需要一个解决办法。
                   - 缓存机器码
                   
                      - 绝大多数情况下，文件不会修改，那编译后的机器码可以考虑缓存下来，这样一来，下次再打开或者刷新页面的时候就省去编译的过程了，可以直接执行了，存储机器码被分成了两种情况，一个是浏览器未关闭时候，直接存储到浏览器本地的内存中，一个是浏览器关闭了，直接存储在磁盘上，而早期的 V8 也确实是这么做的，典型的牺牲空间换时间。
                      - 但是一个很小的代码片段，转换成 AST 之后，变大了很多，文件大了导致一个问题就是需要更大的内存来存储，而 JS 文件转成机器码（即二进制文件），会比原来的 JS 文件大几百甚至几千倍，这就意味这一个几十 KB 的 JS 文件将会达到几十 MB，这就很可怕，本来 Chrome 多进程架构就已经很占用内存了，再来这一出，配置再好的电脑，也怕是无福消受 Chrome 了，毕竟使用者体验的好坏，直接决定了一个产品在市场上是否能生存下去，尽管 V8 缓存了编译后的代码，减少了编译的时间，提高了时间上的效率，但代价是内存占用太大了，所以 Chrome 团队是有必要优化这个问题的。
                         
                  - 惰性编译

                      - 早期版本的 V8 为了解决占用内存和启动速度，引进了惰性编译，那么问题来了，惰性编译做了什么去提高效率的呢？
                      - 惰性编译还是比较容易理解的，从作用域的角度思考，ES6 之前之只有全局作用域和函数作用域，而惰性编译的思路就是 V8 启动的时候只编译和缓存全局作用域的代码，而函数作用域中的代码，会在调用的时候去编译，同样函数内部编译后的代码一样不会被缓存下来。
                      - 引入惰性编译之后，在编译速度和缓存上看来，都得到了提升，一切看起来似乎很完美了，对，是看起来，但是设计出来的东西，你永远不知道使用者会怎么使用，在 ES6 和 Vue、React 等这些没有普及之前，绝大部分开发者都使用的是 jQuery，以及 RequireJS 等类似产品，JQ 插件各种引用，各种插件或者开发者自己封装的方法，为了不污染其他使用者的变量，一般都封装成一个函数，这样问题就来了，惰性编译不会保存函数编译后的机器码和理解编译函数，如果一个插件太大那等到使用函数再去编译，编译的时间上就会变得很慢，这相当于是开发者将惰性编译给玩完了，路给封死了。
                   - 引入字节码

                     - 首先要理解什么是字节码，字节码其实是机器码的抽象，各种字节码的相互构成，可以实现 JS 所需的所有功能，当然首先一点，字节码比机器码占用的内存要小很多很多，基本是机器码所在内存的几十甚至几百分之一，这样一来字节码缓存下来所消耗的内存还是可以接受的。
                     - 这里会有一个疑问，既然 CPU 不能识别字节码，那是不是还需要将字节码转成机器码呢？不然怎么执行，答案是肯定。解释器在将 AST 转为字节码之后，会在执行的时候将字节码转成机器码，这个执行过程肯定是比直接执行机器码要慢的，所以在执行方面，速度上会比较慢，但是 JS 源码通过解析器转 AST，然后再通过解释器转字节码，这个过程是比编译器直接将 JS 源码转机器码要快很多的，全流程看来，整个时间上是差不了多少的，但是却减小了大量的内存占用，何乐而不为。

               - （4）解释执行字节码
               
                    - 通过Ignition（解释器）将AST转为字节码之后，Ignition（解释器）会逐行解释字节码成机器码并执行（已经开始执行JavaScript代码了）
                           
               - （5）监听热点代码，优化热点代码为二进制的机器代码

                    - 当 Ignition 开始执行 JavaScript 代码后，V8 会一直观察 JavaScript 代码的执行情况，并记录执行信息，如每个函数的执行次数、每次调用函数时，传递的参数类型等。如果一个函数被调用的次数超过了内设的阈值，监视器就会将当前函数标记为热点函数（Hot Function），并将该函数的字节码以及执行的相关信息发送给 TurboFan（优化编译器）。TurboFan 会根据执行信息做出一些进一步优化此代码的假设，在假设的基础上将字节码编译为优化的机器代码。如果假设成立，那么当下一次调用该函数时，就会执行优化编译后的机器代码，以提高代码的执行性能。这种字节码配合解释器和编译器的技术被称为即时编译（JIT）
                    - 那如果假设不成立，将优化编译后的机器代码还原为字节码。

                            
               - （6）反优化生成的二进制机器代码。

                    - JS 语言是动态语言，非常之灵活，对象的结构和属性在运行时是可以发生改变的，设想一个问题，如果热代码在某次执行的时候，突然其中的某个属性被修改了，那么编译成机器码的热代码还能继续执行吗？答案是肯定不能。这个时候就要使用到优化编译器的反优化了，他会将热代码退回到 AST 这一步，这个时候解释器会重新解释执行被修改的代码，如果代码再次被标记为热代码，那么会重复执行优化编译器的这个步骤。


							function sum (a, b) {
							    return a + b;
							}
							
							我们都知道 JavaScript 是基于动态类型的，a 和 b 可以是任意类型数据，当执行 sum 函数时，Ignition 解释器会检查 a 和 b 的数据类型，并相应地执行加法或者连接字符串的操作。
							如果 sum 函数被调用多次，每次执行时都要检查参数的数据类型是很浪费时间的。此时 TurboFan 就出场了。它会分析监视器收集的信息，如果以前每次调用 sum 函数时传递的参数类型都是数字，那么 TurboFan 就预设 sum 的参数类型是数字类型，然后将其编译为机器指令。
							但是当某一次的调用传入的参数不再是数字时，表示 TurboFan 的假设是错误的，此时优化编译生成的机器代码就不能再使用了，于是就需要进行优化回退。


<h3 id='七、ASI自动分号插入机制'>七、ASI（自动分号插入机制）</h3>

#### 一、前言 ####

- 学习C#的时候我们知道分号是用作断句的，而且必须加分号，否则编译就不通过了。但JavaScript由于存在ASI机制，因此允许我们省略分号。
- ASI机制不是说在解析过程中解析器自动把分号添加到代码中，而是说解析器除了分号还会以换行为基础按一定的规则作为断句的依据，从而保证解析的正确性。
- 这些规则是基于两点：

   - 以换行为基础；
   - 解析器会尽量将新行并入当前行，当且仅当符合ASI规则时才会将新行视为独立的语句。


#### 二、ASI规则 ####

1. 新行并入当前行将构成非法语句，自动插入分号

        if(1 < 10) a = 1
		console.log(a)

		// 等价于
		if(1 < 10) a = 1;
		console.log(a);

2. 在continue,return,break,throw后自动插入分号

        return
		{a: 1}

		// 等价于
		return;
		{a: 1};

3. ++、--后缀表达式作为新行的开始，在行首自动插入分号

        x
		++
		y
		
        //等价于
		x;
		++y；

4. 代码块的最后一个语句会自动插入分号

		function(){ a = 1 }

		// 等价于
		function(){ a = 1; }

#### 三、	NO ASI规则 ####

1. 新行以 ( 开始

	var a = 1
	var b = a
	(a+b).toString()

	// 会被解析为以a+b为入参调用函数a，然后调用函数返回值的toString函数
	var a = 1
	var b =a(a+b).toString()

2. 新行以 [ 开始

	var a = ['a1', 'a2']
	var b = a
	[0,1].slice(1)

	// 会被解析先获取a[1]，然后调用a[1].slice(1)。
	// 由于逗号位于[]内，且不被解析为数组字面量，而被解析为运算符，而逗号运算符会先执行左侧表达式，然后执行右侧表达式并且以右侧表达式的计算结果作为返回值
	var a = ['a1', 'a2']
	var b = a[0,1].slice(1)

3. 新行以 / 开始

	var a = 1
	var b = a
	/test/.test(b)

	// /会被解析为整除运算符，而不是正则表达式字面量的起始符号。浏览器中会报test前多了个.号
	var a = 1
	var b = a / test / .test(b)

4. 新行以 + 、 - 、 % 和 * 开始

	var a = 2
	var b = a
	 +a

	// 会解析如下格式
	var a = 2
	var b = a + a

5.  新行以 , 或 . 开始

	var a = 2
	var b = a
	.toString()
	console.log(typeof b)
	
	// 会解析为
	var a = 2
	var b = a.toString()
	console.log(typeof b)

- 因为这些符号开头的话，根据上述的ASI的第一条规则，这一行和上一行并成一行的时候，并不会形成非法语句。例如[]会被识别成属性。()会被识别成函数执行语句。
- 在以 ([/+- 开头的语句前加分号，由于正常写法均不会出现以 .,*% 作为语句开头，因此只需记住前面5个即可

      ；(function(){})()



<h3 id='八、V8如何存储js对象'>八、V8如何存储js对象</h3>

#### 一、前言 ####

- JS对象存储在堆中，它更像一个字典，字符串作为键名，任意对象都可以作为键值，通过键名读写键值。然而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8 为了提升存储和查找效率，采用了一套复杂的存储策略。线性结构是一块连续的内存，如线性表和数组，非线性结构一般占用非连续性内存，如链表和树
- 在V8中对象主要由三个指针构成，Element、property、隐藏类。其中Element、property用于存放对象的属性，隐藏类用于描述对象的结构，隐藏类的出现主要是为了提高存取对象属性的效率

#### 二、Element和property ####

先看下下面的一个实例：

	function Foo() {
	    this[100] = 'test-100'
	    this[1] = 'test-1'
	    this["B"] = 'bar-B'
	    this[50] = 'test-50'
	    this[9] =  'test-9'
	    this[8] = 'test-8'
	    this[3] = 'test-3'
	    this[5] = 'test-5'
	    this["A"] = 'bar-A'
	    this["C"] = 'bar-C'
	}
	var bar = new Foo()
	
	for(key in bar){
	    console.log(`index:${key}  value:${bar[key]}`)
	}
	
	console.log(bar)   

    输出：index:1  value:test-1
		 index:3  value:test-3    
		 index:5  value:test-5    
		 index:8  value:test-8    
		 index:9  value:test-9    
		 index:50  value:test-50  
		 index:100  value:test-100
		 index:B  value:bar-B     
		 index:A  value:bar-A     
		 index:C  value:bar-C  

明显看结果没按顺序我们设置的顺序来，这是为什么呢？

- 在 V8 的对象中有两种属性，排序属性 (elements)和常规属性 (properties)。

   - 把对象中的数字属性称为排序属性，在 V8 中被称为 elements。数字属性应该按照索引值大小升序排列。
   - 字符串属性就被称为常规属性，在 V8 中被称为 properties，字符串属性根据创建时的顺序升序排列。
   - 两个属性都有时，排序属性 (elements)先于常规属性(properties)。

- 在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构 来分别保存排序属性和常规属性。分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。
- element默认应该采用连续的存储结构，通过浪费空间换取时间，直接下标访问，提升访问速度。 但当element的序号十分不连续时，会优化成为hash表，因为要浪费的空间太大了，不合算。

		function Foo() {}
		var bar = new Foo()
		for (let i = 0; i < 10; i++) {
		    bar[i] = 'bar' + i
		}
		// bar[1111] = 'bar1111'
	
	    当我们添加了 bar[1111] 之后，数组会变成稀疏数组。为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。


#### 三、快属性和慢属性 ###

- V8将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行 obj.B这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)。
- 采用对象内属性之后，常规属性就被保存到 testObj 对象本身了，这样当再次使用testObj.B来查找 B 的属性值时，V8 就可以直接从 testObj 对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。
- 不过 对象内属性的数量是固定的，默认是 10 个，如果添加的属性 超出了对象分配的空间，则它们将被保存在常规属性存储中。相较于对象内属性，在properties中的常规属性需要额外多一次 properties 的寻址时间，之后便是与对象内属性一致的线性查找（properties 的属性是有规律的类似数组、链表存放）。虽然属性存储多了一层间接层，但可以自由地扩容。
- 通常，我们将保存在线性数据结构中的属性称之为“【快属性】”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。
- 因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“【慢属性】”策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。
- 实例分析对象在内存中是如何布局的

    - 小于等于10个

        function testObj() {}

		var test10 = new testObj()
		
		for (var i = 0; i < 10; i++) {
		  test10[i+'x'] = 'xxx'
		}

      - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内;
      - 并没有 properties 属性 而是直接保存在对象内的，为了减少查找这些属性查找流程，在对象内直接生成映射，快速查找，但是最多 10 个。

    - 大于 10 个

		function testObj() {}
		
		var test20 = new testObj()
		
		for (var i = 0; i < 20; i++) {
		  test20[i+'x'] = 'xxx'
		}

       - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内，其他常规属性以线性数据结构方式存放在 properties 属性里面;
       - 当对象内属性放满（属性超过了 10 个）之后，会以快属性的方式，在 properties 下按创建顺序存放（0、1...9），注意因为 properties 中只有 10 个属性，所以依然是线性的数据结构，我们可以看其都是按照创建时的顺序来排列的。
       - 相较于对象内属性，快属性需要额外多一次 properties 的寻址时间，之后便是与对象内属性一致的线性查找（properties 的属性是有规律的类似数组、链表存放）

    - 大于 20 个
    
		function testObj() {}
		
		var test50 = new testObj()
		
		for (var i = 0; i < 50; i++) {
		  test50[i+'x'] = 'xxx'
		}

       - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内;其他常规属性以非线性字典的数据结构方式存放在 properties 属性里面;
       - 我们可以看到，当数据量大起来以后，在 properties 里的属性已经不线性（119、120），而是以非线性的散列表（字典）（哈希-分离链路）形式存储的。
       - 附：分离链路是哈希 key+链表 value 的结构

#### 四、隐藏类 ####

- JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类

1. 为什么静态语言的效率更高?

- 静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。引擎就可以通过这个数据来提前计算好该属性相对于对象地址的偏移值，在后面需要用到该对象的属性时，可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。
- JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。

2. 将静态的特性引入到 V8

- V8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的。
具体地讲，V8 对每个对象做如下两点假设：

  - 对象创建好了之后就不会添加新的属性；
  - 对象创建好了之后也不会删除属性。
  
- 符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：

  - 对象中所包含的所有的属性；
  - 每个属性相对于对象的偏移量。

- 有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。
- 在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类；
- map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。

3. 多个对象共用一个隐藏类

- 在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：

   - 减少隐藏类的创建次数，也间接加速了代码的执行速度；
   - 减少了隐藏类的存储空间。

- 那么，什么情况下两个对象的形状是相同的，要满足以下条件

   - 从相同的起点，以相同的顺序，添加结构相同的属性（除 Value 外，属性的 Attribute 一致）。

	     let a = {};
		 a.name = 'thorn1'
		 let b = { name: 'thorn2' }
	
	     上例中a和b的隐藏类不一样，那是因为在创建 b 的对象时，省略了下创建空对象这一步，所以a和b的起点不一样

4. 重新构建隐藏类

- 给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。

5. 对象操作的最佳实践

- 前文我们知道频繁改变对象的属性或属性值的数据类型会导致频道重新构建隐藏类的性能问题，基于此我们可以推测出操作对象的最佳实践。

  - 使用字面量初始化对象时，尽量保证属性的顺序一致。

		// bad
		let point = {x:100,y:200};
		let point2 = {y:100,x:200};
		
		// good
		let point = {x:100,y:200};
		let point2 = {x:100,y:200};
		
	为什么不推荐第一种做法呢？因为两个对象的形状不同，会生成不同的隐藏类。
 
 - 尽量使用字面量一次性初始化完整对象属性。
 
   - 因为每次为对象添加属性时V8都需要为该对象重新设置隐藏类。

 - 避免使用delete方法

  - 同样的，删除对象的属性会导致V8会重新构建隐藏类。


#### 五、内联缓存 ####

- 首先我们来看一个代码片:

		function loadX(o) { 
		    return o.x
		}
		var o = { x: 1,y:3}
		var o1 = { x: 3 ,y:6}
		for (var i = 0; i < 90000; i++) {
		    loadX(o)
		    loadX(o1)
		}

- 我们定义了一个 loadX 函数，它有一个参数 o ，该函数只是返回了 o.x 。
- 通常 V8 获取 o.x 的流程是这样的： 查找对象 **o** 的隐藏类，再通过隐藏类查找 **x** 属性偏移量，然后根据偏移量获取属性值 ，在这段代码中 loadX 函数会被反复执行，那么获取 o.x 流程也需要反复被执行。我们有没有办法再度简化这个查找过程，最好能一步到位查找到 x 的属性值呢？答案是，有的。

- V8通过内联缓存策略压缩这个查找过程，提升对象的查找效率。那什么是内联缓存呢？它具体是怎么工作的呢？
 
   - 内联缓存(Inline Cache)，简称IC。在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。
   
   - 接下来我们以示例代码为例详细看看IC的工作流程：
   
     - IC 会为每个函数维护一个 反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。
     - 代码片中 return o.x 是一个调用点，因为它使用了对象和属性，那么V8会在 loadX 函数的反馈向量中为这个调用点分配一个插槽，每个插槽中包括了插槽的索引 (slot index)、插槽的类型 (type)、插槽的状态 (state)、隐藏类 (map) 的地址、还有属性的偏移量，当V8再次调用 loadX 函数执行到 return o.x 时，它会在对应的插槽中查找 x 属性的偏移量，之后 V8就能直接去内存中获取 o.x 的属性值了，可以大大提升执行效率。

#### 六、多态和超态 ####

- 通过缓存执行过程中的基础信息，就能够提升下次执行函数时的效率，但是这有一个前提，那就是多次执行时，对象的形状是固定的，如果对象的形状不是固定的，那 V8 会怎么处理呢？
- 我们调整一下上面这段 loadX 函数的代码，调整后的代码如下所示：
	
	    function loadX(o) { 
		    return o.x
		}
		var o = { x: 1,y:3}
		var o1 = { x: 3, y:6,z:4}
		for (var i = 0; i < 90000; i++) {
		    loadX(o)
		    loadX(o1)
		}

  - 我们可以看到，对象 o 和 o1 的形状是不同的，这意味着 V8 为它们创建的隐藏类也是不同的。
  - 第一次执行时 loadX 时，V8 会将 o 的隐藏类记录在反馈向量中，并记录属性 x 的偏移量。那么当再次调用 loadX 函数时，V8 会取出反馈向量中记录的隐藏类，并和新的 o1 的隐藏类进行比较，发现不是一个隐藏类，那么此时 V8 就无法使用反馈向量中记录的偏移量信息了。
  - 面对这种情况，V8 会选择将新的隐藏类也记录在反馈向量中，同时记录属性值的偏移量，这时，反馈向量中的第一个槽里就包含了两个隐藏类和偏移量。当 V8 再次执行 loadX 函数中的 o.x 语句时，同样会查找反馈向量表，发现第一个槽中记录了两个隐藏类。这时，V8 需要额外做一件事，那就是拿这个新的隐藏类和第一个插槽中的两个隐藏类来一一比较，如果新的隐藏类和第一个插槽中某个隐藏类相同，那么就使用该命中的隐藏类的偏移量。如果没有相同的呢？同样将新的信息添加到反馈向量的第一个插槽中。
  - 一个反馈向量的一个插槽中可以包含多个隐藏类的信息，那么：

     - 如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；
     - 如果一个插槽中包含了 2～4 个隐藏类，那我们称这种状态为多态 (polymorphic)；
     - 如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。

- 如果函数 loadX 的反馈向量中存在多态或者超态的情况，其执行效率肯定要低于单态的，比如当执行到 o.x 的时候，V8 会查询反馈向量的第一个插槽，发现里面有多个 map 的记录，那么 V8 就需要取出 o 的隐藏类，来和插槽中记录的隐藏类一一比较，如果记录的隐藏类越多，那么比较的次数也就越多，这就意味着执行效率越低。
- 所以我们得出一个结论是 尽量保持单态，因为单态的性能优于多态和超态 。

#### 七、在 V8 引擎里 5 个优化代码的技巧 ####

- 对象属性的顺序: 在实例化你的对象属性的时候一定要使用相同的顺序，这样隐藏类和随后的优化代码才能共享；
- 动态属性: 在对象实例化之后再添加属性会强制使得隐藏类变化，并且会减慢为旧隐藏类所优化的代码的执行。所以，要在对象的构造函数中完成所有属性的分配；
- 方法: 重复执行相同的方法会运行的比不同的方法只执行一次要快 (因为内联缓存)；
- 数组: 避免使用 keys 不是递增的数字的稀疏数组，这种 key 值不是递增数字的稀疏数组其实是一个 hash 表。在这种数组中每一个元素的获取都是昂贵的代价。同时，要避免提前申请大数组。最好的做法是随着你的需要慢慢的增大数组。最后，不要删除数组中的元素，因为这会使得 keys 变得稀疏；



<h3 id='九、垃圾回收机制'>九、垃圾回收机制</h3>

#### 一、概念####

   - 垃圾回收机制只作用于对象，因为原始类型的值存在于栈中，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收，而引用类型的值存在于堆中，它们的内存地址存在于栈中，我们在变量中保存的其实是指向引用变量的指针，所以我们不引用一个保存在堆内存中的引用类型的值的时候，需要垃圾回收机制帮我们回收掉这个对象，然后释放掉它的内存
   - 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
   
   - JavaScript的内存管理是自动的，而且是不可见的，当我们创建一个基本类型的值，对象，函数...所有这些都是需要内存的，只要我们创建的值被引用了，该值就保证存在内存中，当该值没有被引用的时候，就需要被回收释放掉它所占用的内存。垃圾回收机制就是找出那些没有被引用的引用类型的值，然后释放掉它的内存。由于垃圾回收器回收内存这个过程的开销比较大，所以这个过程不是实时的，而是定期（周期性）的。

      例1：var a={
               obj:2
              }

         上例中，由于{obj:2}这个对象被a变量引用了，所以这个值就一直存在内存中，如果将a重新赋值为null,这时{obj:2}没有被引用了，则{obj:2}就会被回收，它的内存会被释放掉。

      例2：var a={
               obj:2
              }

           var b = a
           a=null

         上例中，{obj:2}不会被回收，因为虽然a没有引用它，但b引用了它。如果b=null，那么{obj:2}就会被回收。

#### 二、垃圾回收策略####

1. 引用计数(不太常用)

  - （1）原理

         - 引用计数就是跟踪每个引用类型被引用的次数，被引用一次加1，当引用次数为0的时候，就被视为可回收的对象，每当过一段时间开始垃圾回收的时候，就把引用次数为0的变量回收。

  - （2）过程

         - 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型的值的引用次数就是1
         - 同一个值又被赋值给了另一个变量，这个引用类型值的引用次数加1
         - 当包含这个引用类型值的变量又被赋值成另一个值了，那麽这个引用类型值的引用次数减1
         - 当引用次数变成0时，说明没办法访问这个值了
         - 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

         例：var a={name:'jone'}
             var b = a
             a=12
             b=456

          上例中，声明了一个变量并将{name:'jone'}赋值给a,所以{name:'jone'}的引用次数为1，又将{name:'jone'}赋值给了b,所以{name:'jone'}的引用次数为2，第三行又将a的值重新赋值为12，所以{name:'jone'}的引用次数又变成1，第四行又将b的值重新赋值为456，所以{name:'jone'}的引用次数又变成0，这是{name:'jone'}就变成了可回收的对象，垃圾回收器运行的时候它就会被回收。

  - （3）循环引用

          function f() {
           var o1 = {name:566}
           var o2 = {name:122}
           o1.p = o2
           o2.p = o1
          }
             
         上例中,{name:566}和{name:122}两个对象都被引用了两次，由于函数的局部变量只在函数的执行过程中存在，当函数运行结束，会将局部变量o1和o2赋值为null，但此时{name:566}和{name:122}两个对象的引用次数为1不为0，所以这两个对象都不会被垃圾回收机制回收，但是这两个对象已经没有作用了，在函数外部也不可能使用到它们，所以这就造成了内存泄露

         解决方式：

             不使用的时候手动清除：o1.p = null
                                o2.p = null


2. 标记清除（常用）

  - （1）原理

        - 根节点：一般来说，根是代码中引用的全局变量。例如，在 JavaScript 中，可以充当根节点的全局变量是“window”对象。Node.js 中的全局对象被称为“global”。完整的根节点列表由垃圾收集器构建。
      
        - 标记清除分为标记阶段和清除阶段
        
             - 标记阶段：标记清除其实就是可达性（对象是否可访问）测试，垃圾回收器从根集合出发，检查所有的根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。
	       
             - 清除阶段：从根节点开始遍历堆，垃圾收集器释放所有未被标记为活跃的内存块，并将这些内存返回给操作系统

        - 在使用标记清除算法时,未引用对象并不会被立即回收.取而代之的做法是,垃圾对象将一直累计到内存耗尽为止.当内存耗尽时,程序将会被挂起,垃圾回收开始执行.当所有的未引用对象被清理完毕时,程序才会继续执行.
   
  - （2）解决循环引用

           function f() {
           var o1 = {name:566}
           var o2 = {name:122}
           o1.p = o2
           o2.p = o1
          }

         上例中，由于函数执行结束后，局部变量o1和o2就会被回收，全局对象就访问不到这两个对象了，因此，垃圾回收器会认为它们不可访问


<h3 id='十、V8引擎对垃圾回收的优化'>十、V8引擎对垃圾回收的优化</h3>

接上篇垃圾回收~

#### 一、V8内存限制 ####

- 所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。那么问题来了，V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？
- 究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。

   - 首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 
   - 另一方面垃圾回收其实是非常耗时间的操作，在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。

- 垃圾回收策略主要有标记清除和引用计数，现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化

#### 二、分代式垃圾回收 ####

- 我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了

1. **新老生代** 

- V8中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收
- 新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，在 64 位和 32 位系统下分别为 32MB 和 16MB，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大
- V8 整个堆内存的大小就等于新生代加上老生代的内存
- 对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器（副垃圾回收器），同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器（主垃圾回收器）好了

![](./images/GC1.jpg)

2. **新生代垃圾回收**

- 新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法 
- Cheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为空闲区，如下图所示

![](GC2.jpg)

- 新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作
- 当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区
- 新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。
- 发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:

   - 已经经历过一次 Scavenge 回收。
   - 空闲区空间的内存占用超过25%,设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

- 不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

3. **老生代垃圾回收**

- 相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了,标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间

	- 首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象，清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉
	- 标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
![](./images/GC3.jpg)
	
	- 假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配
	- 那如何找到合适的块呢？我们可以采取下面三种分配策略
	 
	  - First-fit，找到大于等于 size 的块立即返回
	  - Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块
	  - Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回
	
	- 这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择
	- 综上所述，标记清除算法或者说策略就有两个很明显的缺点
	
	   - 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
	   - 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
	
	- 而标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）
![](./images/GC4.jpg)

4. **并行回收(Parallel)**

- 在介绍并行之前，我们先要了解一个概念全停顿（Stop-The-World），我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做全停顿
- 既然存在执行一次 GC 比较耗时的情况，考虑到一个人盖房子难，那两个人、十个人...呢？切换到程序这边，那我们可不可以引入多个辅助线程来同时处理，这样是不是就会加速垃圾回收的执行速度呢？因此 V8 团队引入了并行回收机制
- 所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作
![](./images/GC5.jpg)

- 简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了,不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单
- 新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收

5. **增量标记与懒性清理**

- 我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间,所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记
- 增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 GC 标记（如下图）
![](./images/GC6.jpg)

- 试想一下，将一次完整的 GC 标记分次执行，那在每一小次 GC 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？
- 可以看出增量的实现要比并行复杂一点，V8 对这两个问题对应的解决方案分别是三色标记法与写屏障

6. **三色标记法(暂停与恢复)**

- 我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法之前，单纯使用黑色和白色来标记数据就可以了，其标记流程即在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在会从一组跟对象出发，将所有能访问到的数据标记为黑色，遍历结束之后，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象
如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了
- 为了解决这个问题，V8 团队采用了一种特殊方式： 三色标记法
- 三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑

  - 白色指的是未被标记的对象
  - 灰色指自身被标记，成员变量（该对象的引用对象）未被标记
  - 黑色指自身和成员变量皆被标记

- 我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色，就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收
- 采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以
- 三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 全停顿 的时间

7. **写屏障**

- 假如我们有 A、B、C 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 B 的指向由对象 C 改为了对象 D ，接着恢复执行下一次增量分段
- 这时其实对象 C 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 GC 是不会清理 C 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 GC 也会清理，这对我们程序运行并没有太大影响
- 我们再看新的对象 D 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 D 呢，这肯定是不对的
- 为了解决这个问题，V8 增量回收使用 写屏障 (Write-barrier) 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 GC 标记阶段可以正确标记，这个机制也被称作 强三色不变性
- 那在我们上图的例子中，将对象 B 的指向由对象 C 改为对象 D 后，白色对象 D 会被强制改为灰色

8. **懒性清理**

- 增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(Lazy Sweeping)
- 增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记

9. **增量标记与惰性清理的优缺？**

- 增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：
- 首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量

10. **并发回收(Concurrent)**

- 前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？这就要说到并发回收了，它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）
![](./images/GC7.jpg)

- 辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 JavaScript  时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点

11. **V8当前垃圾回收机制**

- V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “
- 其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的
- （1）副垃圾回收器

    - V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从from-to复制到space-to的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。
    
- （2）主垃圾回收器

    - V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，写入屏障（write barriers）技术会在辅助线程在进行并发标记的时候进行追踪。
    - 当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。


<h3 id='十一、浏览器和node事件循环的区别'>十一、浏览器和node事件循环的区别</h3>

#### 一、浏览器事件循环 ####

1. 事件循环概念

- js分为同步任务和异步任务，同步任务都在主线程上执行形成一个执行栈，主线程之外存在一个回调队列
- 同步任务在执行的时候会调用浏览器的API，此时会产生一些异步任务
- 异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。
- 一旦执行栈中的所有同步任务执行完毕(此时js引擎空闲)，系统就会读取任务列队，将可运行的异步任务添加到可执行栈，开始执行
- 上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）。

- 回调队列可分为宏任务和微任务

2. async/await

- async 函数会返回一个 Promise 对象，如果在函数中 return 一个直接量（普通变量），async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。如果你返回了promise那就以你返回的promise为准。
- await 是在等待，等待运行的结果也就是返回值。await后面通常是一个异步操作（promise），但是这不代表 await 后面只能跟异步操作 await 后面实际是可以接普通函数调用或者常量的。

   - 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果
   - 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。

			async function async1(){
			    await async2()
			    console.log('async1 end')
			} 
			
			  function async2(){
			    console.log('async2 end')
			}
			  async1()
			
			setTimeout(()=>{
			   console.log('setTimeout')
			},0)
			
			new Promise(reslove=>{
			    reslove()
			}).then(()=>{
			    console.log('promise')
			})
	
				async2 end
				async1 end
				promise
				setTimeout

 - 上面代码中，调用async1函数，里边await后面跟着async2函数，所以执行async2函数输出async2 end，async2是一个同步函数，所以await后面的语句相当于在.then函数里边，所以会被注册成微任务，继续执行遇到setTimeout加入宏任务队列，遇到Promise.then是微任务，加入微任务列队，第一个宏任务执行完，执行微任务队列的微任务，输出async1 end，promise，执行第二个宏任务输出setTimeout

 - 将上面async2函数改一下

		 async function async1(){
		    await async2()
		    console.log('async1 end')
		} 
		
		async function async2(){
		    console.log('async2 end')
		    return new Promise(reslove=>{
		        reslove()
		    }).then((res)=>{
		        console.log('async2.then end')
		    })
		}
		async1()
		
		setTimeout(()=>{
		   console.log('setTimeout')
		},0)
		
		new Promise(reslove=>{
		    reslove()
		}).then(()=>{
		    console.log('promise')
		})

		async2 end
		async2.then end
		promise
		async1 end
		setTimeout

- 输出变了，async1 end在promise之后了，这是因为await后面的函数返回一个promise，那么

	     await async2
	     console.log(async1 end)
	
	     相当于
	      new Promise(reslove=>{
			    reslove()
			 }).then((res)=>{
			    console.log('async2.then end')
			 }).then(()=>{
	            console.log('async1.then end')
	         })

- 所以是输出async2.then end的then函数先被注册为微任务，然后是下面的promise.then被注册微任务，执行async2.then end的then函数是又产生了一个输出async1 end的then函数微任务，添加到promis后面，所以async1 end在promise之后了
     

#### 二、node事件循环 ####

1. 阶段概述

   - 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。
   - I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。比如网络通信的错误回调
   - 闲置阶段(idle, prepare)：仅系统内部使用。
   - 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
   - 检查阶段(check)：setImmediate() 回调函数在这里执行
   - 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。


- 输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...
- 通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，**直到队列用尽或最大回调数已执行**。当该队列已用尽或达到回调限制，执行该阶段产生的微任务，然后事件循环移动到下一阶段。【node11版本之前】

2. 三大重点阶段

- （1）timer
    - timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。

- （2）poll
   ![](./images/node事件循环.jpg)

    - 进入poll阶段会先去看当前是否存在到时间的定时器，如果存在则进入timer阶段执行timer队列
    - 如果没有定时器, 会去看回调函数队列。

       - 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
       - 如果 poll 队列为空时，会有两件事发生

         - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
         - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。

- （3）check 
   - check阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。

3. process.nextTick

- process.nextTick 是一个独立于 eventLoop 的任务队列。
- 在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。

		setImmediate(() => {
		    console.log('timeout1')
		    Promise.resolve().then(() => console.log('promise resolve'))
		    process.nextTick(() => console.log('next tick1'))
		});
		setImmediate(() => {
		    console.log('timeout2')
		    process.nextTick(() => console.log('next tick2'))
		});
		setImmediate(() => console.log('timeout3'));
		setImmediate(() => console.log('timeout4'));


    - 在 node11 之前，因为每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行，因此上述代码是先进入 check 阶段，执行所有 setImmediate，完成之后执行 nextTick 队列，最后执行微任务队列，因此输出为timeout1=>timeout2=>timeout3=>timeout4=>next tick1=>next tick2=>promise resolve
    - 在 node11 之后，process.nextTick 是微任务的一种,因此上述代码是先进入 check 阶段，执行一个 setImmediate 宏任务，然后执行其微任务队列，再执行下一个宏任务及其微任务,因此输出为timeout1=>next tick1=>promise resolve=>timeout2=>next tick2=>timeout3=>timeout

4. node版本差异

    - node11版本之前：当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，**直到队列用尽或最大回调数已执行**。当该队列已用尽或达到回调限制，执行该阶段产生的微任务，然后事件循环移动到下一阶段。
    - node11版本之后：一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行对应的微任务队列

			setTimeout(()=>{
			    console.log('timer1')
			    Promise.resolve().then(function() {
			        console.log('promise1')
			    })
			}, 0)
			setTimeout(()=>{
			    console.log('timer2')
			    Promise.resolve().then(function() {
			        console.log('promise2')
			    })
			}, 0)
		
		
        - 如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=>promise1=>timer2=>promise2
        - 如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.
        
           - 如果是第二个定时器还未在完成队列中，最后的结果为timer1=>promise1=>timer2=>promise2
           - 如果是第二个定时器已经在完成队列中，则最后的结果为timer1=>timer2=>promise1=>promise2


<h3 id='十二、观察者模式和发布订阅模式'>十二、观察者模式和发布订阅模式</h3>

#### 一、观察者模式 ####

1. 概念

   - 观察者模式中有两个角色观察者和被观察者，它定义了对象间的一对多的依赖关系，当一个被观察者对象的状态发生改变时，依赖于它的所有观察者对象都会收到通知

2. 观察者模式的简单流程

   - 将观察者注册到目标对象的观察者列表中
   - 目标对象进行 通知（notify） 操作
   - 目标对象调用观察者的 更新（update） 方法，将通知的信息传递给观察者

3. 联系实际

   - 报纸期刊的订阅。当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。

4. 简单实现

       //被观察者
		class Subject{
		    constructor() {
		      this.subs = []
		    }
		
		    add(sub) {
		        this.subs.push(sub)
		    }
		
		    remove(sub) {
		        this.subs.filter(item=>{
		            return item!==sub
		        })
		    }
		    
            //当被观察者状态改变时，通知每个观察者进行相应操作
		    notify() {
		        this.subs.forEach(sub=>{
		            sub.update.apply(sub)
		        })
		    }
		}
		
 
        //观察者
		class Observer{
		    constructor(name) {
		        this.name = name
		    }
		    update() {
		        console.log(this.name)
		    }
		}

		let sub = new Subject()
		let obj1 = new Observer('小明')
		let obj2 = new Observer('小红')
  
        //改变了obj2的update函数，被观察者只是在自己状态发生改变时，通知观察者，观察者具体要干什么由观察者自己决定，所以update函数可以任意改变
		obj2.update=function(){
		    console.log('666')
		}
		sub.add(obj1)
		sub.add(obj2)
		sub.notify()

    - 观察者模式中，被观察者自己维护了一个观察者列表，观察者和被观察者都知道对方的存在

#### 二、发布订阅模式 ####

1. 概念

     - 在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。
     - 在发布者和订阅者之间存在第三个组件，称为事件中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。
     - 发布订阅模式有三个角色：发布者、订阅者、事件中心

2. 发布-订阅模式的简单流程：

   - 订阅者需要向事件中心订阅指定的事件
   - 发布者需要向事件中心发布指定的事件
   - 事件中心通知订阅者

3. 简单实现

		 class event {
		    constructor() {
                // 订阅者集合
               // 集合的每个对象里都包含了订阅者类型 type，及要做的事情 callback
		        this.subs = {}
		    }
		
           //订阅者订阅
		    on(key,fn) {
		        if(!this.subs[key]){
		            this.subs[key] = []
		        }
		        this.subs[key].push(fn)
		    }
		
          //发布者发布
		    emit(key,...args) {
		      if(!this.subs[key] || this.subs[key].length===0){
		          return false
		      }
		
		      this.subs[key].forEach((fn)=>{
		          fn(...args)
		      })
		
		    }
		
		    remove(key,fn) {
		        if(!this.subs[key]){
		            return false
		        }
		        if(!fn){
		            this.subs[key].length=0
		        }
		
		        this.subs[key]=this.subs[key].filter((sub)=>{
		            return sub!==fn
		        })
		    }
		}
		
		function dog(name){
		   this.name = name
		   console.log(this.name)
		}
		
		function cat(){
		   console.log('喵喵喵')
		}
		
		let obj = new event()
		obj.on('pet',dog)
		obj.on('pet',cat)
		obj.remove('pet',dog)
		obj.emit('pet','花花')

#### 三、区别 ####

1. 观察者模式中的目标和观察者是直接联系的，而发布-订阅模式中的订阅者和发布者中间是由事件中心来联系的。

   - 观察者模式：目标和观察者是低耦合的，有很强的依赖关系。
   - 发布-订阅模式：由于事件中心的存在使得订阅者和发布者是完全解耦的。

2. 观察者要想订阅目标事件，由于没有事件中心，因此必须将自己添加到目标(Subject) 中进行管理；
   目标在触发事件的时候，也无法将通知操作(notify) 委托给事件中心，因此只能亲自去通知所有的观察者。

3. 从代码实现的角度，
 
   - 观察者模式是面向目标和观察者编程的。
   - 发布-订阅模式是面向调度中心编程的。

#### 四、注意 ####

- 在给出的实例中，观察者模式中在观察者列表中添加的是观察者对象；而发布-订阅模式在事件中心中添加的是回调函数。个人理解观察者模式中可能更倾向于将通知信息返回到观察者自身，而发布-订阅模式可能更倾向于对相应发布事件的处理（通过回调函数）。



<h3 id='十三、判断js数据类型的方法' >十三、判断js数据类型的方法）</h3>

一、typeof

  - typeof对于基本类型的值可以判断出其类型（对于null返回object），对于引用类型的值，除了function都会返回object

二、instanceof

  - instanceof运算符是用来判断一个构造函数的prototype属性所指向的对象是否存在在另一个要检测的对象的原型链上，表达式为A instanceof B，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。
  - instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

三、toString

  - toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

  - 对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。


	Object.prototype.toString.call('') ;   // [object String]
	Object.prototype.toString.call(1) ;    // [object Number]
	Object.prototype.toString.call(true) ; // [object Boolean]
	Object.prototype.toString.call(Symbol()); //[object Symbol]
	Object.prototype.toString.call(undefined) ; // [object Undefined]
	Object.prototype.toString.call(null) ; // [object Null]
	Object.prototype.toString.call(newFunction()) ; // [object Function]
	Object.prototype.toString.call(newDate()) ; // [object Date]
	Object.prototype.toString.call([]) ; // [object Array]
	Object.prototype.toString.call(newRegExp()) ; // [object RegExp]
	Object.prototype.toString.call(newError()) ; // [object Error]
	Object.prototype.toString.call(document) ; // [object HTMLDocument]
	Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用




<h3 id='十四、js数据类型转换' >十四、js数据类型转换）</h3>

https://juejin.cn/post/6844903854882947080
#### 一、类型转换规则 ####
![](./images/类型转换.jpg)

1. 转换为布尔值false的有：0，NaN，""，undefined，null
2. 转换为数值为0的有：false，""，null，[]（undefined转换为数值为NaN）
3. 转换为字符串为空串的有：[]

#### 二、if语句和逻辑语句 ####

- 在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true：

    - null，undefined，''，NaN，0，false

#### 三、各种运数学算符 ####

- 我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型

		1 - true // 0             true=>1
		1 - null //  1            null=>0
		1 * undefined //  NaN     undefined=>NaN
		2 * ['5'] //  10          ['5']=>5

- 注意+是个例外，执行+操作符时：

  1. 只要有一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。
  2. 当一侧为Number类型，另一侧为除String之外的原始类型，则将原始类型转换为Number类型。
  3. 当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。

			123 + '123' // 123123   （规则1）
			123 + null  // 123    （规则2）
			123 + true // 124    （规则2）
			123 + {}  // 123[object Object]    （规则3）


#### 四、== ####

- 使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：

1. NaN

- NaN和其他任何类型比较永远返回false(包括和他自己)

2. Boolean

- Boolean和其他任何类型比较，Boolean首先被转换为Number类型

		true == 1  // true 
		true == '2'  // false
		true == ['1']  // true
		true == ['2']  // false

- 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0：

		undefined == false // false
		null == false // false

3. String和Number

- String和Number比较，先将String转换为Number类型。

		123 == '123' // true
		'' == 0 // true

4. null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false

		null == undefined // true
		null == '' // false
		null == 0 // false
		null == false // false
		undefined == '' // false
		undefined == 0 // false
		undefined == false // false

5. 原始类型和引用类型

- 当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型:
- 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。

     - Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。

         - Number：该场合需要转成数值
         - String：该场合需要转成字符串
         - Default：该场合可以转成数值，也可以转成字符串

- 从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循ECMAScript规范规定的toPrimitive原则，一般会调用引用类型的valueOf和toString方法，你也可以直接重写toPeimitive方法。一般转换成不同类型的值遵循的原则不同，例如：

    - 引用类型转换为Number类型，先调用valueOf，再调用toString
    - 引用类型转换为String类型，先调用toString，再调用valueOf
    - 若valueOf和toString都不存在，或者没有返回基本类型，则抛出TypeError异常。

- 来看看下面这个比较：

     [] == ![] // true

     !的优先级高于==，![]首先会被转换为false，然后根据上面第二点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。

     [null] == false // true
     [undefined] == false // true

     根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。		

#### 五、一道有意思的面试题 ####

- 一道经典的面试题，如何让：a == 1 && a == 2 && a == 3。
- 根据上面的==的隐式转换，我们可以轻松写出答案：

		const a = {
		   value:[3,2,1],
		   valueOf: function () {return this.value.pop(); },
		} 



#### 六、判断JavaScript数据类型的方式 ####

1. typeof

- 适用场景

  - typeof操作符可以准确判断一个变量是否为下面几个原始类型：
		
        typeof 'ConardLi'  // string
		typeof 123  // number
		typeof true  // boolean
		typeof Symbol()  // symbol
		typeof undefined  // undefined

  - 你还可以用它来判断函数类型：
  
		typeof function(){}  // function

- 不适用场景

  - 当你用typeof来判断引用类型时似乎显得有些乏力了,除函数外所有的引用类型都会被判定为object:

		typeof [] // object
		typeof {} // object
		typeof new Date() // object
		typeof /^\d*$/; // object
     
    
  - 另外typeof null === 'object'也会让人感到头痛，这是在JavaScript初版就流传下来的bug，后面由于修改会造成大量的兼容问题就一直没有被修复...

2. instanceof

- instanceof操作符可以帮助我们判断引用类型具体是什么类型的对象：

		[] instanceof Array // true
		new Date() instanceof Date // true
		new RegExp() instanceof RegExp // true

- 我们先来回顾下原型链的几条规则：

	- 所有引用类型都具有对象特性，即可以自由扩展属性
	- 所有引用类型都具有一个__proto__（隐式原型）属性，是一个普通对象
	- 所有的函数都具有prototype（显式原型）属性，也是一个普通对象
	- 所有引用类型__proto__值指向它构造函数的prototype
	- 当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的__proto__中去找

- [] instanceof Array实际上是判断Array.prototype是否在[]的原型链上。所以，使用instanceof来检测数据类型，不会很准确，这不是它设计的初衷：

		[] instanceof Object // true
		function(){}  instanceof Object // true

- 另外，使用instanceof也不能检测基本数据类型，所以instanceof并不是一个很好的选择。

3. toString

- 上面我们提到了toString函数，我们可以调用它实现从引用类型的转换。每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中type是对象的类型。

		const obj = {};
		obj.toString() // [object Object]

- 注意，上面提到了如果此方法在自定义对象中未被覆盖，toString才会达到预想的效果，事实上，大部分引用类型比如Array、Date、RegExp等都重写了toString方法。

        let a = [1,2,3]
        a.toString() // 1,2,3

        let a = true
        a.toString() // true

- 我们可以直接调用Object原型上未被覆盖的toString()方法，使用call来改变this指向来达到我们想要的效果。
![](./images/类型转换2.jpg)

        Object.prototype.toString.call(true)        		[object Boolean]
		Object.prototype.toString.call(123)          		[object Number]
		Object.prototype.toString.call('sss')        		[object String]
		Object.prototype.toString.call(null)         		[object Null]
		Object.prototype.toString.call(undefined)    		[object Symbol]
		Object.prototype.toString.call(Symbol())     		[object Boolean]
		Object.prototype.toString.call({})                  [object Object]
		Object.prototype.toString.call(function fn(){})     [object Function]
		Object.prototype.toString.call([])    				[object Array]
		Object.prototype.toString.call(new Error)    		[object Error]
		Object.prototype.toString.call(new Regexp())    	[object Regexp]
		Object.prototype.toString.call(Math)    			[object Math]
		Object.prototype.toString.call(JSON)    			[object JSON]
		Object.prototype.toString.call(window)    			[object Window]



<h3 id='十五、深拷贝与浅拷贝' >十五、深拷贝与浅拷贝</h3>

#### 一、前言 ####

- js的数据类型分为基本类型和引用类型，深拷贝和浅拷贝是针对引用类型来说的
- 浅拷贝：浅拷贝是创建一个新对象，这个对象有着原始对象的属性值的一份精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个属性就会对另一个产生影响
- 深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象

#### 二、浅拷贝的实现方式 ####

1. Object.assign()

- Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。
		
		let obj1 = { person: {name: "kobe", age: 41},sports:'basketball' };
		let obj2 = Object.assign({}, obj1);
		obj2.person.name = "wade";
		obj2.sports = 'football'
		console.log(obj1); // { person: { name: 'wade', age: 41 }, sports: 'basketball' }

2. 展开运算符...

- 展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。

		let obj1 = { name: 'Kobe', address:{x:100,y:100}}
		let obj2= {... obj1}
		obj1.address.x = 200;
		obj1.name = 'wade'
		console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }

3. Array.prototype.concat()

		let arr = [1, 3, {
		    username: 'kobe'
		    }];
		let arr2 = arr.concat();    
		arr2[2].username = 'wade';
		console.log(arr); //[ 1, 3, { username: 'wade' } ]
		
4. Array.prototype.slice()

		let arr = [1, 3, {
		    username: ' kobe'
		    }];
		let arr3 = arr.slice();
		arr3[2].username = 'wade'
		console.log(arr); // [ 1, 3, { username: 'wade' } ]
		

#### 三、深拷贝的实现 ####

1. JSON.parse(JSON.stringify())

		let arr = [1, 3, {
		    username: ' kobe'
		}];
		let arr4 = JSON.parse(JSON.stringify(arr));
		arr4[2].username = 'duncan'; 
		console.log(arr, arr4) //[ 1, 3, { username: ' kobe' } ] [ 1, 3, { username: 'duncan' } ]

- 这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。
- 但是这种方法存在一些缺点，由于它是依赖于JSON，因此它不支持JSON不支持的其他格式，通过JSON的官网可知，JSON只支持object,array,string,number,true,false,null这几种数据或者值，其他的比如函数，undefined，Date，RegExp等数据类型都不支持。对于它不支持的数据都会直接忽略该属性。
- 注意的就是：

	- 会忽略undefined Symbol    =>忽略
	- 不能序列化函数             =>忽略
	- 不能解决循环引用的对象
	- 不能正确处理 new Date()   =>如果对象中存在Date类型的数据，会被转换成字符串，从而丢失Date的一些特性，比如时间格式化等方法。
	- 不能处理正则              =>{}

		let obj = {
		    h1:undefined,
		    h2:null,
		    h3:function (){},
		    h4:Symbol(),
		    h5:2,
		    h6:new RegExp('ss'),
		    h7:new Date()
		};
		let obj1 = JSON.parse(JSON.stringify(obj));
		obj1.h5 = 'aaa'
		console.log(obj, obj1,typeof obj.h7,typeof obj1.h7)

		//  {
			  h1: undefined,
			  h2: null,
			  h3: [Function: h3],
			  h4: Symbol(),
			  h5: 2,
			  h6: /ss/,
			  h7: 2021-09-16T10:32:32.540Z
			} 

            { h2: null, h5: 'aaa', h6: {}, h7: '2021-09-16T10:32:32.540Z' }
            Object
            String

       循环引用情况下，会报错。
       所谓循环引用的对象，就是对象的属性又指向了自身，window就是最常见的一个环状对象。

       let obj = {name:'hello'}
       obj.self = obj   // self属性又指向了obj对象，形成了一个换
		
       let obj1 = JSON.parse(JSON.stringify(obj));
	   // Uncaught TypeError: Converting circular structure to JSON

2. 递归实现

https://juejin.cn/post/6889327058158092302#heading-7

- 拷贝简单数据类型

   - 如果是简单的数据类型，由于保存的是值，因此只需要返回这个值就行，不存在相互影响的问题。实现如下：
		
        function deepClone(target){
		  return target
		}
		
- 拷贝简单的对象

   - 所谓简单的对象，是指这些对象是由上卖弄的简单数据类型组成的，不存在Array,Function,Date等子类型的数据。比如这种：

		let obj1 = {
		  name:"hello",
		  child:{
		    name:"小明"
		  }
		}

   - 实现思路就是创建一个新的对象，然后把每个对象上的属性拷贝到新对象上。如果这个属性是简单类型的那么就直接返回这个属性值。如果是Object类型，那么就通过for...in遍历讲对象上的每个属性一个一个地添加到新的对象身上。因为无法区分对象的层级，因此使用递归，每次赋值时都是调用自己，反正如果时简单类型就递归一次直接返回值，如果是Object类型，那么就往下递归查找赋值。

		function deepClone(target){
		  if(target instanceof Object){
		      let dist = {};
		      for(let key in target){
		        // 递归调用自己获取到每个值
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}


- 拷贝复杂对象——数组

   - 使用上面的方法我们能够实现拷贝简单的对象，但是对于一些包含子类型的对象，比如数组无法实现。我们看下代码：
   
	    const a = [[11,12],[21,22]];
	    const a2 = deepClone(a);
	    console.log('........:',a2); //{ '0': { '0': 11, '1': 12 }, '1': { '0': 21, '1': 22 } }

   - 我们发现拷贝后的数组，得到的是一个特殊的对象。这个对象以数组的下标作为key值，数组的每一项作为value值，这是因为for in 在遍历数组时由于找不到key值会默认以数组的下表作为key值，数组的每一项作为value值。这样的话最终克隆后得到的数据类型就跟数组不一致了（实际上这就是数组本身的特殊造成的）。最终由数组拷贝后变成了对象。
   - 我们发现问题出在我们把所有的东西都定义成一个{}了，而数组是不能用{}来描述的，因此我们需要根据对象的类型来区分一下最终返回的数据类型。实现代码如下：

		// 先不优化代码
		function deepClone(target){
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 如果是数组，就创建一个[]
		        dist = []
		      }else{
		        dist = {};
		      }
		      for(let key in target){
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

   - 由于数组也可以通过for in进行遍历，因此实际上我们要修改的就是在克隆时，先判断要克隆的对象是不是数组即可。

- 拷贝复杂对象——函数

   - 拷贝函数这个其实有点争议，因为在很多人看来函数是无法拷贝的。在我看来函数实际上不应该有深拷贝的，如果真的要有，那么也就是实现函数的功能，同时函数的对象也必须是符合深拷贝的逻辑(引用属性不等，简单类型属性相等)：
   - 函数实现的功能要相同——返回的值相同
   - 函数身上的引用类型的属性要不相同，直接类型的属性的值要相同。

   - 如下代码所示：
    
		    const fn = function(){return 1};
		    fn.xxx = {yyy:{zzz:1}};
		    const fn2 = deepClone(fn);
		    console.log(fn !== fn2);                 // 函数不相同
		    console.log(fn.xxx!== fn2.xxx);          // 函数引用类型的属性不相同
		    console.log(fn.xxx.yyy!== fn2.xxx.yyy);  // 函数引用类型的属性不相同
		    console.log(fn.xxx.yyy.zzz === fn2.xxx.yyy.zzz);// 函数简单类型的属性值相同
		    console.log(fn() === fn2());            //  函数执行后相等

   - 那么应该如何实现一个函数的拷贝了？

      - 首先需要返回一个新的函数
      - 新的函数执行结果必须与原函数相同。

			function deepClone(target){
			  if(target instanceof Object){
			      let dist ;
			      if(target instanceof Array){
			        dist = []
			      }else if(target instanceof Function){
			        dist = function(){
			            // 在函数中去执行原来的函数，确保返回的值相同
			            return target.call(this, ...arguments);
			        }
			      }else{
			        dist = {};
			      }
			      for(let key in target){
			          dist[key] = deepClone(target[key]);
			      }
			      return dist;
			  }else{
			      return target;
			  }
			}


- 拷贝复杂对象——正则表达式

    - 如何拷贝一个正则了？以一个简单的正则为例：

        const a = /hi\d/ig;

     - 一个正则，其实由两部分组成，正则的模式（斜杠之间的内容）hi\d,以及参数ig。因此，只要能够拿到这两部分就可以得到一个正则表达式。从而实现克隆这个正则。通过正则的source属性就能够拿到正则模式，通过正则的flags属性就能够拿到正则的参数。
   
		const a = /hi\d/ig;
		console.log(a.source);   //   hi\d
		console.log(a.flags)    // ig

     - 因此，我们深拷贝一个正则实际上就是拿到这两部分，然后重新创建一个新的正则，从而实现跟原来的正则相同的功能即可。

		function deepClone(target){
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      for(let key in target){
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}


- 拷贝复杂对象——日期

  - 如果拷贝的是一个日期，在通过我们上面的方法拷贝后，返回的是一个字符串。这个字符串不是Date类型的，它无法调用Date的任何方法。因此，我们需要支持日期格式的拷贝。事实上，通过上面的Array,Function,RexExp复杂对象类型的拷贝，我们可以发现，实际上这些拷贝都是通过new XXX()，相当于创建一个新的对象返回回去。因此，日期的拷贝也是一样：
  
        dist = new Date(source);

  - 将要拷贝的日期，作为参数然后生成一个新的Date。最终实现如下：

		function deepClone(target){
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      for(let key in target){
		          dist[key] = deepClone(target[key]);
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

- 好了，到目前为止我们的深拷贝已经支持了简答数据类型，普通对象，数组，函数，正则，日期这些最常见的数据了。虽然我们的代码中有很多if else结构，但是我觉得这是最容易让大家理解的写法。

- 进一步优化

- 到目前为止，我们虽然写出了一个可使用的深拷贝函数，但是这个函数仍然存在着许多可优化的地方。（这些优化的地方也是面试官容易问到的地方）。

   - 忽略原型上的属性

      - 我们在遍历对象的属性的时候，使用的是for in，for in 会遍历包括原型上的所有可迭代的属性。

			比如：
			let a = Object.create({name:'hello'});
			a.age = 14;

            那么使用遍历时，会遍历name和age属性。而不仅仅是a自身身上的age属性。但是，事实上我们不应该去遍历原型上的属性，因为这样会导致对象属性非常深。因此，使用for in遍历时我们最好把原型上的属性和自身属性区分开来，通过hasOwnProperty筛选出自身的属性进行遍历。
		    
		    for (let key in source) {
		      // 只遍历本身的属性
		      if(source.hasOwnProperty(key)){
		        dist[key] = deepClone(source[key]);
		      }
		    }

      - 因此，优化后的代码如下：

			function deepClone(target){
			  if(target instanceof Object){
			      let dist ;
			      if(target instanceof Array){
			        // 拷贝数组
			        dist = [];
			      }else if(target instanceof Function){
			        // 拷贝函数
			        dist = function () {
			          return target.call(this, ...arguments);
			        };
			      }else if(target instanceof RegExp){
			        // 拷贝正则表达式
			       dist = new RegExp(target.source,target.flags);
			      }else if(target instanceof Date){
			          dist = new Date(target);
			      }else{
			        // 拷贝普通对象
			        dist = {};
			      }
			      for(let key in target){
			          // 过滤掉原型身上的属性
			        if (target.hasOwnProperty(key)) {
			            dist[key] = deepClone(target[key]);
			        }
			      }
			      return dist;
			  }else{
			      return target;
			  }
			}


   - 环状对象的爆栈问题
   
     - 我们在之前使用JSON.parse(JSON.stringify())拷贝对象时，就遇到过如果出现环状对象，会导致报错问题。那么使用我们自己的深拷贝函数同样会遇到问题。这是由于我们在deepClone函数中使用了递归，按理来说每一个递归应该有一个终止条件的，但是由于对象树结构一般会有终点，因此会自动在终点结束递归。但是如果一个对象有属性指向自身，那么就会形成一个环，比如：

			let a = {name:"小明"};
			a.self = a;   // a的self属性指向a

     - 这样的话，在进行递归调用的过程中会无限循环，最终爆栈。因此，我们需要添加递归终止条件。所谓的递归终止条件，就是判断一个对象是否已经被克隆过了，如果被克隆过了那么就直接使用克隆后的对象，不再进行递归。因此，我们需要一个东西来保存可能重复的属性以及它的克隆地址。最好的方式就是map。

		let cache = new Map();
		function deepClone(target){
		  if(cache.get(target)){
		      return cache.get(target)
		  }
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      // 将属性和拷贝后的值作为一个map
		      cache.set(target, dist);
		      for(let key in target){
		          // 过滤掉原型身上的属性
		        if (target.hasOwnProperty(key)) {
		            dist[key] = deepClone(target[key]);
		        }
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}


    - 共用缓存导致的互相影响问题
    
       - 在上面的deepClone函数中，我们通过新增了一个缓存cache来保存已经克隆过的对象和它对应的克隆地址。但是这种方式会带来一个新的问题：由于每次克隆创建一个对象都会使用这个cache，这样的话会导致克隆一个新的对象受到上一个克隆对象的影响。示例：
       
		  let a = {
		    name:"hello",
		  }     
		  let a1 = deepClone(a);
		  console.log(map);  //{ name: 'hello' } => { name: 'hello' }
		  let b = {
		    age:24
		  }
		  let b1 = deepClone(b);
		  console.log(map);  //   { name: 'hello' } => { name: 'hello' },{ age: 24 } => { age: 24 } }

      - 我们发现在深拷贝对象b的时候，map中已经有值了{ name: 'hello' }。而事实上这些值不是b身上已经拷贝过的属性。也就是说b的拷贝受到了a的拷贝的影响，这会导致问题。因此，我们不能让所有的深拷贝共用同一个缓存，而是让每一个深拷贝使用自己的属性。

      - 解决办法是：在调用函数时，每次都创建一个新的map（默认参数），然后如果需要递归，就把这个map往下传。
      
		function deepClone(target,cache = new Map()){
		  if(cache.get(target)){
		      return cache.get(target)
		  }
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);
		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      // 将属性和拷贝后的值作为一个map
		      cache.set(target, dist);
		      for(let key in target){
		          // 过滤掉原型身上的属性
		        if (target.hasOwnProperty(key)) {
		            dist[key] = deepClone(target[key], cache);
		        }
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

   - 对象过长导致的爆栈问题
   
      - 我们知道我们深拷贝中使用了递归，而递归是有递归栈的，递归栈的深度是有限的，一旦对象的递归深度超过了递归栈的深度，那么就可能出现爆栈。
      - 比如，下面的对象a的对象深度有20000个属性。这样的话基本上递归到5000时就出现爆栈了，导致报错。
      
	     let a = {
	        child:null 
	      }
	      let b = a;
	      for(let i = 0;i < 20000;i++){
	        b.child = {
	          child:null
	        }
	        b = b.child;
	      }
	      console.log(a);

    - 这种由于对象过深导致的爆栈问题，暂时没有什么解决办法，而且也很少会有这么深的对象。

  - 好了，到目前为止，我们基本上实现了一个功能较为完整的深拷贝。最终的实现函数如下：
  
		function deepClone(target,cache = new Map()){
		  if(cache.get(target)){
		      return cache.get(target)
		  }
		  if(target instanceof Object){
		      let dist ;
		      if(target instanceof Array){
		        // 拷贝数组
		        dist = [];
		      }else if(target instanceof Function){
		        // 拷贝函数
		        dist = function () {
		          return target.call(this, ...arguments);
		        };
		      }else if(target instanceof RegExp){
		        // 拷贝正则表达式
		       dist = new RegExp(target.source,target.flags);

		      }else if(target instanceof Date){
		          dist = new Date(target);
		      }else{
		        // 拷贝普通对象
		        dist = {};
		      }
		      // 将属性和拷贝后的值作为一个map
		      cache.set(target, dist);
		      for(let key in target){
		          // 过滤掉原型身上的属性
		        if (target.hasOwnProperty(key)) {
		            dist[key] = deepClone(target[key], cache);
		        }
		      }
		      return dist;
		  }else{
		      return target;
		  }
		}

  - 接下来我们就写一个复杂的对象，使用这个对象进行深拷贝，测试我们的函数性能。
  
          const a = {
            i: Infinity,
            s: "",
            bool: false,
            n: null,
            u: undefined,
            sym: Symbol(),
            obj: {
              i: Infinity,
              s: "",
              bool: false,
              n: null,
              u: undefined,
              sym: Symbol(),
            },
            array: [
              {
                nan: NaN,
                i: Infinity,
                s: "",
                bool: false,
                n: null,
                u: undefined,
                sym: Symbol(),
              },
              123,
            ],
            fn: function () {
              return "fn";
            },
            date: new Date(),
            re: /hi\d/gi,
          };
          let a2 = deepClone(a);

































   
<h1 id='css总结' style='background-color:darkgrey;'>css总结<h1>

<h3 id='一、BFC（块级格式化上下文）' >一、BFC（块级格式化上下文）</h3>

- 我们看到的页面是由一个一个的盒子组成的，元素的类型和display属性决定了这个盒子的类型，不同类型的盒子会参与不同的格式化上下文。格式化上下文就是页面中一块独立的渲染区域，并且有一套自己的渲染规则，它规定了其内部的子元素如何布局，而BFC就是display属性为block（此元素将显示为块级），list-item（此元素将显示为列表），table（此元素会作为块级表格来显示）的元素参与的格式化上下文，直译为块级格式化上下文。
 - 它的布局规则是：
       - 内部的盒子会在垂直方向上一个接一个的排列
       - 盒子垂直方向上的距离由margin决定，属于同一个BFC的相邻的两个盒子的margin会发生重叠
       - 对于从左往右的格式来说，盒子的左外边缘（margin-left）会触碰到容器的左边缘（border-left）
       - BFC区域和浮动区域不会重叠（自适应两栏布局）
       - BFC区域就是页面中的一块独立的区域，容器里面的子元素不会影响到外面的元素
       - 计算BFC时浮动元素也会参与计算（解决高度塌陷）        

 - 开启BFC:
       
       - 根元素（html）
       - float属性不为none
       - position属性为absolute,fixed
       - overflow属性不为visible
       - display属性为inline-block,table-cell,table-caption,flex,inline-flex

 - 应用

    - 解决高度塌陷

         - 高度塌陷是由于父元素没有设置高度，高度是由子元素撑起来的，当子元素设置了浮动脱离文档流之后，父元素就会塌陷，这时候我们可以给父元素开启BFC,因为计算BFC时浮动元素也会参与计算，所以就解决了父元素的高度塌陷问题

    - 实现自适应两栏布局BFC

         - 设置两个div，第一个div宽度固定，设置左浮动，第二个div就会自动填满剩余的宽度，正常情况下，第一个div会覆盖一部分第二个div。这时候我们可以给第二个div开启BFC，由于BFC和浮动元素不会重叠，这样就实现了两栏布局

    - 解决margin重叠

         - 由于属于同一个BFC相邻的两个块级元素会发生margin重叠，所以我们可以给其中一个盒子包一层div，然后激活它的BFC，这样它俩就不属于同一个BFC了，就不会margin重叠了


<h3 id='二、清除浮动'>二、清除浮动（https://blog.csdn.net/u012207345/article/details/78279961）</h3>

- 清除浮动的方法主要分为两类，一类是使用clear属性，一类是使用BFC
  - clear属性只能影响使用该属性的元素本身，不能影响其他元素。clear属性规定元素盒子的边不能和浮动元素相邻，所以我们使用clear清除浮动的原理就是，在父元素的最后加一个具有clear属性的块级元素，由于该块级元素不能和浮动元素相邻，而浮动元素的位置我们已经确定了，所以为了满足该元素的需求，将该元素渲染在了浮动元素的下面，由于该元素在父元素的边界内，所以父元素必须增加高度将它包含在内，这样就达到了清除浮动的目的
  - BFC原理是由于开启了BFC的元素在计算其高度时，是要包含浮动元素的，所以给父元素开启BFC就能清除浮动

<h3 id='三、css3动画'>三、css3动画</h3>

- css动画主要有transform，translation，animation。transform可以理解为元素的几何变形，它不会产生动画效果。translation和animation都可以实现过渡动画，不同的是translation只能定义开始状态和结束状态，不能定义中间状态，并且translation动画是需要事件触发的（：hover,:focus,js触发），不能在网页加载时自动执行，并且动画是不能循环的。

<h3 id='四、box-sizing'>四、box-sizing</h3>

- box-sizing 是用于告诉浏览器如何计算一个元素是总宽度和总高度
  - 标准盒模型 box-sizing: content-box

       - width = content width
       - height = content height

  - IE盒模型 box-sizing: border-box

       - width = border + padding + content width
       - heigth = border + padding + content heigth
       

<h1 id='vue总结'>vue总结</font><h1>

<h3 id='一、MVVM'>一、MVVM</h3>

#### 一、什么是MVVM？ ####

- MVVM是Module-View-ViewModule的缩写，Module层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI展现出来，ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作
- Module和View并无直接联系，而是通过ViewModule来联系的，Module和ViewModule是双向数据绑定关系，因此当Module层的数据发生改变时会触发View层刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步
- 这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom

#### 二、MVVM优缺点 ####

- 优点：
   
  - 自动更新dom: 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放
  - 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变
  - 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑
  - 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
  - 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写

- 缺点：

  - 数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了
  - 对于过大的项目，数据绑定需要花费更多的内存

#### 三、mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？ ####

- mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。
- mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
- 区别：
 
    - vue数据驱动，通过数据来显示视图层而不是节点操作
    - 数据操作比较多的场景，更加便捷


<h3 id='二、vue双向绑定原理'>二、vue双向绑定原理</h3>

- https://www.cnblogs.com/wangjiachen666/p/9883916.html
- https://www.cnblogs.com/canfoo/p/6891868.html
#### 一、原理 ####

- vue数据双向绑定是通过数据劫持结合发布订阅者模式的方式来实现的

#### 二、实现过程分析 ####

1. 实现mvvm主要包括两方面，数据变化更新视图，视图变化更新数据
 
   - 视图变化更新数据可以通过事件监听来实现
   - 主要来分析一下数据改变如何来更新视图

2. 数据改变更新视图分析

   - （1）如何知道数据发生变化了

       - 我们可以通过Object.definePrototype(obj,prop,descriptor)方法为属性设置一个set函数，当数据改变了就会触发这个函数，所以我们只要将更新视图的方法写进这个函数里面就好了

          - obj:要定义属性的对象
          - prop:要定义会修改的属性
          - descriptor:要定义或修改的属性的描述符
                  
             - 数据描述符
                  
               - configurable 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认值false
               - enumerable 表示属性是否可枚举,默认值false
               - value 属性值，默认值为undefined
               - writable 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变，默认为 false。
     
             - 存取描述符

                - get:属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值,默认为 undefined。
                - set:属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。

   - (2)实现过程

      - 实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要一个监听器Observer，来监听所有属性。当属性发生变化了就告诉订阅者Watcher看是否需要更新。由于订阅者是很多个的，所以需要一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间统一管理。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：

        - 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
        - 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
        - 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

        1. 实现一个Observer，使数据对象变得可观测

	           function defineReactive（obj,key,val）{
	                 
	               Object.definePrototype(obj,key,{
	 
	                  enumerable: true,
	                  configurable: true,
	
	                  get() {
	                    console.log(`${key}属性被读取了`)
	                    return val    
	                  },
	
	                  set(newVal) {
	                     console.log(`我监测到${key}属性被修改了`)
	                     val = newVal
	                  }
	
	                })
	             }


	           function observable(obj){
	               if(!obj || typeof obj !== 'object'){
	                  return
	               }
	               
	               Object.keys(obj).forEach((key)=>{
	                   defineReactive(obj,key,obj[key])
	               })
	               
	               return obj
	           }


       2. 创建消息订阅器Dep
      
       - 完成了数据的'可观测'，即我们知道了数据在什么时候被读或写了，那么，我们就可以在数据被读或写的时候通知那些依赖该数据的视图更新了，为了方便，我们需要先将所有依赖收集起来，一旦数据发生变化，就统一通知更新。其实，这就是典型的“发布订阅者”模式，数据变化为“发布者”，依赖对象为“订阅者”。现在，我们需要创建一个依赖收集容器，也就是消息订阅器Dep，用来容纳所有的“订阅者”。订阅器Dep主要负责收集订阅者，然后当数据变化的时候后执行对应订阅者的更新函数。

		         class Dep{
		
		           constructor() {
		              this.subs=[]
		            },
		
		           addSub(sub) {
		             this.subs.push(sub) 
		           }
		
		           depend() {
		             if(Dep.target){
		                this.addSub(Dep.target) //保证初始化时，添加订阅者（我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要
		                                                                 做一个判断操作，所以这里的Dep.target指的就是订阅者Watcher）
		             }
		           }
		
		           notify() {
		            this.subs.forEach(sub)=>{
		               sub.update()              //遍历所有订阅者，去执行更新函数(每个订阅者都有一个update函数)
		            })
		           }
		         }
		
		         Dep.target=null

    3. 有了订阅器之后再改造一下defineReactive函数，在defineReactive函数里边加入订阅器

		        function defineReactive(obj,key,val){
		            dep=new Dep()
		           Object.definePrototype(obj,key,{
		               enumerable: true,
		               configurable: true,
		
		               get() {
		                 dep.depend()
		                 console.log(`${key}属性被读取了`);
		                 return val
		               }
		
		               set(newVal) {
		                 val=newVal
		                 console.log(`${key}属性被修改了`);
		                 this.notify() //数据变化通知所有的订阅者
		               }
		           })
		        }


   4. 订阅者Watcher

      - 订阅者在初始化vue实例的时候，需要将自己添加进订阅器Dep中，以便后面数据变化的时候，能够通知到该订阅者，如何添加呢？

        - 我们知道上面我们的监听器Observer是在get函数中执行了，添加订阅者Watcher的操作的，所以我们只需要在初始化vue实例的时候，去执行get方法就好了，而执行get方法就是去获取属性值就好了
        - 我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在Dep.target上缓存下订阅者，添加成功后再将其去掉就可以了

            class Watcher{
              constructor(vm,exp.cb){
                this.vm = vm   // vue实例
                this.exp = exp // 是node节点的v-model或v-on：click等指令的属性值。如v-model="name"，exp就是name
                this.cb = cb   // 是Watcher绑定的更新函数;
                this.value = this.get() //执行自己的get方法，在get方法中会将自己缓存在Dep.target中，并获取vm的属性值，从而触
                                           发监听器Observer的get方法，从而达到将自己添加到订阅器的目的
              },
              
              update() {
               let value = this.vm.data[this.exp] //修改属性值的时候，触发监听器中的set函数,然后执行该方法，获取修改之后的新值
               let oldVal = this.value  //该this.value值是在初始化实例的时候，在get方法中获取到的
               if(value !== oldVal){
                 this.value = value
                 this.cb.call(this.vm,value,oldVal)
               }
              },
              
              get() {
                Dep.target=this //缓存自己
                let value = this.vm.data[this.exp] //获取vm中的属性值，执行Observer中的get函数，把自己添加到订阅器
                Dep.target = null //添加完之后，释放自己
                return value
              }
           	 }


    过程分析：当我们去实例化一个构造函数时(new Watcher),会发生new的四个过程，其中一步是执行我们的构造函数的逻辑，所以我们就会执行它
             的this.get()方法 ，进入get方法，首先会执行：
                                     
                                           Dep.target=this //缓存自己

             实际上就是把 Dep.target 赋值为当前的渲染 watcher ,接着又执行了：

                                           let value = this.vm.data[this.exp]  // 强制执行监听器Observer里的get函数

             在这个过程中会对vm上的数据访问，其实就是为了触发数据对象的getter，每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 this.addSub(Dep.target),即把当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。
             这样实际上已经完成了一个依赖收集的过程。那么到这里就结束了吗？其实并没有，完成依赖收集后，还需要把 Dep.target 恢复成上一个状态，即：
                                           Dep.target = null;  // 释放自己

             因为当前vm的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变。

			 而update()函数是用来当数据发生变化时调用Watcher自身的更新函数进行更新的操作。先通过let value = this.vm.dat[this.exp];获取到最新的数据,然后将其与之前get()获得的旧数据进行比较，如果不一样，则调用更新函数cb进行更新。
			
    5. 将Observer和Watcher关联起来

	         function myVue(data,el,exp){
	            this.data=data
	            observable(data) //将数据变得可观测
	            el.innerHtml = this.data[exp] //初始化模板数据的值
	            new Watcher(this,exp,function(value){
	                 el.innerHtml = value
	           })                        //初始化将订阅者添加到订阅器
	
	           return this
	         }


    6. 测试使用

	       <body>
			<h1 id="name"></h1>
			<input type="text">
			<input type="button" value="改变data内容" onclick="changeInput()">
			
			<script src="observer.js"></script>
			<script src="watcher.js"></script>
			<script>
				var ele = document.querySelector('#name');
				var input = document.querySelector('input');
				
			    var myVue = new myVue({
					name: 'hello world'
				}, ele, 'name');
			 	
				//改变输入框内容
			    input.oninput = function (e) {
			    	myVue.data.name = e.target.value
			    }
				//改变data内容
				function changeInput(){
					myVue.data.name = "难凉热血"
				
				}
			</script>
		</body>
	


     - observer.js

       - 把一个对象的每一项都转化成可观测对象
	

			function observable (obj) {
				if (!obj || typeof obj !== 'object') {
		        	return;
		    	}
				let keys = Object.keys(obj);
				keys.forEach((key) =>{
					defineReactive(obj,key,obj[key])
				})
				return obj;
			}

	
      - 使一个对象转化成可观测对象

			function defineReactive (obj,key,val) {
				let dep = new Dep();
				Object.defineProperty(obj, key, {
					get(){
						dep.depend();
						console.log(`${key}属性被读取了`);
						return val;
					},
					set(newVal){
						val = newVal;
						console.log(`${key}属性被修改了`);
						dep.notify()                    //数据变化通知所有订阅者
					}
				})
			}
		
			class Dep {
				
				constructor(){
					this.subs = []
				}
				//增加订阅者
				addSub(sub){
					this.subs.push(sub);
				}
		        //判断是否增加订阅者
				depend () {
				    if (Dep.target) {
				     	this.addSub(Dep.target)
				    }
				}
		
				//通知订阅者更新
				notify(){
					this.subs.forEach((sub) =>{
						sub.update()
					})
				}
				
			}
		
			Dep.target = null;

   - watcher.js

		    class Watcher {
				constructor(vm,exp,cb){
				    this.vm = vm;
				    this.exp = exp;
				    this.cb = cb;
				    this.value = this.get();  // 将自己添加到订阅器的操作
				}
				get(){
					Dep.target = this;  // 缓存自己
		        	let value = this.vm.data[this.exp]  // 强制执行监听器里的get函数
		        	Dep.target = null;  // 释放自己
		        	return value;
				}
				update(){
					let value = this.vm.data[this.exp];
		        	let oldVal = this.value;
		        	if (value !== oldVal) {
		                this.value = value;
		                this.cb.call(this.vm, value, oldVal);
					}
			    }
		     }


   7. 还有一个细节问题就是我们在赋值的时候是这样的，myVue.data.name = "难凉热血"，而我们的理想形式是myVue.name = '难凉热血'，为了实现这样的形式，我们需要在new SelfVue的时候做一个代理处理，让访问selfVue的属性代理为访问selfVue.data的属性，实现原理还是使用Object.defineProperty( )对属性值再包一层：

	        function myVue (data, el, exp) {
			    var self = this;
			    this.data = data;
			 
			    Object.keys(data).forEach(function(key) {
			        self.proxyKeys(key);  // 绑定代理属性
			    });
			 
			    observe(data);
			    el.innerHTML = this.data[exp];  // 初始化模板数据的值
			    new Watcher(this, exp, function (value) {
			        el.innerHTML = value;
			    });
			    return this;
			}
			 
			myVue.prototype = {
			    proxyKeys: function (key) {
			        var self = this;
			        Object.defineProperty(this, key, {
			            enumerable: false,
			            configurable: true,
			            get: function proxyGetter() {
			                return self.data[key];
			            },
			            set: function proxySetter(newVal) {
			                self.data[key] = newVal;
			            }
			        });
			    }
			}

     	这下我们就可以直接通过myVue.name = '难凉热血'改变属性值了

    8. 实现Compile

       - (1) 为了解析模板，首先需要获取到dom元素，然后对含有dom元素上含有指令的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理
       - (2)接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理,这里通过if(node.nodeType == 1)来判断该节点是否为元素节点，可以分为两种情况：元素节点(v-model,v-bind,v-html,class,v-on)和文本节点且匹配{{}}这种形式，分别处理
	
             - 在每个元素节点中又分为事件指令和普通指令分别处理，因为事件指令比其他的要多传一个参数(事件类型如click）
             
               - 事件指令通过addEventListener来添加事件
               - 文本节点且匹配{{}}这种形式，直接处理
	
     - https://github.com/DMQ/mvvm/blob/master/js/compile.js


<h3 id='三、vue双向绑定原理再理解'>三、vue双向绑定原理再理解</h3>

#### 一、代理的作用 ####

- vue响应式原理依赖Object.definePrototype，通过setter/getter监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。
- 第一步将数据变为响应式的

		 class Vue{
		  constructor(options) {
		     this.data = options.data
		     this.observe(this.data,options.render)
		  }

		  observe(obj,render) {
		    Object.keys(obj).forEach(key => {
		      this.defineReactive(obj,key,obj[key],render) 
		    })
		  }
		
		  defineReactive(obj,key,value,render) {
		     Object.defineProperty(obj,key,{
		       configurable:true,
		       enumerable:true,
		       get:() =>{
		         return value
		       },
		       set:newValue => {
		        value = newValue
		         render(value)
		       }
		
		     })
		  }
		}

		
		let app = new Vue({
		  data:{
		    text1:1,
		    text2:2,
		    text3:3
		  },
		  render(data) {
		    console.log(data)
		  }
		})
		
		app.data.text1 = 6


- 第二步代理

   - 由第一步可以看出来，必须这样调用app.data.text1才能触发setter，因为上面实现中，Object.definePrototype绑定的是obj，也就是data对象，所以必须调用data才能触发setter。现在我们想要实现直接app.text1这样调用，按上面的的分析思路，我们应该让Object.definePrototype绑定app对象，这样改变它的属性就能触发setter，我们可以在Vue的构造函数constructor中为data执行一个代理proxy。这样我们就把data上面的属性代理到了vm实例上。

		class Vue{
		  constructor(options) {
		     this.data = options.data
		     this.proxy.call(this,this.data,options.render)
		  }
		  proxy(obj,render) {
		    let that = this
		    Object.keys(obj).forEach(key => {
		
		      Object.defineProperty(that,key,{
		        configurable:true,
		        enumerable:true,
		        get:() =>{
		          return that.data[key]
		        },
		        set:newValue => {
		         that.data[key] = newValue
		          render(that.data[key])
		        }
		      })
		    })
		  }
		}
		
		let app = new Vue({
		  data:{
		    text1:1,
		    text2:2,
		    text3:3
		  },
		  render(data) {
		    console.log(data)
		  }
		})
		
		app.text1 = 6


#### 二、全部实现过程 ####

https://juejin.cn/post/6989106100582744072#heading-14

			class Vue{
			  constructor(options) {
			    // 获取到传入的对象 没有默认为空对象
			     this.$options = options || {}
			
			     // 获取 el
			     this.$el = options.el === 'string'?document.querySelector(options.el):options.el
			
			     // 获取 data
			     this.$data = options.data || {}
			
			     // 调用 proxyData 处理data中的属性，将data属性代理给Vue实例
			     this.proxyData(this.$data)
			
			     //使用 Obsever 把data中的数据转为响应式
			     new Observer(this.$data)
			
			     //编译模板
			     new Compiler(this)
			    }
			     proxyData(data) {
			       Object.keys(data).forEach(key => {
			          // 进行数据劫持
			          // 把每个data的属性 到添加到 Vue 转化为 getter setter方法
			          Object.defineProperty(this,key,{
			            // 设置可以枚举
			            enumerable:true,
			            // 设置可以配置
			            configurable:true,
			             // 获取数据
			            get:() => {
			              return data[key]
			            },
			            // 设置数据
			            set:newVal => {
			               // 判断新值和旧值是否相等
			              if(newVal === data[key]){
			                return
			              }
			              // 设置新值
			              newVal = data[key]
			            }
			          })
			       })
			     }
			
			}
			
			class Observer{
			
			  constructor(data){
			    //用来遍历data
			    this.walk(data)
			  }
			
			  // 遍历 data 转为响应式
			  walk() {
			    // 判断 data是否为空 和 对象
			    if(!data || typeof data !== 'object'){
			      return
			    }
			    // 遍历 data
			    Object.keys(data).forEach(key => {
			      // 转为响应式
			      this.defineReactive(data,key,data[key])
			    })
			  }
			
			  // 转为响应式
			  // 要注意的 和vue.js 写的不同的是
			  // vue.js中是将 属性给了 Vue 转为 getter setter
			  // 这里是 将data中的属性转为getter setter
			
			  defineReactive(obj,key,value) {
			
			    // 如果是对象类型的 也调用walk 变成响应式，不是对象类型的直接在walk会被return
			    this.walk(value)
			    // 保存一下 this
			    let self = this
			   // 创建 Dep 对象
			    let dep = new Dep()
			    Object.defineProperty(obj,key,{
			      enumerable:true,
			      configurable:true,
			
			      get:() => {
			        // 在这里添加观察者对象 Dep.target 表示观察者
			        if(Dep.target){
			          dep.addSub(Dep.target)
			        }
			        return value
			      },
			
			      set:newVal => {
			         if(value === newVal){
			           return
			         }
			         
			         // 赋值的话如果是newValue是对象，对象里面的属性也应该设置为响应式的
			         self.walk(newVal)
			          // 触发通知 更新视图
			         dep.notify()
			      }
			    })
			  }
			} 
			
			class Dep{
			  constructor() {
			    // 存储观察者
			    this.subs = []
			  }
			
			  // 添加观察者
			  addSub(sub) {
			    // 判断观察者是否存在 和 是否拥有update方法
			     if(sub && sub.updata){
			       this.subs.push(sub)
			     }
			  }
			
			  notify() {
			    // 通知方法
			    this.subs.forEach(sub => {
			      // 触发每个观察者的更新方法
			      sub.updata()
			    })
			  }
			}
			
			
			
			class Compiler {
			  // vm 指 Vue 实例
			  constructor(vm) {
			    // 拿到 vm
			    this.vm = vm
			    // 拿到 el
			    this.el = vm.$el
			    // 编译模板
			    this.compile(this.el)
			  }
			  // 编译模板
			  compile(el) {
			    // 获取子节点 如果使用 forEach遍历就把伪数组转为真的数组
			    let childNodes = [...el.childNodes]
			    childNodes.forEach((node) => {
			      // 根据不同的节点类型进行编译
			      // 文本类型的节点
			      if (this.isTextNode(node)) {
			        // 编译文本节点
			        this.compileText(node)
			      } else if (this.isElementNode(node)) {
			        //元素节点
			        this.compileElement(node)
			      }
			      // 判断是否还存在子节点考虑递归
			      if (node.childNodes && node.childNodes.length) {
			        // 继续递归编译模板
			        this.compile(node)
			      }
			    })
			  }
			  // 编译文本节点(简单的实现)
			  compileText(node) {
			    // 核心思想利用把正则表达式把{{}}去掉找到里面的变量
			    // 再去Vue找这个变量赋值给node.textContent
			    let reg = /\{\{(.+?)\}\}/
			    // 获取节点的文本内容
			    let val = node.textContent
			    // 判断是否有 {{}}
			    if (reg.test(val)) {
			      // 获取分组一  也就是 {{}} 里面的内容 去除前后空格
			      let key = RegExp.$1.trim()
			      // 进行替换再赋值给node
			      node.textContent = val.replace(reg, this.vm[key])
			      // 创建观察者
			      new Watcher(this.vm, key, (newValue) => {
			        node.textContent = newValue
			      })
			    }
			  }
			  // 编译元素节点这里只处理指令
			  compileElement(node) {
			    // 获取到元素节点上面的所有属性进行遍历
			    ![...node.attributes].forEach((attr) => {
			      // 获取属性名
			      let attrName = attr.name
			      // 判断是否是 v- 开头的指令
			      if (this.isDirective(attrName)) {
			        // 除去 v- 方便操作
			        attrName = attrName.substr(2)
			        // 获取 指令的值就是  v-text = "msg"  中msg
			        // msg 作为 key 去Vue 找这个变量
			        let key = attr.value
			        // 指令操作 执行指令方法
			        // vue指令很多为了避免大量个 if判断这里就写个 uapdate 方法
			        this.update(node, key, attrName)
			      }
			    })
			  }
			  // 添加指令方法 并且执行
			  update(node, key, attrName) {
			    // 比如添加 textUpdater 就是用来处理 v-text 方法
			    // 我们应该就内置一个 textUpdater 方法进行调用
			    // 加个后缀加什么无所谓但是要定义相应的方法
			    let updateFn = this[attrName + 'Updater']
			    // 如果存在这个内置方法 就可以调用了
			    updateFn && updateFn.call(this, node, key, this.vm[key])
			  }
			  // 提前写好 相应的指定方法比如这个 v-text
			  // 使用的时候 和 Vue 的一样
			  textUpdater(node, key, value) {
			    node.textContent = value
			    // 创建观察者
			    new Watcher(this.vm, key, (newValue) => {
			      node.textContent = newValue
			    })
			  }
			  // v-model
			  modelUpdater(node, key, value) {
			    node.value = value
			    // 创建观察者
			    new Watcher(this.vm, key, (newValue) => {
			      node.value = newValue
			    })
			    // 这里实现双向绑定
			    node.addEventListener('input', () => {
			      this.vm[key] = node.value
			    })
			  }
			
			  // 判断元素的属性是否是 vue 指令
			  isDirective(attr) {
			    return attr.startsWith('v-')
			  }
			  // 判断是否是元素节点
			  isElementNode(node) {
			    return node.nodeType === 1
			  }
			  // 判断是否是 文本 节点
			  isTextNode(node) {
			    return node.nodeType === 3
			  }
			}
			
			
			class watcher{
			  constructor(vm,key,cb){
			    // vm 是 Vue 实例
			    this.vm = vm
			    // key 是 data 中的属性
			    this.key = key
			    // cb 回调函数 更新视图的具体方法
			    this.cb = cb
			    // 把观察者的存放在 Dep.target
			    Dep.target = this
			    // 旧数据 更新视图的时候要进行比较
			    // 还有一点就是 vm[key] 这个时候就触发了 get 方法
			    // 之前在 get 把 观察者 通过dep.addSub(Dep.target) 添加到了 dep.subs中
			    this.oldVal = vm[key]
			    // Dep.target 就不用存在了 因为上面的操作已经存好了
			    Dep.target = null
			  }
			  // 观察者中的必备方法 用来更新视图
			  update() {
			    // 获取新值
			    let newVal = this.vm[this.key]
			    // 比较旧值和新值
			    if(newVal === this.oldVal){
			      return
			    }
			    // 调用具体的更新方法
			    this.cb(newVal)
			  }
			}
			
			     
<h3 id='四、diff算法' >四、diff算法</h3>

https://juejin.cn/post/6994959998283907102
#### 一、虚拟DOM ####

1. 什么是虚拟DOM？

- 虚拟DOM是一个对象，一个什么样的对象呢？一个用来表示真实DOM的对象，即虚拟DOM就是将真实的DOM的数据抽离出来，以对象的形式模拟树形结构，看下面例子：

		<ul id="list">
		    <li class="item">哈哈</li>
		    <li class="item">呵呵</li>
		    <li class="item">嘿嘿</li>
		</ul>

对应的虚拟DOM为：

        // 旧虚拟DOM

		let oldVDOM = { 
		        tagName: 'ul', // 标签名
		        props: { // 标签属性
		            id: 'list'
		        },
		        children: [ // 标签子节点
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['哈哈']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['呵呵']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['嘿嘿']
		            },
		        ]
		    }


这时候，我修改一个li标签的文本：

		<ul id="list">
		    <li class="item">哈哈</li>
		    <li class="item">呵呵</li>
		    <li class="item">林三心哈哈哈哈哈</li> // 修改
		</ul>

这时候生成的新虚拟DOM为：

        // 新虚拟DOM

		let newVDOM = { 
		        tagName: 'ul', // 标签名
		        props: { // 标签属性
		            id: 'list'
		        },
		        children: [ // 标签子节点
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['哈哈']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['呵呵']
		            },
		            {
		                tagName: 'li', props: { class: 'item' }, children: ['林三心哈哈哈哈哈']
		            },
		        ]
		    }


这就是咱们平常说的新旧两个虚拟DOM，这个时候的新虚拟DOM是数据的最新状态，那么我们直接拿新虚拟DOM去渲染成真实DOM的话，效率真的会比直接操作真实DOM高吗？那肯定是不会的，看下图：

![](./images/diff1.jpg)

示例1是创建一个DOMB然后替换掉DOMA;示例2去创建虚拟DOM+DIFF算法比对发现DOMB跟DOMA不是相同的节点,最后还是创建一个DOMB然后替换掉DOMA;可以明显看出1是更快的。同样的结果,2还要去创建虚拟DOM+DIFF算法对比，所以说使用虚拟DOM比直接操作真实DOM就一定要快这个说法是错误的，不严谨的。

#### 二、什么是diff算法 ####

![](./images/diff2.jpg)

上图中，其实只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。

- 所以，当一些复杂的节点,比如说一个父节点里面有多个子节点,当只是一个子节点的内容发生了改变,那么我们没有必要像示例1重新去渲染这个DOM树,这个时候虚拟DOM+DIFF算法就能够得到很好的体现,我们通过示例2使用**虚拟DOM+Diff算法**去找出改变了的子节点更新它的内容就可以了。
- diff 算法首先要明确一个概念就是 Diff 的对象是虚拟DOM（virtual dom），更新真实 DOM 是 Diff 算法的结果。Diff算法是一种对比算法，对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。

#### 三、为什么要使用虚拟DOM ####

- 当然是前端优化方面，避免频繁操作DOM，频繁操作DOM会可能让浏览器回流和重绘，性能也会非常低，还有就是手动操作 DOM 还是比较麻烦的，要考虑浏览器兼容性问题，当前jQuery等库简化了 DOM操作，但是项目复杂了，DOM操作还是会变得复杂，数据操作也变得复杂
- 并不是所有情况使用虚拟DOM 都提高性能，是针对在复杂的的项目使用。如果简单的操作，使用虚拟DOM,要创建虚拟DOM对象等等一系列操作，还不如普通的DOM 操作
- 虚拟DOM 可以实现跨平台渲染，服务器渲染 、小程序、原生应用都使用了虚拟DOM
- 使用虚拟DOM改变了当前的状态不需要立即的去更新DOM 而且更新的内容进行更新，对于没有改变的内容不做任何操作，通过前后两次差异进行比较
- 虚拟 DOM 可以维护程序的状态，跟踪上一次的状态

#### 四、diff算法原理 ####

1. Diff同层对比

-  传统的计算两颗树的差异时间复杂度为O(n^3),显然成本比较高（老树的每一个节点都去遍历新树的节点，直到找到新树对应的节点。那么这个流程就是 O(n^2)，再紧接着找到不同之后，再计算最短修改距离然后修改节点，这里是 O(n^3)。）

- 新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:深度优先算法。 时间复杂度:O(n)

![](./images/diff3.jpg)

2. diff的对比流程

- 当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，订阅者们就会调用patch方法，给真实DOM打补丁，更新相应的视图
- newVnode和oldVnode：同层的新旧虚拟节点

![](./images/diff4.jpg)

- （1）patch方法

    - patch函数是diff流程的入口函数，这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签(同一类型的标准，下面会讲)：

      - 是：继续执行patchVnode方法进行深层比对
      - 否：没必要比对了，直接整个节点替换成新虚拟节点

    - 来看看patch的核心原理代码

		       function patch(oldVnode, newVnode) {
		
				  // 比较是否为一个类型的节点
				  if (sameVnode(oldVnode, newVnode)) {
		
				    // 是：继续进行深层比较
				    patchVnode(oldVnode, newVnode)
		
				  } else {
				    // 否
		
				    const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点
		
				    const parentEle = api.parentNode(oldEl) // 获取父节点
		
				    createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点
		
				    if (parentEle !== null) {
		
				      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素
		
				      api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点
		
				      // 设置null，释放内存
				      oldVnode = null
				    }
				  }
				
				  return newVnode
				}

- （2）sameVnode方法

    - patch关键的一步就是sameVnode方法判断是否为同一类型节点，那问题来了，怎么才算是同一类型节点呢？这个类型的标准是什么呢？
    - 咱们来看看sameVnode方法的核心原理代码，就一目了然了

				function sameVnode(oldVnode, newVnode) {
		
				  return (
				    oldVnode.key === newVnode.key && // key值是否一样
				    oldVnode.tagName === newVnode.tagName && // 标签名是否一样
				    oldVnode.isComment === newVnode.isComment && // 是否都为注释节点
				    isDef(oldVnode.data) === isDef(newVnode.data) && // 是否都定义了data
				    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同
				  )
		       }

- （3）patchVnode方法

    - 这个函数做了以下事情：

         - 找到对应的真实DOM，称为el
         - 判断newVnode和oldVnode是否指向同一个对象，如果是，那么直接return
         - 如果他们都有文本节点并且不相等，那么将el的文本节点设置为newVnode的文本节点。
         - 如果oldVnode有子节点而newVnode没有，则删除el的子节点
         - 如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el
         - 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要

					function patchVnode(oldVnode, newVnode) {
		
		              // 获取真实DOM对象
					  const el = newVnode.el = oldVnode.el 
		
					  // 获取新旧虚拟节点的子节点数组
					  const oldCh = oldVnode.children, newCh = newVnode.children
		
					  // 如果新旧虚拟节点是同一个对象，则终止
					  if (oldVnode === newVnode) return
		
					  // 如果新旧虚拟节点是文本节点，且文本不一样
					  if (oldVnode.text !== null && newVnode.text !== null && oldVnode.text !== newVnode.text) {
		
					    // 则直接将真实DOM中文本更新为新虚拟节点的文本
					    api.setTextContent(el, newVnode.text)
		
					  } else {
					    // 否则
					
					    if (oldCh && newCh && oldCh !== newCh) {
					      // 新旧虚拟节点都有子节点，且子节点不一样
					
					      // 对比子节点，并更新
					      updateChildren(el, oldCh, newCh)
		
					    } else if (newCh) {
					      // 新虚拟节点有子节点，旧虚拟节点没有
					
					      // 创建新虚拟节点的子节点，并更新到真实DOM上去
					      createEle(newVnode)
		
					    } else if (oldCh) {
					      // 旧虚拟节点有子节点，新虚拟节点没有
					
					      //直接删除真实DOM里对应的子节点
					      api.removeChild(el)
					    }
					  }
					}


- （4）updateChildren方法

    - 这是patchVnode里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在updateChildren方法中，是怎么样一个对比方法呢？就是首尾指针法，新的子节点集合和旧的子节点集合，各有首尾两个指针，举个例子：

				<ul>
				    <li>a</li>
				    <li>b</li>
				    <li>c</li>
				</ul>
				
				修改数据后
				
				<ul>
				    <li>b</li>
				    <li>c</li>
				    <li>e</li>
				    <li>a</li>
				</ul>

     - 那么新旧两个子节点集合以及其首尾指针为：
     
   ![](./images/diff5.jpg)

     - 然后会进行互相进行比较，总共有五种比较情况：

        - oldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - oldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - oldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - oldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE)，相同则执行patchVnode找出两者之间的差异;如没有差异则什么都不操作,结束一次循环
        - 如果以上逻辑都匹配不到
        
            - 分为两种情况

               - 如果新旧节点都有key，那么会根据oldChild的key生成一张hash表（旧子节点的 key 做一个映射到旧节点下标的 key -> index 表），用newStartVnode的key与hash表做匹配，匹配成功，就通过sameVnode()比对

                   - 比对成功：在真实dom中将成功的节点移到newStartVnode对应的位置
                   - 比对失败：(虽然他们具有相同的key,但不是同一个元素)，当新元素对待，直接创建
                
                   https://juejin.cn/post/6990582632270528525#heading-13
                   
		                  // 当四种策略都没有命中
					      // keyMap 为缓存，这样就不用每次都遍历老对象
					      if (!keyMap) {
					        // 初始化 keyMap
					        keyMap = {}
					        // 从oldStartIdx到oldEndIdx进行遍历
					        for (let i = oldStartIdx; i < oldEndIdx; i++) {
					          // 拿个每个子对象 的 key
					          const key = oldCh[i].data.key
					          // 如果 key 不为 undefined 添加到缓存中
					          if (!key) keyMap[key] = i
					        }
					      }


                - 如果没有key,则认为newStartVnode是一个新元素，则直接将newStartVnode生成新的节点插入真实DOM（ps：这下可以解释为什么v-for的时候需要设置key了，如果没有key那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了）

           - 执行过程是一个循环,在每次循环里,只要执行了上述的情况的五种之一就会结束一次循环
           
    - 接下来就以上面代码为例，分析一下比较的过程

       - 分析之前，请大家记住一点，最终的渲染结果都要以newVDOM为准，这也解释了为什么之后的节点移动需要移动到newVDOM所对应的位置

   ![](./images/diff6.jpg)

          - 第一步

			oldS = a, oldE = c
			newS = b, newE = a

            - 比较结果：oldS 和 newE 相等，需要把节点a移动到newE所对应的位置，也就是末尾，同时oldS++，newE--

   ![](./images/diff7.jpg)

         - 第二步

           oldS = b, oldE = c
		   newS = b, newE = e

           - 比较结果：oldS 和 newS相等，需要把节点b移动到newS所对应的位置，同时oldS++,newS++

   ![](./images/diff8.jpg)

        - 第三步

		  oldS = c, oldE = c
		  newS = c, newE = e

          - 比较结果：oldS、oldE 和 newS相等，需要把节点c移动到newS所对应的位置，同时oldS++,newS++

   ![](./image/diff9.jpg)

        - 第四步

          oldS > oldE

          - 则oldCh先遍历完成了，而newCh还没遍历完，说明newCh比oldCh多，所以需要将多出来的节点，插入到真实DOM上对应的位置上

   ![](./images/diff10.jpg)


        - updateChildren的核心原理代码

			function updateChildren(parentElm, oldCh, newCh) {
			  let oldStartIdx = 0, newStartIdx = 0
			  let oldEndIdx = oldCh.length - 1
			  let oldStartVnode = oldCh[0]
			  let oldEndVnode = oldCh[oldEndIdx]
			  let newEndIdx = newCh.length - 1
			  let newStartVnode = newCh[0]
			  let newEndVnode = newCh[newEndIdx]
			  let oldKeyToIdx
			  let idxInOld
			  let elmToMove
			  let before
			  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
			    if (oldStartVnode == null) {
			      oldStartVnode = oldCh[++oldStartIdx]
			    } else if (oldEndVnode == null) {
			      oldEndVnode = oldCh[--oldEndIdx]
			    } else if (newStartVnode == null) {
			      newStartVnode = newCh[++newStartIdx]
			    } else if (newEndVnode == null) {
			      newEndVnode = newCh[--newEndIdx]
			    } else if (sameVnode(oldStartVnode, newStartVnode)) {
			      patchVnode(oldStartVnode, newStartVnode)
			      oldStartVnode = oldCh[++oldStartIdx]
			      newStartVnode = newCh[++newStartIdx]
			    } else if (sameVnode(oldEndVnode, newEndVnode)) {
			      patchVnode(oldEndVnode, newEndVnode)
			      oldEndVnode = oldCh[--oldEndIdx]
			      newEndVnode = newCh[--newEndIdx]
			    } else if (sameVnode(oldStartVnode, newEndVnode)) {
			      patchVnode(oldStartVnode, newEndVnode)
			      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))
			      oldStartVnode = oldCh[++oldStartIdx]
			      newEndVnode = newCh[--newEndIdx]

			    } else if (sameVnode(oldEndVnode, newStartVnode)) {

			      patchVnode(oldEndVnode, newStartVnode)
			      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
			      oldEndVnode = oldCh[--oldEndIdx]
			      newStartVnode = newCh[++newStartIdx]

			    } else {
			      // 使用key时的比较
			      if (oldKeyToIdx === undefined) {
			        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表
			      }
			      idxInOld = oldKeyToIdx[newStartVnode.key]
			      if (!idxInOld) {
			        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
			        newStartVnode = newCh[++newStartIdx]
			      }
			      else {
			        elmToMove = oldCh[idxInOld]
			        if (elmToMove.sel !== newStartVnode.sel) {
			          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
			        } else {
			          patchVnode(elmToMove, newStartVnode)
			          oldCh[idxInOld] = null
			          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)
			        }
			        newStartVnode = newCh[++newStartIdx]
			      }
			    }
			  }
			  if (oldStartIdx > oldEndIdx) {
			    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el
			    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
			  } else if (newStartIdx > newEndIdx) {
			    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
			  }
			}



#### 五、key的作用 ####

1. key的作用主要是为了高效的更新虚拟dom，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少dom操作量，提高性能。

![](./images/diff13.jpg)

- 上图中，没有key值时，在a、b、c的c前面加了一个z，新旧节点的a进行sameVnode（key都为undefined相同）返回true，然后进行pathVnode，新旧虚拟节点是同一个对象，直接return。b同a一样判断。重点看下c和z进行sameVnode（key都为undefined相同，标签什么都相同）返回true，然后进行pathVnode，只有text不相同，所以只是将真实DOM的text的c改为z。然后，新建一个节点c插入。

- 上图中，有key值时，每个节点都有自己的key值，则c和z进行sameVnode返回false，则新节点c又继续和旧节点c比较返回true，最后只需要新建一个z节点插入。

- 当没有key的时候，会认为永远是相同的节点，会一直走patchVnode。上面两种情况，dom操作次数不同。前面的遍历a,b过程dom一样，没有操作，但是从c开始后面两次是进行了DOM的操作的，一次dom更新和一次创建插入。


2. 为什么不建议使用index做key值 

- 平常v-for循环渲染的时候，为什么不建议用index作为循环项的key呢？我们举个例子，左边是初始数据，然后我在数据前插入一个新数据，变成右边的列表：

		<ul>                      <ul>
		    <li key="0">a</li>        <li key="0">林三心</li>
		    <li key="1">b</li>        <li key="1">a</li>
		    <li key="2">c</li>        <li key="2">b</li>
		                              <li key="3">c</li>
		</ul>                     </ul>


- 理说，最理想的结果是：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。但是我们这里用了index来当key的话，真的会实现我们的理想结果吗？可是实践发现，添加这一个li，所有li标签都更新了，为什么会这样呢？还是通过图来解释

- 按理说，a，b，c三个li标签都是复用之前的，因为他们三个根本没改变，改变的只是前面新增了一个林三心

![](./images/diff11.jpg)

- 但是我们前面说了，在进行子节点的 diff算法 过程中，会进行 旧首节点和新首节点的sameNode对比，这一步命中了逻辑，因为现在新旧两次首部节点 的 key 都是 0了，同理，key为1和2的也是命中了逻辑，导致相同key的节点会去进行patchVnode更新文本，而原本就有的c节点，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行patchVnode更新文本，最后一个进行了新增，那就解释了为什么所有li标签都更新了。

- 那我们可以怎么解决呢？其实我们只要使用一个独一无二的值来当做key就行了

		<ul>
		   <li v-for="item in list" :key="item.id">{{ item.title }}</li>
		</ul>

- 为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，a，b，c节点的key就会是永远不变的，更新前后key都是一样的，并且又由于a，b，c节点的内容本来就没变，所以就算是进行了patchVnode，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。

![](./images/diff12.jpg)

<h3 id='五、vue的nextTick' >五、vue的nextTick</h3>

#### 一、vue异步更新DOM策略 ####

- 为什么vue更新dom采用的是异步更新呢？

	   例：<template>
		  <div>
		    <div>{{test}}</div>
		  </div>
		</template>

		export default {
		    data () {
		        return {
		            test: 0
		        };
		    },
		    mounted () {
		      for(let i = 0; i < 1000; i++) {
		        this.test++;
		      }
		    }
		}
		
- 上面的例子中，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter->Dep->Watcher->update->patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。


#### 二、watcher队列 ####

- 我们看下Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。

		update () {
		    /* istanbul ignore else */
		    if (this.lazy) {
		        this.dirty = true
		    } else if (this.sync) {
		        /*同步则执行run直接渲染视图*/
		        this.run()
		    } else {
		        /*异步推送到观察者队列中，下一个tick时调用。*/
		        queueWatcher(this)
		    }
		}

- Vue.js默认是使用异步执行DOM更新。 当异步执行update的时候，会调用queueWatcher函数。

		 /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/
		export function queueWatcher (watcher: Watcher) {
		  /*获取watcher的id*/
		  const id = watcher.id
		  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/
		  if (has[id] == null) {
		    has[id] = true
		    if (!flushing) {
		      /*如果没有flush掉，直接push到队列中即可*/
		      queue.push(watcher)
		    } else {

		      let i = queue.length - 1
		      while (i >= 0 && queue[i].id > watcher.id) {
		        i--
		      }

              //找到该watcher的位置，将新的watcher替换进去
		      queue.splice(Math.max(i, index) + 1, 0, watcher)
		    }

		    // queue the flush
		    if (!waiting) {
		      waiting = true
		      nextTick(flushSchedulerQueue)
		    }
		  }
		}

- 从queueWatcher代码中看出Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等到下一个tick运行时将这个队列queue全部拿出来run一遍，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去。这也解释了同一个watcher被多次触发，只会被推入到队列中一次。

#### 三、nextTick ####

nextTick的实现比较简单，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。执行的目的是在microtask或者task中推入一个function，在当前栈执行完毕（也许还会有一些排在前面的需要执行的任务）以后执行nextTick传入的function，看一下源码：'


 
    - 延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个queueNextTick函数，该函数接受回调函数和执行回调函数的上下文环境
    - 在立即执行nextTick函数的时候，会定义一个timerFunc函数，这个函数是表示了用那个方式（Promise、MutationObserver、setTimeout）执行nextTick队列的回调函数
    - 在当前调用栈执行完以后，执行timerFunc
    
			export const nextTick = (function () {
			  /*存放异步执行的回调*/
			  const callbacks = []
			  /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/
			  let pending = false
			  /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/
			  let timerFunc
			
			  /*下一个tick时的回调*/
			  function nextTickHandler () {
			    /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/
			    pending = false
			    /*执行所有callback*/
			    const copies = callbacks.slice(0)
			    callbacks.length = 0
			    for (let i = 0; i < copies.length; i++) {
			      copies[i]()
			    }
			  }
			
			  
			  /*
			    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法
			    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
			    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
			    参考：https://www.zhihu.com/question/55364497
			  */
			  if (typeof Promise !== 'undefined' && isNative(Promise)) {

			    /*使用Promise*/
			    var p = Promise.resolve()
			    var logError = err => { console.error(err) }
			    timerFunc = () => {
			      p.then(nextTickHandler).catch(logError)
			      if (isIOS) setTimeout(noop)
			    }

                 /*使用MutationObserver*/
			  } else if (typeof MutationObserver !== 'undefined' && (
			    isNative(MutationObserver) ||
			    // PhantomJS and iOS 7.x
			    MutationObserver.toString() === '[object MutationObserverConstructor]'
			  )) {
			    
			    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/
			    var counter = 1
			    var observer = new MutationObserver(nextTickHandler)
			    var textNode = document.createTextNode(String(counter))
			    observer.observe(textNode, {
			      characterData: true
			    })
			    timerFunc = () => {
			      counter = (counter + 1) % 2
			      textNode.data = String(counter)
			    }

               /*使用setTimeout*/
			  } else

			    /*使用setTimeout将回调推入任务队列尾部*/
			    timerFunc = () => {
			      setTimeout(nextTickHandler, 0)
			    }
			  }
			
			  /*
			    推送到队列中下一个tick时执行
			    cb 回调函数
			    ctx 上下文
			  */
			  return function queueNextTick (cb?: Function, ctx?: Object) {
			    let _resolve
			    /*cb存到callbacks中*/
			    callbacks.push(() => {
			      if (cb) {
			        try {
			          cb.call(ctx)
			        } catch (e) {
			          handleError(e, ctx, 'nextTick')
			        }
			      } else if (_resolve) {
			        _resolve(ctx)
			      }
			    })
			    if (!pending) {
			      pending = true
			      timerFunc()
			    }
			    if (!cb && typeof Promise !== 'undefined') {
			      return new Promise((resolve, reject) => {
			        _resolve = resolve
			      })
			    }
			  }
			})()


- 从上面的介绍，可以得知timeFunc()一共有三种实现方式。

  - Promise
  - MutationObserver
  - setTimeout

- 系统中会优先用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
- 在主线程上，如果再遇到macrotask，就把它放到macrotask任务队列末尾，由于一次event loop只能取一个macrotask，所以遇到的宏任务就需要等待其它轮次的事件循环了；如果遇到microtask，则放到本次循环的microtask队列中去。这样就能明白为什么microtask会比macrotask先处理了。这也是nextTick总是要比setTimeout先要执行。

- 下面着重介绍一下MutationObserver。
	
	- MutationObserver是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。
	- 调用过程很简单，但是有点不太寻常：你需要先给他绑回调：
	
    		var mo = new MutationObserver(callback)
	
    - 通过给MutationObserver的构造函数传入一个回调，能得到一个MutationObserver实例，这个回调就会在MutationObserver实例监听到变动时触发。
	- 这个时候你只是给MutationObserver实例绑定好了回调，他具体监听哪个DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的observer方法就可以完成这一步:
		
	        var domTarget = 你想要监听的dom节点
			mo.observe(domTarget, {
			      characterData: true //说明监听文本内容的修改。
			})

#### 四、总结 ####

1. nextTick是Vue提供的一个全局API由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法
2. Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发
生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。
3. 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。
4. 比如，我在干什么的时候就会使用nextTick传一个回调函数进去，在里面执行dom操作即可。
5. 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。

<h3 id='六、vue2.0为什么不能检查数组的变化'>六、vue2.0为什么不能检查数组的变化</h3>

https://www.jb51.net/article/171869.htm
https://juejin.cn/post/6844903614096343047
#### 一、前言 ####

- Vue2.0对于响应式数据的实现有一些不足：

   - 无法检测数组/对象的新增
   - 无法检测通过索引改变数组的操作。
   - 修改数组长度

- 无法检测数组/对象的新增，原因很简单，对象的属性只有先用Object.defineProperty 方法添加属性描述符的 get 和 set 属性才能被监听，新添加的属性肯定没先用 Object.defineProperty 方法，故无法被监听。删除的属性，其 set 属性监听不到，故无法监听。


#### 二、无法检测数组的索引变化？ ####

- 我们来测试一下看看。以下例子，对遍历数组中的每一项，用Object.defineProperty对其进行监测

			function defineReactive(data, key, value) {
				 Object.defineProperty(data, key, {
					 enumerable: true,
					 configurable: true,
					 get: function defineGet() {
						 console.log(`get key: ${key} value: ${value}`)
						 return value
					 },
					 set: function defineSet(newVal) {
						 console.log(`set key: ${key} value: ${newVal}`)
						 value = newVal
					 }
				 })
			}
			 
			function observe(data) {
				Object.keys(data).forEach(function(key) {
					defineReactive(data, key, data[key])
				})
			}
			 
			let arr = [1, 2, 3]
			observe(arr)

- 通过索引改变arr[1]，可以发现触发了set，也就是Object.defineProperty是可以检测到通过索引改变数组的操作的，那Vue2.0为什么没有实现呢？

  - 原来是出于对性能原因的考虑，没有去实现它。而不是不能实现。对于对象而言，每一次的数据变更都会对对象的属性进行一次枚举，一般对象本身的属性数量有限，所以对于遍历枚举等方式产生的性能损耗可以忽略不计，但是对于数组而言呢？数组包含的元素量是可能达到成千上万，假设对于每一次数组元素的更新都触发了枚举/遍历，其带来的性能损耗将与获得的用户体验不成正比，故vue无法检测数组的变动。
不过Vue3.0用proxy代替了defineProperty之后就解决了这个问题。

#### 三、解决方案 ####

1. 数组

	- this.$set(array, index, data)
      - 这是个深度的修改，某些情况下可能导致你不希望的结果，因此最好还是慎用
      
			this.dataArr = this.originArr
			this.$set(this.dataArr, 0, {data: '修改第一个元素'})
			console.log(this.dataArr)        
			console.log(this.originArr)  //同样的 源数组也会被修改 在某些情况下会导致你不希望的结果 



    - splice
      - Vue对数组的7个变异方法（push、pop、shift、unshift、splice、sort、reverse）实现了响应式
      - 所以splice会被监听有响应式，而splice又可以做到增删改。
      - this.items.splice(newLength) 可解决修改数组长度（减小数组长度）

        

   - 利用临时变量进行中转
			
			let tempArr = [...this.targetArr]
			tempArr[0] = {data: 'test'}
			this.targetArr = tempArr

2. 对象

   - this.$set(obj, key ,value) - 可实现增、改
   
   - 对于对象的属性的删除可以用 this.$delete(obj,key) 来解决，this.$delete 是个实例方法，该方法是全局方法 Vue.delete 的一个别名。

   - watch时添加deep：true深度监听，只能监听到属性值的变化，新增、删除属性无法监听

			this.$watch('blog', this.getCatalog, {
			    deep: true
			    // immediate: true // 是否第一次触发
			  });


   - watch时直接监听某个key

			watch: {
			  'obj.name'(curVal, oldVal) {
			    // TODO
			  }
			}



#### 四、vue对数组的observe做了哪些处理？####
- https://juejin.cn/post/6883365724228681742#heading-6

        var Observer = function Observer(value) {
		    this.value = value;
		    this.dep = new Dep();
		    this.vmCount = 0;
		    def(value, '__ob__', this);
		    if (Array.isArray(value)) {
		        if (hasProto) {
		            protoAugment(value, arrayMethods);
		        } else {
		            copyAugment(value, arrayMethods, arrayKeys);
		        }
		        this.observeArray(value);
		    } else {
		        this.walk(value);
		    }
		}

- 执行 this.value = value ，把要监听的数据 value 赋值到 Observer 类的实例对象上。
- 执行 this.dep = new Dep() ，创建一个订阅者收集器，并把赋值到 Observer 类的实例对象上。
- 执行 this.vmCount = 0 ，把 vmCount 赋值到 Observer 类的实例对象上。
- 这样 Observer 类的实例对象就有三个实例属性：value、dep、vmCount。
- 执行 def(value, '__ob__', this) ，把自身的实例对象添加到数据 value 的 __ob__ 属性上，使value 的 __ob__ 属性上保存 Observer 类的一些实例对象和实例方法，在后续逻辑中会经常用到。另外一个对象上若有 __ob__ 属性，则代表这个对象已经被监听过。
- def 方法是对 Object.defineProperty 方法的封装。这就是用 console.log 打印 data 的数据时会发现多了一个 __ob__ 属性的原因。

		function def(obj, key, val, enumerable) {
		    Object.defineProperty(obj, key, {
		        value: val,
		        enumerable: !!enumerable,
		        writable: true,
		        configurable: true
		    });
		}

- 执行 if (Array.isArray(value)) 判断 value 是否是数组类型，若不是执行 this.walk(value) ，若是执行以下代码。

		if (hasProto) {
		    protoAugment(value, arrayMethods);
		} else {
		    copyAugment(value, arrayMethods, arrayKeys);
		}
		this.observeArray(value);


- 可见在 Vue 中对数组类型的数据和对象类型的数据监听的处理方式是不同的，下面分别来介绍各自的处理方式。

#### 四、监听对象类型的数据 ####

- 在 Observer 构造函数中，对于对象类型的数据，执行 this.walk(value) 来监听。来看一下 this.walk 实例方法。

		Observer.prototype.walk = function walk(obj) {
		    var keys = Object.keys(obj);
		    for (var i = 0; i < keys.length; i++) {
		        defineReactive(obj, keys[i]);
		    }
		};


- 监听对象类型的数据 value 过程，是先把 value 作为参数传入 observe(value) 函数，在其中执行 new Observer(value) ，然后在 Observer 构造函数中，调用 this.walk 实例方法，在 this.walk 方法中用 Object.keys() 获取 value 的键集合 keys ，然后遍历 keys 在其中执行 defineReactive(value, keys[i]) ，在 defineReactive 函数中在 value 自身的属性描述符上定义 get 和 set 属性用来监听，再通过 value[keys[i]] 获取 value 每个子属性 val ，如果 val 是对象或数组就会执行 observe(val) 来监听子属性 val，重复开始的流程，这样形成了一个递归调用，这样数据 value不管本身还是它的所有子属性都会被监听到。

#### 五、监听数组类型的数据 ####

- 在 Observer 构造函数中，对于数组类型的数据，执行以下逻辑来监听。

		if (hasProto) {
		    protoAugment(value, arrayMethods);
		} else {
		    copyAugment(value, arrayMethods, arrayKeys);
		}
		this.observeArray(value);

- 先不管上面的 if 逻辑，来看一下 this.observeArray 实例方法。

		Observer.prototype.observeArray = function observeArray (items) {
		    for (var i = 0, l = items.length; i < l; i++) {
		        observe(items[i]);
		    }
		}

- 试想一下，为什么在遍历中不直接调用 defineReactive 函数来把数据变成响应式对象来监听，而是调用 observe 函数。这是因为数组的元素可以是对象、数组等，在 Vue 中对数组类型和对象类型的数据监听流程是不同的，在 defineReactive 函数是直接把对象类型的数据变成响应式对象来监听，只有在 observe 函数中才有做区分。

- 执行 if (hasProto)，其中 hasProto 是这么定义的 var hasProto = '__proto__' in {}，变量 in 对象，判断变量是否是对象的属性。

- 来看一下 protoAugment 函数和 copyAugment 函数。

		function protoAugment(target, src) {
		    target.__proto__ = src;
		}
		function copyAugment(target, src, keys) {
		    for (var i = 0, l = keys.length; i < l; i++) {
		        var key = keys[i];
		        def(target, key, src[key]);
		    }
		}

- 在 protoAugment 函数中把参数 src 赋值到参数 target 的 __proto__。对象的 __proto__ 属性的值就是它所对应的原型对象，在JS中，数组也是一个对象。那么 protoAugment 函数的作用就是把参数 target 的原型对象改成参数 src。
- 但 __proto__ 这个属性在一些版本的浏览器不支持，比如IE9，故要用 '__proto__' in {} 做一下兼容判断。
- 若是浏览器不支持 __proto__ 这个属性，则调用 copyAugment 函数，在其中通过 def方法，把参数 target 的原型对象中的值更改，def 方法已经在上面介绍过。
- 执行protoAugment(value, arrayMethods)，其中 value 是一个数组，要把 value 的原型对象修改成 arrayMethods，那为什么要数组的原型对象修改成 arrayMethods，先来看一下 arrayMethods 是如何定义的。

			var arrayProto = Array.prototype;
			var arrayMethods = Object.create(arrayProto);
			var methodsToPatch = [
			    'push',
			    'pop',
			    'shift',
			    'unshift',
			    'splice',
			    'sort',
			    'reverse'
			];
			methodsToPatch.forEach(function(method) {
			    var original = arrayProto[method];
			    def(arrayMethods, method, function mutator() {
			        var args = [],
			            len = arguments.length;
			        while (len--) args[len] = arguments[len];
			        var result = original.apply(this, args);
			        var ob = this.__ob__;
			        var inserted;
			        switch (method) {

                        //对于push，unshift会新增索引，所以需要手动observe
			            case 'push':
			            case 'unshift':
			                inserted = args;
			                break
                        //splice方法，如果传入了第三个参数，也会有新增索引，所以也需要手动observe
			            case 'splice':
			                inserted = args.slice(2);
			                break
			        }
                    
                    // push，unshift，splice三个方法触发后，在这里手动observe，其他方法的变更会在当前的索引上进行更新，所以不需要再执行ob.observeArray
			        if (inserted) {
			            ob.observeArray(inserted);
			        }
			        ob.dep.notify();
			        return result
			    });
			});
			var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

- 执行 var arrayProto = Array.prototype 获取数组的原型对象并赋值给 arrayProto 。
- 执行 var arrayMethods = Object.create(arrayProto) 创建一个新对象 arrayMethods ，其拥有数组的原型对象。
- 变量 methodsToPatch 中定义了一些常见的数组实例方法，遍历 methodsToPatch 在其中调用 def 函数修改 arrayMethods 上和 methodsToPatch 中同名的实例方法，这叫作函数劫持。
- 执行 var original = arrayProto[method] 把数组的原实例方法缓存到常量 original，然后调用 def 函数，在 def 函数的第三个参数传入重新定义的数组实例方法。
- 在重新定义的数组实例方法中，执行

		var args = [],len = arguments.length;
		while (len--) args[len] = arguments[len];

- 定义一个变量 args，然后把调用数组实例方法时的参数赋值给变量 args，然后执行 var result = original.apply(this, args)，把参数传入 original 该数组原先的实例方法执行，并把执行结果赋值给常量 result 。
- 执行 var ob = this.__ob__，获取属于要被监听数组的 Observer 类实例化的对象赋值给常量 ob。
- 通过 push 或 unshift 会增加索引，对于新增加的属性，需要再手动初始化才能被 observe ，splice方法，如果传入了第三个参数，也会有新增索引，所以也需要手动observe
- 执行 var ob = this.__ob__，获取属于要被监听数组的 Observer 类实例化的对象赋值给常量 ob。


#### 六、vue的 set 方法实现 ####

- Vue.set 是在 initGlobalAPI 函数中定义。initGlobalAPI 函数在定义构造函数 Vue 后马上执行。

		function initGlobalAPI(Vue) {
		    Vue.set = set;
		}
		initGlobalAPI(Vue);

- 其中 Vue.set 是 set 函数赋值的，来看一下 set 函数。

		function set (target: Array<any> | Object, key: any, val: any): any {
		 // 如果target是数组，且key是有效的数组索引，会调用数组的splice方法，
		 // 我们上面说过，数组的splice方法会被重写，重写的方法中会手动Observe
		 // 所以vue的set方法，对于数组，就是直接调用重写splice方法
		 if (Array.isArray(target) && isValidArrayIndex(key)) {
		 target.length = Math.max(target.length, key)
		 target.splice(key, 1, val)
		 return val
		 }
		 // 对于对象，如果key本来就是对象中的属性，直接修改值就可以触发更新
		 if (key in target && !(key in Object.prototype)) {
		 target[key] = val
		 return val
		 }
		 // vue的响应式对象中都会添加了__ob__属性，所以可以根据是否有__ob__属性判断是否为响应式对象
		 const ob = (target: any).__ob__

	    if (target._isVue || (ob && ob.vmCount)) {
	        warn(
	            'Avoid adding reactive properties to a Vue instance or its root $data ' +
	            'at runtime - declare it upfront in the data option.'
	        );
	        return val
	    }

		 // 如果不是响应式对象，直接赋值
		 if (!ob) {
		 target[key] = val
		 return val
		 }
		 // 调用defineReactive给数据添加了 getter 和 setter，
		 // 所以vue的set方法，对于响应式的对象，就会调用defineReactive重新定义响应式对象，defineReactive 函数
		 defineReactive(ob.value, key, val)
		 ob.dep.notify()
		 return val
		}

- 执行 if (isUndef(target) || isPrimitive(target)) 判断参数 target 是否为 undefined、null、字符串、布尔值、数字。若是在控制台打出警告，无法对未定义、null或基础类型数据设置属性，其中 isPrimitive 方法代码如下。

		function isPrimitive(value) {
		    return (
		        typeof value === 'string' ||
		        typeof value === 'number' ||
		        typeof value === 'symbol' ||
		        typeof value === 'boolean'
		    )
		}

- 执行 if (Array.isArray(target) && isValidArrayIndex(key)) 判断参数 target 是否为数组，若是则参数 key 应该为数组下标，用 来判断参数 key 是不是正确的数组下标，
		
		function isValidArrayIndex(val) {
		    var n = parseFloat(String(val));
		    return n >= 0 && Math.floor(n) === n && isFinite(val)
		}

- 数组下标应该是个大于零的整数，且不是无穷大。在 isValidArrayIndex 函数先用 parseFloat 把参数 val，因为 parseFloat 的接收的参数是字符串格式，所以用 String 处理一下参数 val。这里很巧妙利用 Math.floor(n) === n 来判断参数 val 是不是整数，最后用 isFinite 判断参数 val 是不是无穷大。
- 若参数 key 是个正确的数组下标，执行以下逻辑

		target.length = Math.max(target.length, key);
		target.splice(key, 1, val);

- 此时 target 是个数组，这里巧妙的应用 splice 这个数组实例方法，实现通过数组下标来添加一个数组项的功能，同时 splice 这个数组实例方法在 Vue 中被劫持过，故会被监听到。
那为什么还要重新设置一下 target 的长度。是因为 splice 方法有个缺陷，下面用一个例子说明。

		let a = [1,2]
		a[3]=3;
		console.log(a) //[1, 2, empty, 3] 
		let b = [1,2]
		b.splice(3,1,3) //[1, 2, 3]
		console.log(b)

- 说明 splice 实例方法中的参数 key 只要超过数组的长度，那么只会在数组尾部添加上所要的数组元素。为了避免这个缺陷，执行 target.length = Math.max(target.length, key) ，当 key 比target.length 大，就把 key 赋值给 target.length 先扩充一下数组的长度，保证通过 splice 添加数组元素和通过数组下标添加数组元素的结果是一致的。

- 执行 if (key in target && !(key in Object.prototype))，判断参数 key 是否是参数 target 的属性，且不是其原型对象的属性。若是，则 target[key] 已被监听，直接把参数 val 赋值给 target[key] 即可。
- 执行if (target._isVue || (ob && ob.vmCount)) ，用 target._isVue 来判断参数 target 是否为 Vue 实例对象.
- 用 ob && ob.vmCount 来判断参数 target 是否为根数据对象（即 data 选项返回的对象），其中 ob 为参数 target.__ob__，__ob__ 为 Observer 类的实例化对象，在 Observer 构造函数中 只有
- data 为根数据，才会给 vmCount 实例对象赋值。若是在控制台打出警告注意参数 target 不能是 Vue 实例，或者 Vue 实例的根数据对象。
- 执行 if (!ob) 判断参数 target 是否是被监听，如果不是，那么也必要去监听其子属性，执行target[key] = val 直接赋值即可。
- 如果是，执行 defineReactive(ob.value, key, val) 在新增属性的描述符属性上定义 get 和 set 属性来监听新增属性，其中 ob.value 是参数target变成的响应式对象，如果直接用参数 target ，会导致参数 target 本身及其子属性都无法被监听。
- 执行 ob.dep.notify() ，因为参数 target 新增属性了，那么本身也改变了，故触发其订阅者的更新。
- 最后返回新增的值 `val 。

#### 七、Vue.delete的内部逻辑 ####

- Vue.delete 是在 initGlobalAPI 函数中定义。initGlobalAPI 函数在定义构造函数 Vue 后马上执行。

		function initGlobalAPI(Vue) {
		    Vue.delete = del;
		}
		initGlobalAPI(Vue);

- 其中 Vue.delete 是 del 函数赋值的，来看一下 del 函数。

		function del(target, key) {
		    if (isUndef(target) || isPrimitive(target)) {
		        warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
		    }
		    if (Array.isArray(target) && isValidArrayIndex(key)) {
		        target.splice(key, 1);
		        return
		    }
		    var ob = (target).__ob__;
		    if (target._isVue || (ob && ob.vmCount)) {
		        warn(
		            'Avoid deleting properties on a Vue instance or its root $data ' +
		            '- just set it to null.'
		        );
		        return
		    }
		    if (!hasOwn(target, key)) {
		        return
		    }
		    delete target[key];
		    if (!ob) {
		        return
		    }
		    ob.dep.notify();
		}

- 里面部分逻辑和 set 函数是一模一样的，在上面已经介绍过了。来介绍一下不一样的逻辑。
- 当参数 target 为数组时，且参数 key 为正确的数组下标，执行 target.splice(key, 1) ，这里巧妙的应用 splice 这个数组实例方法，实现删除数组中某个元素的功能，同时 splice 这个数组实例方法在 Vue 中被劫持过，故会被监听到。
- 执行 if (!hasOwn(target, key)) ，判断参数 key 是否是参数 target 的属性，若不是，则直接 return 。
- 若不是，执行delete target[key]删除这个对象属性。
- 执行 var ob = (target).__ob__; if(!ob) 判断参数 target 是否被监听，若不是，则直接 return 。
- 若是，执行 ob.dep.notify() ，触发参数 target 本身的订阅者更新。

#### 八、监听数组类型数据的边界场景 ####

- 在上小节讲到只有用push 、pop 、 shift 、unshift 、 splice 、 sort 、 reverse 这些在 Vue 内部重新定义的数组实例方法，去操作数组才能被监听到。其实这些数组实例方法都会去变更原始数组，称为变更方法。那还有一些数组实例方法如 filter 、concat 和 slice ，这些方法不会去变更原始数组，会返回一个新数组，称为替换方法。filter 、concat 和 slice 这些替换方法来操作数组会被监听到。

























<h1 id='网络总结'><font color='darkgrey'>网络总结</font><h1>

<h3 id='一、http请求和响应'>一、http请求和响应</h3>

1.http请求报文

   - 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。

![](./images/http1.JPG)

 (1)请求行

  - 请求行由请求方法字段，URL字段和HTTP协议版本等3个字段组成，它们用空格分隔
    
     例如：GET /index.html HTTP/1.1

 (2)请求头部

  - 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息。
  - 请求头都有：

      - Accept：
      
			例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8

			表示客户端支持的数据格式，或者说客户端“希望”接受到的内容类型。这里只是希望，但是服务器具体返回什么样的内容类型，还是由服务器自己决定，但是无论服务器返回什么样的内容类型，客户端都会接收响应报文，不可能说因为内容类型不同，接收不到服务器响应报文，这不符合http协议规范。

			我们通过浏览器发起get或post请求，该字段都是浏览器自动添加的，同样在服务器端也不会解析该字段的值；
			通过ajax请求或其他手段，我们可以设置该字段的值，但是通常也不进行设置。
			
			该字段的应用场景可以是这样的，有两个终端，比如一个是纯文本阅读器，如Kinder（不能显示图片），另一个是移动终端（可以播放图片和视频），均向服务器请求有关“斑马”的信息，那么这时候服务器端就需要判断什么样的终端应该返回什么样的信息，那么它就可以根据Accept的信息来进行判断，如果解析到的Accept的值为“text/plain”，那么就表示客户端只支持文本类型；如果向上面例子中的那样，则表示客户端文本图片视频都可以。如果我们不加判断，当返回给文本阅读器一张图片时，可能它显示的就是乱码。

      - Accept-Encoding:
      
			例：Accept-Encoding:gzip, deflate, br
			
			表示客户端所支持的解码（解压缩）格式。网络数据的传输都是占据带宽的，而将文件数据压缩能够降低数据量，减少传输时间。所以服务器在返回数据给客户端时，常常对数据进行压缩（对用户透明，通常由服务器或代理来做），而压缩的方式有多种，到底采用哪一种则需要看客户端支持哪种解码方式，这时候就可以根据header中Accept-Encoding的值。
			
			文件或数据的压缩，由服务器或代理来做，一般不需要程序员干预；客户端接收到数据时解压缩，通常由浏览器自动完成，对用户透明。
			对于我们主动发起的ajax请求，一般数据量较少，不需要设置该字段。

     - Accept-Language:
     
			例：Accept-Language:zh-CN,zh;q=0.9
			
			表示客户端支持的语言格式（不是编码格式），如中文/英文，通常浏览器直接发起请求时，浏览器会根据被设置的语言环境（默认语言），来附加上该字段。
			
			一般我们服务器解析报文时，是不理会该字段的。
			
			他的使用场景可以是这样的，假如有个文件，有各种语言的版本，这样当不同请求发来时，我们可以根据Accept-Language的值来判断到底返回哪种语言版本给客户端。
			（其实这种应用场景也一般不采用判断Accept-Language字段的方法，不靠谱，还不如直接在url中体现语言版本呢）

    - Accept-Charset：
    
			例：Accept-Charset:gbk,utf-8;q=0.8
			
			表示客户端支持编码格式。服务器在返回报文时，需要将字符按照一定的编码格式转换为字节序列发送给客户端，那么该采用哪种编码格式呢？
			当然作为服务器端，他可以采用任何一种编码方式，客户端都得完完整整的接收响应报文。因为目前客户端几乎都支持常见编码类型，所以服务器在返回数据时，只需要按照既定的编码方式编码，然后在响应报文中告知客户端所使用的编码方式。这样客户端在接收到报文后按照该方式进行解码，就就不会出现乱码问题。
			
			但是，如果客户端已经定了就使用某种解码方式，那么这时候服务器端就不能那么任性了，他就需要解析Accept-Charset字段，根据这个值，来设定采用的编码方式。
			如上例中，以逗号分隔，客户端支持两种编码方式，gbk和utf-8（gbk优先级高于utf8），其中utf-8后的q值，表示utf-8占的“权重”。
			
            - 题外话：

			服务器端怎么通知浏览器所采用的编码格式呢？
			如果不通知浏览器，那么浏览器会采用什么样的格式解码呢？
			
			服务器端以原生的Servlet & JSP为例：

			  1）当返回的是HTML页面，那么页面meta charset就指定了编码格式
			  2）当返回的是JSP页面，那么页面pageEncoding就指定了编码格式
			  3）当通过resp的Outputstream返回原生内容时，我们可以通过设置响应头content-type/content-charset字段来指定编码格式
			
			那么如果服务器不指定编码格式呢？

			  我的测试环境为win10中文操作系统，浏览器：Chrome 64.0.3282.186（正式版本）
				
				1）返回的html页面不设置meta标签，但是文件本身是utf-8或gbk编码，中文不乱码，服务器会将html页面转换为字节流写给浏览器，浏览器读取字节流，由于找不到meta标签设置的文件格式，就会按照默认的格式解码。这时出现的情况是，当原页面是gbk编码时，浏览器能正常显示页面；当原页面是utf-8编码时，浏览器显示中文乱码。这说明当前Chrome浏览器的默认编码格式为gbk。使用微软自带的Microsoft Edge测试结果一样 。
				
				2）返回JSP页面时，必须指定pageEncoding。
				
				3）通过response的输入流，直接返回生成的字节流。
 
                     当服务器使用gbk编码返回字节流时，地址栏的http请求不乱码，但是ajax请求响应乱码；
			         当服务器使用utf-8返回字节流时，地址栏的http请求乱码，但是ajax不乱码。
			
			
			这说明同一个浏览器，在不同的地方采用的编码格式不同，当浏览器解析页面时，它默认使用的是gbk编码（可能因为我们的中文操作系统，同时是中文版的软件，所以浏览器默认使用gbk格式来解析页面）；当浏览器使用内核XMLHttpRequest对象来解析响应时，默认采用的是utf-8（这个应该跟操作系统语言没关系，内核层面的应该在哪个国家都一样）。所以，如果为了确保在各种情况下都不乱码，服务器一定要通知客户端所采用的编码格式


    - Referer：
    
			例：Referer:http://localhost:8080/test/11.html
			
			表示当前请求是从哪个资源发起的；或者是请求的上一步的地址。
			
			我在11.html页面发起一个请求，这时候浏览器封装的请求头就有上例中的referer字段，表示当前请求是这个资源链接中发起的。
			
			Referer是常用于网站的访问统计，比如我在很多地方都做了广告链接到我网站的主页，这时候我就可以通过Referer来查看哪些地方跳转过来的人多，就说广告的效果好。
			另外，Referer还经常用于防盗链。
			
			   1.防盗链：所谓防盗链是指防止其他web站点页面通过连接本站点的页面来访问本站点内容，这样对于本站点来说侵犯了本站点的版权
               
               2.非法用户： 

                  常访问本站点页面的链接有三种出处:

					  (1) 地址栏输入链接地址。如地址栏上输入www.csdn.net/a.jsp；
					
					  (2)其他站点上的应用程序的页面上通过链接本站点页面资源。如(www.b.com/index.jsp页面上有一链接指向www.csdn.net/a.jsp)；
					
					  (3)本站点上的页面资源连接到本站点的另外的页面资源。如(www.csdn.net/index.jsp页面上有一链接指向www.csdn.net/a.jsp)；
					
				  这三类用户中第一类和第二类通常是非法用户。

               3.如何防盗链

                  通过调用request.getHeader("Referer");判断访问本页面的链接来自哪里。
                  Refer代表网页的来源，及上一页的地址，如果是直接在浏览器上输入地址，回车进来，则没有Refer头。


   - If-Modified-Since：
   
            例：If-Modified-Since:Thu, 29 Mar 2018 08:37:45 GMT

			表示客户端缓存文件的时间。字面翻译的意思是，“如果从…时间改变了”（就请再发送给我一遍新的文件）。
			
			当客户端访问服务器的静态文件时，通常会将资源结果缓存下来，并标记一下文件的缓存时间（根据响应头中的Last-Modified字段）；当接下来再发送同样的请求时，会在请求头中添加上这个字段If-Modified-Since；
			
			服务器端读取字段值，判断服务器端文件的最后修改时间，如果如果不晚于该值，说明浏览器缓存的文件是最新的，然后就不会重新发送文件内容，而是将相应报文的状态设置为304，表示你读取缓存的文件就可以了，这就很大程度上节省了带宽。
			第一次请求头：
			
			GET /mvctest/11.html HTTP/1.1
			Host: localhost:8080
			Connection: keep-alive
			Upgrade-Insecure-Requests: 1
			User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
			Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
			Accept-Encoding: gzip, deflate, br
			Accept-Language: zh-CN,zh;q=0.9
			1
			2
			3
			4
			5
			6
			7
			8
			第一次响应头：
			这里写图片描述
			
			第二次请求头：
			这里写图片描述
			第二次响应头：
			这里写图片描述
			
			需要说明的是，If-Modified-Since字段的值，为服务器端文件最后修改的时间，不是请求的访问时间，时间值为GMT格林尼治时间，不是本地时间。
			浏览器一般只对.html,.jpg,.css,.js等这些静态资源进行缓存，对于jsp页面以及ajax请求的动态结果，不缓存。服务器如Tomcat会自动给静态文件的响应报文添加“Last-Modified”字段，同时解析请求报文中的If-Modified-Since字段，这些都是对我们透明的。
			
			例如，我们将11.html改为11.jsp，那么浏览器将不会缓存页面内容，服务器每次都响应一个完整的页面内容给客户端，也不会在响应报文中添加“Last-Modified”字段。
			每次对于JSP请求的响应结果：
			这里写图片描述
		
		If-None-Match:
		例：
		If-None-Match:W/”607-1522312665174”
		该字段同If-Modified-Since字段一样，都是用来表示资源文件是否是最新的。只不过If-Modified-Since的值为文件的最后修改时间，而该值为资源实体的哈希值，同样是由服务器生成的。
		从上面的截图中我们可以看到：
		第一次请求时，服务器的响应报文中有字段Etag，这就是实体的哈希值，浏览器会缓存文件并记录该值。
		第二次请求时，请求头字段中就有If-None-Match，值为Etag的值，而服务器会判断该值与服务器中文件的哈希值是否相同，如果相同，就返回304，让浏览器读取缓存；否则会返回新的资源文件，并在响应头中设置新的Etag值。
		
		Last-Modified/If-Modified-Since 和 Etag/If-None-Match这两对头字段都是来标记缓存资源的，但是后者的优先级要高于前者。

  - Cache-Control:

		例：Cache-Control:no-cache
	
		字段的字面意思为“缓存-控制”，前面我们将了几个字段表面客户端/服务器如何使用缓存机制，而这个字段就是用来控制缓存的。
		Cache-Control在请求/响应报文头中均可设置，分别表明不同的意思，下面我们以响应报文为例：cache-control在响应报文的的取值可以为：public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。
		所代表的意思为：
		这里写图片描述
		其中，no-cache、no-store、max-age为常用的取值。
		比如，服务器在响应报文中添加Cache-Control：no-store，表示浏览器或各级代理，不要缓存本次的相应内容（即使响应报文中有Etag和Last-Modified）;
		
		比如，响应报文中有Cache-Control：no-cache，表示浏览器可以缓存响应文件，但是在使用缓存之前，必须通过令牌（Etag）来与服务器进行沟通确认缓存有效。
		
		比如，响应报文中有Cache-Control：max-age=500，表示在接下来的500秒内，浏览器可以自主使用缓存内容，不需要向服务器发送同样的请求。
		
		在请求报文中，也可以添加cache-control字段，其取值可以为no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached。
		客户端在发送请求到服务器时，可能会经过很多层代理，而这些代理可能就缓存了本次请求想要的文件，而请求中的cache-control就可以控制，是否使用代理中的缓存文件。
		
		比如，请求报文头中有cache-control：no-cache，那就表示，代理如果返回给我缓存文件时，需要到服务器端进行确认，缓存是不是最新的。
		
		比如，请求报文头中有cache-control：no-store，那就表示，我不需要代理中的缓存文件，我需要直接请求服务器。
		
		所以我们可以看到，cache-control就是用来控制缓存使用的，如是否缓存，是否使用缓存，缓存到期时间等，而Last-Modified/If-Modified-Since 和 Etag/If-None-Match是标识C/S之间怎么使用缓存。
		缓存的使用都是服务器和客户端的默认行为，对用户和程序员的透明的，当然我们可以通过配置文件或程序修改他们的行为规则。
		附：http协议中对缓存的说明

  - User-Agent:

		例：User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
		表示客户端的软件环境。如上可以看出使用的是Window10 64位操作系统，Chrome浏览器等信息。服务器可以根据该字段评估客户端的环境从而给出不同的响应。（比如根据请求是从手机端或是电脑端发起的，返回不同版本的页面）

  - Host：

		例：Host:localhost:8080
		表示请求者的主机地址（IP地址）和端口号。
		服务器端可以根据该字段进行ip过滤等操作。

(3)响应头

    - Etag、Last-Modified、cache-control在前文中已经说明。

    - Content-Length:

		例：Content-Length:607
		表示接收到的响应报文的总长度为607。
		根据这个长度，客户端可以更准确的接收和解析报文内容。或者可以根据当前接收/解析的长度占总长度的百分比，做出进度条的效果。

   - Accept-Ranges:

		例：Accept-Ranges:bytes
		表示服务器支持http中的Range功能，能够分段请求客户端能够分段请求服务器。
		我们上网时常用的“断点续传”，或者服务器所谓的“多线程下载”就是靠的服务器端的Range技术。
		Range功能的请求-响应流程如此：
		客户端发起带range的请求：
		
		GET  /test.rar  HTTP/1.1
		Connection:  close
		Host:  116.1.219.219
		Range:  bytes=0-100
		1
		2
		3
		4
		在头中添加Range字段，表示我要请求[0-100]这101个字节的数据。
		此处Range的值，可以添加多个片段，如 Range：bytes=0-100,200-300等。
		
		服务器响应报文：
		
		HTTP/1.1 206 OK
		Content-Length:  801     
		Content-Type:  application/octet-stream 
		Content-Location: http://www.onlinedown.net/hj_index.htm
		Content-Range:  bytes  0-100/2350        //2350:文件总大小
		Last-Modified: Mon, 16 Feb 2009 16:10:12 GMT
		Accept-Ranges: bytes
		ETag: "d67a4bc5190c91:512"
		Date: Wed, 18 Feb 2009 07:55:26 GMT
		1
		2
		3
		4
		5
		6
		7
		8
		9
		响应报文中有Content-Range字段，表示响应的报文片段内容范围，已经总的数据大小。
		同时Range请求的正常的返回码是206，不是200。
		
		而即使我们请求的不是Range功能请求，那么服务器的返回字段中会有Accept-Range，表示服务器支持Range功能。

  - Server:
  
		例：Server: Apache/2.4.1 (Unix)
		表示服务器的名称，是Unix下的Apache服务器

<h3 id='二、http的请求方法'><font color='#ccc'>二、http的请求方法</font></h3>

  - HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。
  - HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

   1. GET - 默认的请求方式，返回页面具体内容，参数会显示在地址栏中
   2. POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
   3. HEAD - 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
   4. PUT - 从客户端向服务器传送的数据取代指定的文档的内容。
   5. DELETE	- 请求服务器删除指定的页面。
   6. CONNECT - HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
   7. OPTIONS - 允许客户端查看服务器的性能。
   8. TRACE - 回显服务器收到的请求，主要用于测试或诊断。

<h3 id='三、http常用状态码'>三、http常用状态码</h3>

1.1xx - 信息提示：这类状态码表示一个临时的响应信息，并需要请求者继续执行操作的一个状态码

   - 100：继续，客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收,且仍未被拒绝.客户端应当继续发送请求的剩余部分,或者如果请求已经完成,忽略这个响应.服务器必须在请求完成后向客户端发送一个最终响应。（http1.1可用）
   - 101：切换协议，服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 在Upgrade消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特 性的资源。（http1.1可用）

 2.2xx - 成功：这类状态代码表明服务器成功地接受了客户端请求

   - 200:成功,服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
   - 201:已创建,请求成功且服务器已创建了新的资源。 
   - 202:已接受,服务器已接受了请求，但尚未对其进行处理。 
   - 203:非授权信息,服务器已成功处理了请求，但返回了可能来自另一来源的信息。 
   - 204:无内容,服务器成功处理了请求，但未返回任何内容。 
   - 205:重置内容,服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 
   - 206:部分内容,服务器成功处理了部分 GET 请求。

 3.3xx - 重定向：客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。

   - 301：永久重定向，请求的网页已永久移动到新位置，返回信息的location头中会包含新的url，服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
   - 302：暂时重定向
   - 304：使用缓存（协商缓存）
   - 301，302，303，307详解

         - 302

              - HTTP1.0中，在 POST 请求方式上，客户端收到服务端的301或302状态码，那么不能自动的向新的URI发送重复请求，必须跟用户确认是否该重发，因为第二次 POST 时，POST 方法不是幂等，（也就是请求时服务器的资源有可能已经发生了变化），POST 操作会不符合用户预期。但是很多浏览器（user agent）在这种情况下都会把 POST 请求变为 GET 请求。

              - HTTP1.1中，如果客户端发出非 GET、HEAD 请求后，收到服务端的301或302状态码，那么就不能自动的向新URI发送重复请求，除非得到用户的确认。但是，很多浏览器都把301或302当作303 处理了（注意，303 是 HTTP1.1 才加进来的，其实从 HTTP1.0 进化到 HTTP1.1，浏览器什么都没动），它们获取到 HTTP 响应报文头部的 Location 字段信息，并发起一个 GET 请求。

         - 303和307

              - 从上面的介绍可以知道，HTTP1.1和HTTP1.0的302或301状态码意义是一样的，浏览器对它的处理也是一样的，POST方法的重定向在未询问用户的情况下就变成GET，HTTP1.1新加入303和307状态码。
              - 文档中规定303状态码的响应，也就是上边提到的现在浏览器对302状态码的处理：POST重定向为GET。
              - HTTP1.1文档中307状态码则相当于HTTP1.0文档中的302状态码，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。
              - 文档也说到，为兼容很多HTTP1.1之前的浏览器，服务端在需要发出303状态码时，会选择用302状态码替代；而对于307的处理，则需要在响应实体中包含信息，以便不能处理307状态码的用户有能力在新URI中发起重复请求，也就是说，把重定向的页面展示给用户，让用户去点重定向URI链接。
              - 303和307的存在，归根结底是由于POST方法的非幂等属性引起的。


 4.4xx - 客户端错误/请求错误

   - 400：错误请求，客户端请求语法出现错误，服务器无法理解请求的语法。
   - 401：未授权， 请求要求身份验证。 需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过.对于需要登录的网页，服务器可能返回此响应。
   - 403：禁止，客户端没有权利访问所请求内容,服务器拒绝本次请求。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。
   - 404：未找到，服务器找不到所请求的资源。


 5.5xx - 服务器错误:这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

   - 500:服务器内部错误,服务器遇到错误，无法完成请求。 
   - 501:尚未实施,服务器不具备完成请求的功能。 例如，服务器不支持该请求中使用的方法,比如POST 和 PUT.只有GET 和 HEAD 是RFC2616规范中规定服务器必须实现的方法.
   - 502:错误网关,服务器作为网关或代理，从上游服务器收到无效响应。 
   - 503:服务不可用,由于临时的服务器维护或者过载,服务器当前无法处理请求.这个状况是临时的,并且将在一段时间以后恢复.如果能够预计延迟时间,那么响应中可以包含一个Retry-After:头用以标明这个
         延迟时间.如果没有给出这个Retry-After:信息，那么客户端应当以处理500响应的方式处理它.同时,这种情况下,一个友好的用于解释服务器出现问题的页面应当被返回,并且,缓存相关的HTTP头信息
         也应该包含,因为通常这种错误提示网页不应当被客户端缓存. 
   - 504:网关超时,服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
   - 505:HTTP 版本不受支持,服务器不支持请求中所用的 HTTP 协议版本。





<h1 id='es6总结'><font color='darkgrey'>es6总结</font><h1>

<h3 id='一、promise'>一、promise</h3>

1.Promise.all()

   - Promise.all()接受一个数组作为参数，数组成员都是promise对象，当数组中的所有promise对象的状态变为resloved的时候，Promise.all()的状态就会变为resloved；当有一个状态变为rejected的时候，Promise.all()的状态就会变为rejected；
   - 调用then方法时，结果成功的回调函数的参数也是一个数组，按照顺序保存着每一个promise对象reslove执行的值；结果失败的回调函数的参数是第一个变为rejected的promise对象的reject执行的值；
   - Promise.all()可以解决异步并行的问题

     例1：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       resolve(1);
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      resolve(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       resolve(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) // 进入成功的回调，输出[1,2,3]
		},(err)=>{
		    console.log(err)
		})

    - 上例也表明，与哪个promise的状态先变成resolved无关

    例2：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reject(1);
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      reject(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reslove(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) // 进入失败的回调，promise2先进入rejected，所以输出2
		})

    
    例3：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(1)
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      reslove(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) 
		})

    - 上例中只会输出1，3但不会执行then里面的回调，是因为promise里面的代码是同步执行的所以里面的console.log会输出，但promise.all()的状态是pedding，所以不会执行then

    例4：
        let promise1 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       reject(1)
			},10000)
		})
		
		let promise2 = new Promise((reslove,reject)=>{
		   setTimeout(()=>{
		      console.log(2);
		   },9000)
		})
		
		let promise3 = new Promise((reslove,reject)=>{
		    setTimeout(()=>{
		       console.log(3);
			},11000)
		})
		
		let promiseAll = Promise.all([promise1,promise2,promise3])
		
		promiseAll.then((res)=>{
		    console.log(res) 
		},(err)=>{
		    console.log(err) 
		})

    - 上例会输出2，1，3，是因为promise1的状态变为rejected，所以会执行then里面的失败回调，而两个console是同步的依然会执行


 - 由例3和例4可以看出，只要有一个状态为rejected，Promise.all()的状态就会变为rejected，当所有状态为resloved的时候Promise.all()的状态才会变为resloved

2.Promise.race()

   - Promise.race()也是接受一个数组，数组里面的成员为promise对象，它就相当于竞赛一样，第一个promise对象的状态变为resloved的时候，Promise.race()的状态就变为resloved,第一个promise的状态变为rejectd的时候，Promise.race()的状态就变为rejected
   

    例1：
        let promise1 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(1);
			},10000)
		});
		let promise2 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(2);
			},9000)
		});
		let promise3 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(3);
			},11000)
		});
		
		let promiseRace = Promise.race([promise1,promise2,promise3])
		
		promiseRace.then((res)=>{
		    console.log(res) // promise2的状态先发生变化，变为resloved,所以Promise.race的状态变为resloved，输出2
		},(err)=>{
		    console.log(err)
		})
		

    例2：
        let promise1 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(1);
			},10000)
		});
		let promise2 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       reject(2)
			},9000)
		});
		let promise3 = new Promise((resolve,reject)=>{
			setTimeout(()=>{
		       resolve(3);
			},11000)
		});
		
		let promiseRace = Promise.race([promise1,promise2,promise3])
		
		promiseRace.then((res)=>{
		    console.log(res) // promise2的状态先发生变化，变为rejectd,所以Promise.race的状态变为rejected，输出2
		},(err)=>{
		    console.log(err)
		})

3.使用Promise.race()实现超时处理

	let promise1 = new Promise((reslove,reject)=>{
	    setTimeout(()=>{
	       reslove(1)
	    },3000)
	})
	
	let promise2 = new Promise((reslove,reject)=>{
	   setTimeout(()=>{
	      reject(2);
	   },2000)
	})
	
	let promise3 = new Promise((reslove,reject)=>{
	    setTimeout(()=>{
	      reslove(3);
	    },5000)
	})
	
	let promiseAll = Promise.all([promise1,promise2,promise3])
	
   // 超时处理

	function timeoutPromise(promise,delay){
	
	    let timeout = new Promise((reslove,reject)=>{
	        setTimeout(()=>{
	            reject('异步处理超时')
	        },delay)
	    })
	    
	    let promiseRace = Promise.race([promise,timeout])
	    return promiseRace
	}
	


	timeoutPromise(promiseAll,1000).then((res)=>{
	    console.log(res) 
	},(err)=>{
	    console.log(err) 
	})
	
	


<h3 id='二、promise实现原理'>二、promise实现原理</h3>

#### 一、Promise基本结构 ####

- 构造函数Promise必须接受一个函数作为参数，我们称该函数为handle，handle又包含resolve和reject两个参数，它们是两个函数。
- 定义一个判断一个变量是否为函数的方法，后面会用到

		// 判断变量否为function
		const isFunction = variable => typeof variable === 'function'

- 首先，我们定义一个名为 MyPromise 的 Class，它接受一个函数 handle 作为参数

		class MyPromise {
		  constructor (handle) {
		    if (!isFunction(handle)) {
		      throw new Error('MyPromise must accept a function as a parameter')
		    }
		  }
		}


#### 二、Promise状态和值 ####

1. 状态

- Promise存在以下三种状态：

   - Pending(进行中)
   - Fulfilled(已成功)
   - Rejected(已失败)

- 状态只能由 Pending 变为 Fulfilled 或由 Pending 变为 Rejected ，且状态改变之后不会在发生变化，会一直保持这个状态。

2. 值

- Promise的值是指状态改变时传递给回调函数的值
- 上文中handle函数包含 resolve 和 reject 两个参数，它们是两个函数，可以用于改变 Promise 的状态和传入 Promise 的值

		new Promise((resolve, reject) => {
		  setTimeout(() => {
		    resolve('FULFILLED')
		  }, 1000)
		})

       这里 resolve 传入的 "FULFILLED" 就是 Promise 的值

3. resolve 和 reject

- resolve : 将Promise对象的状态从 Pending(进行中) 变为 Fulfilled(已成功)
- reject : 将Promise对象的状态从 Pending(进行中) 变为 Rejected(已失败)
- resolve 和 reject 都可以传入任意类型的值作为实参，表示 Promise 对象成功（Fulfilled）和失败（Rejected）的值

4. 了解了 Promise 的状态和值，接下来，我们为 MyPromise 添加状态属性和值

    - 首先定义三个常量，用于标记Promise对象的三种状态

		// 定义Promise的三种状态常量
		const PENDING = 'PENDING'
		const FULFILLED = 'FULFILLED'
		const REJECTED = 'REJECTED'

    - 再为 MyPromise 添加状态和值，并添加状态改变的执行逻辑

			class MyPromise {
			   constructor (handle) {
			    if (!isFunction(handle)) {
			      throw new Error('MyPromise must accept a function as a parameter')
			    }
			    // 添加状态
			    this._status = PENDING
			    // 添加状态
			    this._value = undefined
			    // 执行handle
			    try {
			      handle(this._resolve.bind(this), this._reject.bind(this)) //这里相当于调用handle函数，并传入了两个实参，handle函数中可能会出错，所以放入try...catch...里面
			    } catch (err) {
			      this._reject(err)
			    }
			  }
	
			  // 添加resovle时执行的函数
			  _resolve (val) {
	            //如果状态已经改变，就直接返回，之后就再改变状态了，也证明了一个promise只执行一次resolve
			    if (this._status !== PENDING) return
			    this._status = FULFILLED
			    this._value = val
			  }
	
			  // 添加reject时执行的函数
			  _reject (err) { 
	           //如果状态已经改变，就直接返回，之后就再改变状态了，也证明了一个promise只执行一次resolve
			    if (this._status !== PENDING) return
			    this._status = REJECTED
			    this._value = err
			  }
			}
	

#### 三、Promise的then方法 ####

- Promise的then方法接收两个可选的参数，promise.then(onFulfilled, onRejected)
1. 参数

   - 如果onFulfilled为函数，当 promise 状态变为成功时必须被调用，其第一个参数为 promise 成功状态传入的值（ resolve 执行时传入的值）
   - 如果onFulfilled不为函数，当promise状态变为成功时，捕获不到resolve中的值，所以这时候resolve中的值会穿透，promise.then的状态一定是成功的，并且会resolve promise中的值

	        let promise1 = new Promise((resolve, reject) => {
			    setTimeout(() => {
			     resolve('success')
			   }, 1000)
			})

			promise2 = promise1.then('这里的onFulfilled本来是一个函数，但现在不是')
			promise2.then(res => {
			  console.log(res) // 1秒后打印出：success
			}, err => {
			  console.log(err)
			})


   - 如果 onRejected 是函数，当 promise 状态变为失败时必须被调用，其第一个参数为 promise 失败状态传入的值（ reject 执行时传入的值）
   - 如果onRejected不为函数，当promise状态变为失败时，捕获不到reject中的值，所以这时候reject中的值会穿透，promise.then的状态一定是失败的，并且会reject promise中的值

			let promise1 = new Promise((resolve, reject) => {
			    setTimeout(() => {
			     reject('fail')
			   }, 1000)
			})
			promise2 = promise1.then(res => res, '这里的onRejected本来是一个函数，但现在不是')
			promise2.then(res => {
			  console.log(res)
			}, err => {
			  console.log(err)  // 1秒后打印出：fail
			})



   - 多次调用

      - then 方法可以被同一个 promise 对象调用多次

        - 当 promise 成功状态时，所有 onFulfilled 需按照其注册顺序依次回调
        - 当 promise 失败状态时，所有 onRejected 需按照其注册顺序依次回调

2. 返回

   - then 方法必须返回一个新的 promise 对象，因此 promise 支持链式调用
   - 这里涉及到 Promise 的执行规则，包括“值的传递”和“错误捕获”机制：

      - 如果 onFulfilled 或者 onRejected 返回一个值 x 

         - 若 x 不为 Promise ，则使 x 直接作为新返回的 Promise 对象的值， 即新的onFulfilled 或者 onRejected 函数的参数.
         - 若 x 为 Promise ，这时后一个回调函数，就会等待该 Promise 对象(即 x )的状态发生变化，才会被调用，并且新的 Promise 状态和 x 的状态相同。

					let promise1 = new Promise((resolve, reject) => {
					    setTimeout(() => {
					      resolve()
					    }, 1000)
					})

					promise2 = promise1.then(res => {
					  // 返回一个普通值
					  return '这里返回一个普通值'
					})

					promise2.then(res => {
					  console.log(res) //1秒后打印出：这里返回一个普通值
					})
		
		
					let promise1 = new Promise((resolve, reject) => {
					  setTimeout(() => {
					    resolve()
					  }, 1000)
					})

					promise2 = promise1.then(res => {
					  // 返回一个Promise对象
					  return new Promise((resolve, reject) => {
					    setTimeout(() => {
					     resolve('这里返回一个Promise')
					    }, 2000)
					  })
					})

					promise2.then(res => {
					  console.log(res) //3秒后打印出：这里返回一个Promise
					})

    - 如果 onFulfilled 或者onRejected 抛出一个异常 e ，则 promise2 必须变为失败（Rejected），并返回失败的值 e
     
	       let promise1 = new Promise((resolve, reject) => {
			  setTimeout(() => {
			    resolve('success')
			  }, 1000)
			})
			promise2 = promise1.then(res => {
			  throw new Error('这里抛出一个异常e')
			})
			promise2.then(res => {
			  console.log(res)
			}, err => {
			  console.log(err) //1秒后打印出：这里抛出一个异常e
			})


- 根据上面的规则，我们来为 完善 MyPromise

   - 修改 constructor : 增加执行队列
      - 由于 then 方法支持多次调用，我们可以维护两个数组，将每次 then 方法注册时的回调函数添加到数组中，等待执行

			constructor (handle) {
			  if (!isFunction(handle)) {
			    throw new Error('MyPromise must accept a function as a parameter')
			  }
			  // 添加状态
			  this._status = PENDING
			  // 添加状态
			  this._value = undefined
			  // 添加成功回调函数队列
			  this._fulfilledQueues = []
			  // 添加失败回调函数队列
			  this._rejectedQueues = []
			  // 执行handle
			  try {
			    handle(this._resolve.bind(this), this._reject.bind(this)) 
			  } catch (err) {
			    this._reject(err)
			  }
			}

     - 添加then方法

        - 首先，then 返回一个新的 Promise 对象，并且需要将回调函数加入到执行队列中

				// 添加then方法
				then (onFulfilled, onRejected) {
				  const { _value, _status } = this
				  switch (_status) {
				    // 当状态为pending时，将then方法回调函数加入执行队列等待执行
				    case PENDING:
				      this._fulfilledQueues.push(onFulfilled)
				      this._rejectedQueues.push(onRejected)
				      break
				    // 当状态已经改变时，立即执行对应的回调函数
				    case FULFILLED:
				      onFulfilled(_value)
				      break
				    case REJECTED:
				      onRejected(_value)
				      break
				  }
				  // 返回一个新的Promise对象
				  return new MyPromise((onFulfilledNext, onRejectedNext) => {
				  })
				}

        - 那返回的新的 Promise 对象什么时候改变状态？改变为哪种状态呢？
           
           - 根据上文中 then 方法的规则，我们知道返回的新的 Promise 对象的状态依赖于当前 then 方法回调函数执行的情况以及返回值，例如 then 的参数是否为一个函数、回调函数执行是否出错、返回值是否为 Promise 对象。
           - 我们来进一步完善 then 方法:

					// 添加then方法
					then (onFulfilled, onRejected) {
					  const { _value, _status } = this
					  // 返回一个新的Promise对象
					  return new MyPromise((onFulfilledNext, onRejectedNext) => {
					    // 封装一个成功时执行的函数
					    let fulfilled = value => {
					      try {
					        if (!isFunction(onFulfilled)) {
					          onFulfilledNext(value)
					        } else {
					          let res =  onFulfilled(value);
					          if (res instanceof MyPromise) {
					            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
					            res.then(onFulfilledNext, onRejectedNext)
					          } else {
					            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
					            onFulfilledNext(res)
					          }
					        }
					      } catch (err) {
					        // 如果函数执行出错，新的Promise对象的状态为失败
					        onRejectedNext(err)
					      }
					    }
					    // 封装一个失败时执行的函数
					    let rejected = error => {
					      try {
					        if (!isFunction(onRejected)) {
					          onRejectedNext(error)
					        } else {
					            let res = onRejected(error);
					            if (res instanceof MyPromise) {
					              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
					              res.then(onFulfilledNext, onRejectedNext)
					            } else {
					              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
					              onFulfilledNext(res)
					            }
					        }
					      } catch (err) {
					        // 如果函数执行出错，新的Promise对象的状态为失败
					        onRejectedNext(err)
					      }
					    }
					    switch (_status) {
					      // 当状态为pending时，将then方法回调函数加入执行队列等待执行
					      case PENDING:
					        this._fulfilledQueues.push(fulfilled)
					        this._rejectedQueues.push(rejected)
					        break
					      // 当状态已经改变时，立即执行对应的回调函数
					      case FULFILLED:
					        fulfilled(_value)
					        break
					      case REJECTED:
					        rejected(_value)
					        break
					    }
					  })
					}


- 接着修改 _resolve 和 _reject ：依次执行队列中的函数

  - 当 resolve 或 reject 方法执行时，我们依次提取成功或失败任务队列当中的函数开始执行，并清空队列，从而实现 then 方法的多次调用，实现的代码如下：

			// 添加resovle时执行的函数
			_resolve (val) {
			  if (this._status !== PENDING) return
			  // 依次执行成功队列中的函数，并清空队列
			  const run = () => {
			    this._status = FULFILLED
			    this._value = val
			    let cb;
			    while (cb = this._fulfilledQueues.shift()) {
			      cb(val)
			    }
			  }
			  // 为了支持同步的Promise，这里采用异步调用
			  setTimeout(() => run(), 0)
			}
			// 添加reject时执行的函数
			_reject (err) { 
			  if (this._status !== PENDING) return
			  // 依次执行失败队列中的函数，并清空队列
			  const run = () => {
			    this._status = REJECTED
			    this._value = err
			    let cb;
			    while (cb = this._rejectedQueues.shift()) {
			      cb(err)
			    }
			  }
			  // 为了支持同步的Promise，这里采用异步调用
			  setTimeout(run, 0)
			}


- 这里还有一种特殊的情况，就是当 resolve 方法传入的参数为一个 Promise 对象时，则该 Promise 对象状态决定当前 Promise 对象的状态。

		const p1 = new Promise(function (resolve, reject) {
		  // ...
		});
		
		const p2 = new Promise(function (resolve, reject) {
		  // ...
		  resolve(p1);
		})

    上面代码中，p1 和 p2 都是 Promise 的实例，但是 p2 的resolve方法将 p1 作为参数，即一个异步操作的结果是返回另一个异步操作。
    注意，这时 p1 的状态就会传递给 p2，也就是说，p1 的状态决定了 p2 的状态。如果 p1 的状态是Pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 Fulfilled 或者 Rejected，那么 p2 的回调函数将会立刻执行。

   - 我们来修改_resolve来支持这样的特性

		  // 添加resovle时执行的函数
		  _resolve (val) {
		    const run = () => {
		      if (this._status !== PENDING) return
		      // 依次执行成功队列中的函数，并清空队列
		      const runFulfilled = (value) => {
		        let cb;
		        while (cb = this._fulfilledQueues.shift()) {
		          cb(value)
		        }
		      }
		      // 依次执行失败队列中的函数，并清空队列
		      const runRejected = (error) => {
		        let cb;
		        while (cb = this._rejectedQueues.shift()) {
		          cb(error)
		        }
		      }
		      /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
		        当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
		      */
		      if (val instanceof MyPromise) {
		        val.then(value => {
		          this._value = value
		          this._status = FULFILLED
		          runFulfilled(value)
		        }, err => {
		          this._value = err
		          this._status = REJECTED
		          runRejected(err)
		        })
		      } else {
		        this._value = val
		        this._status = FULFILLED
		        runFulfilled(val)
		      }
		    }
		    // 为了支持同步的Promise，这里采用异步调用
		    setTimeout(run, 0)
		  }

- 这样一个Promise就基本实现了，现在我们来加一些其它的方法

#### 四、catch方法 ####

- 相当于调用 then 方法, 但只传入 Rejected 状态的回调函数

		// 添加catch方法
		catch (onRejected) {
		  return this.then(undefined, onRejected)
		}


#### 五、静态 resolve 方法 ####

		// 添加静态resolve方法
		static resolve (value) {
		  // 如果参数是MyPromise实例，直接返回这个实例
		  if (value instanceof MyPromise) return value
		  return new MyPromise(resolve => resolve(value))
		}

#### 六、静态 reject 方法 ####

		// 添加静态reject方法
		static reject (value) {
		  return new MyPromise((resolve ,reject) => reject(value))
		}


#### 七、静态 all 方法 ####

		// 添加静态all方法
		static all (list) {
		  return new MyPromise((resolve, reject) => {
		    /**
		     * 返回值的集合
		     */
		    let values = []
		    let count = 0
		    for (let [i, p] of list.entries()) {
		      // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
		      this.resolve(p).then(res => {
		        values[i] = res
		        count++
		        // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
		        if (count === list.length) resolve(values)
		      }, err => {
		        // 有一个被rejected时返回的MyPromise状态就变成rejected
		        reject(err)
		      })
		    }
		  })
		}


#### 八、静态 race 方法 ####

		// 添加静态race方法
		static race (list) {
		  return new MyPromise((resolve, reject) => {
		    for (let p of list) {
		      // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
		      this.resolve(p).then(res => {
		        resolve(res)
		      }, err => {
		        reject(err)
		      })
		    }
		  })
		}


#### 九、finally 方法 ####

- finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作

		finally (cb) {
		  return this.then(
		    value  => MyPromise.resolve(cb()).then(() => value),
		    reason => MyPromise.resolve(cb()).then(() => { throw reason })
		  );
		};


#### 十、完整代码 ####

- 这样一个完整的 Promsie 就实现了，大家对 Promise 的原理也有了解，可以让我们在使用Promise的时候更加清晰明了。

			  // 判断变量否为function
			  const isFunction = variable => typeof variable === 'function'
			  // 定义Promise的三种状态常量
			  const PENDING = 'PENDING'
			  const FULFILLED = 'FULFILLED'
			  const REJECTED = 'REJECTED'
			
			  class MyPromise {
			    constructor (handle) {
			      if (!isFunction(handle)) {
			        throw new Error('MyPromise must accept a function as a parameter')
			      }
			      // 添加状态
			      this._status = PENDING
			      // 添加状态
			      this._value = undefined
			      // 添加成功回调函数队列
			      this._fulfilledQueues = []
			      // 添加失败回调函数队列
			      this._rejectedQueues = []
			      // 执行handle
			      try {
			        handle(this._resolve.bind(this), this._reject.bind(this)) 
			      } catch (err) {
			        this._reject(err)
			      }
			    }
			    // 添加resovle时执行的函数
			    _resolve (val) {
			      const run = () => {
			        if (this._status !== PENDING) return
			        // 依次执行成功队列中的函数，并清空队列
			        const runFulfilled = (value) => {
			          let cb;
			          while (cb = this._fulfilledQueues.shift()) {
			            cb(value)
			          }
			        }
			        // 依次执行失败队列中的函数，并清空队列
			        const runRejected = (error) => {
			          let cb;
			          while (cb = this._rejectedQueues.shift()) {
			            cb(error)
			          }
			        }
			        /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
			          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
			        */
			        if (val instanceof MyPromise) {
			          val.then(value => {
			            this._value = value
			            this._status = FULFILLED
			            runFulfilled(value)
			          }, err => {
			            this._value = err
			            this._status = REJECTED
			            runRejected(err)
			          })
			        } else {
			          this._value = val
			          this._status = FULFILLED
			          runFulfilled(val)
			        }
			      }
			      // 为了支持同步的Promise，这里采用异步调用
			      setTimeout(run, 0)
			    }
			    // 添加reject时执行的函数
			    _reject (err) { 
			      if (this._status !== PENDING) return
			      // 依次执行失败队列中的函数，并清空队列
			      const run = () => {
			        this._status = REJECTED
			        this._value = err
			        let cb;
			        while (cb = this._rejectedQueues.shift()) {
			          cb(err)
			        }
			      }
			      // 为了支持同步的Promise，这里采用异步调用
			      setTimeout(run, 0)
			    }
			    // 添加then方法
			    then (onFulfilled, onRejected) {
			      const { _value, _status } = this
			      // 返回一个新的Promise对象
			      return new MyPromise((onFulfilledNext, onRejectedNext) => {
			        // 封装一个成功时执行的函数
			        let fulfilled = value => {
			          try {
			            if (!isFunction(onFulfilled)) {
			              onFulfilledNext(value)
			            } else {
			              let res =  onFulfilled(value);
			              if (res instanceof MyPromise) {
			                // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
			                res.then(onFulfilledNext, onRejectedNext)
			              } else {
			                //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
			                onFulfilledNext(res)
			              }
			            }
			          } catch (err) {
			            // 如果函数执行出错，新的Promise对象的状态为失败
			            onRejectedNext(err)
			          }
			        }
			        // 封装一个失败时执行的函数
			        let rejected = error => {
			          try {
			            if (!isFunction(onRejected)) {
			              onRejectedNext(error)
			            } else {
			                let res = onRejected(error);
			                if (res instanceof MyPromise) {
			                  // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
			                  res.then(onFulfilledNext, onRejectedNext)
			                } else {
			                  //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
			                  onFulfilledNext(res)
			                }
			            }
			          } catch (err) {
			            // 如果函数执行出错，新的Promise对象的状态为失败
			            onRejectedNext(err)
			          }
			        }
			        switch (_status) {
			          // 当状态为pending时，将then方法回调函数加入执行队列等待执行
			          case PENDING:
			            this._fulfilledQueues.push(fulfilled)
			            this._rejectedQueues.push(rejected)
			            break
			          // 当状态已经改变时，立即执行对应的回调函数
			          case FULFILLED:
			            fulfilled(_value)
			            break
			          case REJECTED:
			            rejected(_value)
			            break
			        }
			      })
			    }
			    // 添加catch方法
			    catch (onRejected) {
			      return this.then(undefined, onRejected)
			    }
			    // 添加静态resolve方法
			    static resolve (value) {
			      // 如果参数是MyPromise实例，直接返回这个实例
			      if (value instanceof MyPromise) return value
			      return new MyPromise(resolve => resolve(value))
			    }
			    // 添加静态reject方法
			    static reject (value) {
			      return new MyPromise((resolve ,reject) => reject(value))
			    }
			    // 添加静态all方法
			    static all (list) {
			      return new MyPromise((resolve, reject) => {
			        /**
			         * 返回值的集合
			         */
			        let values = []
			        let count = 0
			        for (let [i, p] of list.entries()) {
			          // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
			          this.resolve(p).then(res => {
			            values[i] = res
			            count++
			            // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
			            if (count === list.length) resolve(values)
			          }, err => {
			            // 有一个被rejected时返回的MyPromise状态就变成rejected
			            reject(err)
			          })
			        }
			      })
			    }
			    // 添加静态race方法
			    static race (list) {
			      return new MyPromise((resolve, reject) => {
			        for (let p of list) {
			          // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
			          this.resolve(p).then(res => {
			            resolve(res)
			          }, err => {
			            reject(err)
			          })
			        }
			      })
			    }
			    finally (cb) {
			      return this.then(
			        value  => MyPromise.resolve(cb()).then(() => value),
			        reason => MyPromise.resolve(cb()).then(() => { throw reason })
			      );
			    }
			  }
			
			

#### 十一、例题 ####

1. /*例1*/

		Promise.resolve().then(() => {
		    console.log(0);
		    return Promise.resolve(4);
		}).then((res) => {
		    console.log(res)
		})
		
		Promise.resolve().then(() => {
		    console.log(1);
		}).then(() => {
		    console.log(2);
		}).then(() => {
		    console.log(3);
		}).then(() => {
		    console.log(5);
		}).then(() =>{
		    console.log(6);
		})
		
		// 输出 0，1，2，3，4，5，6
		// 解释：
		//上面代码相当于
		
		new Promise(reslove=>{
		    reslove()
		}).then(()=>{
		    console.log(0)
		    return new Promise(reslove=>{
		        reslove(4)
		    })
		
		}).then(res=>{
		    console.log(res)
		    return new Promise(reslove=>{
		        reslove(8)
		    })
		}).then((res)=>{
		    console.log(res)
		})
		
		
		new Promise(reslove=>{
		    reslove()
		}).then(() => {
		    console.log(1);
		}).then(() => {
		    console.log(2);
		}).then(() => {
		    console.log(3);
		}).then(() => {
		    console.log(5);
		}).then(() =>{
		    console.log(6);
		}).then(()=>{
		    console.log(7)
		}).then(()=>{
		    console.log(9)
		})

		/*
		 * 1.将上面的promise称为promise1，下面的promise称为promise2
		 * 2.首先先执行宏任务promise1同步代码，遇到then，将其加入微任务队列，继续执行宏任务promise2同步代码，遇到then，将其加入微任务队列
		 *   微任务队列：[0then,1then]
		 * 3.执行完宏任务，开始执行微任务，执行0then输出0，发现0then返回一个promise，由于then如果返回一个promise，则会自动添加一个内层
		 *   then来等待其状态改变才能执行下一个回调，所以执行完这个promise添加一个then到微任务队列
		 *   微任务队列：[1then,隐形内层then]
		 * 4.继续执行微任务1then，执行完之后遇到2then，将其加入微任务队列
		 *   微任务队列：[隐形内层then,2then]
		 * 5.继续执行隐形内层then，执行完之后发现之后没有then了，继续执行2then，执行完之后遇到3then，将其加入微任务队列
		 *   微任务队列：[3then]
		 * 6.这个时候发现0then在执行完隐形内层then之后终于执行完了，将4then添加到微任务队列
		 *   微任务队列：[3then，4then]
		 * 7.执行3then，执行完之后遇到5then，将其加入微任务队列
		 *   微任务队列：[4then，5then]
		 * 8.执行4then，执行5then，执行完之后遇到6then，将其加入微任务队列
		 *   微任务队列：[6then]
		 * 9.执行6then
		 */


2./*例2*/

		 new Promise((resolve, reject) => {
		    console.log("外部promise");
		    resolve();
		  })
		    .then(() => {
		      console.log("外部第一个then");
		      return new Promise((resolve, reject) => {
		        console.log("内部promise");
		        resolve()
		      })
		      .then(() => {
		      console.log("内部第一个then");
		      })
		      .then(() => {
		      console.log("内部第二个then");
		      });
		    })
		    .then(() => {
		      console.log("外部第二个then");
		    });
		
		    new Promise((resolve, reject) => {
		        console.log("新外部promise");
		        resolve();
		      })
		       .then(()=>{
		           console.log('新外部第一个then')
		       })
		       .then(()=>{
		        console.log('新外部第二个then')
		       })
		       .then(()=>{
		        console.log('新外部第三个then')
		       })
		       .then(()=>{
		        console.log('新外部第四个then')
		       })
		       .then(()=>{
		        console.log('新外部第五个then')
		       })
		        
		      //外部promise=>新外部promise=>外部第一个then=>内部promise=>新外部第一个then=>内部第一个then=>新外部第二个then=>
		      //内部第二个then=>新外部第三个then=>新外部第四个then=>外部第二个then=>新外部第五个then
		    
		    /*
		     * 上面的叫promise1，下面叫promise2
		     * 1.执行promise1输出外部promise，遇到外部第一个then添加到微任务队列，继续执行promise2输出新外部promise，遇到新外部第一个
		     *   then添加到微任务队列
		     *   微任务队列：[外部第一个then,新外部第一个then]
		     * 2.执行微任务队列，执行外部第一个then，输出外部第一个then，继续执行return的promise，输出内部promise，由于内部promise后
		     *   有then，所以不会添加隐形then，将内部第一个then添加到微任务队列
		     *   微任务队列：[新外部第一个then,内部第一个then]
		     * 3.继续执行新外部第一个then，遇到新外部第二个then添加至微任务队列
		     *   微任务队列：[内部第一个then，新外部第二个then]
		     * 4.继续执行内部第一个then，遇到内部第二个then添加至微任务队列
		     *   微任务队列：[新外部第二个then，内部第二个then]
		     * 5.继续执行新外部第二个then，遇到新外部第三个then添加至微任务队列
		     *   微任务队列：[内部第二个then，新外部第三个then]
		     * 6.继续执行内部第二then，执行完之后发现没有then了，继续执行新外部第三个then，遇到新外部第四个then
		     *   微任务队列：[新外部第四个then]
		     * 7.这个时候发现外部第一个then终于执行完了，添加外部第二个then到微任务列队
		     *   微任务队列：[新外部第四个then,外部第二个then]
		     * 8.执行新外部第四个then，遇到新外部第五个then，添加至微任务队列
		     *   微任务队列：[外部第二个then,新外部第五个then]
		     * 9.执行外部第二个then，新外部第五个then,
		     */
		  
3. /*例3*/

		    Promise.resolve().then(() => {
		        console.log(0);
		        return Promise.resolve(4);
		    })
		    .then((res) => {
		        console.log(res)
		    })
		  
		    Promise.resolve().then(() => {
		        console.log(1);
		    }).then(() => {
		        console.log(2);
		    }).then(() => {
		        console.log(3);
		    }).then(() => {
		        console.log(5);
		    }).then(() =>{
		        console.log(6);
		    })
		    
		    // 0=>1=>undefined=>2=>3=>5=>6
		    
		    /*
		     * 和例3相比没有0then中没有return promise
		     * 1.将上面的promise称为promise1，下面的promise称为promise2
		     * 2.首先先执行宏任务promise1同步代码，遇到then，将其加入微任务队列，继续执行宏任务promise2同步代码，遇到then，将其加入微任务队列
		     *   微任务队列：[0then,1then]
		     * 3.执行完宏任务，开始执行微任务，执行0then输出0，继续执行0then中的promise，这个时候0then全部执行完，执行完之后遇到resthen
		     *   微任务队列：[1then,resthen]
		     * 4.继续执行微任务1then，执行完之后遇到2then，将其加入微任务队列
		     *   微任务队列：[resthen,2then]
		     * 5.继续执行resthen，resthen输出传给resthen的值，由于上一个then没有return所以没有返回值，所以输出undefined继续执行2then，执行
		     *   完之后遇到3then，将其加入微任务队列
		     *   微任务队列：[3then]
		     * 6.执行3then，执行完之后遇到5then，将其加入微任务队列
		     *   微任务队列：[5then]
		     * 7.执行5then，执行完之后遇到6then，将其加入微任务队列
		     *   微任务队列：[6then]
		     * 8.执行6then
		     */

4. /*例4*/

		     Promise.resolve().then(() => {
		        console.log(0);
		        Promise.resolve(4);
		        return 99
		    })
		    .then((res) => {
		        console.log(res)
		    })
		    
		    Promise.resolve().then(() => {
		        console.log(1);
		    }).then(() => {
		        console.log(2);
		    }).then(() => {
		        console.log(3);
		    }).then(() => {
		        console.log(5);
		    }).then(() =>{
		        console.log(6);
		    })
		    
		    // 0=>1=>99=>2=>3=>5=>6
		    
		    /*
		     * 和例3相比没有0then中return 99
		     * 1.将上面的promise称为promise1，下面的promise称为promise2
		     * 2.首先先执行宏任务promise1同步代码，遇到then，将其加入微任务队列，继续执行宏任务promise2同步代码，遇到then，将其加入微任务队列
		     *   微任务队列：[0then,1then]
		     * 3.执行完宏任务，开始执行微任务，执行0then输出0，继续执行0then中的promise，0then return一个常量99，这个时候0then全部执行完，
		     *   执行完之后遇到resthen
		     *   微任务队列：[1then,resthen]
		     * 4.继续执行微任务1then，执行完之后遇到2then，将其加入微任务队列
		     *   微任务队列：[resthen,2then]
		     * 5.继续执行resthen，resthen输出传给resthen的值，由于上一个0then return一个99，所以输出99继续执行2then，执行
		     *   完之后遇到3then，将其加入微任务队列
		     *   微任务队列：[3then]
		     * 6.执行3then，执行完之后遇到5then，将其加入微任务队列
		     *   微任务队列：[5then]
		     * 7.执行5then，执行完之后遇到6then，将其加入微任务队列
		     *   微任务队列：[6then]
		     * 8.执行6then
		     */



<h3 id='三、async/await'>三、async/await</h3>

#### 一、async ####

- async是异步函数的标识符，说明该函数是个异步函数，返回值是个promise对象。

		function fn1() {
		  return 1
		}
		console.log(fn1()) //1
		
		async function fn2() {
		  return 1
		}
		console.log(fn2()) // Promise{<fulfilled>:1}

- 从上面例子可以看到，async函数的返回值是一个promise对象，既然是一个promise对象，那就自然可以使用其原型上的属性，比如then、catch等等。

		fn2()
		.then(r => {
		  console.log(r) // 1
		})

- fn2报错也能被then的第二个回调函数或者catch捕获

        fn2()
        .then(res=>{
          console.log(res)
        },err=>{
          console.log(err)
        }).catch(err=>{
          console.log(err)
        })


#### 二、await ####

1. 理解

- await是async wait的缩写，它等待返回的是一个表达式，不管是不是promise对象都可以，只是说如果返回的是promise对象执行的状态不一样而已，需要注意的是await只能在async函数中使用，看下面例子：

		function sync() {
		  setTimeout(() => {
		    console.log(666)
		  }, 3000)

		}


	   async function test(){
		  await sync() //undefined
		  console.log(888)
	   }
		
       test() 
       // 888
       // 666
       

		async function async1(){
		  return new Promise(resolve => {
		    setTimeout(() => {
              console.log('666')
		      resolve()
		    }, 2000)
		  })
		}
		
		async function test2() {
		  await async1()
		  console.log(888)
		}
		
		test2()
        //666
        //888

- 可以看出上面例子中，如果await等来的是一个promise对象，它会"阻塞"后面的代码，直到这个promise对象有返回结果，不管这个结果是成功还是失败。如果不是一个promise对象，那await后的表达式就是要等待的东西。
- 就算不是promise对象那么await后面的内容还是相当于在then执行，跟promise的区别在于如果等待的是一个promise对象，那么要等待这个对象解析完成，如果没有resolve或者reject那么后面的内容就不会执行

		// eg1
		
		function fn1() {
		  return new Promise(()=> {
		  
		  })
		}
		
		async function fn2() {
		  await fn1()
		  console.log('wait fn1') // 这里的值永远也不会打印，因为函数fn1这个promise对象的状态没有改变
		}
		fn2()


		// eg2
		
		async function fn2() {
		    await 2
		    console.log(24) 
		}
		
		fn2()
		console.log('this') 
		
		//等同于
		 async function fn2() {
		    Promise.resolve(2)
		    .then(r => {
		      console.log(24)
		    })
		 }
		 fn2()
		 console.log('this')
		
		//this
		//24

2. 关于await返回值

- await后是一个promise对象，如果是resolve状态，值就是resolve参数。如果是reject状态，会将错误抛出

		// resolve
		let p = await Promise.resolve(3)
		console.log(p) // 3

		// reject
		let p = await Promise.reject('error')
		console.log(p) // 控制台报错

- await后不是promise对象，则返回值就是该值的本身

		let p = await 3
		console.log(p) // 3

        let p = await function fn(){}
        console.log(p) // [Function: fn]


#### 三、错误捕获 ####

1. await后面如果跟的是promise

   - 可以使用await后面promise的reject或者catch捕获

		async function fn2() {
		    await Promise.reject(2).catch(e=>{
		        console.log(666)
		    })
		    .then(res=>{
		        
		    },e=>{
		       console.log(777)
		   })
		}
		
		
		
		  fn2().then(res=>{
		      console.log(888)
		  },e=>{
		      console.log(999)
		  }).catch(err=>{
		      console.log('555')
		      //console.log(err)
		  })

         //666
         //888 
         //因为错误被内部的promise捕获了，所以fn2进入了成功的回调

2. await后面无论跟的是promise还是其他值

   - 可以使用try...catch...

		async function fn2() {
		    try{
		        await a
		    }catch(e){
		        console.log(666)
		    }
		    
		}
		
		
		
		  fn2().then(res=>{
		      console.log(888)
		  },e=>{
		      console.log(999)
		  }).catch(err=>{
		      console.log('555')
		  })

         //666
         //888
         //因为错误被try...catch...捕获了，所以fn2进入了成功的回调

    - 可以使用fn2()的then第二个参数或者catch

       async function fn2() {
		   
		        await a
		    
		}
		
		
		
		  fn2().then(res=>{
		      console.log(888)
		  },e=>{
		      console.log(999)
		  }).catch(err=>{
		      console.log('555')
		  })

         //999
         //因为错误没被内部捕获，所以进入fn2的then的第二个回调
         
#### 四、实现async/await ####

- async/await实际上是对Generator（生成器）的封装，是一个语法糖

    - async/await自带执行器，不需要手动调用next()就能自动执行下一步
    - async函数返回值是Promise对象
    - await能够返回Promise的resolve/reject的值

- 我们对async/await的实现，其实也就是对应以上三点封装Generator

1. 自动执行

- 我们先来看一下，对于这样一个Generator，手动执行是怎样一个流程

		function* myGenerator() {
		  yield Promise.resolve(1);
		  yield Promise.resolve(2);
		  yield Promise.resolve(3);
		}
		
		// 手动执行迭代器
		const gen = myGenerator()
		gen.next().value.then(val => {
		  console.log(val)
		  gen.next().value.then(val => {
		    console.log(val)
		    gen.next().value.then(val => {
		      console.log(val)
		    })
		  })
		})
		
		//输出1 2 3

- 我们也可以通过给gen.next()传值的方式，让yield能返回resolve的值

		function* myGenerator() {
		  console.log(yield Promise.resolve(1))   //1
		  console.log(yield Promise.resolve(2))   //2
		  console.log(yield Promise.resolve(3))   //3
		}
		
		// 手动执行迭代器
		const gen = myGenerator()
		gen.next().value.then(val => {
		  // console.log(val)
		  gen.next(val).value.then(val => {
		    // console.log(val)
		    gen.next(val).value.then(val => {
		      // console.log(val)
		      gen.next(val)
		    })
		  })
		})

- 显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且yield能返回resolve的值，基于这两个需求，我们进行一个基本的封装，这里async/await是关键字，不能重写，我们用函数来模拟

		function run(gen) {
		  var g = gen()                     //由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环
		
		  function _next(val) {             //封装一个方法, 递归执行g.next()
		    var res = g.next(val)           //获取迭代器对象，并返回resolve的值
		    if(res.done) return res.value   //递归终止条件
		    res.value.then(val => {         //Promise的then方法是实现自动迭代的前提
		      _next(val)                    //等待Promise完成就自动执行下一个next，并传入resolve的值
		    })
		  }
		  _next()  //第一次执行
		}


- 对于我们之前的例子，我们就能这样执行：

		function* myGenerator() {
		  console.log(yield Promise.resolve(1))   //1
		  console.log(yield Promise.resolve(2))   //2
		  console.log(yield Promise.resolve(3))   //3
		}

		run(myGenerator)

- 这样我们就初步实现了一个async/await。简单来说，我们封装了一个run方法，run方法里我们把执行下一步的操作封装成_next()，每次Promise.then()的时候都去执行_next()，实现自动迭代的效果。在迭代的过程中，我们还把resolve的值传入gen.next()，使得yield得以返回Promise的resolve的值
- 这里插一句，是不是只有.then方法这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield后边除了接Promise，还可以接thunk函数，thunk函数不是一个新东西，所谓thunk函数，就是单参的只接受回调的函数，无论是Promise还是thunk函数，其核心都是通过传入回调的方式来实现Generator的自动执行。

2. 返回Promise & 异常处理

- 虽然我们实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：

   - 需要兼容基本类型：这段代码能自动执行的前提是yield后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(gen().next.value)都用Promise.resolve()转化一遍
   - 缺少错误处理：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用Generator.prototype.throw()，把错误抛出来，才能被外层的try-catch捕获到
   - 返回值是Promise：async/await的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise

- 我们改造一下run方法：

		function run(gen) {
		  //把返回值包装成promise
		  return new Promise((resolve, reject) => {
		    var g = gen()
		
		    function _next(val) {
		      //错误处理
		      try {
		        var res = g.next(val) 
		      } catch(err) {
		        return reject(err); 
		      }
		      if(res.done) {
		        return resolve(res.value);
		      }
		      //res.value包装为promise，以兼容yield后面跟基本类型的情况
		      Promise.resolve(res.value).then(
		        val => {
		          _next(val);
		        }, 
		        err => {
		          //抛出错误
		          g.throw(err)
		        });
		    }
		    _next();
		  });
		}


<h3 id='四、try...catch...'>四、try...catch...</h3>

- try...catch...能捕捉到的异常，必须是线程执行已经进入 try catch 但 try catch 未执行完的时候抛出来的,这个时候才能被捕捉到。

1. 之前

- 代码报错的时候，线程执行未进入 try catch，那么无法捕捉异常。
  
   - 比如语法异常（syntaxError），因为语法异常是在语法检查阶段就报错了，线程执行尚未进入 try catch 代码块，自然就无法捕获到异常。

			try{
			    
			        a.
			  
			}catch(e){
			    console.log('捕获到错误了')
			}

        //报错

2. 之中

- 代码报错的时候，线程执行处于 try catch 之中，则能捕捉到异常。

          try{
			   a
			}catch(e){
			    console.log('捕获的错误了')
			}

         //捕获到错误了

3. 之后

- 代码报错的时候，线程已经执行完 try catch，这种不能捕捉到异常。

		try{
		    setTimeout(res=>{
		        a
		    },1000)
		}catch(e){
		    console.log('捕获到错误了')
		}        

       //报错

- setTimeout 里面报错，实际上是 1s 之后执行的代码报错，此时代码块 try catch 已经执行完成，故无法捕捉异常。

		try{
		    function fn(){
		        a
		    }
		}catch(e){
		    console.log('捕获到错误了')
		}
		
		fn()      

       //报错

- 方法定义在 try catch 代码块里面，但是执行方法在 try catch 外，在执行 fn 方法的时候报错，此时 try catch 已经执行完成，故而无法捕捉异常。
- 所以try...catch...捕获不到异步任务
- 解决方案：
    1. 可以将try...catch...写到异步里面

	        setTimeout(res=>{
			   try{
			      a
			   }catch(e){
			     console.log('捕获到错误了')
			   }
			},1000)

    



4. promise

		try{
		    new Promise((reslove,reject)=>{
		        a
               console.log(666)
		    })
               console.log(333)
		}catch(e){
		    console.log('发生错误了')
		}

        //Uncaught (in promise) ReferenceError: a is not defined
        // 333

- 这里线程在执行 a的时候，事实上属于同步执行，try catch 并未执行完成，按理应该能捕捉到异常，这里为啥无法捕捉呢？
  - 这是因为，promise在执行
  
		  	(reslove,reject)=>{
				        a
		     }
   - 这个回调的时候被包裹在了try...catch...里面，其中所有的异常都被内部捕获到了，并未往上抛异常。try...catch...是不能冒泡的，内部捕获了，外部就捕获不到了。
   - 所以还能输出333
   - Promise 的异常都是由 reject 和 Promise.prototype.catch 来捕获，不管是同步还是异步。

			class MyPromise {
			    constructor (handle) {
			      if (!isFunction(handle)) {
			        throw new Error('MyPromise must accept a function as a parameter')
			      }

			      // 添加状态
			      this._status = PENDING

			      // 添加状态
			      this._value = undefined

			      // 添加成功回调函数队列
			      this._fulfilledQueues = []

			      // 添加失败回调函数队列
			      this._rejectedQueues = []

			      // 执行handle
			      try {
			        handle(this._resolve.bind(this), this._reject.bind(this)) 
			      } catch (err) {
			        this._reject(err)
			      }
			   }
			}

     
5. async/await

- 将try...catch写在async函数最外层并不能捕获async...await的异常，而是会走到Promise的异常抛出。

		async function fn(){
		    await a
		    
		}
		
		try{
		    fn()
		}catch(e){
		    console.log('捕获到错误了')
		}

        //报错

- 因为async返回了一个promise，所以执行它相当于在执行promise

- async...await捕获异常，需要将await函数写在try...catch中

		async function fn(){
		    try{
		        await a
		    }catch(e){
		        console.log('捕获到错误了')
		    }
		    
		}
		fn()

       // 捕获到错误了


<h3 id='五、Object&Map&WeakMap&Set&WeakSet' >五、Object&Map&WeakMap&Set&WeakSet</h3>

#### 一、Map和Object的区别 ####

1. Map和Object都是键值对的集合，但Map的键可以是任意类型，而Object的键只能是字符串和Symbol（非字符串会转换为字符串）

   - Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键
   - 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。

2. Map 默认情况下不包含任何键，所有键都是自己添加进去的。不同于 Object 原型链上有一些默认的键。
3. Map 的键值对个数可以轻易通过size属性获取，Object 需要手动计算


#### 二、Map的属性和方法 ####

1. 属性

   - constructor：构造函数
   - size：返回字典中所包含的元素个数

2. 方法

   - 操作方法：
   
       - set(key, value)：向字典中添加新元素
       - get(key)：通过键查找特定的数值并返回
       - has(key)：判断字典中是否存在键key
       - delete(key)：通过键 key 从字典中移除对应的数据
       - clear()：将这个字典中的所有元素删除
       
   - 遍历方法
  
       - Keys()：将字典中包含的所有键名以迭代器形式返回
       - values()：将字典中包含的所有数值以迭代器形式返回
       - entries()：返回所有成员的迭代器
       - forEach()：遍历字典的所有成员

#### 三、WeakMap ####

1. WeakMap特性

   - （1）只接受对象作为键名，不接受其他类型的值作为键名
   - （2）WeakMap的键名引用的对象是弱引用

        - 什么是强引用？

               例如：let obj = {foo:5}
                    let arr = [obj]
                    obj=null

          - 上面代码中，arr数组对于对象{foo:5}就是一个强引用，当obj不在引用这个对象时，这个对象也不会被垃圾回收机制清除，因为arr仍然存在着对对象的引用，必须手动清除引用才会被垃圾回收机制回收

                        arr[0]=null      

         - 所以Map对**键名**所引用的对象也是强引用

               例如：let map = new Map()
                    let obj = {foo:6}
                    map.set(obj,3)
                    obj=null
 
          - 上面代码中，清除obj对{foo:6}的引用，垃圾回收机制也不会回收这个对象，因为还存在着map对这个对象的引用


        - 什么是弱引用？

           - 弱引用和强引用相对，弱引用是指垃圾回收机制在回收这个对象的时候，不会考虑该引用

	               例如：let map = new WeakMap()
	                    let obj = {foo:6}
	                    map.set(obj,3)
	                    obj=null
 
            - 上面代码中，清除obj对{foo:6}的引用，垃圾回收机制就会回收这个对象，它不考虑WeakMap对该对象的引用，因为WeakMap的引用是弱引用


   - （3）不可遍历

       - 正因为WeakMap对键名所引用的对象是弱引用关系，因此WeakMap内部成员是会取决于垃圾回收机制有没有执行，运行前后成员个数很可能是不一样的，而垃圾回收机制的执行又是不可预测的，因此不可遍历
       - 也因此他没有size属性和那些遍历方法


2. WeakMap的属性和方法

- （1）属性

        - constructor：构造函数

- （2）方法

       - 相比map也没有clear方法

       - set(key, value)：向字典中添加新元素
       - get(key)：通过键查找特定的数值并返回
       - has(key)：判断字典中是否存在键key
       - delete(key)：通过键 key 从字典中移除对应的数据
       

3. WeakMap的应用

- （1） 通过 WeakMap 缓存计算结果

     - 使用 WeakMap，你可以将先前计算的结果与对象相关联，而不必担心内存管理。以下功能 countOwnKeys() 是一个示例：它将以前的结果缓存在 WeakMap 中 cache。

				const cache = new WeakMap();
				
				function countOwnKeys(obj) {
				  if (cache.has(obj)) {
				    return [cache.get(obj), 'cached'];
				  } else {
				    const count = Object.keys(obj).length;
				    cache.set(obj, count);
				    return [count, 'computed'];
				  }
				}

- （2）部署私有属性

     - 利用弱映射，将内部属性设置为实例的弱引用对象，当实例删除时，私有属性也会随之消失，因此不会内存泄漏

			const _counter = new WeakMap();
			const _action = new WeakMap();
			
			class Countdown {
			  constructor(counter, action) {
			    _counter.set(this, counter);
			    _action.set(this, action);
			  }
			  
			  dec() {
			    let counter = _counter.get(this);
			    counter--;
			    _counter.set(this, counter);
			    if (counter === 0) {
			      _action.get(this)();
			    }
			  }
			}
			


			let invoked = false;
			
			const countDown = new Countdown(3, () => invoked = true);
			countDown.dec();
			countDown.dec();
			countDown.dec();
			
			console.log(`invoked status: ${invoked}`)


#### 四、Set ####

- Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。判断类似于全等，但是在Set 中认为 NaN 与 NaN 相等

1. Set的属性和方法

    - 属性：

        - constructor：构造函数
        - size：返回集合所包含的元素个数

   - 方法

      - 操作方法：
   
       - add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。
       - delete(value)：删除某个值，删除成功返回 true，否则返回 false。
       - has(value)：返回一个布尔值，表示该值是否为 Set 的成员。
       - clear()：清除所有成员，没有返回值。
       
      - 遍历方法
  
       - Keys()：返回键名的遍历器。
       - values()：返回键值的遍历器。
       - entries()：返回键值对的遍历器
       - forEach()：使用回调函数遍历每个成员。

       - 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。


#### 五、WeakSet ####

- 成员必须都是对象
- 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。
- WeakSet 不可迭代，因此不能被用在 for-of 等循环中
- WeakSet 没有 size 属性。

1. 属性和方法

- （1）属性

        - constructor：构造函数

- （2）方法

       - 相比Set也没有clear方法

       - add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。
       - delete(value)：删除某个值，删除成功返回 true，否则返回 false。
       - has(value)：返回一个布尔值，表示该值是否为 Set 的成员。
   

























<h1 id='node总结'><font color='darkgrey'>node总结</font><h1>