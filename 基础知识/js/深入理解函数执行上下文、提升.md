https://segmentfault.com/a/1190000009041008
一、函数执行上下文（EC）

- 每当控制器转到ECMScript的可执行代码的时候，就会进入一个执行上下文
- 可执行代码包括：

      - 全局代码：例如加载外部js文件或者本地的<script></script>标签内的代码。全局代码不包括任何函数体内的代码，这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。
      
      - 函数代码：任何一个函数体内的代码，需要注意的是，任何一个函数体的代码是不包括内部函数的代码的

      - Eval代码：eval内部的代码

二、执行环境栈（ECS）

 - 我们知道js引擎是单线程的，也就是说同一时间只能发生一件事情，其他事情将被放在执行栈中排队等待。
 
 - 所以当浏览器首次载入你的脚本的时候，默认进入全局执行上下文，这时全局上下文就会被推入执行环境栈。如果你在你的全局代码中调用一个函数,这时，你的程序时序将进入被调用的函数，并创建一个新的执行上下文，并将该执行上下文推入执行环境栈的顶部。如果你调用的函数内部又调用了一个内部函数，会重复上述过程。

 - 上述是在一层一层的创建执行上下文的过程，并没有执行代码，该过程中会存在一个变量对象（VO）。
 
 - 先创建完所有的执行上下文之后才开始执行上下文，该过程中会存在一个活动对象（AO）。
 
 - 浏览器总会执行位于栈顶的执行上下文，一旦当前执行上下文函数执行结束，它将从栈顶弹出，并将上下文控制权交给当前栈

三、变量对象（VO）和活动对象（AO）

 1.变量对象（VO）

    - js的执行上下文都有一个对象用来存放执行上下文可被访问但是不能被delete的函数标识符、形参、变量声明等，这个对象就叫变量对象（VO），它们会被挂在这个对象上。对象的属性名对应它们的名字，对象的属性值对应它们的值，但这个对象是规范上的或者说是引擎实现上的不可在js环境中访问到的活动对象。

 2.活动对象（AO）

    - 有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文中的变量对象就会被激活，也就是该上下文中的函数标识符、形参、变量声明等就可以被访问到了。

四、执行上下文建立细节分析

   1.创建阶段（当函数被调用，函数所在的执行上下文被推入执行环境栈中，还未执行函数内部代码）

       - 创建作用域链（Scope Chain）
       - 创建参数、函数和变量
       - 求this的值

      - 我们可以将每个执行上下文抽象成一个对象，这个对象具有三个属性

          ECObj={
             scopeChain:{/*变量对象+所有腹肌执行上下文的变量对象*/}，
             variableObject:{/*函数 arguments/参数，内部变量和函数声明*/}，
             this:{}
          }

   2.执行阶段

       - 初始化变量的值和函数的引用，执行代码

   3.解释器执行代码流程

   （1）查找调用函数的代码
      
   （2）执行代码之前，先进入创建执行上下文阶段

          - 初始化作用域链

               - 进入一个新的执行环境之后就会创建该环境的作用域链。
               - 作用链的作用是保证执行环境有权访问的所有变量和函数的有序访问。
               - 作用链的前端始终都是当前执行环境的活动对象，作用域链的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。


          - 创建变量对象（VO）

               - 创建arguments对象，检查上下文
               - 初始化参数名称和值并创建引用的复制
               - 扫描上下文的函数声明（而非函数表达式）

                   - 为发现的每一个函数，在变量对象上创建一个属性，属性名字为函数名字，其有一个指向函数在内存中的引用
                   - 如果有和函数名字相同的属性已经存在，则就不用新建函数名字的属性了，直接覆盖该属性
                
               - 扫描上下文的变量声明

                   - 为发现的每个变量声明，在变量对象上创建一个属性，属性名字为变量的名字，并且将变量的值初始化为undefined
                   - 如果有和变量名字相同的属性已经存在，将不会进行任何操作并继续扫描（注意和函数声明的区别）

          - 求出上下文内部的this值

   （3）激活/代码执行阶段

           - 在当前上下文上运行/解释函数代码，并随着代码一行行执行为变量赋值

     例如：function foo(i){
            var a = 'hello'
            var b = function(){}
            function c(){}
          }

          foo(22)

    
   解释：- 当我们调用foo(22)时，先进入创建执行上下文阶段(VO初始化阶段)

    
         ECObj={
           scopeChain:{...},
           variableObject:{
             arguments:{
                0:22,
                length:1
             },
             i:22,
             c:pointer to function c(),
             a:undefined,
             b:undefined
           },
           this:{...}
         }
 
        正如上述过程所述：VO的初始化过程是有顺序的：形参->函数声明->变量声明


             形参：变量对象的一个属性，其属性名为形参的名字，属性值为实参的值，如果没有传递参数，其值为undefined
             函数声明：变量对象的一个属性，其属性名和属性值都是函数对象创建出来的，如果变量对象已经包含了相同名字的属性，则替换它的值

                例：function foo1(a){
                     console.log(a)
                     function a(){}
                   }

                   foo1(20) //'function a(){}'

             变量声明：变量对象的一个属性，其属性名即如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性

                例1：function foo2(a){
                      console.log(a)
                      var a = 10  
                    }
              
                    foo2(20) //'20'

                例2：function foo2(){
                      console.log(a)
                      var a = 10  
                      function a(){}
                    }
              
                    foo2(20) //'function a(){}'

              函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值

                例1：function foo3(a){
                      var a = 10  
                      function a(){}
                      console.log(a)
                    }
               
                    foo3(20) //'10'

                
                例2：function foo3(a){
                      var a
                      function a(){}
                      console.log(a)
                    }
               
                    foo3(20) //'function a(){}'


      - 然后是执行阶段（AO）

           正如上面过程所述，创建的过程仅负责处理定义属性的名字，而并不为他们指派具体的值，当然还有对形参/实参的处理。一旦创建阶段完成，执行流进入函数并且激活/代码执行阶段，看下面函数执行完成后的样子：

                          ECObj={
				           scopeChain:{...},
				           variableObject:{
				             arguments:{
				                0:22,
				                length:1
				             },
				             i:22,
				             c:pointer to function c(),
				             a:'hello',
				             b:pointer to function privateB()
				           },
				           this:{...}
				         }


五、总结

  1.EC分为两个阶段。创建执行上下文和执行代码
  2.每个EC都可以抽离成一个对象，这个对象具有三个属性，分别为：作用域链Scope，VO/AO（VO和AO只能有一个）以及this
  3.函数EC中的AO在进入函数EC时，确定了arguments对象的属性，在执行函数EC时，其他变量属性具体化
  4.EC创建过程是有先后顺序的：参数声明 > 函数声明 > 变量声明
              