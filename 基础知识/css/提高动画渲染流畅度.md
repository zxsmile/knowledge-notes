一、浏览器渲染流程

浏览器拿到数据包之后，会根据文件的指定编码将数据包中的字节转换成字符(即你编写的代码)，然后再将字符转换成token，消耗token生成dom树，以同样的处理流程生成cssdom树，同时执行页面中的js代码，最终根据dom树和cssdom树，计算样式生成渲染树，渲染树中只会包含即将显示到页面中的元素及其样式信息(如head元素，display为hidden的元素就不会包含在渲染树中)；然后根据渲染树需要进行布局(layout)来计算每个元素在页面上的位置；接下来渲染引擎开始进行绘制(paint)，这一步分为若干阶段：

* 根据渲染树将每层的各个元素绘制
* 然后将绘制出的若干连续图像进行栅格化
* 最后将栅格化后的图像合成(composite)为要显示在屏幕上的图像

对每一层的绘制是由浏览器来完成的，最后的合成是由GPU来完成的，而栅格化过程取决于浏览器的设置，chrome默认开启GPU栅格化，否则由CPU来完成

当首次将dom树构建完成之后，每次页面改变需要执行的主要流程是：

JavaScript->style->layout->paint->composite

* JavaScript：执行js逻辑，修改dom,修改css等
* style:计算样式生成渲染树
* layout:计算元素占据的空间以及在屏幕中的位置
* paint:绘制是填充像素的过程，一般包括绘制文本，颜色，图像，边框，阴影，基本上包括元素的每个可视部分，绘制一般是在多个层上完成的，形成多个渲染层
* composite：在dom树中的每个节点都会对应一个layoutObject，当它们的layoutObject处于相同的坐标空间的时候，就会形成一个渲染层(RenderLayers),渲染层来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示

某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的图层(GraphicsLayer)，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个

而每个图层都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上

在浏览器中，页面的渲染由浏览器的渲染进程完成，在渲染进程中包括主线程，worker线程，Compositer线程，Raster线程，上面五个步骤的前四个步骤都是由主线程来完成的，最后一个composite步骤主要由Compositer线程和Raster线程来完成，然后由GPU完成位图的合成并显示到页面上

二、如何变成合成层

* 3d或透视变换css属性，例如translate3d,translateZ等等（js一般通过这种方式，使元素获得复合层）

* <video><iframe><canvas><webgl>等元素

* 混合插件（如flash）。

* 元素自身的 opacity和transform 做 CSS 动画

* 拥有css过滤器的元素

* 使用will-change属性

* position:fixed

* 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

三、合成层的优点

* 合成层的位图，会交由 GPU 合成，比 CPU 处理要快

* 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
    
* 对于 transform 和 opacity 效果，不会触发 layout 和 paint

注意：

    * 提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU。当需要repaint的时候可以只repaint本身，不影响其他层，但是paint之前还有style， layout,那就意味着即使合成层只是repaint了自己，但style和layout本身就很占用时间
    
    * 仅仅是transform和opacity不会引发layout 和paint，那么其他的属性不确定

总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能

四、transform 和 opacity提高动画的流畅度

假如我们a元素和b元素，我们将a元素使用left属性，做一个移动动画：

	<style>
		#a, #b {
		 position: absolute;
		}
		
		#a {
		 left: 10px;
		 top: 10px;
		 z-index: 2;
		 animation: move 1s linear;
		}
		
		#b {
		 left: 50px;
		 top: 50px;
		 z-index: 1;
		}
		
		@keyframes move {
		 from { left: 30px; }
		 to { left: 100px; }
		}
	</style>
	<div id="#a">A</div>
	<div id="#b">B</div>

这种情况对于动画的每一帧，浏览器会计算元素的几何形状，渲染新状态的图像，并把它们发送给GPU。因为重排和重绘发生在动画的每一帧，一个有效避免reflow和repaint的方式是我们仅仅画两个图像；一个是a元素，一个是b元素及整个页面；我们将这两张图片发送给GPU，然后动画发生的时候；只做两张图片相对对方的平移

我们使用translate来代替left：

	<style>
		#a, #b {
		 position: absolute;
		}
		
		#a {
		 left: 10px;
		 top: 10px;
		 z-index: 2;
		 animation: move 1s linear;
		}
		
		#b {
		 left: 50px;
		 top: 50px;
		 z-index: 1;
		}
		
		@keyframes move {
		 from { transform: translateX(0); }
		 to { transform: translateX(70px); }
		}
	</style>
	<div id="#a">A</div>
	<div id="#b">B</div>

浏览器在动画执行之前就知道动画如何开始和结束，因为浏览器没有看到需要reflow和repaint的操作；浏览器就会画两张图像作为复合层，并将它们传入GPU

* 这样做有两个优势：

     * 动画将会非常流畅

     * 动画不在绑定到CPU，即使js执行大量的工作；动画依然流畅


五、GPU动画的优点和缺点

* 每秒60帧，动画平滑、流畅

* 一个合适的动画工作在一个单独的线程，它不会被大量的js计算阻塞

* 3D“变换”是便宜的

缺点：

    * 提升一个元素到复合层需要额外的重绘，有时这是慢的。（即我们得到的是一个全层重绘，而不是一个增量）

    * 绘图层必须传输到GPU。取决于层的数量和传输可能会非常缓慢。这可能让一个元素在中低档设备上闪烁

    * 每个复合层都需要消耗额外的内存，过多的内存可能导致浏览器的崩溃

    * 如果你不考虑隐式合成，而使用重绘；会导致额外的内存占用，并且浏览器崩溃的概率是非常高的

六、提高动画性能

* 提高动画性能，减少动画卡顿的主要目标是减少reflow和rapaint

1.js动画和css动画比较

(1)js动画

* 缺点：JavaScript在浏览器的主线程中运行，而其中还有很多其他需要运行的JavaScript、样式计算、布局、绘制等对其干扰。这也就导致了线程可能出现阻塞，从而造成丢帧的情况

* 优点：JavaScript的动画与CSS预先定义好的动画不同，可以在其动画过程中对其进行控制：开始、暂停、回放、中止、取消都是可以做到的。而且一些动画效果，比如视差滚动效果，只有JavaScript能够完成
CSS动画

(2)css动画

* 缺点：缺乏强大的控制能力。而且很难以有意义的方式结合到一起，使得动画变得复杂且易于出问题

* 优点：浏览器可以对动画进行优化。它必要时可以创建图层，然后在主线程之外运行

(3)注意

* 动画开始时，都会触发一次paint
    
* 对于纯css3操作transform和opacity的动画，在动画开始时，浏览器会自动将动画元素提升为合成层，但是在动画结束后，合成层会失效。在动画结束后(合成层失效)的那一帧，浏览器是会触发Paint的。如果我们强制将动画元素提升为合成层，动画结束后的那一帧，就不会触发Paint了
    
* 对于js操作css3的transform和opacity的动画，在动画过程中，浏览器不会自动将动画元素提升为合成层，但是也不会触发Paint。在动画结束的那一帧，不管我们是否强制将动画元素提升为合成层，当页面动画元素嵌套复杂时，可能会触发Paint

   
2.性能优化

(1)避免隐式合成

* 保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画

* 将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗

(2)开启GPU硬件加速

* 浏览器的GPU加速功能是将需要进行动画的元素提升到一个独立的层（layer），这样就可以避免浏览器进行重新布局（Reflow）和绘制（Repaint），将原先的浏览器使用CPU绘制位图来实现的动画效果转为让GPU使用图层合成（composite）来实现，如果两张图层内部没有发生改变，浏览器就不再进行布局和绘制，直接使用GPU的缓存来绘制每个图层，GPU只负责将各个图层合成来实现动画，这就可以充分利用GPU的资源和优势，减轻CPU的负载，可以使动画更流畅。通过改变两张图片之间的相对位置代替绘制一张图片的每一帧来实现动画，虽然视觉效果相同，但省去了许多绘制的时间。

* 为了让浏览器将动画元素提升到一个独立的层，可以使用transform和opacity属性来实现动画，当设置了这两个属性之一时，浏览器会自动进行这一优化操作（透明度的变化可以通过GPU改变a通道来实现，不需要浏览器进行重绘）。对于上面的动画，可以改变transform来代替改变left和top属性：

* 如果动画并不需要对transform和opacity属性做出改变，可以使用其他的方法强制浏览器为这些元素创建单独的层，比如设置一个没有效果的样式：transform：translateZ(0);这不会对元素的实际样式做出改变。但这是一种hack，规范的做法是使用will-change属性，设置它的值为需要做变换的属性，如will-change: left;浏览器就会知道left这个属性会发生变化，因此会开启硬件加速优化性能。

(3)减小复合层的尺寸

比如一张图片，开始的时候可以将它的尺寸设置的很小，然后再scale将它们放大，这样可以减少大量存储空间

	<div id="a"></div>
	<div id="b"></div>
	
	<style>
		#a, #b {
		 will-change: transform;
		}
		
		#a {
		 width: 100px;
		 height: 100px;
		}
		
		#b {
		 width: 10px;
		 height: 10px;
		 transform: scale(10);
		}
	</style>


(4)用css动画而不是js动画

* css动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。而如果使用js动画，浏览器必须计算每一帧的状态；为了保证平滑的动画，我们必须在浏览器主线程计算新状态；把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画； 当主线程的计算任务过多时，会造成动画的延迟、卡顿。所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞








