# 一、`http1.0` #

## 特性

#### 无状态：服务器不跟踪不记录请求过的状态

* HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）
* 这种无状态性可以借助cookie/session机制来做身份认证和状态记录

#### 无连接：浏览器每次请求都需要建立tcp连接

* 无法复用连接：每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低
* 队头阻塞：由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了

# 二、`http1.1` #

## 特性

#### 长连接：

* HTTP1.1增加了一个Connection字段，通过设置Keep-Alive可以保持HTTP连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，提高了网络的利用率
* 如果客户端想关闭HTTP连接，可以在请求头中携带Connection: false来告知服务器关闭请求

#### 管道化：

* 基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回
* **虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题**

#### 缓存机制：

* 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略

#### 断点传输

* 在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率
* 在 Header 里两个参数实现的，客户端发请求时对应的是 Range， 服务器端响应时对应的是 Content-Range
* https://www.cnblogs.com/purpleraintear/p/6026085.html

#### Host头域

* Host:客户端指定自己想访问的WEB服务器的域名/IP地址和端口号。例如：Host：rss.sina.com.cn
* 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。由于HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。**在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点**
* 在http 1.1中不能缺失host字段,如果缺失, 服务器返回400 bad request，http1.1中不能缺失host字段，但host字段可以是空值
* 在http 1.0中可以缺失host字段

#### 状态码扩充

* 新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除

#### 请求方式新增

* https://www.cnblogs.com/purpleraintear/p/6026085.html

#### 节约带宽

* HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。这是支持文件断点续传的基础

* HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽

#### 性能优化

* https://www.cnblogs.com/purpleraintear/p/6026085.html

# 三、`http2.0` #

## 特性

#### 二进制分帧

* HTTP2.0通过在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能
* 将所有传输的信息分割为**更小的消息和帧**,并对它们采用**二进制格式的编码**
* 所以HTTP1.0和1.1的解析是**基于文本，**2.0的协议解析采用**二进制格式**

#### 多路复用

* 流（stream）：已建立连接上的双向字节流。
* 消息：与逻辑消息对应的完整的一系列数据帧。
* 帧（frame）：HTTP2.0通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）
* **基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走**，每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装
* 多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流
* **HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性**

#### 头部压缩

* 在HTTP1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷
* HTTP2.0使用HPACK算法对header的数据进行压缩，减少了header的大小，并在两端维护了索引表，用于记录出现过的header，后续在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值

#### 请求优先级

* 把HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个31 比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级
* 服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端
* HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。

#### 服务器推送

* 服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求
* HTTP 2.0 连接后，客户端与服务器交换SETTINGS 帧，借此可以限定双向并发的流的最大数量
* 所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行
* **服务器必须遵循请求- 响应的循环，只能借着对请求的响应推送资源**


