## 一、虚拟化技术

#### 1.什么是虚拟化技术？

- 虚拟化是虚拟机的核心。虚拟化这种技术通过创建虚拟的计算环境，将物理资源（如处理器、内存、存储和网络）抽象化。
- 虚拟化技术使用软件，在计算机硬件上创造一个抽象层，能够将单台计算机的硬件元素（处理器、内存、存储等）分成多个虚拟计算机（通常称为**虚拟机**）。每个虚拟机都会运行自己的操作系统，其行为就像一台独立的计算机，即使它只在一部分实际底层计算机硬件上运行。
- **虚拟化使用软件来模拟硬件并创建虚拟计算机系统。虚拟计算机系统被称为虚拟机，它是一种严密隔离的软件容器，内含操作系统和应用。**
- **实现虚拟化需要虚拟机监视器或虚拟机管理器（VMM）或Hypervisor**
- 主机：主机一般指实际存在的计算机（即物理机），又称宿主机。但当虚拟机嵌套时，运行虚拟机的虚拟机也是宿主机，但却不是物理机。
- 虚拟机：虚拟机指在物理机上运行的操作系统中模拟出来的计算机，又称为客户机，理论上完全等同于实体的物理机。每个虚拟机都可以安装自己的操作系统或应用程序，并连接网络。

#### 2.虚拟机的发展历程

- 虚拟化技术已经走过了三个时代，没有容器化技术的演进就不会有 Docker 技术的诞生。

  ![VM1](.\images\VM5.png)

**（1）早期探索阶段**

- 虚拟机概念的起源可以追溯到 20 世纪 60 年代，当时大型机计算资源昂贵且利用率较低，为了提高资源利用率，研究人员开始探索如何在一台大型机上同时运行多个不同的操作系统和应用程序。**早期的虚拟机实现主要基于硬件虚拟化技术，通过对大型机硬件进行特殊设计和改造，使得可以在其上创建多个独立的虚拟计算环境。**例如，IBM 的 System/360 大型机就支持在硬件层面创建多个虚拟机，每个虚拟机都可以运行不同的操作系统，如 OS/360、CMS 等。这些早期的虚拟机系统为后来虚拟机技术的发展奠定了基础，但由于硬件成本高昂且技术复杂，主要应用于大型企业和科研机构的大型机环境中。

**（2）基于软件虚拟化的兴起**

- 随着计算机技术的发展，个人计算机和小型服务器逐渐普及，对虚拟机技术的需求也开始向这些平台扩展。20 世纪 90 年代，基于软件虚拟化的虚拟机技术开始兴起。**这种技术不再依赖于特殊的硬件设计，而是通过在操作系统之上运行的虚拟化软件来实现虚拟机的创建和管理**。例如，VMware 公司在 1998 年推出了第一款基于 x86 架构的虚拟机产品 VMware Workstation，它可以在普通的个人计算机上创建多个虚拟机，运行不同的操作系统，如 Windows、Linux 等。这一时期的虚拟机软件主要面向系统测试与开发人员，为他们提供了一个便捷的多操作系统测试环境，大大提高了软件研发的效率。

**（3）硬件辅助虚拟化的出现与发展**

- 进入 21 世纪，随着计算机硬件技术的不断进步，特别是英特尔和 AMD 等处理器厂商在其芯片中引入了硬件辅助虚拟化技术（如英特尔的 VT - x 和 AMD 的 AMD - V），虚拟机技术得到了进一步的发展和完善。**硬件辅助虚拟化技术通过在处理器中增加特殊的指令集和硬件支持，大大提高了虚拟机的性能和效率，降低了虚拟化软件的复杂度。**基于硬件辅助虚拟化的虚拟机产品如 VMware ESX/ESXi、Microsoft Hyper - V、Citrix XenServer 等开始在企业数据中心和云计算环境中得到广泛应用，成为构建虚拟化数据中心和云计算基础设施的核心技术之一。这些产品不仅支持大规模的虚拟机部署，还提供了丰富的功能，如虚拟机动态迁移、高可用性、资源调度等，为企业提供了更加灵活、高效、可靠的 IT 基础设施解决方案。

**（4）容器化技术与虚拟机的融合发展**

- 近年来，随着容器化技术（如 Docker）的兴起，虚拟机技术与容器化技术开始出现融合发展的趋势。**容器化技术是一种轻量级的虚拟化技术，它通过共享操作系统内核的方式在同一台物理计算机上创建多个隔离的应用程序运行环境。与传统虚拟机相比，容器化技术具有更高的资源利用率和更快的启动速度，但在隔离性和安全性方面相对较弱。**因此，一些虚拟机产品开始集成容器化技术，将虚拟机的强隔离性和安全性与容器的高资源利用率和快速部署能力相结合，为用户提供更加灵活和多样化的虚拟化解决方案。例如，VMware 的 Tanzu 产品线就支持在虚拟机环境中运行容器化应用程序，实现了虚拟机与容器的无缝集成和协同工作。
  


#### 3.Hypervisor分类

**（1）Type1 裸机型**

- 裸金属虚拟化架构指在硬件基础之上，没有直接安装任何操作系统，而是直接安装的虚拟机软件（Hypervisor），所有的操作系统都是虚拟机，没有任何操作系统是泡在硬件之上的。

- Hypervisor可以当作操作系统，由用户空间，用户空间是用来管理创建虚拟机的。

  ![VM1](.\images\VM3.png)

  ![VM1](.\images\VM4.png)

**（2）Type2 主机托管型（寄居虚拟化、寄居架构)**

- 寄居虚拟化运行在宿主操作系统上，**这种虚拟化方式依赖于宿主机的操作系统，特点是需要通过虚拟化软件来实现**。如果想要使用虚拟化功能，需要安装对应的厂商软件（**虚拟化管理软件**)，在软件中安装操作系统。常见的软件有Oracle VirtualBox和VMware Workstation。**虚拟化管理软件作为底层操作系统（Windows或Linux等）上的一个普通应用程序，然后通过其创建相应的虚拟机，共享底层服务器资源。**

  ![VM1](.\images\VM1.png)

  ![VM1](.\images\VM2.png)

#### 4.虚拟化技术的分类

- 虚拟化技术经过多年的发展，已经成为一个庞大的技术家族，其技术种类繁多，实现的应用也自成体系。我们可以按照虚拟化实现方法、虚拟化实现机制、虚拟化架构模型以及虚拟化应用领域4个维度对虚拟化技术进行分类。

**（1） 按照虚拟化实现方法分类，**虚拟化技术可以分为软件虚拟化技术和硬件辅助虚拟化技术。

​       ①**软件虚拟化**是指在操作系统层面上实现虚拟化，通过在虚拟机和宿主机之间添加一个虚拟化层，来模拟一个完整的虚拟化环境。软件虚拟化的优点是可以在没有硬件支持的情况下实现虚拟化，但是由于需要在操作系统层面上进行虚拟化，因此会带来一定的性能损失。常见的软件虚拟化技术包括VMware Workstation、VirtualBox、QEMU等。

​       ②**硬件辅助虚拟化**是指在硬件层面上实现虚拟化，通过在CPU中添加虚拟化指令集，来提高虚拟化的性能和效率。硬件辅助虚拟化的优点是可以在硬件层面上实现虚拟化，可以提高虚拟化的性能和效率，但是由于需要硬件支持，因此不是所有的CPU都支持硬件辅助虚拟化。常见的硬件辅助虚拟化技术包括Intel VT-x和AMD-V等。在使用这些技术的虚拟化软件中，常见的有VMware ESXi、Hyper-V等。

 

**（2） 按照虚拟化实现机制分类，**虚拟化技术可以分为全虚拟化技术、半虚拟化技术和容器虚拟化技术。

​        ①**全虚拟化技术**是一种在虚拟机中运行的操作系统不知道自己是在虚拟机中运行的虚拟化技术。它支持在虚拟机中运行多种操作系统，这些操作系统都认为自己是在物理服务器上运行的。全虚拟化技术通常使用虚拟机技术实现，可以在同一台物理服务器上运行多个虚拟机，每个虚拟机都有自己的操作系统、应用程序和文件系统，它们之间相互隔离，互不干扰。

​       ②**半虚拟化技术**是一种在虚拟机中运行的操作系统知道自己是在虚拟机中运行的虚拟化技术。它支持在虚拟机中运行多种被修改的操作系统，这些操作系统都知道自己是在虚拟机中运行的，它们与虚拟化层之间可以直接通信，从而提高了性能。半虚拟化技术通常使用
虚拟机技术实现，可以在同一台物理服务器上运行多个虚拟机，每个虚拟机都有自己的操作系统、应用程序和文件系统，它们之间相互隔离，互不干扰。

​        ③**容器虚拟化技术**是一种将应用程序及其依赖项打包成一个容器的虚拟化技术。容器虚拟化技术可以在同一台物理服务器上运行多个容器，每个容器都有自己的文件系统、网络和进程空间，但是它们共享同一个操作系统内核。容器虚拟化技术可以提高应用程序的可移植性和兼容性，同时也可以提高服务器的利用率和灵活性。

 

**（3） 按照虚拟化架构模型分类，**虚拟化技术可以分为裸金属架构、寄居架构和混合架构。

​       ①**裸金属架构**是一种直接在物理服务器上运行虚拟机的虚拟化技术。在裸金属架构中，虚拟机监控器（Virtual Machine Monitor，VMM）直接运行在物理服务器的硬件上，虚拟机则运行在VMM之上。裸金属架构可以提供接近于原生性能的虚拟化环境，但是需要支持硬件辅助虚拟化技术。

​       ②**寄居架构**是一种在操作系统之上运行虚拟机的虚拟化技术。在寄居架构中，VMM运行在操作系统之上，虚拟机则运行在VMM之上。寄居架构可以实现更好的资源隔离和管理，但是需要操作系统的支持，同时也会带来一定的性能损失。

​       ③**混合架构**是一种将裸金属架构和寄居架构相结合的虚拟化技术。在混合架构中，VMM直接运行在物理服务器的硬件上。混合架构中VMM只负责CPU和内存虚拟化，I/O设备的虚拟化由VMM和特权级操作系统共同完成。

| **架构类型** | **优点**                                                     | **缺点**                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 裸金属架构   | (1)性能接近于原生架构，因为VMM直接运行在物理服务器的硬件上，不需要操作系统的干预(2)可以支持更多的操作系统和应用程序，因为VMM可以直接访问物理服务器的硬件资源(3)可以提供更好的安全性和隔离性，因为虚拟机之间是完全隔离的 | (1)需要支持硬件辅助虚拟化技术，否则无法运行VMM(2)部署和管理比较复杂，需要专业的技术人员进行配置和维护(3)不支持动态资源分配和管理，需要手动配置虚拟机的资源 |
| 寄居架构     | (1)部署和管理比较简单，可以使用操作系统的管理工具进行配置和维护(2)支持动态资源分配和管理，可以根据需要调整虚拟机的资源(3)可以实现更好的资源隔离和管理，因为虚拟机之间是通过操作系统进行隔离的 | (1)性能比裸金属架构的略差，因为VMM需要运行在操作系统之上(2)可能会受到操作系统的限制，例如操作系统的内存限制和文件系统限制(3)可能会受到操作系统的安全漏洞影响，例如操作系统的漏洞可能会影响到所有运行在宿主机上的虚拟机 |
| 混合架构     | 可以同时享受裸金属架构和寄居架构的优点，例如可以提供接近于原生性能的虚拟化环境，同时也可以实现更好的资源隔离和管理 | (1)部署和管理比较复杂，需要专业的技术人员进行配置和维护(2)可能会受到操作系统的限制和安全漏洞的影响，需要进行适当的安全措施 |

 

**（4） 按照虚拟化应用领域分类，**虚拟化技术可以分为服务器虚拟化技术、存储虚拟化技术、网络虚拟化技术、桌面虚拟化技术、应用程序虚拟化技术和平台虚拟化技术。

​        ①**服务器虚拟化技术**是一种将一台物理服务器划分为多个虚拟机的虚拟化技术。它可以使多个虚拟机在同一台物理服务器上运行，从而提高服务器的利用率和灵活性。服务器虚拟化技术通常使用虚拟机技术实现，可以在同一台物理服务器上运行多个虚拟机，每个虚拟机都有自己的操作系统、应用程序和文件系统，它们之间相互隔离，互不干扰。

​        ②**存储虚拟化技术**是一种将多个存储设备虚拟化为一个逻辑存储设备的虚拟化技术。它可以提高存储资源的利用率和可管理性，同时也可以提高数据的可靠性和可用性。存储虚拟化技术通常使用存储虚拟化器实现，存储虚拟化器可以将多个存储设备虚拟化为一个逻辑存储设备，从而使应用程序可以访问逻辑存储设备而不需要知道实际的存储设备。

​        ③**网络虚拟化技术**是一种将物理网络设备虚拟化为多个逻辑网络设备的虚拟化技术。它可以提高网络资源的利用率和可管理性，同时也可以提高网络的可靠性和可用性。网络虚拟化技术通常使用网络虚拟化器实现，网络虚拟化器可以将物理网络设备虚拟化为多个逻辑网络设备，从而使应用程序可以访问逻辑网络设备而不需要知道实际的网络设备。

​        ④**桌面虚拟化技术**是一种将多个虚拟桌面运行在一台物理计算机上的虚拟化技术。桌面虚拟化技术可以将多个用户的桌面环境隔离开，从而提高桌面资源的利用率，简化桌面管理和配置，同时也可以提高桌面的安全性和可靠性。

​        ⑤**应用程序虚拟化技术**是一种将应用程序和其依赖的库文件打包成一个独立的虚拟化容器，从而可以在不同的操作系统和环境中运行的虚拟化技术。应用程序虚拟化技术可以简化应用程序的部署和管理，同时也可以提高应用程序的可移植性和安全性。

​        ⑥**平台虚拟化技术**是一种将整个操作系统和应用程序打包成一个独立的虚拟化容器从而可以在不同的硬件和操作系统中运行的虚拟化技术。平台虚拟化技术可以简化应用程序的部署和管理，同时也可以提高应用程序的可移植性和安全性。

#### 5.主流虚拟化技术

- 虚拟化技术种类繁多，下面简要介绍几种当前应用较为广泛的虚拟化技术：VMware的vSphere、思杰的XenServer、微软的Hyper-V、KVM和Docker。

**（1）VMware的vSphere：**VMware的vSphere是一套服务器虚拟化解决方案，其核心组件为VMware ESXi。ESXi是一款可以独立安装和运行在裸机上的系统，与其他VMwareWorkstation软件不同的是，它不再依存于宿主操作系统。在ESXi安装好以后，可以通过vSphere Client远程连接控制，在ESXi服务器上创建多个虚拟机，再为这些虚拟机安装好Linux/Windows Server系统，使之成为能提供各种网络应用服务的虚拟服务器。ESXi可以从内核级支持硬件辅助虚拟化，运行于其中的虚拟服务器在性能与稳定性上不亚于普通的硬件服务器，而且更易于管理与维护。

**（2）思杰的XenServer：**思杰的XenServer是一款开源的虚拟化平台，通过它可以在一台物理服务器上运行多个虚拟机。XenServer支持多种操作系统，包括Windows.Linux和Solaris等。XenServer的虚拟化技术基于Xen Hypervisor，它可以将物理服务器的资源划分至多个虚拟机中，每个虚拟机都可以独立运行自己的操作系统和应用程序。XenServer还提供了一些高级功能，如动态内存管理、虚拟机快照等。

**（3）微软的Hyper-V：**微软的Hyper-V是一款虚拟化平台，通过它可以在Windows Server操作系统上运行多个虚拟机。Hyper-V支持多种操作系统，包括Windows、Linux和FreeBSD等。Hyper-V的虚拟化技术基于Windows Hypervisor，它可以将物理服务器的资源划分至多个虚拟机中，每个虚拟机都可以独立运行自己的操作系统和应用程序。Hyper-V还提供了一些高级功能，如动态内存管理、虚拟机快照等。

**（4）KVM：**KVM是一款开源的虚拟化平台，通过它可以在Linux操作系统上运行多个虚拟机。KVM的虚拟化技术基于Linux内核，通过它可以将物理服务器的资源划分至多个虚拟机中，每个虚拟机都可以独立运行自己的操作系统和应用程序。KVM支持多种操作系统，包括Windows、Linux和FreeBSD等。KVM还提供了一些高级功能，如动态内存管理、虚拟机快照等。

**（5）Docker：**Docker是一款开源的容器化平台，通过它可以在一台物理服务器上运行多个容器。Docker的容器化技术基于Linux内核，通过它可以将物理服务器的资源划分到多个容器中，每个容器都可以独立运行自己的应用程序。Docker支持在多种操作系统部署，包括Windows、Linux和macOS等。Docker还提供了一些高级功能，如容器快照等。

#### 6.虚拟机如何虚拟不同硬件

- 虚拟机虚拟不同硬件的方式主要包括：硬件抽象、硬件模拟、硬件直通、硬件加速等。

**（1）硬件抽象**

- 硬件抽象是虚拟化技术的核心，通过在物理计算机硬件和操作系统之间创建一个中间层（虚拟化层），使操作系统和应用程序对底层硬件的感知一致。硬件抽象层提供了一个标准化的接口，屏蔽了不同物理硬件的差异。
- 虚拟化层通常被称为虚拟机监视器（VMM）或Hypervisor。Hypervisor负责对物理计算机的硬件资源进行抽象和管理，将硬件资源划分为多个独立的部分，并为每个虚拟机实例提供一个虚拟的硬件资源视图。
- Hypervisor可以分为两类（**虚拟化架构分类**）：Type1（裸金属）和Type2（寄居）。

**（2）硬件模拟**

- 硬件模拟通过软件模拟实际硬件设备，使虚拟机能够访问和使用不同类型的硬件。硬件模拟在兼容性和灵活性方面具有优势，但性能可能较低。

- **设备模拟的类型**
  - 硬件模拟包括CPU模拟、内存模拟、存储设备模拟和网络设备模拟等。每种设备模拟都有其独特的实现方法和挑战。

- **CPU模拟**
  - CPU模拟通过软件实现对不同指令集架构（ISA）的支持，使虚拟机能够运行在与物理CPU不同的架构上。常见的CPU模拟器包括QEMU和Bochs。

**（3）硬件直通**

- 硬件直通技术（例如Intel VT-d和AMD IOMMU）允许虚拟机直接访问物理硬件设备，从而提高性能和兼容性。硬件直通通过虚拟机管理程序将物理设备映射到虚拟机中，使虚拟机能够直接与设备进行交互。

- **Intel VT-d和AMD IOMMU**
  - Intel VT-d和AMD IOMMU是两种常见的硬件直通技术，分别由Intel 和AMD 提供。它们通过输入输出内存管理单元实现设备的地址转换和访问控制。

- **硬件直通的优势**
  - 硬件直通的主要优势是性能和兼容性。由于虚拟机可以直接访问物理硬件，性能损失较小。同时，硬件直通还可以提高设备的兼容性，是虚拟机能够使用更多类型的硬件设备。

**（4）硬件加速**

- 硬件加速技术利用专用硬件提升虚拟机性能。例如，GPU虚拟化通过硬件加速图形处理，提高虚拟机的图形性能。

- **GPU虚拟化**
  - GPU虚拟化是硬件加速的一中常见形式，通过将物理GPU资源分配给多个虚拟机，提高图形处理性能。常见的	GPU虚拟化技术包括NVIDIA GRID 和AMD MxGPU。

- **其他硬件加速技术**
  - 除了GPU虚拟化，硬件加速还包括网络加速、存储加速和加密加速等。例如：SR-IOV(单根输入输出虚拟化)技术通过营建支出，将网络接口卡（NIC）和存储设备虚拟化，提高网络和存储性能。

**（5）相关问答**

- **为什么虚拟机可以虚拟不同硬件？**
  - 虚拟机可以虚拟不同硬件还能是因为它使用了虚拟化技术，可以将物理硬件资源抽象化为虚拟的形式，并通过软件模拟出各种不同类型的硬件设备。

- **虚拟机如何实现虚拟不同硬件？**

  - 虚拟机通过虚拟化软件层物理硬件资源进行抽象化，然后通过模拟器或者Hypervisor来模拟各种不同类型的硬件设备。这样，虚拟机就可以在虚拟环境中使用与物理硬件相同的操作系统和应用程序，同时可以根据需要配置不同类型的虚拟硬件设备。

- **虚拟机虚拟不同硬件会对性能产生影响吗？**
  - 虚拟机虚拟不同的硬件会对性能产生一定的影响。由于虚拟机需要模拟硬件设备，所以在访问和操作硬件时会引入额外的开销。但是，现代虚拟化技术已经相当成熟，虚拟机在模拟硬件时会尽量优化性能，减少对实际硬件的访问次数，以提供接近物理硬件性能的虚拟化环境。此外，硬件的性能和虚拟机的配置也会对性能产生影响，合理配置硬件资源和优化虚拟机设置可以提高性能。



## 二、虚拟机

##### 1.什么是虚拟机？

- **虚拟机（Virtual Machine，VM）是一种通过软件仿真生成的独立计算机环境，它能够运行操作系统和应用程序，类似于物理计算机。**

- **虚拟机（VM）是对实际计算机系统的模拟或虚拟化，它提供物理计算机的所有功能，但以软件形式存在。它取代了对物理计算基础设施或硬件的需求，创建了一个部署软件应用程序的环境。**
- 简单来说，虚拟机是一种模拟物理机运行的特殊软件。
- 虚拟机（也称为客户机），是在物理计算机（称为宿主机）上构建的，使用宿主机的CPU核心和内存等资源。单个宿主机可以同时托管多个虚拟机。
- 每个虚拟机都独立运行，拥有自己的操作系统、内存、存储、CPU和网络接口，独立于硬件主机上的其他VM运行。
- **虚拟机无法直接与物理计算机交互，它依赖于一个轻量级软件层（称为虚拟机管理程序）来协调虚拟机与底层物理硬件之间的通信。**
- **虚拟机管理程序将物理计算机的资源（例如CPU、内存和存储）分配给每个虚拟机，并保证各虚拟机之间的独立性，避免相互干扰。**

#### 2.虚拟机的分类

**（1）系统虚拟机**

- 系统虚拟机是最常见的一种虚拟机类型，它主要用于在一台物理计算机上运行多个不同的操作系统。系统虚拟机可以完全模拟出一台真实计算机的硬件环境，包括 CPU、内存、硬盘、网络接口等，使得每个虚拟机都可以独立安装和运行不同的操作系统，如 Windows、Linux、macOS 等。系统虚拟机的典型应用场景包括系统测试与开发、多操作系统办公环境、服务器整合等。例如，软件测试人员可以在一台物理计算机上创建多个不同操作系统的虚拟机，分别安装和测试不同版本的软件，以确保软件在各种操作系统环境下的兼容性和稳定性。在企业数据中心中，系统虚拟机可以将多个服务器的应用程序整合到少数几台物理服务器上，通过虚拟机的隔离性和资源管理功能，提高服务器资源的利用率，降低硬件成本和能源消耗。

**（2）进程虚拟机**

- **进程虚拟机也成为应用程序虚拟机或托管运行时环境。**

- 进程虚拟机与系统虚拟机不同，它主要是为了在特定的操作系统平台上运行单个应用程序或一组相关的应用程序而设计的。进程虚拟机不是模拟完整的计算机硬件环境，而是针对特定的编程语言或应用程序运行环境进行优化，提供一个隔离的运行时环境。例如，Java 虚拟机（JVM）就是一种典型的进程虚拟机，它可以在不同的操作系统上运行 Java 应用程序。JVM 负责将 Java 字节码解释或编译为机器码，并为 Java 应用程序提供内存管理、线程调度、垃圾回收等运行时服务。其他的进程虚拟机还包括微软的.NET 虚拟机、Python 的 PyPy 等。如果没有Java 虚拟机，就需要为每一个操作系统写一个JVM程序用来运行java代码。
- **进程虚拟机的主要优势在于它可以提供跨平台的应用程序运行能力，使得开发人员可以编写一次代码，然后在不同的操作系统上运行，而无需关心底层操作系统的差异。**

#### 3.虚拟机应用场景

- **多租户云服务**：在云服务提供商的基础设施中，虚拟机常用于为不同的客户提供独立的计算环境。这种环境确保每个客户的数据和操作系统彼此隔离，提高了安全性和隐私性。
- **开发与测试环境**：开发人员可以使用虚拟机模拟不同的操作系统和硬件配置，测试应用程序的兼容性和性能。
- **灾难恢复与备份**：虚拟机的快照功能可以用于系统备份和灾难恢复，确保在系统故障时能够快速恢复到正常状态。

#### 4.虚拟机的优点

- **资源隔离性强**：每个虚拟机都有自己独立的操作系统和应用程序，彼此完全隔离。这种隔离性确保了一个虚拟机中的故障不会影响其他虚拟机。
- **操作系统多样性**：虚拟机允许在同一台物理服务器上运行不同的操作系统。例如，可以在同一台服务器上同时运行Windows、Linux和BSD系统。
- **成熟的管理工具**：虚拟机技术已经发展多年，拥有成熟的管理工具和生态系统，支持企业级应用的部署和管理。

#### 5.虚拟机的缺点

- **性能开销大**：由于虚拟机需要仿真完整的硬件环境，并运行一个完整的操作系统，资源利用率相对较低，性能开销较大。
- **启动时间长**：虚拟机的启动需要加载完整的操作系统，启动时间通常较长。
- **占用资源多**：每个虚拟机都需要独立的操作系统，占用较多的内存和存储资源。

## 三、容器

#### 1.环境配置的难题

- 软件开发最大的难题就是环境配置，要保证软件在机器中运行起来，用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行起来。
  - 举例来说，安装一个Python应用，计算机必须有Python引擎，还必须有各种依赖，可能还要配置环境变量。环境变量配置很麻烦，如果换一台机器，就得重来一次，费时费力。
- 很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。

#### 2.虚拟机

- 虚拟机就是带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。
- **可以将软件和操作系统一起打包成虚拟机部署在物理机中，这样用户就可以通过虚拟机还原软件的原始环境了**， 但这样在物理机中再运行一个完整的虚拟机，有几个缺点：
  - **（1）资源占用多**
    - 虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。
  - **（2）冗余步骤多**
    - 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。
  - **（3）启动慢**
    - 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。
- 既然多加一个操作系统太重，那我就只打包**软件和系统依赖库加配置**就好了。然后将这部分系统文件挂到 主机的操作系统下，利用一个叫 **Namespace** 的能力让它看起来就像是一个独立操作系统一样。再利用一个叫 **Cgroup** 的能力限制它能使用的计算资源。这就省掉了一层笨重的操作系统，同时还让软件轻松跑在各类操作系统上。这就是我们常说的 **容器技术**。

#### 3.Linux容器

- 由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。
- **Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。**或者说，在正常进程的外面套了一个[保护层](https://link.juejin.cn?target=https%3A%2F%2Fopensource.com%2Farticle%2F18%2F1%2Fhistory-low-level-container-runtimes)。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
- 由于容器是进程级别的，相比虚拟机有很多优势。
  - **（1）启动快**
    - 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。
  - **（2）资源占用少**
    - 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。
  - **（3）体积小**
    - **容器只要包含用到的组件**即可，而**虚拟机是整个操作系统的打包**，所以容器文件比虚拟机文件要小很多。

- 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。

- 容器（Container）是一种**轻量级的虚拟化技术**，它通过**操作系统级**的虚拟化，将**应用程序及其依赖环境打包在一起**，确保应用程序可以在**任何环境**中**一致运行**。与虚拟机不同，**容器共享宿主操作系统的内核，而不是虚拟化整个操作系统。**

- **容器是一种操作系统层的虚拟化技术。**

- **容器使用宿主操作系统的内核，通过命名空间（Namespace）和控制组（Cgroups）技术实现资源的隔离和限制。命名空间确保每个容器拥有独立的系统视图，如进程树、网络接口和文件系统；控制组则限制和分配容器的资源使用，如CPU、内存和I/O。**

- **容器化技术通常依赖于镜像（Image）来实现应用程序的打包。一个镜像包含了应用程序运行所需的所有依赖项，包括代码、库、工具和配置文件。容器运行时（如Docker、Podman）负责管理和运行这些容器镜像。**

- 容器虚拟化中，**容器没有自己的操作系统（OS），直接共享宿主机的内核，也没有hypervisor这一层进行资源隔离和限制，因此对容器的控制都是操作系统本身去控制的。**

- **容器只是运行在宿主机上的一种特殊的进程**，多个容器之间使用的还是同一个宿主机的操作系统内核。

  ![VM6](.\images\VM6.png)

- 容器彻底改变了 IT 和软件的开发。 它们允许**将软件和文件打包成独立的包（称为“容器映像”）**，这些包可在不同计算机（真实计算机或虚拟机）上运行，并且以**一致且可预测的方式执行**此操作。 以下描述引自 Docker 网站：
- “容器是一个标准的软件单元，它**将代码及其所有依赖项打包**，从而**使应用程序能够快速、可靠地从一个计算环境运行到另一个计算环境**。 Docker 容器映像是轻型、独立的可执行软件包，其中包括运行应用程序所需的一切内容：代码、运行时、系统工具、系统库和设置。”
- 容器化解决了软件开发过程中一个令人非常头疼的问题：开发人员编写代码，在自己本地环境测试完成后，将代码部署到测试或生产环境中，经常会遇到各种各样的问题。明明本地完美运行的代码为什么部署后出现很多 bug，原因有很多：**不同的操作系统、不同的依赖库等，总结一句话就是因为本地环境和远程环境不一致**。
- **容器化技术正好解决了这一关键问题，它将软件程序和运行的基础环境分开。开发人员编码完成后将程序打包到一个容器镜像中，镜像中详细列出了所依赖的环境，在不同的容器中运行标准化的镜像，从根本上解决了环境不一致的问题。**

#### 4.容器的应用场景

- **微服务架构**：容器非常适合微服务架构，每个微服务可以运行在独立的容器中，具有高扩展性和灵活性。通过容器编排工具（如Kubernetes），可以实现自动化的部署、扩展和管理。
- **持续集成/持续部署（CI/CD）**：容器的快速启动和一致性特性，使其成为CI/CD流程中的理想选择。开发人员可以使用容器创建一致的开发和测试环境，确保代码在各个环境中的一致性。
- **跨平台部署**：容器化应用可以在不同的环境中一致运行，无论是开发、测试还是生产环境。这使得跨平台部署变得更加简单和可靠。

#### 5.容器的优点

- **轻量级**：容器不需要虚拟化整个操作系统，资源利用率高，启动速度快。
- **一致性**：由于容器镜像包含了所有依赖项，确保应用程序在不同环境中（开发、测试、生产）运行的一致性
- **易于部署和扩展**：容器可以很容易地复制、分发和部署，特别适合微服务架构和持续集成/持续部署（CI/CD）流程。
- **支持快速扩展**：由于容器的轻量级特性，可以快速启动和销毁，支持应用程序的弹性扩展。

#### 6.容器的缺点

- **隔离性不如虚拟机**：容器共享宿主操作系统的内核，隔离性较虚拟机弱，可能存在安全风险。
- **依赖宿主操作系统**：容器必须与宿主操作系统的内核兼容，限制了操作系统的多样性。
- **管理复杂性**：容器的快速启动和销毁虽然带来了灵活性，但也增加了管理的复杂性，尤其是在大规模容器集群中。

#### 7.Docker

**（1）什么是docker?**

- **Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。
- **Docker必须部署在Linux内核的系统上，如果其他系统（比如：Windows、macOS）想部署Docker就必须安装一个虚拟Linux环境。**
  
  - 比如在Windows上部署Docker的方法都是先安装一个虚拟机，并在安装Linux系统的虚拟机中运行Docker。
- Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。
- 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

- docker是一种容器化技术的落地。是基于容器技术的轻量级虚拟化解决方案。

- **docker本身并不是容器，它是创建容器的工具，是应用容器引擎。**

- docker本质上是一个进程，使用go语言开发的一个工具。

- 通常，Docker 容器镜像必须为特定的平台构建。例如 Windows 容器不能在 Linux 上运行，反之亦然；以前，绕过此限制的一种方法是启动运行所需操作系统实例的虚拟机，并在虚拟机中运行容器。
   然而 Docker 团队后来设计了一个更优雅的解决方案，称为 **manifest**，它允许多个操作系统的镜像并行打包。尽管 manifest 还处于试验阶段，但这暗示了容器可能成为跨平台应用程序解决方案和跨环境应用程序解决方案。

- ![VM8](.\images\VM8.png)

  ![VM9](.\images\VM9.png)



**（2）Docker的基本组成**

- Docker的三大组成部分为：镜像（image）、容器（container）、仓库（repository）

- **镜像**

  - 是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。

  - **镜像不包含任何动态数据，其内容在构建之后也不会改变**

  - 只有通过这个镜像文件才能生成Docker容器实例（docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。）

  - Docker 镜像（Image）就是一个**只读**的模板。镜像可以用来创建 Docker 容器，**一个镜像可以创建很多容器。**

  - **镜像可以通过Dockerfile定义，在运行容器前需要编写 Docker File，通过 Dockerfile生成镜像，然后才能运行 Docker 容器。**

  - Docker File 定义了运行镜像（**image**）所需的所有内容，包括操作系统和软件安装位置。一般情况下都不需要从头开始编写 Docker File，在 Docker Hub 中有来自世界各地的工程师编写好的镜像，你可以基于此修改。

  - **镜像加载原理**

    - **UnionFS**

      - UnionFS（联合文件系统）: 是一种分层轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同的目录挂载到同一个虚拟文件系统下。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。
      - 我们在下载的时候看到一层层的就是用的UnionFS
      - 最大层数127
      - 特性：一次同时加载多个文件系统，但从外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录

    - **镜像如何加载**

      - docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。最低层是一个引导文件系统，即bootfs。Docker镜像的第二层(由下而上数)是root文件系统rootfs也就是我们称为的base image基础镜像，它位于引导文件系统上。
      - `boots`(`boot file system`）主要包含 `bootloader`和 `Kernel`, `bootloader`主要是引导加 `kernel`, `Linux`刚启动时会加`bootfs`文件系统，在 `Docker`镜像的最底层是 `boots`。这一层与我们典型的`Linux/Unix`系统是一样的，包含`boot`加載器和内核。当`boot`加载完成之后整个内核就都在内存中了，此时内存的使用权已由 `bootfs`转交给内核，此时系统也会卸载`bootfs`。
      - `rootfs`（`root file system`),在 `bootfs`之上。包含的就是典型 `Linux`系统中的`/dev`,`/proc`,`/bin`,`/etc`等标准目录和文件。 `rootfs`就是各种不同的操作系统发行版，比如 `Ubuntu`, `Centos`等等。

    - **分层理解**

      - 我们在下载镜像的过程中，发现是一层一层的下载，为什么`Docker`镜像要采用这种分层结构？

      - 最大的好处，应该**资源共享**了！比如有多个镜像都从相同的基础镜像构建而来，那么只需在磁盘上保留一份基础镜像，同时内存中也只需要加载一份基础镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。

      - 所有的 `Docker`镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。

        - 举一个简单的例子，假如基于 `Ubuntu Linux16.04`创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 `Python`包， 就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含`3`个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。

          ![VM11](.\images\VM11.png)

        

        - **在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。**

    - **Docker镜像层都是只读的，容器层是可写的。**

      - 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作‘容器层’，‘容器层’之下的都叫‘镜像层’。
      - 所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。

- **容器**

  - **容器是用镜像创建的运行实例，容器就类似于一个虚拟化的运行环境。**就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。
  - 容器是在隔离的环境中运行的进程，具有自己的文件系统、网络空间和进程空间。
  - 容器可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台
  - 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。
  - **image 文件生成的容器实例，本身也是一个文件，称为容器文件。**也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。

- **仓库**

  - Docker仓库是用于存储和分享Docker镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。类似于：
    - Maven仓库，存放各种jar包的地方；
    - github仓库，存放各种git项目的地方；
    - Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。
  - 最常用的是Docker Hub，它是一个公共的镜像仓库，包含了大量的官方和社区维护的镜像。除了公共仓库，还可以搭建私有的Docker仓库，用于存储和分享自定义的镜像。国内的公开仓库包括阿里云 、网易云等

![VM10](.\images\VM10.png)

#### 8. K8s(Kubernetes)—容器编排系统

**（1）K8s出现的原因**

- 尽管 Docker 为容器化的应用程序提供了开放标准，但随着容器越来越多出现了一系列新问题：
  - 如何**协调、调度和管理**这些容器？
  - 如何在升级应用程序时**不中断服务**？
  - 如何**监视**应用程序的运行状况？
  - 如何批量重新启动容器里的程序？
- 解决这些问题需要容器编排技术，可以将众多机器抽象，对外呈现出一台超大机器。现在业界比较流行的有：**k8s**、Mesos、**Docker Swarm**。
- 在业务发展初期只有几个微服务，这时用 Docker 就足够了，但随着业务规模逐渐扩大，容器越来越多，运维人员的工作越来越复杂，这个时候就需要编排系统解救 opers。

**（2）Kubernetes与Docker的关系**

- Kubernetes与Docker之间的关系可以说是相辅相成的。**Docker为Kubernetes提供了强大的容器运行时环境，而Kubernetes则为Docker容器提供了自动化管理和编排的能力。**简而言之，**Docker解决了应用程序的打包和运行问题，而Kubernetes解决了应用程序的分布式管理和扩展问题**。
- Docker是Kubernetes中默认的容器运行时技术，但Kubernetes同时支持其他容器运行时，如containerd和CRI-O。这种灵活性使得Kubernetes能够满足不同用户的需求。相辅相成的关系使得Kubernetes和Docker在构建现代微服务架构方面具有优势。
- **Docker 是用于构建、分发、运行（Build, Ship and Run）容器的平台和工具。**
- **而 k8s 实际上是一个使用 Docker 容器进行编排的系统，主要围绕 pods 进行工作。Pods 是 k8s 生态中最小的调度单位，可以包含一个或多个容器。**
- Docker 和 k8s 是根本上不同的技术，两者可以很好的协同工作

**（3）k8s架构和组件**

- k8s 由众多组件组成，组件间通过 API 互相通信，归纳起来主要分为三个部分：

  - controller manager
  - nodes
  - pods

- **k8s 集群架构图**：

  ![k8s1](.\images\k8s1.png)

  - **Controller Manager**，即控制平面，用于**调度**程序以及节点状态**检测**。
  - **Nodes**，构成了 Kubernetes 集群的集体计算能力，**实际部署容器运行的地方**。
  - **Pods**，Kubernetes 集群中**资源的最小单位**。

- 下图是 **Kubernetes 集成 Jenkins 实现 CICD**（一图胜千言，需要对其有一个大致的认识）：

  ![k8s2](.\images\k8s2.png)

**（4）Kubernetes与Docker在微服务架构中的应用**

- **应用部署**
  - 通过Docker容器化技术，我们可以将应用程序及其依赖项打包到一个容器中，保证应用程序在不同环境中的一致性。Kubernetes作为编排平台，可以自动化地部署、管理和扩展这些容器，满足应用程序在不同场景下的需求。
- **服务发现与负载均衡**
  - Kubernetes提供了服务发现和负载均衡功能，**可以自动地将请求分发到不同的容器实例，从而实现高可用性和高性能**。此外，Kubernetes还支持基于应用程序性能和资源需求的自动扩缩容，进一步优化了系统的响应能力。
- **容错与故障恢复**
  - Kubernetes具有自我修复能力，**当某个容器实例出现故障时，Kubernetes会自动重新调度并启动一个新的实例来替换故障实例**。这样的设计可以保证微服务应用的高可用性和故障容忍能力。
- **系统监控与日志管理**
  - Kubernetes集成了一系列系统监控和日志管理工具，如Prometheus和ELK Stack，可以帮助开发者和运维人员实时监控容器和应用程序的性能、资源消耗和日志，从而快速定位和解决问题。

**（5）相关问题**

- 为什么要用k8s？没有k8s可以使用docker吗？
  - 可以。实际上一些小型公司，在业务不太复杂的情况下都是直接使用 Docker。尽管 k8s 有很多好处，但是众所周知它非常复杂，业务比较简单可以放弃使用 k8s。但 k8s 在业务达到一定规模后也得启用！
- 没有Docker可以使用k8s吗？
  - k8s是容器编排工具，必须有容器。k8s 经常与 Docker 进行搭配使用，但是也可以使用其他容器，如 RunC、Containerted 等。

## 四、容器与虚拟机

- 容器与虚拟机相似，因为它们都**提供了可以在其中运行软件的可预测且隔离的环境**。
- **容器和虚拟机并不互斥**。 实际上，它们经常一起使用。 如果 Windows 用户运行在 Linux 容器中打包的软件，则可在 VM 中运行 Linux，并在 VM 中承载 Docker 和容器化软件。 在云中，容器与其他云工作负载一样承载在 VM 中。
- 容器并不能替代虚拟机，它们两者也不应被视为功能相等。 与虚拟机不同，**容器不允许在同一计算机上并行运行多个操作系统**。 例如，如果主机运行 Linux，则该计算机上的所有容器也必须使用 Linux。 （Windows 用户经常在 Windows 上运行 Linux 容器，但这是可行的，因为 Docker 在 Windows 计算机上运行 Linux VM 并在 VM 中承载容器。）此外，由于容器不会对硬件进行虚拟化，因此不适用于执行涉及直接硬件交互的系统级任务的应用程序。 一种简单的思路是，虚拟机监控程序对整个计算机（包括其硬件）进行虚拟化，而容器对软件进行虚拟化并使用主机的操作系统作为操作系统平台。

![VM6](.\images\VM7.png)                      

**（1） 架构**

- **容器**：容器是一种**应用级或操作系统级**的虚拟化技术。它们**共享宿主操作系统的内核，但各自拥有独立的用户空间**。容器通过操作系统的虚拟化功能，如命名空间（Namespace）和控制组（Cgroups），实现资源的隔离和限制。容器中的每个应用程序都运行在与宿主操作系统共享的内核上，因此不需要独立的操作系统。
- **虚拟机**：虚拟机是一种**基础架构级或硬件级**的虚拟化技术。每个虚拟机都有自己**独立的操作系统内核、文件系统和内存分配**。虚拟机通过虚拟机监控器（Hypervisor）在物理硬件之上运行，虚拟机监控器负责将物理资源划分为多个虚拟实例，并为每个虚拟机提供独立的硬件虚拟化。

**（2）性能**

- **容器**：由于容器共享宿主操作系统的内核，减少了虚拟化层的开销，因此它们通常比虚拟机性能更好。容器通过直接利用宿主操作系统的资源，降低了资源消耗和延迟，从而提升了整体性能。
- **虚拟机**：虚拟机由于需要运行一个完整的客操作系统，同时管理虚拟化层的开销，其性能通常低于容器。虚拟机监控器在分配和管理资源时会引入额外的开销，导致资源利用率相对较低。

**（3）资源利用率**

- **容器**：容器通过直接利用宿主的资源，提供了更高效的资源利用率。由于容器不需要独立的操作系统，它们可以在更少的资源下运行多个实例，从而提高计算资源的利用效率。
- **虚拟机**：虚拟机需要为每个实例分配独立的资源，包括操作系统所需的CPU、内存和存储空间。由于每个虚拟机都运行在独立的操作系统上，资源利用率相对较低。

**（4）延迟**

- **容器**：容器由于能够**直接访问宿主硬件，并且不需要通过虚拟化层**，因此具有较低的延迟。这使得容器特别适合需要高性能和低延迟的应用程序。
- **虚拟机**：虚拟机引入了额外的虚拟化层，**需要通过虚拟机监控器来访问物理硬件**。这种额外的开销导致虚拟机的延迟相对较高。

**（5）启动时间**

- **容器**：容器的启动时间通常非常短，接近即时。因为**容器不需要启动完整的操作系统**，它们可以在几秒钟内启动并开始运行应用程序。这种快速启动特性使得容器非常适合需要快速部署和扩展的应用场景。
- **虚拟机**：虚拟机的启动时间较长，因为它们**需要加载和启动一个完整的操作系统**。通常，启动一个虚拟机需要几分钟的时间，这在需要频繁启动和关闭实例的场景中可能成为一种劣势。

**（6）隔离性**

- **容器**：容器使用操作系统级的隔离，通过命名空间和控制组来隔离不同的容器。然而，由于**容器共享宿主操作系统的内核，其隔离性不如虚拟机强**。这种隔离性不足可能带来一定的安全风险，尤其是在多租户环境中。
- **虚拟机**：虚拟机提供了**完整的隔离性**，因为每个虚拟机都运行在独立的虚拟机监控器上，并拥有自己的操作系统内核。这种**硬件级的隔离确保了虚拟机之间的完全独立**，即使一个虚拟机被攻破，也不会影响其他虚拟机。

**（7）可移植性**

- **容器**：容器具有高度的可移植性，可以在不同的系统上保持一致的行为。**容器镜像包含了应用程序的所有依赖项**，因此无论在**开发、测试还是生产环境中，容器化的应用程序都可以一致运行**。
- **虚拟机**：虚拟机的可移植性相对较低，因为它们**依赖于特定的硬件和操作系统配置**。将虚拟机从一个环境迁移到另一个环境时，可能需要进行**配置调整**，以确保虚拟机能够正常运行。

**（8）安全性**

- **容器**：由于容器共享宿主操作系统的内核，其**安全性依赖于宿主操作系统的安全性**。尽管容器运行时（如Docker、Podman）提供了一些安全功能（如命名空间和控制组），但容器的安全性通常低于虚拟机。**共享内核的设计**使得容器在某些情况下更容易受到攻击。
- **虚拟机**：虚拟机的安全性较高，因为每个虚拟机运行在**独立的操作系统**上，具有**强隔离性**。这种隔离性确保了即使一个虚拟机遭到攻击，其他虚拟机和宿主系统仍然保持安全。

**（9）灵活性**

- **容器**：容器在资源分配和扩展方面具有更大的灵活性。由于**容器轻量级且启动迅速**，它们可以轻松地进行动态扩展和缩减，以应对不同的负载需求。容器编排工具（如Kubernetes）进一步增强了这种灵活性，使得容器能够在大规模集群中自动化管理。
- **虚拟机**：虚拟机的灵活性较低，因为它们**需要固定的资源分配**。更改虚拟机的资源配置通常需要重新启动虚拟机，或对其配置进行手动调整。这使得虚拟机在处理动态负载变化时不如容器灵活。

**（10） 密度**

- **容器**：由于容器的轻量级特性，它们可以在一台宿主机上以更高的密度部署。多个容器可以**共享同一套资源**，而不会相互干扰，从而实现更高的资源利用率。
- **虚拟机**：虚拟机由于需要**独立的操作系统和更多的资源开销**，其密度通常低于容器。在同样的**硬件配置**下，能够运行的虚拟机数量往往少于容器。

**（11）效率**

- **容器**：容器在存储和内存利用率方面更加高效。由于容器**不需要独立的操作系统**，它们可以**在更少的存储和内存资源下运行多个实例**，特别适合大规模部署。
- **虚拟机**：虚拟机需**要为每个实例分配额外的存储和内存资源**，因为每个虚拟机都包含一个**完整的操作系统**。这种资源开销使得虚拟机的效率相对较低。

**（12）部署复杂性**

- **容器**：容器的部署过程相对简单。通过**容器镜像，应用程序及其依赖项可以被打包成一个独立的单元**，便于分发和部署。容器编排工具进一步简化了容器的管理，使得大规模部署更加容易。
- **虚拟机**：虚拟机的部署过程相对复杂，**需要配置和管理独立的操作系统。每个虚拟机实例都需要进行操作系统安装、配置和优化**，这使得虚拟机的部署和维护更加费时费力。

**（13） 使用场景**

- **容器**：容器非常适合**微服务架构、持续集成/持续部署（CI/CD）流程、应用程序的快速扩展和管理分布式系统**。在这些场景中，容器的**轻量级、快速启动和高密度特性**发挥了重要作用。
- **虚拟机**：虚拟机通常用于**运行遗留应用程序、测试不同的操作系统、创建隔离的操作系统环境以及开发沙箱**。虚拟机**强大的隔离性和多操作系统支持**，使其在需要高安全性和多样化操作系统的场景中具有优势。

## 五、CI/CD

#### 1.什么是CI/CD?

- CI/CD是 `Continuous Integration` 和 `Continuous Deployment` 的缩写，是一种软件开发流程。

- CI/CD的主要思想是通过自动化的工具，频繁地把代码从开发环境持续集成到测试环境和生产环境，以实现快速反馈和持续交付。在前端项目中，通常会实现以下步骤：

  - 在代码提交到版本库后，触发自动构建和测试。

  - 通过自动化测试工具检测代码质量，确保代码符合要求。

  - 在代码通过测试后，自动发布到生产环境。

- CI/CD 可拆解为 CI 和 CD，其中 CI 为持续集成，CD 为持续交付与持续部署。CI/CD 是一种通过在应用开发阶段引入[自动化](https://link.juejin.cn?target=https%3A%2F%2Fwww.redhat.com%2Fzh%2Ftopics%2Fautomation%2Fwhats-it-automation)来频繁向客户交付应用的方法。

  - Continuous Integration (CI) 【持续集成】

    - 现代应用开发的目标是让**多位开发人员同时处理同一应用的不同功能**。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为“合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE)，而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜。

    - **持续集成（CI）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或“主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。**这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。

      

  - Continuous Delivery (CD) 【持续交付】

    - 完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。**持续交付的目标是拥有一个可随时部署到生产环境的代码库。**
    - 在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。

  - Continuous Deployment (CD)【持续部署】

    - 对于一个成熟的 CI/CD 管道来说，最后的阶段是持续部署，指的是代码在通过所有测试后自动部署到生产环境，几乎不需要人为干预。