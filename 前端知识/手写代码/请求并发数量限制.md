#### **定义请求池主函数函数**

```javascript
export const handQueue = (  
  reqs // 请求数量
) => {}
```

接受一个参数`reqs`，它是一个数组，包含需要发送的请求。函数的主要目的是对这些请求进行队列管理，确保并发请求的数量不会超过设定的上限。

#### **定义dequeue函数**

```scss
const dequeue = () => {  
  while (current < concurrency && queue.length) {  
    current++;  
    const requestPromiseFactory = queue.shift() // 出列  
    requestPromiseFactory()  
      .then(() => { // 成功的请求逻辑  
      })  
      .catch(error => { // 失败  
        console.log(error)  
      })  
      .finally(() => {  
        current--  
        dequeue()  
      });  
  }  
}
```

这个函数用于从请求池中取出请求并发送。它在一个循环中运行，直到当前并发请求数`current`达到最大并发数`concurrency`或请求池`queue`为空。对于每个出队的请求，它首先增加`current`的值，然后调用请求函数`requestPromiseFactory`来发送请求。当请求完成（无论成功还是失败）后，它会减少`current`的值并再次调用`dequeue`，以便处理下一个请求。

#### **定义返回请求入队函数**

```scss
return (requestPromiseFactory) => {  
  queue.push(requestPromiseFactory) // 入队  
  dequeue()  
}
```

函数返回一个函数，这个函数接受一个参数`requestPromiseFactory`，表示一个返回Promise的请求工厂函数。这个返回的函数将请求工厂函数加入请求池`queue`，并调用`dequeue`来尝试发送新的请求，当然也可以自定义axios，利用`Promise.all`统一处理返回后的结果。

#### 整合代码

```javascript
import axios from 'axios'

export const handQueue = (
  reqs // 请求总数
) => {
  reqs = reqs || []


  const requestQueue = (concurrency) => {
    concurrency = concurrency || 6 // 最大并发数
    const queue = [] // 请求池
    let current = 0

    const dequeue = () => {
      while (current < concurrency && queue.length) {
        current++;
        const requestPromiseFactory = queue.shift() // 出列
        requestPromiseFactory()
          .then(() => { // 成功的请求逻辑
          })
          .catch(error => { // 失败
            console.log(error)
          })
          .finally(() => {
            current--
            dequeue()
          });
      }

    }

    return (requestPromiseFactory) => {
      queue.push(requestPromiseFactory) // 入队
      dequeue()
    }

  }

  const enqueue = requestQueue(6)

  for (let i = 0; i < reqs.length; i++) {

    enqueue(() => axios.get('/api/test' + i))
  }
}
```

