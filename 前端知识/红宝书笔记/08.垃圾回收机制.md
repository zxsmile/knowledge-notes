### 十、垃圾回收机制 ###

#### 1. 内存的生命周期

- **内存分配**：当我们声明变量，对象，函数的时候，系统会自动为他们分配内存（申请）；

- **内存使用**：即读写内存，使用分配的内存（存放一些东西，比如对象等）；

- **内存回收**：使用完毕，由垃圾回收器自动回收不使用的内存，（释放内存）；

- **全局变量一般不会回收（关闭页面回收）**

- **一般情况下局部变量的值，不用了，会被自动回收**

  	//为变量分配内存
  	const age = 18;
  	
  	//为对象分配内存
  	const obj = {
  	  name: '小明',
  	  age: 18,
  	};
  	
  	//为函数分配内存
  	function fn (){
  	 
  	    //局部变量的值，在函数调用完后，不使用就会被自动回收
  	    const age = 18;
  	    console.log(age);
  	}
  	fn()

​		

#### 2. 垃圾回收机制的对象

- 基本类型存放在栈中，引用类型存放在堆中。javascript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。

- 在JavaScript中，垃圾回收机制不仅适用于引用类型（如对象、数组等），也适用于基本类型（如Number、String、Boolean等）。基本类型的值通常存储在栈内存中，这些值的大小是固定的，因此它们的生命周期相对简单。当基本类型的变量不再被使用时，它们所占用的内存会被自动回收。这是因为JavaScript的内存管理机制会自动分配和释放内存，包括基本类型和引用类型的内存。

- **垃圾回收机制的核心目的是防止内存泄漏**，即确保不再使用的内存能够被释放，避免程序因占用过多内存而导致性能下降或崩溃。

- 对于基本类型，由于其生命周期相对简单（即声明后立即存在，直到变量作用域结束或变量被显式删除），因此它们的内存管理相对直接。

- 而对于引用类型，如对象、数组等，垃圾回收机制通过更复杂的算法（如标记清除和引用计数）来管理内存，确保只有当这些引用类型完全不再被引用时，它们的内存才会被回收‌。

- 总的来说，无论是基本类型还是引用类型，JavaScript的垃圾回收机制都确保了内存的有效管理，防止了内存泄漏的发生，从而保证了程序的稳定运行和性能优化。

#### 3. 全停顿

- 在介绍垃圾回收算法之前，我们先了解一下「**全停顿**」。垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「**全停顿**」（`Stop The World`）。例如，如果一次GC需要50ms，应用逻辑就会暂停50ms。

- **全停顿的目的，是为了解决应用逻辑与垃圾回收器看到的情况不一致的问题。**
  - 举个例子，在自助餐厅吃饭，高高兴兴地取完食物回来时，结果发现自己餐具被服务员收走了。这里，服务员好比垃圾回收器，餐具就像是分配的对象，我们就是应用逻辑。在我们看来，只是将餐具临时放在桌上，但是服务员看来觉得你已经不需要使用了，因此就收走了。你与服务员对于同一个事物看到的情况是不一致，导致服务员做了与我们不期望的事情。因此，为避免应用逻辑与垃圾回收器看到的情况不一致，垃圾回收算法在执行时，需要停止应用逻辑。

#### 4.垃圾回收(GC)算法

（1）**引用计数法**

   - 设置引用数，判断当前引用数是否为0，如果为0则是垃圾对象，就会被垃圾回收器回收。

   - 语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数，这也算是引用计数算法的一个缺点，就是我们需要单独拿出一片空间去维护每个变量的引用计数，这对于比较大的程序，空间开销还是比较大的。

   - 具体流程：
     - 设置引用计数器
     - 当对象的引用关系发生变化时，引用计数器就会修改引用数字
     - 当引用数字为 0 时，立即回收

     - 优点：
     - 发现垃圾时，**立即回收**
     - 最大限度减少程序暂停，当发现内存即将到达临界点时，就开始进行引用计数清除，即空间不会被占满

     - 缺点：
     - 无法回收循环引用的对象
     - 时间复杂度比较高
     - 资源消耗比较大，会对所有对象进行数值的监控和修改，本身就会占用时间和资源


（2）**标记清除法**

   - 标记清除法其实就是可达性测试，垃圾回收器从根集合出发，检查所有的根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。

   - 根节点：一般来说，根是代码中引用的全局变量。例如，在 JavaScript 中，可以充当根节点的全局变量是“window”对象。Node.js 中的全局对象被称为“global”，兼容写法：可以使用最新的 ( globalThis ) 代替两者，实现两种环境的兼容。完整的根节点列表由垃圾收集器构建。

   - 标记清除分为标记阶段和清除阶段

     - 标记阶段：标记清除其实就是可达性（对象是否可访问）测试，垃圾回收器从根集合出发，检查所有的根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。

     - 清除阶段：从根节点开始遍历堆，垃圾收集器释放所有未被标记为活跃的内存块，并将这些内存返回给操作系统

      - 优点：
      - 解决**循环引用**的问题

      - 缺点：
      - **不会立即回收垃圾对象**，即使发现了垃圾对象，也必须遍历完后才进行清除，清除时程序停止工作产生卡顿

      - 产生**空间碎片化**，即链表地址不连续


（3）**标记整理**

   - 为了解决内存碎片化的问题，提高对内存的利用，引入了标记整理算法。

   - 标记整理可以看做是标记清除的**增强**。标记阶段的操作和标记清除一致。

   - 清除阶段会先执行整理，移动对象位置,将存活的对象移动到一边，然后再清理端边界外的内存。（在标记和清除中间，还添加了内存空间的整理）

   - 具体流程：
     - 标记阶段：递归遍历，对可达对象可达对象即活动对象做标记

     - 整理阶段：清除前先进行整理，移动对象位置，让地址产生连续

     - 清除阶段：递归遍历，清除未标记的对象未标记的对象即非活动对象

     - 优点：

     - 比标记清除法过程多了对碎片化空间的整理，即会有较少碎片空间 

     - 标记 -> 整理碎片化空间 -> 清除

     - 缺点：和标记清除法一样，不会立即清除垃圾对象，清除时程序仍然是暂停的，多了移动对象位置过程，回收的效率比较慢。


（4）**增量标记**

   - 为了减少**全停顿**的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。

   - 长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将**全暂停标记**换成了**增量标记**。改进后的标记方式，最大停顿时间减少到原来的1/6。

#### 5. v8引擎垃圾回收策略---分代式垃圾回收

- 垃圾回收策略主要有标记清除和引用计数，**现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化**

（1）**介绍**

- 采用分代回收的思想，内存分为新生代、老生代；
- 针对不同对象采用不同算法：

  - 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
  - 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。
- **V8堆的空间等于新生代空间加上老生代空间，且针对不同的操作系统对空间做了内存的限制。**
- 针对浏览器来说，这样的内存是足够使用的。限制内存的原因：
  - **首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停。**
  - **另一方面垃圾回收其实是非常耗时间的操作，在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。针对浏览器的GC机制，经过不断的测试，如果内存再设置大一点，`GC`回收的时间就会达到用户的感知，会造成感知上的卡顿。**

（2） **回收新生代对象**

- 回收新生代对象主要采用**Scavenge 算法加标记整理算法**。而Scavenge 算法的具体实现，主要采用了Cheney算法。**回收器策略：并行回收**

- Cheney算法 中将堆内存一分为二（两个等大空间），一个是处于使用状态的空间我们暂且称之为使用区(from)，一个是处于闲置状态的空间我们称之为空闲区(to)。如下图所示：

![GC2](D:\knowledge-notes\前端知识\js\images\GC2.jpg)


- 新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。

- 当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。

- **新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。**

- 发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况**触发晋升**:

  - 已经经历过一次 Scavenge 回收（一轮GC还存活的新生代需要晋升）。

  - 当对象从使用区空间复制到空闲区空间时，空闲区空间的内存占用超过25%,设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。

- 不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

（3） **回收老生代对象**

  - 回收老生代对象主要采用**标记清除、标记整理、增量标记算法，主要使用标记清除算法，只有在内存分配不足时，采用标记整理算法。**

   - 首先使用标记清除完成垃圾空间的回收；
   - 采用标记整理进行空间优化；
   - 采用增量标记进行效率优化；


 **Orinoco优化**

 - orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。

#### 6.内存泄露（虽然有垃圾回收机制，但我们编写代码操作不当还是会造成内存泄露。）

- 内存泄漏指应用程序已经不再需要的内存，由于某种原因，未释放或无法释放

- 内存泄露可能带来的问题：变慢、卡顿、高延迟。

- **常见的内存泄露情况**

（1）**意外的**全局变量

  - 在js中，一个未声明变量的使用，会在全局对象中创建一个新的变量；在浏览器环境下，全局对象就是
      	

    	window：
    	
    	   function  data() {
    		     a = 'test'
    		}	
    		
    		// 上面的写法等价于
    		function data() {
    		     window.a = 'test'
    		}
    		
    	    function data() {

  	       this.a = 'test'
  	        // 函数自身发生调用，this指向全局对象window
  	    }
  	    data();

  - 上面的a变量应该是data()内部作用域变量的引用，由于没有使用关键词（let、const、var）来声明这个变量，这时变量a就被创建成了全局变量，这时候就会导致内存泄漏。

- **解决方式：使用var、let、const来定义变量，或者在js文件开头添加'use strict'，开启严格模式**

（2）**定时器**

  - 定时器setInterval或者setTimeout在不需要使用的时候，没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。另外，浏览器中的requestAnimationFrame也存在这个问题，在不需要的时候用cancelAnimationFrame来取消使用。

    ```
    var someResource = getData();
    	setInterval(function() {
    	    var node = document.getElementById('Node');
    	    if(node) {
    	        // 处理 node 和 someResource
    	        node.innerHTML = JSON.stringify(someResource));
    	    }
    	}, 1000);
    ```

      - 上例中，如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放。

- **解决方式：当不需要interval或者timeout的时候，调用clearInterval或者clearTimeout。**

（3）**没有清理对DOM元素的引用同样造成内存泄露**

		const refA = document.getElementById('refA');
		document.body.removeChild(refA); // dom删除了
		console.log(refA, 'refA'); // 但是还存在引用能console出整个div 没有被回收
		refA = null;
		console.log(refA, 'refA'); // 解除引用

-  **解决方式：refA = null；包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听。**


（4）**闭包**

  - 闭包是指有权访问另一个**函数作用域**的变量的**函数**

  - 闭包的本质就是**当前函数作用域**存在指向**父级函数作用域**的引用

  - 闭包 = 函数 + 函数能够访问的自由变量

  - 自由变量是指在函数中使用的，但既不是当前函数参数也不是当前函数的局部变量的变量。

  **个人理解：函数+函数的原因是，全局作用域本身就是关闭页面才会被释放，而函数作用域是函数执行完就应该被释放，由于子函数的引用导致没被释放，就形成了闭包。**

	   function fn(){
	    let result = {}
	    return function(){
	        //因为闭包内i你用了result，导致它不会被垃圾机制回收，导致内存泄露
	        return result
	    }
	   }
	   let fn1 = fn()
	   fn1()

- **解决方式：上面代码可以直接通过将fn1置为null来清除引用，也可以少用闭包的方式**


（5）**循环引用**

  - 循环引用在引用计数策略下会导致内存泄露，标记清除不会。

    ```
    function fn() {
      const o1 = {}
      const o2 = {}
      o1.p = o2
      o2.p  = o1
    }
    
    fn()
    ```

    - a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境。在标记清除方式下是没有问题的，但在引用计数策略下，a和b的引用次数为1不为0，不会被垃圾回收器回收内存。如果fn函数被大量调用，就会造成内存泄露，这时候就需要手动解除引用（置为null）

​      **解决方式：不使用的时候手动清除：o1.p = null o2.p = null**

（6）**未清理的console**

  - 如果在console中输出了对象，那么浏览器就需要把这个引用关系保存下来，才能在控制台上看到相应的对象，这样同样也会造成内存泄露。

  **解决方式：清除或者注释掉console.log()**

（7）**事件监听器**

- 活动事件侦听器将**防止在其范围内捕获的所有变量被垃圾收集。添加后，事件侦听器将一直有效，直到：**

  - **使用 removeEventListener() 显式删除**

  - **关联的 DOM 元素被移除**

- 对于某些类型的事件，它会一直保留到用户离开页面，就像应该多次单击的按钮一样。但是，有时我们希望事件侦听器执行一定次数。

  ```
  const hugeString = new Array(100000).join('x');
  
  document.addEventListener('keyup', function() { // 匿名内联函数，无法删除它
    doSomething(hugeString); // hugeString 将永远保留在回调的范围内
  });
  ```

  

- 在上面的示例中，匿名内联函数用作事件侦听器，这意味着不能使用 removeEventListener() 删除它。同样，document 不能被删除，因此只能使用 listener 函数以及它在其范围内保留的内容，即使只需要启动一次。

- 那该如何防止这个问题呢？**一旦不再需要，我们应该通过创建指向事件侦听器的引用并将其传递给 removeEventListener() 来注销事件侦听器。**

  ```
  function listener() {
    doSomething(hugeString);
  }
  
  document.addEventListener('keyup', listener); 
  document.removeEventListener('keyup', listener);
  ```

- 如果事件侦听器只能执行一次，addEventListener() 可以接受第三个参数，这是一个提供附加选项的对象。假定将 {once:true} 作为第三个参数传递给 addEventListener() ，则侦听器函数将在处理一次事件后自动删除

  ```
  document.addEventListener('keyup', function listener() {
    doSomething(hugeString);
  }, {once: true}); 
  ```

  


（8）**缓存**

- 如果我们不断地将内存添加到缓存中，而不删除未使用的对象，并且没有一些限制大小的逻辑，那么缓存可以无限增长。

  	let user_1 = { name: "Peter", id: 12345 };
  	let user_2 = { name: "Mark", id: 54321 };
  	const mapCache = new Map();
  	
  	function cache(obj){
  	  if (!mapCache.has(obj)){
  	    const value = `${obj.name} has an id of ${obj.id}`;
  	    mapCache.set(obj, value);
  	
  	    return [value, 'computed'];
  	  }
  	
  	  return [mapCache.get(obj), 'cached'];
  	}
  	
  	cache(user_1); // ['Peter has an id of 12345', 'computed']
  	cache(user_1); // ['Peter has an id of 12345', 'cached']
  	cache(user_2); // ['Mark has an id of 54321', 'computed']
  	
  	console.log(mapCache); // {{…} => 'Peter has an id of 12345', {…} => 'Mark has an id of 54321'}
  	user_1 = null;
  	
  	console.log(mapCache); // {{…} => 'Peter has an id of 12345', {…} => 'Mark has an id of 54321'}

- 在上面的示例中，缓存仍然保留 user_1 对象。因此，我们需要将那些永远不会被重用的变量从缓存中清除。

- **可以使用 WeakMap 来解决此问题。它是一种具有弱键引用的数据结构，仅接受对象作为键。如果我们使用一个对象作为键，并且它是对该对象的唯一引用——相关变量将从缓存中删除并被垃圾收集。**在以下示例中，将 user_1 对象清空后，相关变量会在下一次垃圾回收后自动从 WeakMap 中删除。

  	let user_1 = { name: "Peter", id: 12345 };
  	let user_2 = { name: "Mark", id: 54321 };
  	const weakMapCache = new WeakMap();
  	
  	function cache(obj){
  	  // ...
  	
  	  return [weakMapCache.get(obj), 'cached'];
  	}
  	
  	cache(user_1); // ['Peter has an id of 12345', 'computed']
  	cache(user_2); // ['Mark has an id of 54321', 'computed']
  	console.log(weakMapCache); // {(…) => "Peter has an id of 12345", (…) => "Mark has an id of 54321"}
  	user_1 = null;
  	
  	console.log(weakMapCache); // {(…) => "Mark has an id of 54321"}


####  ####