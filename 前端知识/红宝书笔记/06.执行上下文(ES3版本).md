### 一、执行上下文（ES3版本）

#### 1. 概念

- 执行上下文可以理解为函数运行的环境。每个函数执行时，都会给对应的函数创建这样一个执行环境。

- JS运行环境大概包括三种情况：全局环境、函数环境、eval环境（不推荐使用，所以不讨论）。

- 一个JS程序中，必定会产生多个执行上下文，JS引擎会以栈的方式处理它们，这个栈，我们称之为函数调用栈。

- 栈底永远都是全局上下文，栈顶就是当前正在执行的上下文。

- 由于栈是先进后出的结构，我们不难推出以下四点：

  - 只有栈顶的上下文处于执行中，其他上下文需要等待

  -  全局上下文只有唯一的一个，它在浏览器关闭时出栈

  - 函数的执行上下文的个数没有限制

  - 每次某个函数被调用，就会有个新的执行上下文为其创建。

#### 2. 执行上下文的生命周期

- 当调用一个函数时，一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段

（1）创建阶段

​          - 在这个阶段中，执行上下文会分别创建**变量对象，建立作用域链，以及确定this的指向**。

（2）代码执行阶段

​         - 创建完成之后，就会开始执行代码，这个时候，会完成**变量赋值，函数引用，以及执行其他代码**。

#### 3.变量对象(VO)

（1）当一个函数被调用时，执行上下文就创建了，执行上下文包含了函数所有声明的变量和函数，保存这些变量跟函数的对象，我们称之为变量对象。

（2） 变量对象的创建，依次经历了以下几个过程：

   - **建立arguments对象。**检查当前上下文中的参数，建立该对象下的属性与属性值。

   - **检查当前上下文的函数声明**，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。**如果有和函数名字相同的属性已经存在，则就不用新建函数名字的属性了，直接覆盖该属性。**

   - **检查当前上下文中的变量声明**，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。**如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，将不会进行任何操作直接跳过并继续扫描（注意和函数声明的区别），原属性值不会被修改。**

     	function foo() { 
     	  console.log('function foo')
     	}
     	var foo = 20;
     	console.log(foo); // 20

   上述说了，变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？

- **这是因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而foo = 20是在执行上下文的执行过程中运行的，输出结果自然会是20。**

   对比下例：

	   console.log(foo); // function foo
	
	   function foo() { 
		console.log('function foo') 
	   }
	
	   var foo = 20;
	
	- 上例的执行顺序为：
	
	   首先将所有函数声明放入变量对象中function foo() { console.log('function foo') }
	
	   其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值
	
	   然后开始执行阶段代码的执行
	
	   console.log(foo); // function foo
	   foo = 20;

（3） VO的初始化过程是有顺序的：**形参->函数声明->变量声明**

```
例如：function foo(i){
	   var a = 'hello'
	   var b = function(){}
	   function c(){}
	 }
		
     foo(22)
```

- 当我们调用foo(22)时，先进入创建执行上下文阶段(VO初始化阶段)

```
ECObj={
     scopeChain:{...},
     variableObject:{
         arguments:{
            0:22,
  		    length:1
		  },
         i:22,//形参
         c:pointer to function c(),//函数声明
         a:undefined,//变量声明
         b:undefined//变量声明（函数表达式）
     },
     this:{...}
}
```

- 名字相同情况下，函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值
  ​

  ```
    例1：function foo1(a){
           console.log(a)
           function a(){}
        }
  
        foo1(20) //'function a(){}' //在创建过程中，形参被函数覆盖了
        
    例2：function foo2(a){
  	     console.log(a)
  	     var a = 10  
  	  }
  
        foo2(20) //'20' //在创建过程中，变量名和形参一样了，直接跳过
            
    例3：function foo2(){
  	     console.log(a)
  	     var a = 10  
  	     function a(){}
  	  }
  	              
  	  foo2(20) //'function a(){}' 在创建过程中，变量名和形参一样了，直接跳过，函数直接覆盖
  
    例5：function foo3(a){
  		var a = 10  
  		function a(){}
  		console.log(a)
        }
  		               
  	  foo3(20) //'10' //赋值情况下
  
  	 例6：function foo3(a){
              var a
              function a(){}
              console.log(a)
           }
  		               
           foo3(20) //'function a(){}' //没有赋值情况下
  ```

- **未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。**

- **变量对象和活动对象其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。**

      ECObj={
      		    scopeChain:{...},
      		    variableObject:{
      		       arguments:{
      		         0:22,
      		         length:1
      		       },
      		       i:22,
      		       c:pointer to function c(),
      		       a:'hello',//赋值
      		       b:pointer to function privateB()//赋值
      		     },
      		     this:{...}
      		}

#### 4.作用域

- 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

- es5中作用域只有全局作用域和函数作用域，es6新增了块级作用域。

- 块级作用域在如下情况被创建：

  * 在一个函数内部
  * 在一个代码块（由一对花括号包裹）内部


- JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。

  - 编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。
    - 词法分析、语法分析、可执行代码生成、作用域规则确定......

  - 执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。

    - 执行上下文创建、代码执行、垃圾回收......

![](D:/knowledge-notes/前端知识/红宝书笔记/images/img6.png)

- **自由变量**

  - 什么是“自由变量”？先看个例子：

       var x = 10;
      function fn() {
          var b = 20;
          console.log(x+b); // x在这里就是一个自由变量
      }
      
       - 取x的值时，需要到另一个作用域中取，x就被称作“自由变量”。
      
      var x = 10;
      function fn() {
          console.log(x);
      }
      function show(f){
          var x = 20;
          (function () {
              f(); // 这里输出什么？？？
          })();
      }
      show(fn); //10

​        -  自由变量要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”。

​        - 为什么呢？因为作用域是在代码编译过程就确定下来的，然后就不会改变，这就是所谓的“静态作用域”。

#### 5.作用域链

- 每个执行环境的作用域链由**当前环境的变量对象及父级环境的作用域链**构成,作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。

- **作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象**

- 作用链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。


		function fn(a,b){
		    var x = 'string',
		}
		fn(1,2);

- 在一个函数定义的时候,会创建一个这个函数对象的[[scope]]属性（内部属性,只有JS引擎可以访问, 但FireFox的几个引擎（SpiderMonkey和Rhino）提供了私有属性__parent__来访问它)，并将这个[[scope]]属性指向定义它的作用域链上。

- 函数被调用前，初始化function fn，fn有个私有属性[[scope]],它会被初始化为定义它的作用域链(即当前全局的作用域)，fn.[[scope]="globalScope"。

- 调用函数fn(1,2)，开始创建fn执行上下文，同时创建作用域链fn.scopeChain = [fn.[[scope]]]，此时作用域链中有全局作用域。

- fn活动对象AO被初始化后，把活动对象作为变量对象推到作用域链前端，此时fn.scopeChain = [fn.AO,fn.[[scope]]]，构建完成，此时作用域链中有两个值，一个当前活动对象，一个全局作用域。

- fn的作用域链构建完成，作用域链中有两个值，第一个是fn函数自身的活动对象，能访问自身的变量，还有一个是全局作用域，所以fn能访问外部的变量。这里就说明了为什么函数中能够访问函数外部的变量，因为有作用域链，在自身找不到就顺着作用域链往上找。