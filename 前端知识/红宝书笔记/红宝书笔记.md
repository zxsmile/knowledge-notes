#### 一、语法 ####

「**1.区分大小写**」

「**2.标识符**」

-所谓标识符，就是指变 量、函  数、属性的名字或者函数的参数。

#### 二、变量 ####

- ECMAScript的变量松散类型的，所谓松散类型就是可以用来保存任何类型的数据。

- 换句话说，每个变量仅仅是一个用于保存值的占位符而已。

- 使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。

	function test(){
	  var a = 'hi' //局部变量
	}
	
	test()
	alert(a); //错误

- 省略var操作符，变量就成了全局变量。这样，只要调用过一次函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到、

	function test(){
	  a = 'hi' //全局变量
	}
	
	test()
	alert(a); //hi

#### 三、数据类型 ####

JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。

其中 Symbol 和 BigInt 是ES6 中新增的数据类型：

Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。

BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。


- ECMAScript变量可能包含两种不同的数据类型的值：基本数据类型值和引用数据类型值。

- javascript代码在执行的时候会将不同的变量存于内存中的不同位置。

   - 栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）以及 引用数据类型的指针

   - 堆：引用数据类型（对象、数组和函数）的值
   
- 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。

**请注意，不存在闭包的时候，上面的存储结论是对的。但是存在闭包时，闭包用到的变量（原始数据类型、引用数据类型）都会存到[[Scopes]]，然后放到堆内存**


####四、判断数据类型的方法####

「**1.typeof**」

	console.log(typeof 1);               // number
    console.log(typeof true);            // boolean
	console.log(typeof 'str');           // string
	console.log(typeof undefined);       // undefined
	console.log(typeof null);            // object
	console.log(typeof Symbol());        // symbol    
	console.log(typeof BigInt(123));   	 // bigint 
    console.log(typeof []);              // object    
	console.log(typeof function(){});    // function
	console.log(typeof {});              // object
	console.log(typeof new RegExp());    // object
	console.log(typeof new Date());      // object

- 其中数组、对象、null都会被判断为object，其他判断正确。

- 不同对象在底层都表示为二进制，在JavaScript中，二进制前三位都为0的话会被判断为object类型，null的二进制表示全0，自然前三位也是0，所以执行typeof时会返回object

- 使用typeof操作符检测函数时，该操作符会返回'function'。

- 在Safari 5及之前版本和Chrome 7及之前版本中，使用typeof检查正则表达式时，由于规范的原因，这个操作符也返回'function'。ECMA-262规定任何在内部实现[[Call]]方法的对象都应该在应用typeof操作符时返回'function'。由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回'function'。在IE和Firefox中，对正则表达式应用typeof会返回'object'。

- typeof的判断原理是：将值转换为二进制后，看其前三位是不是0，所有的引用类型（除了function）的二进制前三位都是0，null的二进制全部是0。因此，在需要区分具体引用类型时，typeof并不是最佳选择。

「**2.instanceof**」

- instanceof 是JavaScript中的一个运算符，用于判断一个对象是否为某个构造函数的实例，或者说是该构造函数（或其原型链上的任何构造函数）实例化的。因此instanceof()只能用于引用类型判断。

- instanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。

- 根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。

- 如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。

	console.log(2 instanceof Number);                    // false
	console.log(true instanceo f Boolean);                // false 
	console.log('str' instanceof String);                // false 
	 
	console.log([] instanceof Array);                    // true
	console.log(function(){} instanceof Function);       // true
	console.log({} instanceof Object);                   // true

- **instanceof的弊端**
  
  （1）只能用于引用类型的判断

  （2）篡改原型链

        - 由于 instanceof 是沿着原型链去判断，因此当我们尝试修改原有原型链的指向就会造成判断错误：

	        function Person() {}
			function Monster() {}
			
			const p = new Person();
			
			console.log(p instanceof Person); // true
			Person.prototype = Monster.prototype;
			console.log(p instanceof Person); // false
			console.log(p.__proto__ === Person.prototype); // false

         - 但针对一些内置的构造函数：Object、Array、Date等它们的prototype是不允许进行修改的，因此可以大胆的进行使用instanceof进行判断

            console.log(Object.getOwnPropertyDescriptor(Object, "prototype")); 
			console.log(Object.getOwnPropertyDescriptor(Array, "prototype"));
			console.log(Object.getOwnPropertyDescriptor(Date, "prototype"));
			console.log(Object.getOwnPropertyDescriptor(RegExp, "prototype"));
			console.log(Object.getOwnPropertyDescriptor(Map, "prototype"));
			console.log(Object.getOwnPropertyDescriptor(Set, "prototype"));

            {value: {…}, writable: false, enumerable: false, configurable: false}
            {value: Array(0), writable: false, enumerable: false, configurable: false}
            {value: {…}, writable: false, enumerable: false, configurable: false}
            {value: {…}, writable: false, enumerable: false, configurable: false}
            {value: Map, writable: false, enumerable: false, configurable: false}
            {value: Set, writable: false, enumerable: false, configurable: false}

         - 所以这种操作就别想辣：

            const cache = Array.prototype;
			const emptyObj = Object.create(null);
			Array.prototype = emptyObj; // no use 
			console.log(Array.prototype === emptyObj, Array.prototype === cache); // false  true
			console.log([] instanceof Array); // true


  （3）不同全局执行上下文

       - **在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。**比如两个不同版本的Array构造函数，如果要把数组从一个框架传给另一个框架，则这个给数组的构造函数将有别于在第二个框架内本地创建的数组。

           例如：window1  const arr = [1,2,3]

                 window2 arr instanceof Array => false

       - 起初，你会认为这样并没有意义，但是当你在你的脚本中开始处理多个 frame 或多个 window 以及通过函数将对象从一个窗口传到另一个窗口时，这就是一个有效而强大的话题。
       
       - 解决这个问题的一种方法是使用 Object.prototype.toString.call，它不依赖于具体的构造函数或原型链，而是直接检查对象的内部标识。
       
		<!DOCTYPE html>
		<html lang="en">
		  <head>
		    <meta charset="UTF-8" />
		    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
		    <title>Document</title>
		  </head>
		  <body>
		    <h1>page1</h1>
		    <!-- 引入 iframe -->
		    <iframe src="./two.html"></iframe>
		    <script>
		      const arr = [];
		      const window2 = window.frames[0]; // 拿到 iframe window 对象
		      console.log(arr instanceof window2.Array); //false
		    </script>
		  </body>
		</html>
		
**综上所述判断类型要斟酌当前的场景再合理的使用 instanceof，当然也可以使用 Array.isArray 或者 Object.prototype.toString.call 来进行判断，更加准确和安全。**


「**3.constructor 属性**」


「**4.Object.prototype.toString.call()**」

- Object.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：这种方案还是非常强大的，不仅基础数据类还是引用数据类型，甚至是正则对象，时间对象，Error对象等都能准确判断出来。

    const _toString = Object.prototype.toString;
    console.log(_toString.call({}));                  // [object Object]
    console.log(_toString.call([]));                  // [object Array]
    console.log(_toString.call(1));                   // [object Number]
    console.log(_toString.call("abc"));               // [object String]
    console.log(_toString.call(false));               // [object Boolean]
    console.log(_toString.call(function () {}));      // [object Function]
    console.log(_toString.call(null));                // [object Null]
    console.log(_toString.call(undefined));           // [object Undefined]
    console.log(_toString.call(Symbol("")));          // [object Symbol]
    console.log(_toString.call(BigInt(9007199254740991))); // [object BigInt]
    console.log(_toString.call(new Date()));          // [object Date]
    console.log(_toString.call(new RegExp()));        // [object RegExp]
    console.log(_toString.call(new Error()));         // [object Error]
    console.log(_toString.call(new Map()));           // [object Map]
    console.log(_toString.call(new Set()));           // [object Set]



#### 五、js的堆栈和其他语言的堆栈的区别 ####

** 在其他常见的语言中，用来保存变量和对象的内存一般分为栈内存和堆内存，而在JavaScript中，所谓的栈和堆都是放在堆内存中的，而在堆内存中，js把其分为栈结构和堆结构，这里常被误认为是堆内存和栈内存，但是我们可以把它简称为栈和堆**
 
**实际上，js的所有数据都是引用类型。因此我们才能看到js的值类型也有属性和方法（严格来讲，只有引用类型采用属性和方法）。所以，js的所有数据都是存储存储在堆内存中**

**在JavaScript中，堆内存和栈内存的区别不是由语言本身直接实现的，而是由JavaScript引擎在底层处理**

![](./images/img3.webp)
 
「**1.堆和栈的区别**」

- 理解堆与栈这两个概念时，需要放到具体的场景下去理解。一般情况下有两层含义：

（1）内存操作场景下，堆与栈表示两种内存的管理方式。
   
     - 栈由操作系统自动分配和释放，用于存放简单的数据段，占据固定大小的空间，比如基本数据类型和函数的参数值等。
     - 堆由开发人员自主分配和释放，若不主动释放，程序结束时由浏览器回收，用于存储引用类型（引用类型的变量实际上保存的不是变量本身，而是指向内存空间的指针）

（2）数据结构场景下，堆与栈表示两种常用的数据结构。

     - JavaScript存在栈和队列的概念，通过数组的方式，模拟实现堆栈。
     - 
     - 栈：栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。通过数组的push()、pop()方法实现栈。

     - 堆：堆其实是一种优先队列，也就是说队列中存在优先级，比如队列中有很多待执行任务，执行时会根据优先级找优先度最高的先执行。
     

#### 六、js的内存 ####

「**1.背景**」

- 不管什样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要我们自己手动的管理内存，某些编程语言会自动帮助我们管理内存。

- 而js它所具备的内存管理就是自动进行了，不对使用者开放。

- js的内存管理对我们来说，变成了黑盒一样的存在，一旦我们因为错的引用持有（例如闭包或全局变量），就会导致内存泄露。

「**2.认识内存管理**」

- 但不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期：

    第一步：分配申请我们需要的内存（申请）；

    第二步：使用分配的内存（存放一些东西，比如对象等）；

    第三步：不需要使用时，对其进行释放；
   
    **全局变量一般不会回收（关闭页面回收）。一般情况下局部变量的值，不用了，会被自动回收。**

- 不同的编程语言对于第一步和第三步会有不同的实现：

   （1）手动管理内存：比如C、C++，包括早期的OC，都是需要手动来管理内存的申请和释放的（malloc和free函数）；

       这种方式需要程序员手动管理内存，容易出现内存泄漏和野指针等问题，程序的稳定性和安全性有一定的风险。


   （2）自动管理内存：比如Java、JavaScript、Python、Swift、Dart等，它们有自动帮助我们管理内存；

      在这些语言中，存在垃圾回收机制来自动回收不再使用的内存空间，程序员只需要正确地使用变量和对象等引用类型数据，垃圾回收器就会自动进行内存管理，释放不再被引用的内存空间。

      这种方式可以避免内存泄漏和野指针等问题，提高程序的稳定性和安全性

- 对于开发者来说，JavaScript 的内存管理是自动的、无形的，也是抽象的

   （1）我们创建的原始值、对象、函数……这一切都会占用内存

   （2）好处在于我们并不需要手动来对它们进行管理，JavaScript引擎会帮助我们处理好它，但同样会带来一定的坏处(人为)：我们可能会忽略掉内存管理在其中的作用，导致相关理解产生偏差

「**3.在JavaScript的执行过程中，主要有三种类型的内存空间：代码空间、栈空间、堆空间**」

- 代码空间：用来存放可执行代码

- 栈空间：一块连续的内存区域，容量较小，读取速度快，被设计成先进后出结构

- 堆空间：不连续的内存区域，容量较大，用于储存大数据，读取速度慢

#### 七、栈、堆、队列 ####

**js以执行上下文的方式在堆内存中模拟实现类似栈内存的操作模式，因此，我们可以以传统的堆栈概念来理解js的内存空间**

- 栈（stack）、堆（heap）、队列（queue）是js的三种数据结构。

「**1.栈**」

- 栈的特点是：出口和入口是同一个，遵循着先进后出、后进先出的原则。数据只能顺序的入栈，顺序的出栈。
- 在栈里，新元素都靠近栈顶，旧元素都接近栈底。

    let a1 = 0; // 栈内存
    let a2 = "this is string" // 栈内存
	let a3 = null; // 栈内存

![](./images/img1.awebp)

「**2.堆**」

- 堆的特点是无序的key-value键值对存储方式。
- 堆的存取方式跟顺序没有关系，不局限出入口。

	let b = { x: 10 }; // 变量 b 存在于栈中，{ x: 10 } 作为对象存在于堆中
	let c = [1, 2, 3]; // 变量 c 存在于栈中，[1, 2, 3] 作为对象存在于堆中
    var arr1 = []
    var arr2 = []
    console.log(arr1===arr2] ///false
    因为在栈里的变量，存的是地址，而不是它的值，此时比较的是两个数组的存储地址，地址当然是不一样的，所以是false

「**3.堆与栈比较**」

- 堆是动态分配内存，内存大小不一，也不会自动释放。
- 栈是自动分配相对固定大小的内存空间，并由系统自动释放。
- 栈是线性结构，后进先出，便于管理
- 堆，一个混沌，杂乱无章，方便存储和开辟内存空间。


下图有助理解栈内存、堆内存

![](./images/img2.awebp)

「**4.为什么大部分高级语言都用栈来管理函数调用？**」

（1）函数调用栈

每个函数的调用时，解释器都会现在栈中创建一个调用栈（call stack）来存储函数的调用流程顺序。然后把该函数添加进调用栈，解释器会为被添加进的函数再创建一个栈帧（Stack Frame）并立即执行。如果正在执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈并执行。直到这个函数执行结束，对应的栈帧也会被立即销毁。栈帧中一般会存放信息包括：

  - 函数的返回地址和参数
 
  - 临时变量：函数局部变量+编译器自动生成的其他临时变量

  - 函数调用的上下文

（2）从函数自身的特性来分析这个问题

     - 函数具有可被调用的特性，代码执行控制权从最开始父函数调用子函数开始，移交给子函数，再由子函数执行完成后又移交给父函数，这个控制权的转移证明了：函数调用者的生命周期总是长于被调用者（后进），而且被调用者的生命周期总是先于调用者结束（先出）
     
     - 函数还有作用域的限制，在执行的时候，定义在函数内部的临时变量与外部环境隔离，只能在函数内访问，外部函数无权访问，当函数执行介绍后，临时变量也会随之被销毁。关于临时变量的资源占用情况证明了：被调用者的资源分配总是晚于调用者（后进），同时被调用者的资源释放却又总先于调用者（先出）



「**5.为什么会有堆内存和栈内存之分？**」

 **JS中的内存分类与JS引擎有关，在浏览中一般是V8引擎；要进行内存区分主要是为了进行垃圾回收（比如在V8的垃圾回收机制中会根据新生代、老生代内存采用不同回收算法来保证垃圾回收效率），从而使程序运行时占用的内存最小**

（1）栈内存：变量基本上用完就回收了，相比于堆来说存取速度会快，并且栈内存中的数据是可以共享的。

（2）堆内存：堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)。创建对象是为了反复利用（因为对象的创建成本通常较大），这个对象将被保存到运行时数据区（也就是堆内存）。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。


「**6.队列**」

- 队列的特点是是 先进先出，数据存取时 "从队尾插入，从队头取出"。
- 与栈的区别：栈的存入取出都在顶部一个出入口，而队列分两个，一个出口，一个入口


![](./images/img4.awebp)


#### 八、执行上下文（ES3版本）####

「**1.概念**」

- 执行上下文可以理解为函数运行的环境。每个函数执行时，都会给对应的函数创建这样一个执行环境。

- JS运行环境大概包括三种情况：全局环境、函数环境、eval环境（不推荐使用，所以不讨论）。

- 一个JS程序中，必定会产生多个执行上下文，JS引擎会以栈的方式处理它们，这个栈，我们称之为函数调用栈。

- 栈底永远都是全局上下文，栈顶就是当前正在执行的上下文。

- 由于栈是先进后出的结构，我们不难推出以下四点：

  - 只有栈顶的上下文处于执行中，其他上下文需要等待

  - 全局上下文只有唯一的一个，它在浏览器关闭时出栈

  - 函数的执行上下文的个数没有限制

  - 每次某个函数被调用，就会有个新的执行上下文为其创建。

「**2.执行上下文的生命周期**」

- 当调用一个函数时，一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段

（1）创建阶段

     - 在这个阶段中，执行上下文会分别创建**变量对象，建立作用域链，以及确定this的指向**。

（2）代码执行阶段

     - 创建完成之后，就会开始执行代码，这个时候，会完成**变量赋值，函数引用，以及执行其他代码**。


「**3.变量对象(VO)**」

（1）当一个函数被调用时，执行上下文就创建了，执行上下文包含了函数所有声明的变量和函数，保存这些变量跟函数的对象，我们称之为变量对象。

（2） 变量对象的创建，依次经历了以下几个过程：

   - **建立arguments对象。**检查当前上下文中的参数，建立该对象下的属性与属性值。
    
   - **检查当前上下文的函数声明**，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。**如果有和函数名字相同的属性已经存在，则就不用新建函数名字的属性了，直接覆盖该属性。**

   - **检查当前上下文中的变量声明**，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。**如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，将不会进行任何操作直接跳过并继续扫描（注意和函数声明的区别），原属性值不会被修改。**

		function foo() { 
          console.log('function foo')
        }
		var foo = 20;
		
		console.log(foo); // 20

   上述说了，变量声明的foo遇到函数声明的foo会跳过，可是为什么最后foo的输出结果仍然是被覆盖了？

    **这是因为上面的三条规则仅仅适用于变量对象的创建过程。也就是执行上下文的创建过程。而foo = 20是在执行上下文的执行过程中运行的，输出结果自然会是20。**

   对比下例：

	   console.log(foo); // function foo

	   function foo() { 
		console.log('function foo') 
	   }

	   var foo = 20;

	- 上例的执行顺序为：
	
	   首先将所有函数声明放入变量对象中function foo() { console.log('function foo') }
	
       其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值

	   然后开始执行阶段代码的执行
	
       console.log(foo); // function foo
	   foo = 20;

（3） VO的初始化过程是有顺序的：**形参->函数声明->变量声明**

        例如：function foo(i){
			  var a = 'hello'
			  var b = function(){}
			  function c(){}
			}
			
			foo(22)

        - 当我们调用foo(22)时，先进入创建执行上下文阶段(VO初始化阶段)

    
			         ECObj={
			           scopeChain:{...},
			           variableObject:{
			             arguments:{
			                0:22,
			                length:1
			             },
			             i:22,//形参
			             c:pointer to function c(),//函数声明
			             a:undefined,//变量声明
			             b:undefined//变量声明（函数表达式）
			           },
			           this:{...}
			         }

            
        - 名字相同情况下，函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值
       
            例1：function foo1(a){
			      console.log(a)
			      function a(){}
			     }
		
		         foo1(20) //'function a(){}' //在创建过程中，形参被函数覆盖了
  
            例2：function foo2(a){
		          console.log(a)
		          var a = 10  
		    	 }

                 foo2(20) //'20' //在创建过程中，变量名和形参一样了，直接跳过
              
            例3：function foo2(){
		          console.log(a)
		          var a = 10  
		          function a(){}
		         }
		              
		         foo2(20) //'function a(){}' 在创建过程中，变量名和形参一样了，直接跳过，函数直接覆盖

            例5：function foo3(a){
			       var a = 10  
			       function a(){}
			       console.log(a)
			     }
			               
			     foo3(20) //'10' //赋值情况下
			
			                
			 例6：function foo3(a){
			       var a
			       function a(){}
			       console.log(a)
			      }
			               
			      foo3(20) //'function a(){}' //没有赋值情况下
 
- **未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。**

- **变量对象和活动对象其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。**

             ECObj={
				    scopeChain:{...},
				    variableObject:{
				       arguments:{
				         0:22,
				         length:1
				       },
				       i:22,
				       c:pointer to function c(),
				       a:'hello',//赋值
				       b:pointer to function privateB()//赋值
				     },
				     this:{...}
				}


「**4.作用域**」

- 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

- es5中作用域只有全局作用域和函数作用域，es6新增了块级作用域。

- 块级作用域在如下情况被创建：

  * 在一个函数内部
  * 在一个代码块（由一对花括号包裹）内部


- JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。

    - 编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。
        - 词法分析、语法分析、可执行代码生成、作用域规则确定......

    - 执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。

        - 执行上下文创建、代码执行、垃圾回收......
        
![](./images/img6.png)

- **自由变量**

   什么是“自由变量”？先看个例子：

        var x = 10;
		function fn() {
		    var b = 20;
		    console.log(x+b); // x在这里就是一个自由变量
		}

        - 取x的值时，需要到另一个作用域中取，x就被称作“自由变量”。

		var x = 10;
		function fn() {
		    console.log(x);
		}
		function show(f){
		    var x = 20;
		    (function () {
		        f(); // 这里输出什么？？？
		    })();
		}
		show(fn); //10

        - 自由变量要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”。

        - 为什么呢？因为作用域是在代码编译过程就确定下来的，然后就不会改变，这就是所谓的“静态作用域”。

「**5.作用域链**」

- 每个执行环境的作用域链由**当前环境的变量对象及父级环境的作用域链**构成,作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。

- 作用链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。


		function fn(a,b){
		    var x = 'string',
		}
		fn(1,2);


在一个函数定义的时候,会创建一个这个函数对象的[[scope]]属性（内部属性,只有JS引擎可以访问, 但FireFox的几个引擎（SpiderMonkey和Rhino）提供了私有属性__parent__来访问它)，并将这个[[scope]]属性指向定义它的作用域链上。

(1)函数被调用前，初始化function fn，fn有个私有属性[[scope]],它会被初始化为定义它的作用域链(即当前全局的作用域)，fn.[[scope]="globalScope"。

(2)调用函数fn(1,2)，开始创建fn执行上下文，同时创建作用域链fn.scopeChain = [fn.[[scope]]]，此时作用域链中有全局作用域。

(3)fn活动对象AO被初始化后，把活动对象作为变量对象推到作用域链前端，此时fn.scopeChain = [fn.AO,fn.[[scope]]]，构建完成，此时作用域链中有两个值，一个当前活动对象，一个全局作用域。

fn的作用域链构建完成，作用域链中有两个值，第一个是fn函数自身的活动对象，能访问自身的变量，还有一个是全局作用域，所以fn能访问外部的变量。这里就说明了为什么函数中能够访问函数外部的变量，因为有作用域链，在自身找不到就顺着作用域链往上找。

#### 九、执行上下文（ES5版本） ####

「**1.执行上下文的生命周期**」

- 当调用一个函数时，一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段

（1）创建阶段

     - 在这个阶段中，执行上下文会分别创建**词法环境，变量环境，以及确定this的指向**。

（2）代码执行阶段

     - 创建完成之后，就会开始执行代码，这个时候，会完成**变量赋值，函数引用，以及执行其他代码**。
     
    **注意：var在创建阶段为undefined，如果有值就对应赋值，像let const值为未初始化，如果有值就赋值，无值则赋予undefined**

「**2.词法环境（LexicalEnvironment）**」

- 简单来说，词法环境是一种持有**标识符—变量映射**的结构。
- 这里的标识符指的是变量/函数的名字，而变量是对实际对象（包含函数类型对象）或原始数据的引用。

（1）在词法环境中有两个组成部分：

- 环境记录(EnvironmentRecord)： 储存变量和函数声明的实际位置

- 对外部环境的引用(Outer)：当前可以访问的外部词法环境，通过其访问父级词法环境（作用域），词法作用域链也是保存在[[Scope]]属性上的。

（2）词法环境分为两种类型：

- 全局环境： 全局执行上下文，他没有外部环境的引用，拥有一个全局对象window和关联的方法和属性（比如: Math,String,Date等）。还有用户定义的全局变量，并将this指向全局对象。

- 函数环境： 用户在函数定义的变量将储存在环境记录中。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。环境记录中包含：用户声明的变量、函数、还有arguments对象。

- 举例词法环境在伪代码中如下：

		GlobalExectionContent = {//全局执行上下文
		  LexicalEnvironment: {//词法环境
		    EnvironmentRecord: {//环境记录
		      Type: "Object",
		      // 剩余标识符
		    },
		    Outer: null,//对外部环境的引用
		  }
		}
		
		FunctionExectionContent = {//函数执行上下文
		  LexicalEnvironment: {//词法环境
		    EnvironmentRecord: {//环境记录
		      Type: "Declarative",
		      // 剩余标识符
		    },
		    Outer: [Global or outer function environment reference],//对外部环境的引用
		  }
		}



「**3.变量环境（VariableEnvironment）**」

- 变量环境也是一个词法环境，他具有词法环境中所有的属性。

- 单独分出这个变量环境的概念是为 ES6 服务的：

   - ES6 中，词法环境组件和 变量环境的一个不同就是**前者被用来存储函数声明和变量（let 和 const）绑定**，而**后者只用来存储 var 变量绑定**

		 例：let a = 20;  
			const b = 30;  
			var c;
			
			function add(e, f) {  
			 var g = 20;  
			 function c(){}
			 return e + f + g;  
			}
			
			c = add(20, 30);

   - 在预编译阶段。生成的词法环境和变量环境如下：

		GlobalExectionContent = {
		  thisBinding: Global,
		  LexicalEnvironment: {//词法环境
		    EnvironmentRecord: {//环境记录
		      Type: "Object",
		      a: <uninitialied>,
		      b: <uninitialied>,
		      add: <func>
		      // 剩余标识符
		    },
		    Outer: null,//对外部环境的引用
		  },
		
		  VariableEnvironment: {//变量环境
		    EnvironmentRecord: {//环境记录
		      Type: "Object",
		      c: undefined,
		      // 剩余标识符
		    },
		    Outer: null,//对外部环境的引用
		  }
		}
		
		FunctionExectionContent = {
		  thisBinding: Global,
		  LexicalEnvironment: {//词法环境
		    EnvironmentRecord: {//环境记录
		      Type: "Declarative",
		      arguments: {
		        0: 20,
		        1: 30,
		        length: 2,
		      },
		      e: 20,
		      f: 30,
		      c: reference to function c(){}
		      // 剩余标识符
		    },
		    Outer: GlobalLexicalEnvironment,//对外部环境的引用
		  },
		  VariableEnvironment: {//变量环境
		    EnvironmentRecord: {//环境记录
		      Type: "Declarative",
		      g: undefined,
		      // 剩余标识符
		    },
		    Outer: GlobalLexicalEnvironment,//对外部环境的引用
		  }
		}

**我们发现使用let和const声明的变量在词法环境创建时是未赋值初始值。而使用var定义的变量在变量环境创建时赋值为undefined。这也就是为什么const、let声明的变量在声明钱调用会报错，而var声明的变量不会**

「**4.变量提升**」

（1）**变量提升（Hoisting）**被认为是，Javascript 中执行上下文（特别是创建和执行阶段）工作方式的一种认识,从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中

- 由上述概念我们可以得出一个关键信息：**js代码在执行之前需要进行编译，变量和函数的声明在编译阶段会被放在内存中**

（2）**变量提升的本质：**js执行一段代码需要先编译，编译的过程中会生成对应的执行上下文，变量和函数的声明会保存到其中的变量对象中，代码执行的时候会从当前执行上下文的变量对象逐层往上（词法作用域规则）寻找变量和函数，直到全局执行上下文。

（3）**var的缺陷：**

    - 受变量提升的影响，容易出现变量污染、变量覆盖、代码层面不好理解等问题
  
    - 不支持块级作用域，很容易在不知情的情况下声明全局变量，本应销毁的变量没有被销毁

  为了解决这个设计缺陷，es6引入支持块级作用域的关键字let、const

（4）**暂时性死区**

通过前面对词法环境和变量环境的学习，我们发现使用let和const声明的变量在词法环境创建时是未赋值初始值。而使用var定义的变量在变量环境创建时赋值为undefined。

**这不就是暂时性死区的原因吗？**

- 用 let、const 或 class 声明的变量可以称其从代码块的开始一直到代码执行到变量声明的位置并被初始化前，都处于一个“暂时性死区”（Temporal dead zone，TDZ）中。

- 当变量处于暂时性死区之中时，其尚未被初始化，并且任何访问其的尝试都将导致抛出 ReferenceError。当代码执行到变量被声明的位置时，变量会被初始化为一个值。如果变量声明中未指定初始值，则变量将被初始化为 undefined。

**为什么存在变量提升？**

     - 变量提升的原因是因为js执行代码前需要先进行编译，它是通过变量环境实现的。

**为什么要引入let、const，它们是怎么支持块级作用域的?**

     - 引入支持块级作用域关键字let、const是为了避免var由于设计缺陷在变量提升的作用下，引发的一系列问题：不经意的情况定义全局变量，污染变量、覆盖变量等。让代码执行更加的规范以及符合我们的常识：代码块执行完了里面的变量应该被立刻销毁。外部无法访问内部代码块的变量。
     
     - 块级作用域是通过词法环境实现的，每一个块级作用域内的变量都会在当前执行上下文中的词法组件以栈的形式保存下来。每当一个块级作用域代码执行完成。便会从栈顶弹出。

**暂时性死区触发的原因是什么，为什么会引入这么一个概念？**

      - **let、const也存在变量提升的情况**, 但是对它们做了一道限制：没有默认值 undefined。直到代码执行到声明语句之后，才可以对其使用。代码块开头到声明语句前的这段区域为暂时性死区,在暂时性死区内使用变量，会有ReferenceError错误。解决了var在声明前就可以使用，给人带来困扰、难以理解的问题


「**5.可执行代码执行阶段**」

代码执行时根据之前的环境记录对应赋值，比如早期var在创建阶段为undefined，如果有值就对应赋值，**像let const值为未初始化，如果有值就赋值，无值则赋予undefined**，最后执行代码。


「**6.梳理创建执行上下文的步骤**」

**（1）创建全局执行上下文的步骤**
  
- this绑定，把全局执行上下文中的this指向window对象；

- 确定词法环境，把全局执行上下文中的所有**函数声明和使用let、const声明的变量存储到词法环境的环境记录器**，把全局执行上下文的对外部环境的引用指向null；

- 确定变量环境：把全局执行上下文中的**var声明的变量存储变量环境的环境记录器**，并把这些变量的值**初始化为undefined；**

**（2）创建函数执行上下文的步骤**

- this绑定，函数执行上下文中的this的指向取决于函数是如何调用，在代码运行前已经确定好了每一次调用函数的代码中的this的指向；

- 确定词法环境，把函数执行上下文中的所有**函数声明和使用let、const声明的变量存储到词法环境的环境记录器**，另外还会把包含**函数参数的arguments对象存储到词法环境的环境记录器**，把函数执行上下文的对外部环境的引用指向；

- 确定变量环境：把函数执行上下文中的**var声明的变量存储变量环境的环境记录器**，并把这些变量的值**初始化为undefined**；


**（3）全局和函数执行上下文的不同**

- 函数可以被多次调用，所以同一个函数被调用多次会有多个函数执行上下文，每个函数执行上下文的this不一定相同，但是都会在代码运行前确定；

- 函数的词法环境的变量中，还包含给函数传入的参数组成的arguments对象，这也表明函数的参数可以理解为函数内部声明的内部变量，和函数内部定义的函数变量一样；

- 函数的执行上下文的词法环境还包含对外部环境的引用（包含对父级作用域1的引用），**这意味在代码还没执行的时候，函数可以访问的父级作用域就已经确定了（思考一下闭包？）**。
- 

#### 十、垃圾回收机制 ####

「**1.内存的生命周期**」

**内存分配**：当我们声明变量，对象，函数的时候，系统会自动为他们分配内存（申请）；

**内存使用**：即读写内存，使用分配的内存（存放一些东西，比如对象等）；

**内存回收**：使用完毕，由垃圾回收器自动回收不使用的内存，（释放内存）；
 
**全局变量一般不会回收（关闭页面回收）**

**一般情况下局部变量的值，不用了，会被自动回收**

		//为变量分配内存
		const age = 18;

		//为对象分配内存
		const obj = {
		  name: '小明',
		  age: 18,
		};

		//为函数分配内存
		function fn (){

		    //局部变量的值，在函数调用完后，不使用就会被自动回收
		    const age = 18;
		    console.log(age);
		}
		fn()

		
「**2.垃圾回收机制的对象**」

- 基本类型存放在栈中，引用类型存放在堆中。javascript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。

-在JavaScript中，垃圾回收机制不仅适用于引用类型（如对象、数组等），也适用于基本类型（如Number、String、Boolean等）。基本类型的值通常存储在栈内存中，这些值的大小是固定的，因此它们的生命周期相对简单。当基本类型的变量不再被使用时，它们所占用的内存会被自动回收。这是因为JavaScript的内存管理机制会自动分配和释放内存，包括基本类型和引用类型的内存。

- **垃圾回收机制的核心目的是防止内存泄漏**，即确保不再使用的内存能够被释放，避免程序因占用过多内存而导致性能下降或崩溃。

- 对于基本类型，由于其生命周期相对简单（即声明后立即存在，直到变量作用域结束或变量被显式删除），因此它们的内存管理相对直接。

- 而对于引用类型，如对象、数组等，垃圾回收机制通过更复杂的算法（如标记清除和引用计数）来管理内存，确保只有当这些引用类型完全不再被引用时，它们的内存才会被回收‌。

- 总的来说，无论是基本类型还是引用类型，JavaScript的垃圾回收机制都确保了内存的有效管理，防止了内存泄漏的发生，从而保证了程序的稳定运行和性能优化。

「**3.全停顿**」

- 在介绍垃圾回收算法之前，我们先了解一下「**全停顿**」。垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「**全停顿**」（`Stop The World`）。例如，如果一次GC需要50ms，应用逻辑就会暂停50ms。

**全停顿的目的，是为了解决应用逻辑与垃圾回收器看到的情况不一致的问题。**

举个例子，在自助餐厅吃饭，高高兴兴地取完食物回来时，结果发现自己餐具被服务员收走了。这里，服务员好比垃圾回收器，餐具就像是分配的对象，我们就是应用逻辑。在我们看来，只是将餐具临时放在桌上，但是服务员看来觉得你已经不需要使用了，因此就收走了。你与服务员对于同一个事物看到的情况是不一致，导致服务员做了与我们不期望的事情。因此，为避免应用逻辑与垃圾回收器看到的情况不一致，垃圾回收算法在执行时，需要停止应用逻辑。


「**4.垃圾回收(GC)算法**」

（1）**引用计数法**
 
   - 设置引用数，判断当前引用数是否为0，如果为0则是垃圾对象，就会被垃圾回收器回收。
   
   - 语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数，这也算是引用计数算法的一个缺点，就是我们需要单独拿出一片空间去维护每个变量的引用计数，这对于比较大的程序，空间开销还是比较大的。
   
   - 具体流程：
        - 设置引用计数器
        - 当对象的引用关系发生变化时，引用计数器就会修改引用数字
        - 当引用数字为 0 时，立即回收
            
    - 优点：
        - 发现垃圾时，**立即回收**
        - 最大限度减少程序暂停，当发现内存即将到达临界点时，就开始进行引用计数清除，即空间不会被占满

    - 缺点：
        - 无法回收循环引用的对象
        - 时间复杂度比较高
        - 资源消耗比较大，会对所有对象进行数值的监控和修改，本身就会占用时间和资源
 

（2）**标记清除法**

   - 标记清除法其实就是可达性测试，垃圾回收器从根集合出发，检查所有的根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。

   - 根节点：一般来说，根是代码中引用的全局变量。例如，在 JavaScript 中，可以充当根节点的全局变量是“window”对象。Node.js 中的全局对象被称为“global”，兼容写法：可以使用最新的 ( globalThis ) 代替两者，实现两种环境的兼容。完整的根节点列表由垃圾收集器构建。

   - 标记清除分为标记阶段和清除阶段
        
       - 标记阶段：标记清除其实就是可达性（对象是否可访问）测试，垃圾回收器从根集合出发，检查所有的根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。
	       
       - 清除阶段：从根节点开始遍历堆，垃圾收集器释放所有未被标记为活跃的内存块，并将这些内存返回给操作系统

    - 优点：
        - 解决**循环引用**的问题

    - 缺点：
        - **不会立即回收垃圾对象**，即使发现了垃圾对象，也必须遍历完后才进行清除，清除时程序停止工作产生卡顿
        
        - 产生**空间碎片化**，即链表地址不连续


（3）**标记整理**
 
   - 为了解决内存碎片化的问题，提高对内存的利用，引入了标记整理算法。

   - 标记整理可以看做是标记清除的**增强**。标记阶段的操作和标记清除一致。

   - 清除阶段会先执行整理，移动对象位置,将存活的对象移动到一边，然后再清理端边界外的内存。（在标记和清除中间，还添加了内存空间的整理）

   - 具体流程：
        - 标记阶段：递归遍历，对可达对象可达对象即活动对象做标记
        
        - 整理阶段：清除前先进行整理，移动对象位置，让地址产生连续
        
        - 清除阶段：递归遍历，清除未标记的对象未标记的对象即非活动对象

    - 优点：
    
        - 比标记清除法过程多了对碎片化空间的整理，即会有较少碎片空间 
        
        - 标记 -> 整理碎片化空间 -> 清除

     - 缺点：和标记清除法一样，不会立即清除垃圾对象，清除时程序仍然是暂停的，多了移动对象位置过程，回收的效率比较慢。


（4）**增量标记**

   - 为了减少**全停顿**的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。
   
   - 长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将**全暂停标记**换成了**增量标记**。改进后的标记方式，最大停顿时间减少到原来的1/6。


「**5.v8引擎垃圾回收策略---分代式垃圾回收**」

- 垃圾回收策略主要有标记清除和引用计数，**现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化**

（1）**介绍**

    - 采用分代回收的思想，内存分为新生代、老生代；

    - 针对不同对象采用不同算法：

      - 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
      - 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

    - **V8堆的空间等于新生代空间加上老生代空间，且针对不同的操作系统对空间做了内存的限制。**

    - 针对浏览器来说，这样的内存是足够使用的。限制内存的原因：

    **首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停。**
    **另一方面垃圾回收其实是非常耗时间的操作，在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。针对浏览器的GC机制，经过不断的测试，如果内存再设置大一点，`GC`回收的时间就会达到用户的感知，会造成感知上的卡顿。**
   
（2） **回收新生代对象**

- 回收新生代对象主要采用**Scavenge 算法加标记整理算法**。而Scavenge 算法的具体实现，主要采用了Cheney算法。**回收器策略：并行回收**

- Cheney算法 中将堆内存一分为二（两个等大空间），一个是处于使用状态的空间我们暂且称之为使用区(from)，一个是处于闲置状态的空间我们称之为空闲区(to)。如下图所示

![](GC2.jpg)


- 新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。

- 当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。

- **新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。**

- 发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况**触发晋升**:

   - 已经经历过一次 Scavenge 回收（一轮GC还存活的新生代需要晋升）。
   
   - 当对象从使用区空间复制到空闲区空间时，空闲区空间的内存占用超过25%,设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。

- 不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

（3） **回收老生代对象**

  - 回收老生代对象主要采用**标记清除、标记整理、增量标记算法，主要使用标记清除算法，只有在内存分配不足时，采用标记整理算法。**
  
   - 首先使用标记清除完成垃圾空间的回收；
   - 采用标记整理进行空间优化；
   - 采用增量标记进行效率优化；


 **Orinoco优化**

 - orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。
 

「**6.内存泄露**」（虽然有垃圾回收机制，但我们编写代码操作不当还是会造成内存泄露。）

- 内存泄漏指应用程序已经不再需要的内存，由于某种原因，未释放或无法释放

- 内存泄露可能带来的问题：变慢、卡顿、高延迟。

**常见的内存泄露情况**

（1）**意外的**全局变量

  - 在js中，一个未声明变量的使用，会在全局对象中创建一个新的变量；在浏览器环境下，全局对象就是window：
  
		function  data() {
		     a = 'test'
		}
		// 上面的写法等价于
		function data() {
		     window.a = 'test'
		}
		
		function data() {
		   this.a = 'test'
		    // 函数自身发生调用，this指向全局对象window
		}
		data();

  - 上面的a变量应该是data()内部作用域变量的引用，由于没有使用关键词（let、const、var）来声明这个变量，这时变量a就被创建成了全局变量，这时候就会导致内存泄漏。

**解决方式：使用var、let、const来定义变量，或者在js文件开头添加'use strict'，开启严格模式**

（2）**定时器**

  - 定时器setInterval或者setTimeout在不需要使用的时候，没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。另外，浏览器中的requestAnimationFrame也存在这个问题，在不需要的时候用cancelAnimationFrame来取消使用。

		var someResource = getData();
		setInterval(function() {
		    var node = document.getElementById('Node');
		    if(node) {
		        // 处理 node 和 someResource
		        node.innerHTML = JSON.stringify(someResource));
		    }
		}, 1000);

        - 上例中，如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放。

**解决方式：当不需要interval或者timeout的时候，调用clearInterval或者clearTimeout。**

（3）**没有清理对DOM元素的引用同样造成内存泄露**

		const refA = document.getElementById('refA');
		document.body.removeChild(refA); // dom删除了
		console.log(refA, 'refA'); // 但是还存在引用能console出整个div 没有被回收
		refA = null;
		console.log(refA, 'refA'); // 解除引用

   **解决方式：refA = null；包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听。**


（4）**闭包**

  - 闭包是指有权访问另一个**函数作用域**的变量的**函数**

  - 闭包的本质就是**当前函数作用域**存在指向**父级函数作用域**的引用

  - 闭包 = 函数 + 函数能够访问的自由变量

  - 自由变量是指在函数中使用的，但既不是当前函数参数也不是当前函数的局部变量的变量。

  **个人理解：函数+函数的原因是，全局作用域本身就是关闭页面才会被释放，而函数作用域是函数执行完就应该被释放，由于子函数的引用导致没被释放，就形成了闭包。**

   function fn(){
    let result = {}
    return function(){
        //因为闭包内i你用了result，导致它不会被垃圾机制回收，导致内存泄露
        return result
    }
   }
   let fn1 = fn()
   fn1()

   **解决方式：上面代码可以直接通过将fn1置为null来清除引用，也可以少用闭包的方式**


（5）**循环引用**

  - 循环引用在引用计数策略下会导致内存泄露，标记清除不会。

     function fn() {
       const o1 = {}
       const o2 = {}
       o1.p = o2
       o2.p  = o1
     }
    
     fn()

    a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境。在标记清除方式下是没有问题的，但在引用计数策略下，a和b的引用次数为1不为0，不会被垃圾回收器回收内存。如果fn函数被大量调用，就会造成内存泄露，这时候就需要手动解除引用（置为null）

   **解决方式：不使用的时候手动清除：o1.p = null o2.p = null**
             
（6）**未清理的console**
  
  - 如果在console中输出了对象，那么浏览器就需要把这个引用关系保存下来，才能在控制台上看到相应的对象，这样同样也会造成内存泄露。

  **解决方式：清除或者注释掉console.log()**


#### 十一、引用类型 ####

「**1.Object类型**」

(1)创建Object实例方式

   - 使用new操作符后跟Object构造函数

     let obj = new Object()
     obj.name = 'offer'

   - 对象字面量
   
     let obj = {
        name:'offer'
     }

「**2.Array类型**」

(1)创建Array实例方式

  - 使用Array构造函数
     
     let arr = new Array(3) //创建一个包含3项的数组
     let arr = new Array('offer') //创建一个包含1项，即字符串'offer'的数组

   - 数组字面量

     let arr = ['offer']

 (2)数组的length属性很有特点------它不是只读的，通过设置length，可以从数组末尾移除项或向数组中添加新项。新项值为undefined





















       
#### 六、总结 ####


五、函数

1.arguments(实参)

 - argunments对象存储函数的所有参数，访问这个参数对象，可以获取传递给函数的每一个参数。
 
	 fn(a,b){
	   console.log(a,b,arguments) //  Arguments(4) [1, 2, 'sjjsjsj0', 256]
	 }
	
	 fn(1,2,'sjjsjsj0',256)
 
 - 在给函数的形参传值的情况下，改变arguments对象中的值会直接反映到对应的形参，反之亦然。但是形参和实参arguments这两个值的内存空间是独立的。
 
	//改变实参arguments[1],形参b也跟着变化了
	 function fn(a,b,c){
	   arguments[1] = 10
	   console.log(a,b,c,arguments) //1 10 undefined Arguments(2) [1, 10]
	      
	 }
	 fn(1,'kkdkdk')
	
	//改变形参b,实参arguments[1]也跟着变化了
	 function fn(a,b,c){
	   b=25
	   console.log(a,b,c,arguments) //1 25 undefined Arguments(2) [1, 25]
	      
	 }
	 fn(1,'kkdkdk')

- 函数某个形参没有传值的情况下，arguments和形参的值不会相互影响

    //形参c没有传值，改变实参arguments[2],形参c的值仍未undefined
	 function fn(a,b,c){
	   arguments[2] = 20
	   console.log(a,b,c,arguments) //1 'kkdkdk' undefined Arguments(2) [1, 'kkdkdk', 2: 20]  
	 }
	 fn(1,'kkdkdk')
	
	//形参c没有传值,改变形参c,实参arguments[1]也跟着变化了
	 function fn(a,b,c){
	   c=10
	   console.log(a,b,c,arguments) //1 'kkdkdk' 10 Arguments(2) [1, 'kkdkdk']
	      
	 }
	 fn(1,'kkdkdk')


 - 严格模式下，对arguments对象做出了一些限制，比如上面例子中那样的赋值会变得无效。重写arguments的值会导致语法错误。

2.没有重载

- 函数重载是指在同一个作用域内定义多个同名函数，但这些函数的参数列表不同，以便根据传入的参数类型和数量自动选择调用哪个函数。‌ 函数重载是面向对象编程语言（如‌C++和‌Java）中的一种特性，它允许使用相同的函数名称来实现不同的功能，从而提高了代码的复用性和灵活性。

- ECMAScript函数不能像传统意义上那样实现重载。而在其他语言（如JAVA）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。

- ECMAScript函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数真正的重载是不可能做到的。

	function overload(a){
		console.log('一个参数')
	}
	
	function overload(a,b){
		console.log('两个参数')
	}
	
	// 在支持重载的编程语言中，比如 java
	overload(1);   	  //一个参数
	overload(1,2);    //两个参数
	
	
	// 在 JavaScript 中
	overload(1);   	  //两个参数
	overload(1,2);    //两个参数

- 在JavaScript中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的，所JavaScript 没有真正意义的重载。
- 