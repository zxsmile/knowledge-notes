### 一、栈、堆、队列 ###

- js以执行上下文的方式在堆内存中模拟实现类似栈内存的操作模式，因此，我们可以以传统的堆栈概念来理解js的内存空间

- 栈（stack）、堆（heap）、队列（queue）是js的三种数据结构。

####  1. 栈

- 栈的特点是：出口和入口是同一个，遵循着先进后出、后进先出的原则。数据只能顺序的入栈，顺序的出栈。

- 在栈里，新元素都靠近栈顶，旧元素都接近栈底。

  ```
  let a1 = 0; // 栈内存
  let a2 = "this is string" // 栈内存
  let a3 = null; // 栈内存
  ```

![img1](D:\张旭资料\knowledge-notes\前端知识\红宝书笔记\images\img1.png)

####  2. 堆

- 堆的特点是无序的key-value键值对存储方式。

- 堆的存取方式跟顺序没有关系，不局限出入口。

  ```
  let b = { x: 10 }; // 变量 b 存在于栈中，{ x: 10 } 作为对象存在于堆中
  let c = [1, 2, 3]; // 变量 c 存在于栈中，[1, 2, 3] 作为对象存在于堆中
  var arr1 = []
  var arr2 = []
  console.log(arr1===arr2] ///false
  ```

- 因为在栈里的变量，存的是地址，而不是它的值，此时比较的是两个数组的存储地址，地址当然是不一样的，所以是false

#### 3. 堆与栈比较

- 堆是动态分配内存，内存大小不一，也不会自动释放。
- 栈是自动分配相对固定大小的内存空间，并由系统自动释放。
- 栈是线性结构，后进先出，便于管理
- 堆，一个混沌，杂乱无章，方便存储和开辟内存空间。


下图有助理解栈内存、堆内存

![img2](D:\knowledge-notes\前端知识\红宝书笔记\images\img2.png)

#### 4. 为什么大部分高级语言都用栈来管理函数调用？

（1）函数调用栈

- 每个函数的调用时，解释器都会现在栈中创建一个调用栈（call stack）来存储函数的调用流程顺序。然后把该函数添加进调用栈，解释器会为被添加进的函数再创建一个栈帧（Stack Frame）并立即执行。如果正在执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈并执行。直到这个函数执行结束，对应的栈帧也会被立即销毁。栈帧中一般会存放信息包括：
  - 函数的返回地址和参数
  - 临时变量：函数局部变量+编译器自动生成的其他临时变量
  - 函数调用的上下文

（2）从函数自身的特性来分析这个问题

- 函数具有可被调用的特性，代码执行控制权从最开始父函数调用子函数开始，移交给子函数，再由子函数执行完成后又移交给父函数，这个控制权的转移证明了：函数调用者的生命周期总是长于被调用者（后进），而且被调用者的生命周期总是先于调用者结束（先出）
-  函数还有作用域的限制，在执行的时候，定义在函数内部的临时变量与外部环境隔离，只能在函数内访问，外部函数无权访问，当函数执行介绍后，临时变量也会随之被销毁。关于临时变量的资源占用情况证明了：被调用者的资源分配总是晚于调用者（后进），同时被调用者的资源释放却又总先于调用者（先出）

#### 5. 为什么会有堆内存和栈内存之分？

- **JS中的内存分类与JS引擎有关，在浏览中一般是V8引擎；要进行内存区分主要是为了进行垃圾回收（比如在V8的垃圾回收机制中会根据新生代、老生代内存采用不同回收算法来保证垃圾回收效率），从而使程序运行时占用的内存最小**
- **栈内存**：变量基本上用完就回收了，相比于堆来说存取速度会快，并且栈内存中的数据是可以共享的。
- **堆内存**：堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)。创建对象是为了反复利用（因为对象的创建成本通常较大），这个对象将被保存到运行时数据区（也就是堆内存）。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

#### 6. 队列

- 队列的特点是是 先进先出，数据存取时 "从队尾插入，从队头取出"。
- 与栈的区别：栈的存入取出都在顶部一个出入口，而队列分两个，一个出口，一个入口

![img4](D:\张旭资料\knowledge-notes\前端知识\红宝书笔记\images\img4.png)