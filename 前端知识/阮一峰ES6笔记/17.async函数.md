# 一、含义

`async` 函数是什么？

一句话，**它就是 `Generator` 函数的语法糖。**

前文有一个 `Generator` 函数，依次读取两个文件。

```
const fs = require('fs');
const readFile = function (fileName) {
      return new Promise(function (resolve, reject) {
        fs.readFile(fileName, function(error, data) {
          if (error) return reject(error);
          resolve(data);
        });
      });
};

const gen = function* () {
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```

上面代码的函数`gen`可以写成`async`函数，就是下面这样。

```
const asyncReadFile = async function () {
  const f1 = await readFile('/etc/fstab');
  const f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```

一比较就会发现，**`async`函数就是将 `Generator` 函数的星号（*）替换成`async`，将`yield`替换成`await`，仅此而已。**

**`async`函数对 `Generator` 函数的改进**，体现在以下四点：

## 1、内置执行器

`Generator` 函数的执行必须靠执行器，所以才有了`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，与普通函数一模一样，只要一行。

```
 asyncReadFile();
```

**上面的代码调用了`asyncReadFile`函数，然后它就会自动执行，输出最后结果。这完全不像 `Generator` 函数，需要调用`next`方法，或者用`co`模块，才能真正执行，得到最后结果。**

## 2、更好的语义。

`async`和`await`，比起星号和`yield`，语义更清楚了。**`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。**

## 3、更广的适用性

`co`模块约定，`yield`命令后面只能是 `Thunk` 函数或 `Promise` 对象，而**`async`函数的`await`命令后面，可以是 `Promise` 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 `resolved` 的 `Promise` 对象）。**

## 4、返回值是`Promise`

进一步说，`async`函数完全可以看作多个异步操作，包装成的一个 `Promise` 对象，而`await`命令就是内部`then`命令的语法糖。

# 二、基本用法

**`async`函数返回一个 `Promise` 对象，可以使用`then`方法添加回调函数。**

**当函数执行的时候，一旦遇到`await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句** 

# 三、返回`Promise`对象

  - **`async`函数返回一个`Promise`对象**

  - **`async`函数内部`return`语句返回的值，会成为`then`方法回调函数的参数**

    ```
    async function f() {
      return 'hello world';
    }
    
    f().then(v => console.log(v))
    // "hello world"
    ```

    - 上面代码中，函数`f`内部`return`命令返回的值，会被`then`方法回调函数接收到。

    

  - **`async`函数内部抛出错误，会导致返回的 `Promise` 对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到。**

    	```
    async function f() {
        throw new Error('出错了');
    }
    f().then(
        v => console.log('resolve', v),
        e => console.log('reject', e)
    )
    //reject Error: 出错了
    ```
    
    ​    

# 四、`Promise`对象的状态变化

  - **`async`函数返回的 `Promise` 对象，必须等到内部所有`await`命令后面的 `Promise` 对象执行完，才会发生状态改变，除非遇到`return`语句或者抛出错误。也就是说，只有`async`函数内部的异步操作执行完，才会执行`then`方法指定的回调函数。**

  - 下面是一个例子。

    ```
    async function getTitle(url) {
      let response = await fetch(url);
      let html = await response.text();
      return html.match(/<title>([\s\S]+)<\/title>/i)[1];
    }
    getTitle('https://tc39.github.io/ecma262/').then(console.log)
    // "ECMAScript 2017 Language Specification"
    ```

  - 上面代码中，函数`getTitle`内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行`then`方法里面的`console.log`。

# 五、`await`命令

#### `await`命令后面是一个 `Promise` 对象

正常情况下，`await`命令后面是一个 `Promise` 对象，返回该对象的结果。

#### `await`命令后面如果不是 `Promise` 对象

**`await`命令后面如果不是 `Promise` 对象，就直接返回对应的值**

```
async function f() {
	  // 等同于
	  // return 123;
	  return await 123;
	}
f().then(v => console.log(v))
// 123
```

#### await命令后面是一个`thenable`对象（即定义了`then`方法的对象）

**`async` 函数可以保留运行堆栈。**

```
const a = () => {
  b().then(() => c());
};
```

上面代码中，函数`a`内部运行了一个异步任务`b()`。当`b()`运行的时候，函数`a()`不会中断，而是继续执行。等到`b()`运行结束，可能`a()`早就运行结束了，`b()`所在的上下文环境已经消失了。如果`b()`或`c()`报错，错误堆栈将不包括`a()`。

现在将这个例子改成`async`函数。

```
   const a = async () => {
     await b();
     c();
   };
```

上面代码中，**`b()`运行的时候，`a()`是暂停执行，上下文环境都保存着。一旦`b()`或`c()`报错，错误堆栈将包括`a()`。**


# 六、`async`函数的实现原理

  - `async` 函数的实现原理，就是将 `Generator` 函数和自动执行器，包装在一个函数里。

      ```
      async function fn(args) {
       	   // ...
       	}
       	// 等同于
       	function fn(args) {
       	    return spawn(function* () {
       	    // ...
       	    });
       	}
      ```

  - 所有的`async`函数都可以写成上面的第二种形式，其中的`spawn`函数就是自动执行器。

  - 下面给出`spawn`函数的实现，基本就是前文自动执行器的翻版。

    ```
    function spawn(genF) {
      return new Promise(function(resolve, reject) {
        const gen = genF();
        function step(nextF) {
          let next;
          try {
            next = nextF();
          } catch(e) {
            return reject(e);
          }
          if(next.done) {
            return resolve(next.value);
          }
          Promise.resolve(next.value).then(function(v) {
            step(function() { return gen.next(v); });
          }, function(e) {
            step(function() { return gen.throw(e); });
          });
        }
        step(function() { return gen.next(undefined); });
      });
    }
    ```

    

# 七、顶层`await`

  - 早期的语法规定是，`await`命令只能出现在 `async` 函数内部，否则都会报错。

    ```
    // 报错
    const data = await fetch('https://api.example.com');
    ```

    

  - 上面代码中，`await`命令独立使用，没有放在 `async` 函数里面，就会报错。

  - **从 `ES2022` 开始，允许在模块的顶层独立使用`await`命令，使得上面那行代码不会报错了。它的主要目的是使用`await`解决模块异步加载的问题。**

  - **注意，顶层`await`只能用在 `ES6` 模块，不能用在 `CommonJS` 模块。这是因为 `CommonJS` 模块的`require()`是同步加载，如果有顶层`await`，就没法处理加载了。**

  - 下面是顶层`await`的一些使用场景。

    		```
      // import() 方法加载
      const strings = await import(`/i18n/${navigator.language}`);
      // 数据库操作
        const connection = await dbConnector();
        // 依赖回滚
        let jQuery;
        try {
          jQuery = await import('https://cdn-a.com/jQuery');
        } catch {
          jQuery = await import('https://cdn-b.com/jQuery');
        }
      ```
      
        
      
  - **注意，如果加载多个包含顶层`await`命令的模块，加载命令是同步执行的。** 	

    		```
      // x.js
      console.log("X1");
      await new Promise(r => setTimeout(r, 1000));
      console.log("X2");
      // y.js
        console.log("Y");
        // z.js
        import "./x.js";
        import "./y.js";
        console.log("Z");
      ```
      
        
      
  - 上面代码有三个模块，最后的`z.js`加载`x.js`和`y.js`，打印结果是`X1`、`Y`、`X2`、`Z`。这说明，`z.js`并没有等待`x.js`加载完成，再去加载`y.js`。

  - 顶层的`await`命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。