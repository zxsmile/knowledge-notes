#  整体原理简述

## 先看现象：`$nextTick` 的“意外”

我们用一个简单的计数器例子来看看可能发生的情况：

![vue46](..\images\vue46.png)

当你点击按钮后，观察控制台输出，可能会得到类似这样的结果：

![vue47](..\images\vue47.png)

发现了吗？回调 `A`执行时，拿到的 `DOM` 内容显示的计数还是0，尽管同步代码里`count`已经变成了1。而回调 B则符合预期，拿到了更新后的内容1。

这个现象说明，`$nextTick`的执行时机并非简单地“等待 `DOM` 渲染完毕”。要理解它，我们得先补上两个关键的知识点。

## 图解核心交互流程

在深入细节前，我们先用一个时序图（`Sequence Diagram`）来描绘一下上面例子中，用户操作、数据修改、`$nextTick`调用以及最终 `DOM` 更新的大致流程：

![vue48](..\images\vue48.png)

这个图清晰地展示了回调函数和 `DOM` 更新任务是如何进入同一个队列，并按顺序执行的。接下来我们详细解释背后的机制。

#### 知识点一：浏览器的“时间管理员”——事件循环与微任务

浏览器运行 `JavaScript` 是单线程的，但它通过**事件循环（`Event Loop`）**机制来处理异步任务，避免阻塞。事件循环中有两种主要的任务队列：

1.**宏任务（`Macrotask`）队列：**存放`script`(整体代码块)、`setTimeout/setInterval`回调、`I/O` 操作、用户交互事件（如点击）等。每次事件循环，只会从这个队列里取出一个任务来执行。

2.**微任务（`Microtask`）队列：**存放`Promise.then/catch/finally`的回调、`MutationObserver`回调、`queueMicrotask`安排的任务，以及`Vue` 的`$nextTick`回调和 `DOM` 更新任务。

**关键规则：**在一个宏任务执行结束后，浏览器会**立即**检查微任务队列，并**清空**它，执行里面所有的微任务。如果在执行微任务的过程中，又产生了新的微任务，这些新来的也会在**当前这一轮**被执行掉，直到微任务队列彻底干净为止。然后才可能进行 `UI` 渲染，并开始下一轮的事件循环（取下一个宏任务）。

**这意味着微任务拥有极高的优先级**，它们总是在当前同步代码执行完、下一次渲染发生前被集中处理掉。

#### 知识点二：`Vue` 的“智能更新”——异步 `DOM` 更新

当你修改 `Vue` 组件里的数据（比如`this.count = 1`）时，`Vue` 并不会立刻冲过去更新真实的 `DOM` 。这是出于性能考虑：如果短时间内连续修改多次数据，频繁操作 `DOM` 会非常消耗性能。

#### `Vue` 的策略是**异步批量更新**：

1.**侦测变化：**数据一变，依赖这个数据的 `Watcher`（观察者）就会收到通知。

2.**入队缓冲：**负责更新视图的那个 `Watcher（Render Watcher）`，不会马上干活。它会调用一个内部函数`queueWatcher`，把自己添加到一个**异步更新队列**里。这个过程会进行去重处理，保证同一个 `Watcher` 在一个更新周期里只进来一次。

3.**调度执行：**`queueWatcher`函数最关键的一步，是调用了`nextTick`，并把一个叫`flushSchedulerQueue`的函数作为回调传进去。这个`flushSchedulerQueue`函数的任务就是遍历整个异步更新队列，执行所有待更新 `Watcher` 的`run`方法，最终触发 `Virtual DOM` 的比对和真实 `DOM` 的更新。

##### 划重点：`Vue` 本身就是用`nextTick`来安排 `DOM` 更新的！`DOM` 更新操作，是被 `Vue` 打包成了一个任务，放进了微任务队列等待执行。

#### 解密时刻：`$nextTick` 与 `DOM` 更新的“共享通道”

现在我们来看看`this.$nextTick(callback)`的内部运作（基于 `Vue 2.x` 简化逻辑）：

1.**回调收集站 (`callbacks`数组)：**你每次调用`this.$nextTick(fn)，`你的函数`fn`都会被推进这个全局的`callbacks`数组里排队。

2.**异步调度开关 (`pending`标志)：**用一个`pending`变量（初始为`false`）来确保在同一个事件循环“`tick`”内，只启动一次异步任务去处理`callbacks`队列。

- 当第一次调用`nextTick`时，发现`pending`是`false`，就把它设为`true`，然后调用`timerFunc`。`timerFunc`会优先尝试用`Promise.resolve().then(flushCallbacks)`（这是微任务）来异步触发`flushCallbacks`函数。如果环境不支持 `Promise`，它会依次尝试`MutationObserver`（微任务）、`setImmediate`（宏任务，`Node` 环境）、最后是`setTimeout(flushCallbacks, 0)`（宏任务）。目标是尽快把`flushCallbacks`的执行塞进异步队列，微任务是最佳选择。

- 如果在同一个“`tick`”内后续再调用`nextTick`，此时`pending`已经是`true`了，就不会再调用`timerFunc`，只是简单地把新的回调函数加到`callbacks`数组末尾。

3.**回调执行官 (`flushCallbacks`函数)：**当事件循环执行到那个被`timerFunc`安排的异步任务时（通常是微任务阶段），`flushCallbacks`函数就会被调用。它干几件事：

- 把`pending`设回`false`，表示这一批次的异步处理开始了，允许下一轮再启动新的。
- **非常重要：**创建`callbacks`数组的一个**副本**(`copies = callbacks.slice(0)`)。
- 清空原来的`callbacks`数组 (`callbacks.length = 0`)。
- 遍历那个**副本**(`copies`)，按顺序执行里面的每一个回调函数。

#### 核心真相：

**无论是你自己写的`this.$nextTick(yourCallback)`，还是 `Vue` 内部为了安排 `DOM` 更新调用的`nextTick(flushSchedulerQueue)`，它们的回调函数，最终都进入了同一个`callbacks`数组！**

**执行顺序揭晓：先来后到，排队执行！**

既然大家都在一个队列里排队，并且`flushCallbacks`是按顺序执行的，那么：

在一个事件循环的“`tick`”内（即一次宏任务及其随后的所有微任务处理期间）：

- DOM 更新任务 (`flushSchedulerQueue`) 和你的`$nextTick`回调的**实际执行顺序**，就取决于它们被添加到`callbacks`数组的**先后次序**。

- 谁先调用了`nextTick`把自己的回调塞进去，谁的回调就在队列前面，在接下来的微任务处理阶段就会被`flushCallbacks`先执行到。

#### 再看开头的例子，豁然开朗：

在`increment`方法里：

1、`this.$nextTick(回调A)`先执行，回调`A`第一个进入`callbacks`数组。[回调`A`]。并安排了微任务`flushCallbacks`。

2、`this.count += 1`执行，触发内部 `DOM` 更新流程，调用`nextTick(DOM更新任务)`，`DOM`更新任务进入数组。[回调`A`, `DOM`更新任务]。

3、`this.$nextTick(回调B)`执行，回调`B`进入数组。[回调`A`, `DOM`更新任务, 回调`B`]。

4、同步代码结束。

5、事件循环进入微任务阶段，执行`flushCallbacks`。

6、`flushCallbacks`按副本[回调`A`, `DOM`更新任务, 回调`B`]的顺序执行：

- 执行回调`A`：此时`DOM`更新任务还没执行，`DOM` 没变，所以看到当前计数: 0。
- 执行`DOM`更新任务：`Vue` 更新 `DOM`，内容变为当前计数: 1。
- 执行回调`B`：此时 `DOM` 刚刚更新完，所以看到当前计数: 1。

**如何确保回调在 `DOM` 更新后执行？**

理解了原理，答案就很清晰了。要想让你的`$nextTick`回调稳定地在 `DOM` 更新之后执行，最佳实践是：

**始终先完成数据修改操作，然后再调用`this.$nextTick`。**

![vue49](..\images\vue49.png)

遵循这个模式，数据修改会先触发 `Vue` 内部调用`nextTick`来安排 `DOM` 更新。你随后调用的`this.$nextTick`则将你的回调放在更新任务之后。这样，在微任务阶段，`DOM` 更新就自然地先执行了。

#### `microtask`

从名字看，我们可以把它称为微任务。对应的，`task`队列中的任务也被叫做`macrotask`。名字相似，性质可不一样了。

每一次事件循环都包含一个`microtask`队列，在循环结束后会依次执行队列中的`microtask`并移除，然后再开始下一次事件循环。

在执行`microtask`的过程中后加入`microtask`队列的微任务，也会在下一次事件循环之前被执行。也就是说，`macrotask`总要等到`microtask`都执行完后才能执行，`microtask`有着更高的优先级。

`microtask`的这一特性，简直是做队列控制的最佳选择啊！`vue`进行`DOM`更新内部也是调用`nextTick`来做异步队列控制。而当我们自己调用`nextTick`的时候，它就在更新`DOM`的那个`microtask`后追加了我们自己的回调函数，从而确保我们的代码在`DOM`更新后执行，同时也避免了`setTimeout`可能存在的多次执行问题。

常见的`microtask`有：`Promise`、`MutationObserver`、`Object.observe`(废弃)，以及`nodejs`中的`process.nextTick`

咦？好像看到了`MutationObserver`，难道说`vue`用`MO`是想利用它的`microtask`特性，而不是想做`DOM`监听？对喽，就是这样的。核心是`microtask`，用不用`MO`都行的。事实上，`vue`在2.5版本中已经删去了`MO`相关的代码，因为它是`HTML5`新增的特性，在`iOS`上尚有`bug`。

那么最优的`microtask`策略就是`Promise`了，而令人尴尬的是，`Promise`是`ES6`新增的东西，也存在兼容问题呀~ 所以`vue`就面临一个降级策略。

#### `vue`的降级策略

上面我们讲到了，队列控制的最佳选择是`microtask`，而`microtask`的最佳选择是`Promise`.但如果当前环境不支持`Promise`，`vue`就不得不降级为`macrotask`来做队列控制了。

`macrotask`有哪些可选的方案呢？前面提到了`setTimeout`是一种，但它不是理想的方案。因为`setTimeout`执行的最小时间间隔是`13ms`的样子，略微有点延迟。还有其他的方案吗？

不卖关子了，在`vue2.5`的源码中，`macrotask`降级的方案依次是：`setImmediate`、`MessageChannel`、`setTimeout`.

`setImmediate`是最理想的方案了，可惜的是只有`IE`和`nodejs`支持。

`MessageChannel`的`onmessage`回调也是`microtask`，但也是个新`API`，面临兼容性的尴尬...

所以最后的兜底方案就是`setTimeout`了，尽管它有执行延迟，可能造成多次渲染，算是没有办法的办法了。

#### 总结

`$nextTick`并非是一个神奇的“等待 `DOM` 渲染完成”的指令，它更准确的身份是**“将回调推迟到下一个微任务队列中执行”**的调度器。

因为 `Vue` 的 `DOM` 更新本身也依赖`nextTick`机制，并且用户调用和内部调用共享同一个回调队列，所以它们的执行顺序取决于谁先“挂号”（注册回调）。

记住**“先改数据，后`$nextTick`”**这个简单有效的实践原则，就能在绝大多数场景下确保你的回调在 `DOM` 更新后运行。理解了这层原理，下次再遇到关于`$nextTick`的时序问题，你就能从容应对，精准定位啦！

`vue`用异步队列的方式来控制`DOM`更新和`nextTick`回调先后执行

`microtask`因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕

因为兼容性问题，`vue`不得不做了`microtask`向`macrotask`的降级方案

# 一、前言

此篇主要手写 `Vue2.0` 源码-**异步更新原理**

上一篇咱们主要介绍了 `Vue` 渲染更新原理咱们已经可以实现数据改变 视图自动更新了 那么此篇主要是对视图更新的性能优化 包含 `nextTick` 这一重要的 `api` 实现

```html
<script>
  // Vue实例化
  let vm = new Vue({
    el: "#app",
    data() {
      return {
        a: 123,
      };
    },
    // render(h) {
    //   return h('div',{id:'a'},'hello')
    // },
    template: `<div id="a">hello {{a}}</div>`,
  });

  // 当我们每一次改变数据的时候  渲染watcher都会执行一次 这个是影响性能的
  setTimeout(() => {
    vm.a = 1;
    vm.a = 2;
    vm.a = 3;
  }, 1000);
</script>
```

大家思考一下 按照之前的逻辑 每次我们改变数据的时候都会触发相应的 `watcher` 进行更新 如果是渲染 `watcher` 那是不是意味着 数据变动一次 就会重新渲染一次 这样其实是很浪费性能的 我们有没有更好的方法 让数据变动完毕后统一去更新视图呢

# 二、`watcher` 更新的改写

```javascript
// src/observer/watcher.js

import { queueWatcher } from "./scheduler";
export default class Watcher {
  update() {
    // 每次watcher进行更新的时候  是否可以让他们先缓存起来  之后再一起调用
    // 异步队列机制
    queueWatcher(this);
  }
  run() {
    // 真正的触发更新
    this.get();
  }
}
```

我们把 `update` 更新方法改一下 增加异步队列的机制

#### 三、`queueWatcher` 实现队列机制

```javascript
// src/observer/scheduler.js

import { nextTick } from "../util/next-tick";
let queue = [];
let has = {};
function flushSchedulerQueue() {
  for (let index = 0; index < queue.length; index++) {
    //   调用watcher的run方法 执行真正的更新操作
    queue[index].run();
  }
  // 执行完之后清空队列
  queue = [];
  has = {};
}

// 实现异步队列机制
export function queueWatcher(watcher) {
  const id = watcher.id;
  //   watcher去重
  if (has[id] === undefined) {
    //  同步代码执行 把全部的watcher都放到队列里面去
    queue.push(watcher);
    has[id] = true;
    // 进行异步调用
    nextTick(flushSchedulerQueue);
  }
}
}
```

新建 `scheduler.js` 文件 表示和调度相关 先同步把 `watcher` 都放到队列里面去 执行完队列的事件之后再清空队列 主要使用 `nextTick` 来执行 `watcher` 队列

#### 四、`nextTick` 实现原理

```javascript
// src/util/next-tick.js

let callbacks = [];
let pending = false;
function flushCallbacks() {
  pending = false; //把标志还原为false
  // 依次执行回调
  for (let i = 0; i < callbacks.length; i++) {
    callbacks[i]();
  }
}
let timerFunc; //定义异步方法  采用优雅降级
if (typeof Promise !== "undefined") {
  // 如果支持promise
  const p = Promise.resolve();
  timerFunc = () => {
    p.then(flushCallbacks);
  };
} else if (typeof MutationObserver !== "undefined") {
  // MutationObserver 主要是监听dom变化 也是一个异步方法
  let counter = 1;
  const observer = new MutationObserver(flushCallbacks);
  const textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true,
  });
  timerFunc = () => {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
} else if (typeof setImmediate !== "undefined") {
  // 如果前面都不支持 判断setImmediate
  timerFunc = () => {
    setImmediate(flushCallbacks);
  };
} else {
  // 最后降级采用setTimeout
  timerFunc = () => {
    setTimeout(flushCallbacks, 0);
  };
}

export function nextTick(cb) {
  // 除了渲染watcher  还有用户自己手动调用的nextTick 一起被收集到数组
  callbacks.push(cb);
  if (!pending) {
    // 如果多次调用nextTick  只会执行一次异步 等异步队列清空之后再把标志变为false
    pending = true;
    timerFunc();
  }
}
```

新建 `util/next-tick.js` 代表工具类函数 因为 `nextTick` 用户也可以手动调用 主要思路就是采用微任务优先的方式调用异步方法去执行 `nextTick` 包装的方法

# 五、`$nextTick` 挂载原型

```javascript
// src/render.js

import { nextTick } from "./util/next-tick";

export function renderMixin(Vue) {
  // 挂载在原型的nextTick方法 可供用户手动调用
  Vue.prototype.$nextTick = nextTick;
}
```

最后把`$nextTick` 挂载到 `Vue` 的原型

# 六、异步更新的思维导图

![vue16](..\images\vue16.png)