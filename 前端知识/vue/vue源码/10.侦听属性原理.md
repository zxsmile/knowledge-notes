```html
<script>
  // Vue实例化
  let vm = new Vue({
    el: "#app",
    data() {
      return {
        aa: 1,
        bb: 2,
      };
    },
    template: `<div id="a">hello 这是我自己写的Vue{{name}}</div>`,
    methods: {
      doSomething() {},
    },
    watch: {
      aa(newVal, oldVal) {
        console.log(newVal);
      },
      // aa: {
      //   handle(newVal， oldVal) {
      //     console.log(newVal);
      //   },
      //   deep: true
      // },
      // aa: 'doSomething',
      // aa: [{
      //   handle(newVal， oldVal) {
      //     console.log(newVal);
      //   },
      //   deep: true
      // }]
    },
  });
  setTimeout(() => {
    vm.aa = 1111;
  }, 1000);
</script>
```

侦听属性的写法很多 可以写成 字符串 函数 数组 以及对象 对于对象的写法自己可以增加一些 `options` 用来增强功能 侦听属性的特点是监听的值发生了变化之后可以执行用户传入的自定义方法

# 一、侦听属性的初始化

```javascript
// src/state.js

// 统一初始化数据的方法
export function initState(vm) {
  // 获取传入的数据对象
  const opts = vm.$options;
  if (opts.watch) {
    //侦听属性初始化
    initWatch(vm);
  }
}

// 初始化watch
function initWatch(vm) {
  let watch = vm.$options.watch;
  for (let k in watch) {
    const handler = watch[k]; //用户自定义watch的写法可能是数组 对象 函数 字符串
    if (Array.isArray(handler)) {
      // 如果是数组就遍历进行创建
      handler.forEach((handle) => {
        createWatcher(vm, k, handle);
      });
    } else {
      createWatcher(vm, k, handler);
    }
  }
}
// 创建watcher的核心
function createWatcher(vm, exprOrFn, handler, options = {}) {
  if (typeof handler === "object") {
    options = handler; //保存用户传入的对象
    handler = handler.handler; //这个代表真正用户传入的函数
  }
  if (typeof handler === "string") {
    //   代表传入的是定义好的methods方法
    handler = vm[handler];
  }
  //   调用vm.$watch创建用户watcher
  return vm.$watch(exprOrFn, handler, options);
}
```

`initWatch`初始化Watch对数组进行处理  `createWatcher`处理`Watch`的兼容性写法 包含字符串 函数 数组 以及对象 最后调用`$watch` 传入处理好的参数进行创建用户`Watcher`

# 二、`$watch`

```javascript
//  src/state.js
import Watcher from "./observer/watcher";
Vue.prototype.$watch = function (exprOrFn, cb, options) {
  const vm = this;
  options = options || {}
  options.user = true
  //  user: true 这里表示是一个用户watcher
  let watcher = new Watcher(vm, exprOrFn, cb, { ...options, user: true });
  // 如果有immediate属性 代表需要立即执行回调
  if (options.immediate) {
    cb(); //如果立刻执行
  }
};
```

原型方法`$watch` 就是创建自定义 `watch` 的核心方法 把用户定义的 `options` 和 `user:true` 传给构造函数 `Watcher`

这里我们看到 `vm.$watch` 其实是生成了 `Watcher` 对象，有这几个地方要康康：

- `expOrFn`，这里是需要监听的属性值。
- `options.user`，表明是用户定义的，watcher 更新时会调用用户定义的回调函数 `cb`。
- `options.immediate`，立即求值，一开始就会传递当前值到定义的侦听函数。

## `expOrFn`

这里我重点说一下 `expOrFn`。`expOrFn` 是可以支持属性表达式的，按照 `Vue` 文档的说法：

> 观察 `Vue` 实例上的一个表达式或者一个函数计算结果的变化。

也就是说可以像这样去设置：

```javascript
vm.$watch('a.b', function (newVal, oldVal) {
  // 属性 a 改变或者 a.b 改变都会触发
})

vm.$watch(
  function () {
    return this.c + this.d
  },
  function (newVal, oldVal) {
    // 属性 c 改变或者 d 改变都会触发
  }
)
```

第一种情况下 `expOrFn` 是表达式。在 `src/core/observer/watcher.js` 中找到 `Watcher` 的构造函数：

```javascript
  // 如果表达式是一个函数
    if (typeof exprOrFn === "function") {
      this.getter = exprOrFn;
    } else {
      this.getter = function () {
        //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b
        let path = exprOrFn.split(".");
        let obj = vm;
        for (let i = 0; i < path.length; i++) {
          obj = obj[path[i]]; //按照watcher传过来的字符串a.a.a.a.b一步一步按顺序找属性                                 vm.a.a.a.a.b
        }
        return obj;
      };
    }
```

上面是按照表达式的路径顺序（`a.a.a.a.b`）去逐步获得路径上的属性（对象）以及最后的值。这里我们回忆下 `defineReactive`，按顺序去访问表达式路径上的属性会触发属性的 `get`，这样就建立了依赖关系（路径上的所有属性都会），当涉及的属性变化时就会通知 watcher 了~ 同理第二种情况下是一个函数也是一样的。

# 三、`Watcher` 改造

```javascript
// src/observer/watcher.js

import { isObject } from "../util/index";
export default class Watcher {
  constructor(vm, exprOrFn, cb, options) {
    // this.vm = vm;
    // this.exprOrFn = exprOrFn;
    // this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法
    // this.options = options; //额外的选项 true代表渲染watcher
    // this.id = id++; // watcher的唯一标识
    // this.deps = []; //存放dep的容器
    // this.depsId = new Set(); //用来去重dep

    this.user = options.user; //标识用户watcher

    // 如果表达式是一个函数
    if (typeof exprOrFn === "function") {
      this.getter = exprOrFn;
    } else { // 如果是字符串对象路径形式，返回闭包函数
      this.getter = function () {
        //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b
        let path = exprOrFn.split(".");
        let obj = vm;
        for (let i = 0; i < path.length; i++) {
          obj = obj[path[i]]; //vm.a.a.a.a.b
        }
        return obj;
      };
    }
    // 实例化就进行一次取值操作 进行依赖收集过程
    this.value = this.get();
  }
     get() {
       pushTarget(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上
       const res = this.getter.call(this.vm); //如果watcher是渲染watcher 那么就相当于执行  vm._update(vm._render()) 这个方法在render函数执行的时候会取值 从而实现依赖收集
       if (this.deep) {  // 如果有定义deep属性
         traverse(value)  // 进行深度监听
        }
       popTarget(); // 在调用方法之后把当前watcher实例从全局Dep.target移除
       return res;
    }
  //   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次
     addDep(dep) {
       let id = dep.id;
       if (!this.depsId.has(id)) {
         this.depsId.add(id);
         this.deps.push(dep);
         //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面
         dep.addSub(this);
       }
     }
  //   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了
  // 执行派发更新
     update() {
       // 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算
      if (this.lazy) {
         this.dirty = true;
       }else if (this.sync) {// 如果有设置sync为true
         this.run()// 不走nextTick队列，直接执行
       }else{
         // 否则加入队列，异步执行run()
         // 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用
         // 异步队列机制
        queueWatcher(this);
       }
     }
    
     depend(){
       // 计算属性的watcher存储了依赖项的dep
       let i=this.deps.length
       while(i--){
         this.deps[i].depend() //调用依赖项的dep去收集渲染watcher
       }
     }
           
  run() {
    const newVal = this.get(); //// 重新求值，新值
    const oldVal = this.value; //缓存之前的值，老值
    this.value = newVal; //现在的新值将成为下一次变化的老值
    if (this.user) {//如果是user-watcher
      // 如果两次的值不相同  或者值是引用类型 因为引用类型新老值是相等的 他们是指向同一引用地址
      if (newVal !== oldVal || isObject(newVal)) {
        this.cb.call(this.vm, newVal, oldVal);
      }
    } else {
      // 渲染watcher
      this.cb.call(this.vm);
    }
  }
}
```

咱们主要关注非注释的地方  这里主要改造有两点

1.实例化的时候为了兼容用户 `watch` 的写法 会将传入的字符串写法转成 `Vue` 实例对应的值 并且调用 `get` 方法获取并保存一次旧值

2.`run` 方法判断如果是用户 `watch` 那么执行用户传入的回调函数 `cb` 并且把新值和旧值作为参数传入进去

## 监听属性的`deep`深度监听原理

之前的`get`方法内有说明，如果有`deep`属性，则执行`traverse`方法：

```
const seenObjects = new Set()  // 不重复添加

function traverse (val) {
  _traverse(val, seenObjects)
  seenObjects.clear()
}

function _traverse (val, seen) {
  let i, keys
  const isA = Array.isArray(val)  // val是否是数组
  
  if ((!isA && !isObject(val))  // 如果不是array和object
        || Object.isFrozen(val)  // 或者是已经冻结对象
        || val instanceof VNode) {  // 或者是VNode实例
    return  // 再见
  }
  
  if (val.__ob__) {  // 只有object和array才有__ob__属性
    const depId = val.__ob__.dep.id  // 手动依赖收集器的id
    if (seen.has(depId)) {  // 已经有收集过
      return  // 再见
    }
    seen.add(depId)  // 没有被收集，添加
  }
  
  if (isA) {  // 是array
    i = val.length
    while (i--) {
      _traverse(val[i], seen)  // 递归触发每一项的get进行依赖收集
    }
  } 
  
  else {  // 是object
    keys = Object.keys(val)
    i = keys.length
    while (i--) {
      _traverse(val[keys[i]], seen)  // 递归触发子属性的get进行依赖收集
    }
  }
}
```

看着还挺复杂，简单来说`deep`的实现原理就是递归的触发数组或对象的`get`进行依赖收集，因为只有数组和对象才有`__ob__`属性，也就是我们第七章说明的手动依赖管理器，将它们的依赖收集到`Observer`类里的`dep`内，完成`deep`深度监听。

> `watch`总结：这里说明了为什么`watch`和`this.$watch`的实现是一致的，以及简单解释它的原理就是为需要观察的数据创建并收集`user-watcher`，当数据改变时通知到`user-watcher`将新值和旧值传递给用户自己定义的回调函数。最后分析了定义`watch`时会被使用到的三个参数：`sync`、`immediate`、`deep`它们的实现原理。简单说明它们的实现原理就是：`sync`是不将`watcher`加入到`nextTick`队列而同步的更新、`immediate`是立即以得到的值执行一次回调函数、`deep`是递归的对它的子值进行依赖收集。



# 四、侦听属性的思维导图

![vue19](..\images\vue19.png)

# 五、实例演示`watch`流程

```
watch监听属性示例：
<template>  
  <div>{{name}}</div>
</template>

export default {  // App组件
  data() {
    return {
      name: 'cc'
    }
  },
  watch: {
    name(newName, oldName) {...}  // 派发新值和旧值给回调
  },
  mounted() {
    setTimeout(() => {  
      this.name = 'ww'  // 触发name的set
    }, 1000)
  }
}

```

![vue23](..\images\vue23.png)