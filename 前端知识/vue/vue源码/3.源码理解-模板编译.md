# 简答

## `Vue`模版编译原理

`vue`中的模板`template`无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的`HTML`语法，所有需要将`template`转化成一个`JavaScript`函数，这样浏览器就可以执行这一个函数并渲染出对应的`HTML`元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析`parse`，优化`optimize`，生成`generate`，最终生成可执行函数`render`。

- **解析阶段**：使用大量的正则表达式对`template`字符串进行解析，将标签、指令、属性等转化为抽象语法树`AST`。
- **优化阶段**：遍历`AST`，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行`diff`比较时，直接跳过这一些静态节点，优化`runtime`的性能。
- **生成阶段**：将最终的`AST`转化为`render`函数字符串。

# 一、什么是模板编译？(`runtime-compiler`版本) #

- 模板编译的主要功能是将模板编译成为渲染函数，而渲染函数则会根据应用状态生成 `vnode`，再通过 `vnode` 进行渲染。

- 在 `Vue.js` 中，模板编译可分为下面三个部分：

   - 解析器：将模板解析为 `AST`
   
   - 优化器：遍历 `AST` 标记静态节点

   - 代码生成器：使用 `AST` 生成渲染函数

![vue源码3](..\images\vue源码3.png)

###### 1.1、解析器

  - **前面提到解析器的作用就是将模板解析成 `AST`，其中又包括过滤器解析器，文本解析器和 `HTML` 解析器。**
  
  - **过滤器解析器顾名思义是用来解析模板中的过滤器的，文本解析器是用来解析带变量的文本，最重要的就是 `HTML` 解析器。**
  
  - **`HTML` 解析器用于解析 `HTML` 标签的起始位置，结束位置，文本，注释等等，并触发钩子函数，每当钩子函数被触发，就会生成一个对应的 `AST` 节点。**
  
  - **`AST` 节点其实和 `vNode` 有些类似，都是用对象来表明的，一个对象表示一个节点，对象中的属性用于存储节点的各类信息**，可以看下面的例子：

	```
	// 原始模板
	
	<div>
	  <p>{{name}}</p>
	</div>
	
	
	// 转为AST后
	
	{
	  tag: 'div',
	  type: 1,
	  staticRoot: false,
	  static: false,
	  plain: true,
	  parent: undefined,
	  attrsList: [],
	  attrsMap: {},
	  children: [
	    {
	      tag: 'p',
	      type: 1,
	      staticRoot: false,
	      static: false,
	      plain: true,
	      parent: {tag: 'div', ...},
	      attrsList: [],
	      attrsMap: {},
	      children: [
	        {
	          type: 2,
	          text: '{{name}}',
	          static: false,
	          expression: '_s(name)'
	        }
	      ]
	    }
	  ]
	}
	```
	
	

###### 1.2、HTML解析器

  - 前面提到 `HTML` 解析器在解析过程中会触发各种钩子函数，包括标签钩子函数、结束钩子函数、文本钩子函数以及注释钩子函数。伪代码如下：

  ```
  parseHTML(template, {
  
    start(tag, attrs, unary) {
      // 每当解析到标签开始位置时，触发该函数
    },
    end () {
      // 解析到标签结束位置时触发
    },
    chars(text) {
      // 解析到文本时触发
    },
    comment(text) {
      // 解析到注释时触发
    }
  
  })
  ```

  - 正是这些钩子函数的存在帮助我们构建 `AST` 节点。在 `start` 函数中创建构建元素内容的节点，在 `chars` 函数中创建文本节点，在 `comment` 函数中构建注释节点。当钩子函数不再触发后，就说明模板解析完毕，`AST` 构建完成。

# 二、`new`一个`Vue`实例 #

	let vue = new Vue({
	  render: h => h(App)
	}).$mount('#app')
	
	console.log(vue)

平时都是使用`vue-cli`开发，`vue-cli`给我们配置的很齐全，所以我们可能会忽略了入口文件里`Vue`实例是怎么去`new`的，`id`为`app`的`div`标签是怎么渲染到页面的。

```
// 此代码只是演示
let vue = new Vue({
    el: '#app',
    data() {
        return {
            a: 1,
            b: [1]
        }
    },
    render(h) {
        return h('div', { id: 'hhh' }, 'hello')
    },
    template: `<div id='hhh' style="aa:1;bb:2"><a>{{xxx}}{{ccc}}</a></div>`
}).$mount('#app')

console.log(vue)
```

举个例子，上面的代码，有`el`，有`template`，有`render`，有`$mount`，但是渲染只能是渲染一次，那么，这几个东西里谁有权力去渲染这一次呢，或者说，谁的权力最大呢？

这是官网上的一张图：

![vue源码2](..\images\vue源码2.png)

通过上图，可以总结为以下几点：

1. 渲染到哪个根节点上：判断有无`el`属性，有的话直接获取`el`根节点，没有的话调用`$mount`去获取根节点

2. 渲染哪个模板：

- 有`render`：这时候优先执行`render`函数，`render`优先级 > `template`
- 无`render`：
  - 有`template`：拿`template`去解析成`render`函数的所需的格式，并使用调用`render`函数渲染
  - 无`template`：拿`el`根节点的`outerHTML`去解析成`render`函数的所需的格式，并使用调用`render`函数渲染

3. 渲染的方式：无论什么情况，最后都统一是要使用render函数渲染

# 三、重点实现 #

1.`$mount`函数的实现

2.解析`template`成抽象语法树（`AST`）

3.将抽象语法树（`AST`）转成`render`渲染所需的格式

# 四、`$mount`函数 #

$mount函数重点在于判断各属性的有无情况，还有记得返回`Vue`实例，便于后续访问实例

```
// src/init.js

import { initState } from "./state";
import { compileToFunctions } from "./compiler/index";
export function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    const vm = this;
    // 这里的this代表调用_init方法的对象(实例对象)
    //  this.$options就是用户new Vue的时候传入的属性
    vm.$options = options;
    // 初始化状态
    initState(vm);

    // 如果有el属性 进行模板渲染
    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };

  // 这块代码在源码里面的位置其实是放在vue/src/platforms/web/runtime-with-compiler.js里面
  // 代表的是Vue源码里面包含了compile编译功能 这个和runtime-only版本需要区分开
  Vue.prototype.$mount = function (el) {
    const vm = this;
    const options = vm.$options;
    el = document.querySelector(el);

    // 如果不存在render属性
    if (!options.render) {
      // 如果存在template属性
      let template = options.template;

      if (!template && el) {
        // 如果不存在render和template 但是存在el属性 直接将模板赋值到el所在的外层html结构（就是el本身 并不是父元素）
        template = el.outerHTML;
      }

      // 最终需要把tempalte模板转化成render函数
      if (template) {
        const render = compileToFunctions(template);
        options.render = render;
      }
    }
  };
}
```



# 五、`compileToFunctions`函数 #	

- `compileToFunctions`函数是模板编译的入口函数，包含`parse`和`generate`的执行，返回值是一个`render`函数

	```
	// src/compiler/index.js
	
	import { parse } from "./parse";
	import { generate } from "./codegen";
	
	export function compileToFunctions(template) {
	
	  // 我们需要把html字符串变成render函数
	  // 1.把html代码转成ast语法树  ast用来描述代码本身形成树结构 不仅可以描述html 也能描述css以及js语法
	  // 很多库都运用到了ast 比如 webpack babel eslint等等
	  let ast = parse(template);
	
	  // 2.优化静态节点
	  // 这个有兴趣的可以去看源码  不影响核心功能就不实现了
	  //   if (options.optimize !== false) {
	  //     optimize(ast, options);
	  //   }
	
	  // 3.通过ast 重新生成代码
	  // 我们最后生成的代码需要和render函数一样
	  // 类似_c('div',{id:"app"},_c('div',undefined,_v("hello"+_s(name)),_c('span',undefined,_v("world"))))
	  // _c代表创建元素 _v代表创建文本 _s代表文Json.stringify--把对象解析成文本
	  let code = generate(ast);
	
	  //   使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值
	  let renderFn = new Function(`with(this){return ${code}}`);
	
	  return renderFn;
	}
	```
	
	新建 `compiler` 文件夹 表示编译相关功能 核心导出 `compileToFunctions` 函数 主要有三个步骤:
	
	1.生成 `ast` 
	
	2.优化静态节点 
	
	3.根据 `ast` 生成 `render` 函数


# 六、解析 `html` 并生成 `ast` #	

	// src/compiler/parse.js
	
	// 以下为源码的正则);
	
	const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`; //匹配标签名 形如 abc-123
	
	正则表达式解释：标签名的第一个元素可以是：大小写字母和_，后面的元素可以是0或多个：-、.、数字、_、大小写字母
	
	const qnameCapture = `((?:${ncname}\\:)?${ncname})`; //匹配特殊标签 形如 abc:234 前面的abc:可有可无
	
	正则表达式解释：
	    - ()：当你把一个正则表达式用一对小括号包起来的时候，就形成了一个捕获组。它会把括号里面的正则表达式匹配到的内容保存到该分组里面。  
	
	    - (?:)：非捕获组的语法是在捕获组的基础上，在左括号的右侧加上?:就可以了，那就是(?:)，既然是非捕获组，那它就不会把正则匹配到的内容保存到分组里面。这样可以进行分组而不进行捕获，括号只表示最原始的功能---划分整体
	    - (?:[a-zA-Z_][\\-\\.0-9_a-zA-Z]*\\:)? 这个?表示0或1次，这里匹配的是有命名空间的标签，比如：<namespace:xxx>
	 
	    - ((?:[a-zA-Z_][\\-\\.0-9_a-zA-Z]*\\:)?[a-zA-Z_][\\-\\.0-9_a-zA-Z]*)  这个完整正则表示匹配<namespace:xxx>或者<xxx>


	const startTagOpen = new RegExp(`^<${qnameCapture}`); // 匹配标签开始 形如 <abc-123 捕获里面的标签名
	正则表达式解释：
	    - 这里在上面正则的基础上加了一个以<开头，^<((?:[a-zA-Z_][\\-\\.0-9_a-zA-Z]*\\:)?[a-zA-Z_][\\-\\.0-9_a-zA-Z]*)表示匹配<namespace:xxx或者<xxx


	const startTagClose = /^\s*(\/?)>/; // 匹配标签结束  >
	正则表达式解释：
		- ^\s*表示0或者多个空格
		- (\/?)表示0或者1个/
		- /^\s*(\/?)>/整体表示匹配: >、/>
		
	const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`); // 匹配标签结尾 如 </abc-123> 捕获里面的标签名
		
	正则表达式解释：
		- ^<\\/((?:[a-zA-Z_][\\-\\.0-9_a-zA-Z]*\\:)?[a-zA-Z_][\\-\\.0-9_a-zA-Z]*)[^>]*>  匹配结束标签


​	

​		
​	const attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/; // 匹配属性  形如 id="app"
​	
	正则表达式解释：
		- [^] 表示对上面一个集合取非，[^abc]表示除a、b、c之外的单个字符
	    - ^\s* 表示以0或多个空格开头
		- ([^\s"'<>\/=]+)表示属性名不能有空格、"、'、<、>、/、=
		- (?:\s*(=)\s* 表示 = 前后可以有0或多个空格
		- "([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)? 表示属性值是前后双引号形式，中间的属性值只要不是双引号1或多次，或者前后单引号形式，中间的属性值只要不是单引号1或多次，或者没有双引号和单引号属性值名字除了空格、"、'、<、>、`、=，?表示属性值可有可无  例如：a = "kk"或 a = 'kk' 或 a = kk 或 a=
		- 上面的属性正则表达式中，属性名是分组1、等号是分组2、属性值是分组3/分组4/分组5
		
	let root, currentParent; //代表根节点 和当前父节点
		
	// 栈结构 来表示开始和结束标签
	let stack = [];
		
	// 标识元素和文本type
	const ELEMENT_TYPE = 1;
	const TEXT_TYPE = 3;
	
	// 生成ast方法
	function createASTElement(tagName, attrs) {
	  return {
	    tag: tagName,
	    type: ELEMENT_TYPE,
	    children: [],
	    attrs,
	    parent: null,
	  };
	}
	
	// 对开始标签进行处理
	function handleStartTag({ tagName, attrs }) {
	  let element = createASTElement(tagName, attrs);
	  if (!root) {
	    root = element;
	  }
	  currentParent = element;
	  stack.push(element);
	}
	
	// 对结束标签进行处理
	function handleEndTag(tagName) {
	  // 栈结构 []
	  // 比如 <div><span></span></div> 当遇到第一个结束标签</span>时 会匹配到栈顶<span>元素对应的ast 并取出来
	  let element = stack.pop();
	
	  // 当前父元素就是栈顶的上一个元素 在这里就类似div
	  currentParent = stack[stack.length - 1];
	
	  // 建立parent和children关系
	  if (currentParent) {
	    element.parent = currentParent;
	    currentParent.children.push(element);
	  }
	}
	
	// 对文本进行处理
	function handleChars(text) {
	
	  // 去掉空格
	  text = text.replace(/\s/g, "");
	
	  if (text) {
	    currentParent.children.push({
	      type: TEXT_TYPE,
	      text,
	    });
	  }
	}
	
	// 解析标签生成ast核心
	export function parse(html) {
	  while (html) {
	    // 查找<
	    // 如果textEnd为，说明是一个开始标签或者结束标签,<div>jjj</div>比如这个例子中的div前面那个<
	    //如果textEnd > 0，说明就是文本的结束位置,<div>jjj</div>比如这个例子中的/div前面那个<
	    
	    let textEnd = html.indexOf("<");
	
	    // 如果<在第一个 那么证明接下来就是一个标签 不管是开始还是结束标签
	    if (textEnd === 0) {
	      // 如果开始标签解析有结果
	      const startTagMatch = parseStartTag();
	
	      if (startTagMatch) {
	        // 把解析好的标签名和属性解析生成ast
	        handleStartTag(startTagMatch);
	        continue;
	      }
	
	      // 匹配结束标签</
	      const endTagMatch = html.match(endTag);
	
	      if (endTagMatch) {
	        advance(endTagMatch[0].length);
	        handleEndTag(endTagMatch[1]);
	        continue;
	      }
	    }
	
	    let text;
	    // 形如 hello<div></div>
	
	    if (textEnd >= 0) {
	      // 获取文本
	      text = html.substring(0, textEnd);
	    }
	    if (text) {
	      advance(text.length);
	      handleChars(text);
	    }
	  }
	
	  // 匹配开始标签
	  function parseStartTag() {
	    const start = html.match(startTagOpen); //[<div , div, ] 
	
	    if (start) {
	      const match = {
	        tagName: start[1], 正则里面的第一个分组对应标签名
	        attrs: [],
	      };
	      //匹配到了开始标签 就截取掉
	      //start[0]表示match返回的第一项，表示匹配到的结果，假如匹配一个<div>标签，那么start[0]就是<div，所以start[0].length为4
	      advance(start[0].length);
	
	      // 开始匹配属性
	      // end代表结束符号>  如果不是匹配到了结束标签
	      // attr 表示匹配的属性
	      let end, attr;
	      while (
	        !(end = html.match(startTagClose)) &&
	        (attr = html.match(attribute)) 
	        // 假如 id="app"，返回[id="app" , id , = ,app]
	      ) {
	        advance(attr[0].length);
	        attr = {
	          name: attr[1],
	          value: attr[3] || attr[4] || attr[5], //这里是因为正则捕获支持双引号 单引号 和无引号的属性值
	        };
	        match.attrs.push(attr);
	      }
	      if (end) {
	        //   代表一个标签匹配到结束的>了 代表开始标签解析完毕
	        advance(1);
	        return match;
	      }
	    }
	  }
	  //截取html字符串 每次匹配到了就往前继续匹配
	  function advance(n) {
	    html = html.substring(n);
	  }
	  //   返回生成的ast
	  return root;
	}

利用正则 匹配 `html` 字符串 遇到开始标签 结束标签和文本 解析完毕之后生成对应的 `ast` 并建立相应的父子关联 不断的 `advance` 截取剩余的字符串 直到 `html`全部解析完毕 咱们这里主要写了对于开始标签里面的属性的处理--`parseStartTag`

# 七、根据 `ast` 重新生成代码 #	

	// src/compiler/codegen.js
	
	const defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g; //匹配花括号 {{  }} 捕获花括号里面的内容
	正则表达式解释：匹配花括号，中间可以是任意字符以及回车、换行、回车
	
	function gen(node) {
	  // 判断节点类型
	  // 主要包含处理文本核心
	  // 源码这块包含了复杂的处理  比如 v-once v-for v-if 自定义指令 slot等等  咱们这里只考虑普通文本和变量表达式{{}}的处理
	
	  // 如果是元素类型
	  if (node.type == 1) {
	    //   递归创建
	    return generate(node);
	  } else {
	    //   如果是文本节点
	    let text = node.text;
	    // 不存在花括号变量表达式
	    if (!defaultTagRE.test(text)) {
	      return `_v(${JSON.stringify(text)})`;
	    }
	    // 正则是全局模式 每次需要重置正则的lastIndex属性  不然会引发匹配bug
	    let lastIndex = (defaultTagRE.lastIndex = 0);
	    let tokens = [];
	    let match, index;
	
	    while ((match = defaultTagRE.exec(text))) {
	      // index代表匹配到的位置
	      index = match.index;
	      if (index > lastIndex) {
	        //   匹配到的{{位置  在tokens里面放入普通文本
	        tokens.push(JSON.stringify(text.slice(lastIndex, index)));
	      }
	      //   放入捕获到的变量内容
	      tokens.push(`_s(${match[1].trim()})`);
	      //   匹配指针后移
	      lastIndex = index + match[0].length;
	    }
	    // 如果匹配完了花括号  text里面还有剩余的普通文本 那么继续push
	    if (lastIndex < text.length) {
	      tokens.push(JSON.stringify(text.slice(lastIndex)));
	    }
	    // _v表示创建文本
	    return `_v(${tokens.join("+")})`;
	  }
	}
	
	// 处理attrs属性
	function genProps(attrs) {
	  let str = "";
	  for (let i = 0; i < attrs.length; i++) {
	    let attr = attrs[i];
	    // 对attrs属性里面的style做特殊处理
	    if (attr.name === "style") {
	      let obj = {};
	      attr.value.split(";").forEach((item) => {
	        let [key, value] = item.split(":");
	        obj[key] = value;
	      });
	      attr.value = obj;
	    }
	    str += `${attr.name}:${JSON.stringify(attr.value)},`;
	  }
	  return `{${str.slice(0, -1)}}`;
	}
	
	// 生成子节点 调用gen函数进行递归创建
	function getChildren(el) {
	  const children = el.children;
	  if (children) {
	    return `${children.map((c) => gen(c)).join(",")}`;
	  }
	}
	// 递归创建生成code
	export function generate(el) {
	  let children = getChildren(el);
	  let code = `_c('${el.tag}',${
	    el.attrs.length ? `${genProps(el.attrs)}` : "undefined"
	  }${children ? `,${children}` : ""})`;
	  return code;
	}

拿到生成好的 `ast` 之后 需要把 `ast` 转化成类似

```
_c('div',{id:"app"},_c('div',undefined,_v("hello"+_s(name)),_c('span',undefined,_v("world"))))
```

这样的字符串

# 八、`code`字符串生成`render`函数 #	

	export function compileToFunctions(template) {
	
	  let code = generate(ast);
	
	  // 使用with语法改变作用域为this  之后调用render函数可以使用call改变this 方便code里面的变量取值 比如 name值就变成了this.name
	  let renderFn = new Function(`with(this){return ${code}}`);
	
	  return renderFn;
	}
