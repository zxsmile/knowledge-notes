## 一、什么是计算属性？

计算属性是`Vue.js`提供的一项特性，用于将计算逻辑封装为属性。这些属性的值是根据其他数据属性计算得出的，并且会在其依赖的数据属性发生变化时自动更新。计算属性的一个主要优点是它们将计算逻辑从模板中分离出来，使模板更加干净和易读。

## 二、计算属性的原理

计算属性的原理基于`Vue.js`的响应式系统。当一个计算属性依赖于某些数据属性时，`Vue.js`会建立一个依赖关系，将这个计算属性标记为“依赖”这些数据属性。当依赖的数据属性发生变化时，`Vue.js`会自动重新计算计算属性的值。这是通过`Getter`和`Setter`方法实现的。

让我们通过一个示例来深入了解计算属性的原理：

```html
<template>
  <div>
    <p>原始消息：{{ message }}</p>
    <p>反转消息：{{ reversedMessage }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, Vue.js'
    }
  },
  computed: {
    reversedMessage() {
      return this.message.split('').reverse().join('');
    }
  }
}
</script>
```

在上面的示例中，我们有一个`message`数据属性和一个`reversedMessage`计算属性，后者依赖于前者。当`message`的值发生变化时，`reversedMessage`会自动更新。这是因为`Vue.js`在内部建立了依赖关系，知道`reversedMessage`依赖于`message`。

# 三、计算属性 vs 方法

在某些情况下，您可能会使用方法来完成与计算属性相似的工作。例如，您可以使用一个方法来反转消息：

```html
<template>
  <div>
    <p>原始消息：{{ message }}</p>
    <p>反转消息：{{ reverseMessage() }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, Vue.js'
    }
  },
  methods: {
    reverseMessage() {
      return this.message.split('').reverse().join('');
    }
  }
}
</script>
```

尽管方法可以达到相同的效果，但计算属性有一些优势：

1. **缓存**：计算属性会缓存其结果，只在依赖的数据属性发生变化时才重新计算。这意味着如果多次访问计算属性，它只会计算一次并缓存结果，而方法则会在每次调用时重新计算。
2. **依赖追踪**：`Vue.js`能够追踪计算属性的依赖关系，确保只有真正依赖的数据属性发生变化时才会触发计算属性的更新。这提高了性能并减少不必要的更新。

# 四、计算属性的 `Getter` 和 `Setter`

计算属性不仅具有`Getter` 方法，还可以定义`Setter`方法。`Setter`方法允许您修改计算属性的值，同时也会影响依赖于它的数据属性。

```html
<template>
  <div>
    <p>原始消息：{{ message }}</p>
    <p>反转消息：{{ reversedMessage }}</p>
    <button @click="reverseMessage">反转消息</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, Vue.js'
    }
  },
  computed: {
    reversedMessage: {
      get() {
        return this.message.split('').reverse().join('');
      },
      set(newMessage) {
        this.message = newMessage;
      }
    }
  }
}
</script>
```

在上述示例中，我们定义了`reversedMessage`计算属性的`Getter`和`Setter`方法。`Getter`方法用于获取反转后的消息，`Setter`方法用于将新的消息赋值给`message`数据属性。这使我们能够通过点击按钮来反转消息。

# 五、计算属性的缓存

计算属性在性能优化方面有一个重要的特性：它们是具有缓存的。这意味着计算属性的值只在其依赖的数据属性发生变化时才会重新计算，然后缓存结果。如果依赖的数据属性没有发生变化，计算属性会返回缓存的值，而不会重新计算。

这对于性能是非常重要的，特别是当计算属性依赖于昂贵的计算或需要向服务器发出请求时。`Vue.js`会确保不会不必要地多次计算相同的值。

# 六、源码

## 1、初始化

在 `Vue`初始化实例的过程中，如果用户 `options`选项中存在计算属性时，则初始化计算属性

```javascript
// 初始化状态
export function initState(vm) {
  const opts = vm.$options // 获取所有的选项

  // 初始化数据
  if (opts.data) { initData(vm) }

  // 初始化计算属性
  if (opts.computed) { initComputed(vm) }
}
```

我们给每个计算属性都创建了一个 `Watcher`实例，标识为`lazy:true`， 在初始化`watcher`时不会立即执行 `get`方法（计算属性方法）

并将计算属性`watcher` 都保存到了 `Vue`实例上，让我们可以在后续的 `getter`方法中通过 `vm`获取到当前的计算属性`watcher`

然后使用`Object.defineProperty`去劫持计算属性

```javascript
// 初始化计算属性
function initComputed(vm) {
  const computed = vm.$options.computed
  const watchers = (vm._computedWatchers = {}) // 将每个计算属性对应的watcher 都保存到 
  
   // 遍历computed
  for (let key in computed) {
     // 取值
    let userDef = computed[key]

     // computed可以设置为函数类型，也可以设置为对象设置get属性（如果是对象必须定义get属性）
    let fn = typeof userDef === 'function' ? userDef : userDef.get

    // 给每个计算属性都创建一个 watcher，并标识为 lazy，不会立即执行 get-fn
    watchers[key] = new Watcher(vm, fn, { lazy: true })

    // 劫持计算属性getter/setter
    defineComputed(vm, key, userDef)
  }
}

```

## 2、对计算属性进行属性劫持

```javascript
//  src/state.js

// 定义普通对象用来劫持计算属性
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: () => {},
  set: () => {},
};

// 重新定义计算属性  对get和set劫持
function defineComputed(target, key, userDef) {
  if (typeof userDef === "function") {
    // 如果是一个函数  需要手动赋值到get上
    sharedPropertyDefinition.get = createComputedGetter(key);
  } else {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = userDef.set;
  }
  //   利用Object.defineProperty来对计算属性的get和set进行劫持
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

// 重写计算属性的get方法 来判断是否需要进行重新计算
function createComputedGetter(key) {
  return function () {
    const watcher = this._computedWatchers[key]; //获取对应的计算属性watcher
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值
      }
      return watcher.value;
    }
  };
}
```

`defineComputed` 方法主要是重新定义计算属性 其实最主要的是劫持 `get` 方法 也就是计算属性依赖的值 为啥要劫持呢 因为我们需要根据依赖值是否发生变化来判断计算属性是否需要重新计算

`createComputedGetter` 方法就是判断计算属性依赖的值是否变化的核心了 我们在计算属性创建的 `Watcher` 增加 `dirty` 标志位 如果标志变为 `true` 代表需要调用 `watcher.evaluate` 来进行重新计算了

## 3、`Watcher` 改造

```javascript
// src/observer/watcher.js

// import { pushTarget, popTarget } from "./dep";
// import { queueWatcher } from "./scheduler";
// import {isObject} from '../util/index'
// // 全局变量id  每次new Watcher都会自增
// let id = 0;

export default class Watcher {
  constructor(vm, exprOrFn, cb, options) {
    // this.vm = vm;
    // this.exprOrFn = exprOrFn;
    // this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法
    // this.options = options; //额外的选项 true代表渲染watcher
    // this.id = id++; // watcher的唯一标识
    // this.deps = []; //存放dep的容器
    // this.depsId = new Set(); //用来去重dep
    // this.user = options.user; //标识用户watcher
    this.lazy = options.lazy; //标识计算属性watcher
    this.dirty = this.lazy; //dirty可变  表示计算watcher是否需要重新计算 默认值是true

    // 如果表达式是一个函数
    // if (typeof exprOrFn === "function") {
    //   this.getter = exprOrFn;
    // } else {
    //   this.getter = function () {
    //     //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b
    //     let path = exprOrFn.split(".");
    //     let obj = vm;
    //     for (let i = 0; i < path.length; i++) {
    //       obj = obj[path[i]]; //vm.a.a.a.a.b
    //     }
    //     return obj;
    //   };
    // }
    // 非计算属性实例化就会默认调用get方法 进行取值  保留结果 计算属性实例化的时候不会去调用get
    this.value = this.lazy ? undefined : this.get();
  }
  get() {
    pushTarget(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上
    const res = this.getter.call(this.vm); //计算属性在这里执行用户定义的get函数 访问计算属性的依赖项 从而把自身计算Watcher添加到依赖项dep里面收集起来
    popTarget(); // 在调用方法之后把当前watcher实例从全局Dep.target移除
    return res;
  }
  //   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次
  //   addDep(dep) {
  //     let id = dep.id;
  //     if (!this.depsId.has(id)) {
  //       this.depsId.add(id);
  //       this.deps.push(dep);
  //       //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面
  //       dep.addSub(this);
  //     }
  //   }
  //   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了
  update() {
    // 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算
    if (this.lazy) {
      this.dirty = true;
    } else {
      // 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用
      // 异步队列机制
      queueWatcher(this);
    }
  }
  //   计算属性重新进行计算 并且计算完成把dirty置为false
  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }
  depend() {
    // 计算属性的watcher存储了依赖项的dep
    let i = this.deps.length;
    while (i--) {
      this.deps[i].depend(); //调用依赖项的dep去收集渲染watcher
    }
  }
  //   run() {
  //     const newVal = this.get(); //新值
  //     const oldVal = this.value; //老值
  //     this.value = newVal; //跟着之后  老值就成为了现在的值
  //     if (this.user) {
  //       if(newVal!==oldVal||isObject(newVal)){
  //         this.cb.call(this.vm, newVal, oldVal);
  //       }
  //     } else {
  //       // 渲染watcher
  //       this.cb.call(this.vm);
  //     }
  //   }
}
```

我们主要看没被注释的代码 这里主要改造有四点

1.实例化的时候如果是计算属性 不会去调用 `get` 方法访问值进行依赖收集

2.`update` 方法只是把计算 `watcher` 的 `dirty` 标识为 `true` 只有当下次访问到了计算属性的时候才会重新计算

3.新增 `evaluate` 方法专门用于计算属性重新计算

4.新增 `depend` 方法 让计算属性的依赖值收集外层 `watcher`--这个方法非常重要 我们接下来分析

## 4、外层 `Watcher` 的依赖收集

```javascript
// src/state.js

function createComputedGetter(key) {
//   return function () {
//     const watcher = this._computedWatchers[key]; //获取对应的计算属性watcher
//     if (watcher) {
//       if (watcher.dirty) {
//         watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值
        if (Dep.target) {
    // 如果Dep还存在target 这个时候一般为渲染watcher 计算属性依赖的数据也需要收集
          watcher.depend()
        }
//       }
//       return watcher.value;
//     }
//   };
// }
```

这里就体现了 `watcher.depend` 方法的重要性了 我们试想一下 当我们计算属性依赖的值发生了改变 这时候 `watcher` 的 `dirty` 为 `true` 下次访问计算属性 他确实也重新计算了 但是 我们从头到尾都没有触发视图更新 也就是数据改变了 视图没有重新渲染

这是为什么呢？

因为模板里面只有计算属性 而计算属性的依赖值的 `dep` 里面只收集了计算 `watcher` 的依赖 自身变化也只是通知了计算 `watcher` 调用 `update` 把 `dirty` 置为 `true` 所以我们要想个办法把计算属性的依赖项也添加渲染 `watcher`  的依赖 让自身变化之后首先通知计算 `watcher` 进行重新计算 然后通知渲染 `watcher` 进行视图更新

怎么做呢？我们来看看下面的代码就清楚了

```javascript
// src/observer/dep.js

// 默认Dep.target为null
Dep.target = null;
// 栈结构用来存watcher
const targetStack = [];

export function pushTarget(watcher) {
  targetStack.push(watcher);
  Dep.target = watcher; // Dep.target指向当前watcher
}
export function popTarget() {
  targetStack.pop(); // 当前watcher出栈 拿到上一个watcher
  Dep.target = targetStack[targetStack.length - 1];
}
```

可见最初设计存放 `watcher` 的容器就是一个栈结构 因为整个 `Vue` 生命周期的过程中会存在很多的 `watcher`  比如渲染 `watcher` 计算 `watcher` 侦听 `watcher` 等 而每个 `watcher`  在调用了自身的 `get` 方法前后会分别调用 `pushTarget` 入栈和 `popTarget` 出栈 这样子当计算属性重新计算之后就立马会出栈 那么外层的 `watcher`  就会成为新的 `Dep.target` 我们使用 `watcher.depend` 方法让计算属性依赖的值收集一遍外层的渲染 `watcher` 这样子当计算属性依赖的值改变了既可以重新计算又可以刷新视图

## 5、计算属性的思维导图



![vue20](..\images\vue20.png)