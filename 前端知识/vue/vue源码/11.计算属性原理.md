## 一、什么是计算属性？

计算属性是`Vue.js`提供的一项特性，用于将计算逻辑封装为属性。这些属性的值是根据其他数据属性计算得出的，并且会在其依赖的数据属性发生变化时自动更新。计算属性的一个主要优点是它们将计算逻辑从模板中分离出来，使模板更加干净和易读。

## 二、计算属性的原理

计算属性的原理基于`Vue.js`的响应式系统。当一个计算属性依赖于某些数据属性时，`Vue.js`会建立一个依赖关系，将这个计算属性标记为“依赖”这些数据属性。当依赖的数据属性发生变化时，`Vue.js`会自动重新计算计算属性的值。这是通过`Getter`和`Setter`方法实现的。

让我们通过一个示例来深入了解计算属性的原理：

```html
<template>
  <div>
    <p>原始消息：{{ message }}</p>
    <p>反转消息：{{ reversedMessage }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, Vue.js'
    }
  },
  computed: {
    reversedMessage() {
      return this.message.split('').reverse().join('');
    }
  }
}
</script>
```

在上面的示例中，我们有一个`message`数据属性和一个`reversedMessage`计算属性，后者依赖于前者。当`message`的值发生变化时，`reversedMessage`会自动更新。这是因为`Vue.js`在内部建立了依赖关系，知道`reversedMessage`依赖于`message`。

# 三、计算属性 vs 方法

在某些情况下，您可能会使用方法来完成与计算属性相似的工作。例如，您可以使用一个方法来反转消息：

```html
<template>
  <div>
    <p>原始消息：{{ message }}</p>
    <p>反转消息：{{ reverseMessage() }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, Vue.js'
    }
  },
  methods: {
    reverseMessage() {
      return this.message.split('').reverse().join('');
    }
  }
}
</script>
```

尽管方法可以达到相同的效果，但计算属性有一些优势：

1. **缓存**：计算属性会缓存其结果，只在依赖的数据属性发生变化时才重新计算。这意味着如果多次访问计算属性，它只会计算一次并缓存结果，而方法则会在每次调用时重新计算。
2. **依赖追踪**：`Vue.js`能够追踪计算属性的依赖关系，确保只有真正依赖的数据属性发生变化时才会触发计算属性的更新。这提高了性能并减少不必要的更新。

# 四、计算属性的 `Getter` 和 `Setter`

计算属性不仅具有`Getter` 方法，还可以定义`Setter`方法。`Setter`方法允许您修改计算属性的值，同时也会影响依赖于它的数据属性。

```html
<template>
  <div>
    <p>原始消息：{{ message }}</p>
    <p>反转消息：{{ reversedMessage }}</p>
    <button @click="reverseMessage">反转消息</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, Vue.js'
    }
  },
  computed: {
    reversedMessage: {
      get() {
        return this.message.split('').reverse().join('');
      },
      set(newMessage) {
        this.message = newMessage;
      }
    }
  }
}
</script>
```

在上述示例中，我们定义了`reversedMessage`计算属性的`Getter`和`Setter`方法。`Getter`方法用于获取反转后的消息，`Setter`方法用于将新的消息赋值给`message`数据属性。这使我们能够通过点击按钮来反转消息。

# 五、计算属性的缓存

**计算属性在性能优化方面有一个重要的特性：它们是具有缓存的。这意味着计算属性的值只在其依赖的数据属性发生变化时才会重新计算，然后缓存结果。如果依赖的数据属性没有发生变化，计算属性会返回缓存的值，而不会重新计算。**

这对于性能是非常重要的，特别是当计算属性依赖于昂贵的计算或需要向服务器发出请求时。`Vue.js`会确保不会不必要地多次计算相同的值。

# 六、源码

## 1、初始化

在 `Vue`初始化实例的过程中，如果用户 `options`选项中存在计算属性时，则初始化计算属性

```javascript
// 初始化状态
export function initState(vm) {
  const opts = vm.$options // 获取所有的选项

  // 初始化数据
  if (opts.data) { initData(vm) }

  // 初始化计算属性
  if (opts.computed) { initComputed(vm) }
}
```

我们给每个计算属性都创建了一个 `Watcher`实例，标识为`lazy:true`， 在初始化`watcher`时不会立即执行 `get`方法（计算属性方法）

并将计算属性`watcher` 都保存到了 `Vue`实例上，让我们可以在后续的 `getter`方法中通过 `vm`获取到当前的计算属性`watcher`

然后使用`Object.defineProperty`去劫持计算属性

```javascript
// 初始化计算属性
function initComputed(vm) {
  const computed = vm.$options.computed
  const watchers = vm._computedWatchers = Object.create(null) // 创建一个纯净对象
  
   // 遍历computed
  for (let key in computed) {
     // 取值
    let userDef = computed[key] // computed每项对应的回调函数

     // computed可以设置为函数类型，也可以设置为对象设置get属性（如果是对象必须定义get属性）
    let fn = typeof userDef === 'function' ? userDef : userDef.get

    // 给每个计算属性都创建一个 watcher，并标识为 lazy，不会立即执行 get-fn
    watchers[key] = new Watcher(vm, fn, { lazy: true })// 实例化computed-watcher

    // 劫持计算属性getter/setter
    defineComputed(vm, key, userDef)
  }
}

```

## 2、对计算属性进行属性劫持

```javascript
//  src/state.js

// 定义普通对象用来劫持计算属性
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: () => {},
  set: () => {},
};

// 重新定义计算属性  对get和set劫持
//这个方法的作用就是让computed成为一个响应式数据，并定义它的get属性，也就是说当页面执行渲染访问到computed时，才会触发get然后执行createComputedGetter方法，
function defineComputed(target, key, userDef) {
  if (typeof userDef === "function") {
    // 如果是一个函数  需要手动赋值到get上
    sharedPropertyDefinition.get = createComputedGetter(key);
  } else {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = userDef.set;
  }
  //   利用Object.defineProperty来对计算属性的get和set进行劫持
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

// 重写计算属性的get方法 来判断是否需要进行重新计算
function createComputedGetter(key) {// 高阶函数
  return function () { // 返回函数
    const watcher = this._computedWatchers && this._computedWatchers[key]; //获取对应的计算属性watcher，得到key对应的computed-watcher
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值
      }
       if (Dep.target) {  // 当前的watcher，这里是页面渲染触发的这个方法，所以为render-watcher
        watcher.depend()  // 收集当前watcher
      }
      return watcher.value  // 返回求到的值或之前缓存的值
    }
  };
}

class Watcher {
  ...
  
  evaluate () {
    this.value = this.get()  //  计算属性求值
    this.dirty = false  // 表示计算属性已经计算，不需要再计算
  }
  
  depend () {
    let i = this.deps.length  // deps内是计算属性内能访问到的响应式数据的dep的数组集合
    while (i--) {
      this.deps[i].depend()  // 让每个dep收集当前的render-watcher
    }
  }
```

`defineComputed` 方法主要是重新定义计算属性 其实最主要的是劫持 `get` 方法 也就是计算属性依赖的值 为啥要劫持呢 因为我们需要根据依赖值是否发生变化来判断计算属性是否需要重新计算

`createComputedGetter` 方法就是判断计算属性依赖的值是否变化的核心了 我们在计算属性创建的 `Watcher` 增加 `dirty` 标志位 如果标志变为 `true` 代表需要调用 `watcher.evaluate` 来进行重新计算了

这里的变量`watcher`就是之前`computed`对应的`computed-watcher`实例，接下来会执行`Watcher`类专门为计算属性定义的两个方法，在执行`evaluate`方法进行求值的过程中又会触发`computed`内可以访问到的响应式数据的`get`，它们会将当前的`computed-watcher`作为依赖收集到自己的`dep`里，计算完毕之后将`dirty`置为`false`，表示已经计算过了。

然后执行`depend`让计算属性内的响应式数据订阅当前的`render-watcher`，所以`computed`内的响应式数据会收集`computed-watcher`和`render-watcher`两个`watcher`，当`computed`内的状态发生变更触发`set`后，首先通知`computed`需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到`computed`计算后的值，最后渲染到页面。

> `Ps`: 计算属性内的值须是响应式数据才能触发重新计算。



## 3、`Watcher` 改造

```javascript
// src/observer/watcher.js

 import { pushTarget, popTarget } from "./dep";
 import { queueWatcher } from "./scheduler";
 import {isObject} from '../util/index'
 // 全局变量id  每次new Watcher都会自增
 let id = 0;

export default class Watcher {
  constructor(vm, exprOrFn, cb, options) {
     this.vm = vm;
     this.exprOrFn = exprOrFn; // computed的回调函数
     this.cb = cb; //回调函数 比如在watcher更新之前可以执行beforeUpdate方法
     this.options = options; //额外的选项 true代表渲染watcher
     this.id = id++; // watcher的唯一标识
     this.deps = []; //存放dep的容器
     this.depsId = new Set(); //用来去重dep
     this.user = options.user; //标识用户watcher
     this.lazy = options.lazy; //标识计算属性watcher
     this.dirty = this.lazy; //dirty可变  表示计算watcher是否需要重新计算 默认值是true

    // 如果表达式是一个函数
     if (typeof exprOrFn === "function") {
      this.getter = exprOrFn;
     } else {
       this.getter = function () {
         //用户watcher传过来的可能是一个字符串   类似a.a.a.a.b
         let path = exprOrFn.split(".");
         let obj = vm;
         for (let i = 0; i < path.length; i++) {
           obj = obj[path[i]]; //vm.a.a.a.a.b
         }
         return obj;
       };
     }
    // 非计算属性实例化就会默认调用get方法 进行取值  保留结果 计算属性实例化的时候不会去调用get
    this.value = this.lazy ? undefined : this.get();
  }
  get() {
    pushTarget(this); // 在调用方法之前先把当前watcher实例推到全局Dep.target上
    const res = this.getter.call(this.vm); //计算属性在这里执行用户定义的get函数 访问计算属性的依赖项 从而把自身计算Watcher添加到依赖项dep里面收集起来
    popTarget(); // 在调用方法之后把当前watcher实例从全局Dep.target移除
    return res;
  }
  //   把dep放到deps里面 同时保证同一个dep只被保存到watcher一次  同样的  同一个watcher也只会保存在dep一次
   addDep(dep) {
     let id = dep.id;
     if (!this.depsId.has(id)) {
        this.depsId.add(id);
        this.deps.push(dep);
        //   直接调用dep的addSub方法  把自己--watcher实例添加到dep的subs容器里面
        dep.addSub(this);
     }
  }
    
  //   这里简单的就执行以下get方法  之后涉及到计算属性就不一样了
  update() {
    // 计算属性依赖的值发生变化 只需要把dirty置为true  下次访问到了重新计算
    if (this.lazy) {
        // 当computed内的响应式数据触发set后，// 通知computed需要重新计算了
      this.dirty = true;
    }else if (this.sync) {// 如果有设置sync为true
       this.run()// 不走nextTick队列，直接执行
     } else {
      // 每次watcher进行更新的时候  可以让他们先缓存起来  之后再一起调用
      // 异步队列机制
      queueWatcher(this);
    }
  }
    
  //   计算属性重新进行计算 并且计算完成把dirty置为false
  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }
    
  depend() {
    // 计算属性的watcher存储了依赖项的dep
    let i = this.deps.length;
    while (i--) {
      this.deps[i].depend(); //调用依赖项的dep去收集渲染watcher
    }
  }
    
     run() {
       const newVal = this.get(); //新值
       const oldVal = this.value; //老值
       this.value = newVal; //跟着之后  老值就成为了现在的值
       if (this.user) {
         if(newVal!==oldVal||isObject(newVal)){
           this.cb.call(this.vm, newVal, oldVal);
        }
       } else {
         // 渲染watcher
         this.cb.call(this.vm);
      }
    }
}
```

我们主要看没被注释的代码 这里主要改造有四点

1.实例化的时候如果是计算属性 不会去调用 `get` 方法访问值进行依赖收集

2.`update` 方法只是把计算 `watcher` 的 `dirty` 标识为 `true` 只有当下次访问到了计算属性的时候才会重新计算

3.新增 `evaluate` 方法专门用于计算属性重新计算

4.新增 `depend` 方法 让计算属性的依赖值收集外层 `watcher`--这个方法非常重要 我们接下来分析

每个计算属性都有一个`computed watcher`，响应式属性内每个`key`都有`dep`。初次渲染组件的时候`render watcher`中使用计算属性的时候`pushTarget(this)`把计算属性的`computed watcher`添加到了`Dep.target`，访问计算属性回调函数内的响应式属性，触发响应式属性`get`的时候，响应式属性对应的`dep`收集`computed watcher`，同时`computed watcher`也会把对应的`dep`存储起来，求值结束后计算属性的`computed watcher`执行了`popTarget()`，当前`Dep.target`就又变成`render watcher`了，这时候计算属性`get`内又调用了`watcher.depend()`，这里的watcher是计算属性的`watcher`，计算属性前面存储了响应式属性的`dep`，这里调用`depend()`，会让这个计算属性所有的依赖的响应式属性把当前的`render watcher`存储起来。

## 4、外层 `Watcher` 的依赖收集

```javascript
// src/state.js

function createComputedGetter(key) {
//   return function () {
//     const watcher = this._computedWatchers[key]; //获取对应的计算属性watcher
//     if (watcher) {
//       if (watcher.dirty) {
//         watcher.evaluate(); //计算属性取值的时候 如果是脏的  需要重新求值
        if (Dep.target) {
    // 如果Dep还存在target 这个时候一般为渲染watcher 计算属性依赖的数据也需要收集
          watcher.depend()
        }
//       }
//       return watcher.value;
//     }
//   };
// }
```

这里就体现了 `watcher.depend` 方法的重要性了 我们试想一下 当我们计算属性依赖的值发生了改变 这时候 `watcher` 的 `dirty` 为 `true` 下次访问计算属性 他确实也重新计算了 但是 我们从头到尾都没有触发视图更新 也就是数据改变了 视图没有重新渲染

这是为什么呢？

因为模板里面只有计算属性 而计算属性的依赖值的 `dep` 里面只收集了计算 `watcher` 的依赖 自身变化也只是通知了计算 `watcher` 调用 `update` 把 `dirty` 置为 `true` 所以我们要想个办法把计算属性的依赖项也添加渲染 `watcher`  的依赖 让自身变化之后首先通知计算 `watcher` 进行重新计算 然后通知渲染 `watcher` 进行视图更新

怎么做呢？我们来看看下面的代码就清楚了

```javascript
// src/observer/dep.js

// 默认Dep.target为null
Dep.target = null;
// 栈结构用来存watcher
const targetStack = [];

export function pushTarget(watcher) {
  targetStack.push(watcher);
  Dep.target = watcher; // Dep.target指向当前watcher
}
export function popTarget() {
  targetStack.pop(); // 当前watcher出栈 拿到上一个watcher
  Dep.target = targetStack[targetStack.length - 1];
}
```

可见最初设计存放 `watcher` 的容器就是一个栈结构 因为整个 `Vue` 生命周期的过程中会存在很多的 `watcher`  比如渲染 `watcher` 、计算 `watcher` 、侦听 `watcher` 等 而每个 `watcher`  在调用了自身的 `get` 方法前后会分别调用 `pushTarget` 入栈和 `popTarget` 出栈 这样子当计算属性重新计算之后就立马会出栈 那么外层的 `watcher`  就会成为新的 `Dep.target` 我们使用 `watcher.depend` 方法让计算属性依赖的值收集一遍外层的渲染 `watcher` 这样子当计算属性依赖的值改变了既可以重新计算又可以刷新视图

## 5、计算属性的思维导图



![vue20](..\images\vue20.png)

## 6、最后还是以一个示例结合流程图来帮大家理清楚这里的逻辑：

```
export default {
  data() {
    return {
      manName: "cc",
      womanName: "ww"
    };
  },
  computed: {
    newName() {
      return this.manName + ":" + this.womanName;
    }
  },
  methods: {
    changeName() {
      this.manName = "ss";
    }
  }
};
```

![vue24](..\images\vue24.png)

> `watch`总结：为什么计算属性有缓存功能？因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值；为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？因为内部的响应式数据会收集`computed-watcher`，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值。

#### 请问`computed`属性和`watch`属性分别什么场景使用？

当模板中的某个值需要通过一个或多个数据计算得到时，就可以使用计算属性，还有计算属性的函数不接受参数；监听属性主要是监听某个值发生变化后，对新值去进行逻辑处理。



