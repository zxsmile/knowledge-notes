# 一、概念 #

- [ ] 传统的路由指的是后端路由，路由指的是前端发给后端一个`url`，也就是通向某个页面的地址，后端服务器根据这个地址找到对应的页面，然后把该页面文件发给前端，前端接收到再展示给用户。
- [ ] 在传统多页应用中，每次`URL`变化都会导致页面刷新，体验就像“翻书”一样。而在`SPA`中，我们希望页面内容能根据`URL`变化而切换，但又不想刷新整个页面。于是，前端路由应运而生。
- [ ] 对于 `Vue` 这类渐进式前端开发框架，为了构建 `SPA`（单页面应用），需要引入前端路由（因为当 `url` 发生改变，只是表明页面组件排列组合的方式变了，并不需要向后端发送请求重载页面。），这也就是 `vue-router` 存在的意义。前端路由的核心，就在于——改变视图的同时不会向后端发出请求。
- [ ] **问题：**
  - [ ] 如何感知URL变化？
  - [ ] 如何让页面内容与URL同步？

# 二、`hash`模式 #

- [ ] 它的特点在于：`hash` 虽然出现`URL`中，但不会被包含在`HTTP`请求中，对后端完全没有影响，因此改变`hash`不会重新加载页面。

- [ ] 原理：核心是锚点值的改变，哈希路由利用 `URL` 的 `hash` 部分（即 # 及其后内容）来实现前端路由切换。`hash` 变化不会导致页面重新加载，浏览器会触发 `hashchange` 事件，我们监听到锚点值改变了就去局部改变页面数据，不做页面的跳转。即根据 `hash` 值渲染对应内容。

- [ ] **核心机制：**

  - [ ] 监听`hashchange`事件，感知URL变化
  - [ ] 根据`hash`值渲染对应组件

  

```
window.addEventList('hashchange',function(e){})

window.location.hash可以读取到hash值
```

- [ ] 代码示例

```
<body>
	   <div class = 'box' id='box'>lalal</div>
	   
	    <script>
	       var appdiv=document.getElementById('box')
	        window.addEventListener('hashchange',function(e){
	            console.log(appdiv)
	            switch(location.hash){
				              case '#/login':
				               appdiv.innerHTML='我是登录页面';
				    		             break;
				  	            case '#/register':
				  	              appdiv.innerHTML='我是注册页面';
				  	             break;
				           }
	        })
	    </script>
	</body>
```
- [ ] 对于`hash`模式会创建`hashHistory`对象,在访问不同的路由的时候,会发生两件事:`HashHistory.push()`将新的路由添加到浏览器访问的历史的栈顶,和`HasHistory.replace()`替换到当前栈顶的路由，这样因为`hash`发生变化的`url`都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用了。
- [ ] #后面的部分不会被包含到`http`请求当中去，所以改变`hash`值也不会触发请求，所以页面也不会报`404`错误
- [ ] 生活化类比
  - [ ] 哈希路由就像一本厚厚的笔记本，每一页的右上角都贴着一个彩色标签（`#`）。你在翻阅时，只需看标签就能快速定位到想要的章节，无需重新打开整本书。这里的 `#`，就像是每个标签的颜色或编号，帮助你一眼找到目标内容。
  - [ ] 在本例中，`URL` 中的 `#/about`、`#/home` 等，就像是你在笔记本上贴的“关于”“首页”等标签。每次点击导航链接，页面不会整体刷新（不会重新翻开书），而是直接跳转到带有对应标签的那一页内容，实现了高效的内容切换和定位。

# 三、history模式 #

- [ ] 原理：`History`路由利用了浏览器的 **history对象**，通过`pushState`、`replaceState`等`API`修改`URL`而不刷新页面。相比哈希路由，`URL` 更加美观，无需 `#`。

- [ ] `history`模式是基于我们常用的`window.history`对象方法

- [ ] **核心机制：**

  - [ ] 使用`pushState`修改URL
  - [ ] 监听`popstate`事件，感知前进/后退
  - [ ] 根据`location.pathname`渲染对应组件

- [ ] 常用的方法包括：
      

  - [ ] `history.forward();` 在历史记录中前进一步
  - [ ] `history.back();`    在历史记录中后退一步
  - [ ] `history.go(n)；`    在历史记录中跳转`n`步骤，`n=0`为刷新本页,n=-1为后退一页
  - [ ] `history.pushState(state,title,url);` 用于在浏览历史中添加历史记录，但并不触发跳转
  - [ ] `history.replaceState(state,title,url`); 替换当前页在历史记录中的信息，`replaceState`不会在`window.history`里新增历史记录点，而`pushState`会在历史记录点里新增一个记录点的
    - [ ] `state`状态对象：一个与指定网址相关的状态对象，`popstate`事件触发时，该对象会传入回调函数。如果不需要该对象，此处可以填`null`
    - [ ] `title`页面标题：新页面的标题，目前所有浏览器都不支持，所以填`null`
    - [ ] `url`可选的`url`：浏览器不会检查`url`是否存在，只改变`url`，`url`必须同域，不能跨域
    - [ ] `history.state`; 是一个属性，可以得到当前页的`state`信息。
  - [ ] `window.onpopstate`;
    - [ ] 是一个事件，在点击浏览器后退按钮或`js`调用`forward()`、`back()`、`go()`时触发。监听函数中可传入一个event对象，`event.state`即为通过`pushState()`或`replaceState()`方法传入的`data`参数
  - [ ] 调用  `history.pushState()`  或  `history.replaceState()`  用来在浏览历史中添加或修改记录，不会触发`popstate`事件；只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在`Javascript`代码中调用`history.back()`）
  - [ ] 由于通过`history`的`api`调整，并不会向后端发起请求，所以也就达到了前端路由的目的。但是,刷新页面，或使用后退，前进按钮,就会请求服务器，然而服务器上根本没有这个资源，就会报`404`。所以，使用此模式需要后台配合把接口都打到我们打包后的`index.html`上。

- [ ] 代码示例

  ```
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>History 路由示例</title>
    <style>
      nav a { margin: 0 10px; }
      #router-view { margin-top: 20px; }
    </style>
  </head>
  <body>
    <nav>
      <a href="/home" data-link>首页</a>
      <a href="/about" data-link>关于</a>
      <a href="/contact" data-link>联系</a>
    </nav>
    <div id="router-view"></div>
    <script>
      const routes = [
        { path: '/home', component: () => '<h2>首页内容</h2>' },
        { path: '/about', component: () => '<h2>关于我们</h2>' },
        { path: '/contact', component: () => '<h2>联系方式</h2>' }
      ];
      const routerView = document.getElementById('router-view');
      function render(path) {
        const route = routes.find(r => r.path === path);
        routerView.innerHTML = route ? route.component() : '<h2>404 Not Found</h2>';
      }
      function onLinkClick(e) {
        if (e.target.matches('[data-link]')) {
          e.preventDefault();
          const path = e.target.getAttribute('href');
          history.pushState({}, '', path);
          render(path);
        }
      }
      window.addEventListener('popstate', () => render(location.pathname));
      document.body.addEventListener('click', onLinkClick);
      window.addEventListener('DOMContentLoaded', () => render(location.pathname));
    </script>
  </body>
  </html>
  
  ```

- [ ]  生活化类比

  - [ ] 想象你住在一套超大的智能别墅，走廊上有无数个房间，每个房间都装修成不同风格（`URL`）。你每进一个房间，都会在手里的“穿越记事本”（`history` 栈）上写下房间名和进门时间，顺便画个小表情。想回到之前的房间？不用穿越时空，只需翻翻记事本，瞬间回到那一页，房间里的家具、气味、甚至你上次吃了一半的薯片都还在原地。
  - [ ] 你可以一路向前探索新房间，也可以“后退”回到厨房找回刚才没喝完的奶茶。每次 `pushState` 就像新开一扇门，`popstate` 就像倒带回忆，整个过程无比丝滑，邻居都看不出你其实一直没离开这栋房子。

# 四、`hash`和`history`的对比 #

- [ ] `Hash` 模式是使用 `URL` 的 `Hash` 来模拟一个完整的 `URL`，因此当 `URL` 改变的时候页面并不会重载。`History` 模式则会直接改变 `URL`，所以在路由跳转的时候会丢失一些地址信息，在刷新或直接访问路由地址的时候会匹配不到静态资源。因此需要在服务器上配置一些信息，让服务器增加一个覆盖所有情况的候选资源，比如跳转 `index.html` 什么的
- [ ] hash路由优缺点
  - [ ] 优点
    - [ ] 实现简单，兼容性好（兼容到`ie8`）
    - [ ] 绝大多数前端框架均提供了给予`hash`的路由实现
    - [ ] 不需要服务器端进行任何设置和开发
    - [ ] 除了资源加载和`ajax`请求以外，不会发起其他请求
  - [ ] 缺点
    - [ ] 对于部分需要重定向的操作，后端无法获取`hash`部分内容，导致后台无法取得`url`中的数据，典型的例子就是微信公众号的`oauth`验证
    - [ ] 服务器端无法准确跟踪前端路由信息
    - [ ] 对于需要锚点功能的需求会与目前路由机制冲突

- [ ] History(browser)路由 优缺点
  - [ ] 优点
    - [ ] 对于重定向过程中不会丢失`url`中的参数。后端可以拿到这部分数据
    - [ ] 绝大多数前端框架均提供了`browser`的路由实现
    - [ ] 后端可以准确跟踪路由信息
    - [ ] 可以使用`history.state`来获取当前`url`对应的状态信息
  - [ ] 缺点
    - [ ] 兼容性不如`hash`路由(只兼容到`IE10`)
    - [ ] 需要后端支持，每次返回`html`文档

