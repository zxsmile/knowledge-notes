## *一、`js` 模块化的发展史和构建工具的变化

- `javascript` 语言设计之初，只是作为一个简单的脚本语言用来丰富网站的功能，并不像 `java`、`c++`那样有 `module` 的概念，发展到现在的模样，也经历了相当长的时间。 这段时间，可以简单归纳为：
  - 青铜时代 - `no module`；
  - 白银时代 - `cjs`、`amd`、`cmd`、`umd`、`esm` 相继出现；
  - 黄金时代 - 组件模块化；

- 不同的时代，构建工具也不同。

#### 1.青铜时代

- 由于没有 module 的概念，` javascript` 无法在语言层面实现模块之间的相互隔离、相互依赖，只能由开发人员手动处理。 相应的，早期的 web 开发也比较简单甚至简陋:

- 通过对象或者`IIFE`(闭包)的方式实现模块隔离；

- 通过手动确定 script 的加载顺序确定模块之间的依赖关系。` jsp `开发模式，没有专门的前端，`html`、`js`、`css `代码通常也由后端开发人员编写。

- 为了节省带宽和保密，通常需要对前端代码做压缩混淆处理。这个时候，构建工具为 `YUI Tool + Ant`。

#### 2.白银时代

- `chrome v8` 引擎 和 `node` 的横空出世，给前端带来了无限的可能。 同时，`javascript` 的模块化标准也有了新的发展:
  - `commonjs` 规范，适用于` node` 环境开发。
  - `amd`、`cmd` 规范，适用于浏览器环境。
  - `umd`，兼容 `amd`、`commonjs`，代码可以同时运行在浏览器和 node 环境。
  - `ESM`，即 `ES6 module`(这个时候还不是很成熟)；

- 同时还出现了` less`、`sass`、 `es6`、` jslint`、 `eslint`、`typescript` 等新的东西， 前端角色也开始承担越来越重要的作用，慢慢的独立出来。 有了 `node` 提供的平台，大量的工具开始涌现:
  - `requirejs `提供的 `r.js `插件，可以分析 `amd` 模块依赖关系、合并压缩`js`、优化 `css`；
  - `less / sass` 插件，可以将` less / sass` 代码转化为` css` 代码；
  - `babel`，可以将 `es6` 转化为` es5`；
  - `ypescript`，将 `ts` 编译为` js`；
  - `jslint / eslint`，代码检查； ...

- 这个时候，我们可以将上面的的这些操作配置成一个个任务，然后通过 `Grunt / Gulp` 自动执行任务。

#### 3.黄金时代

- 基于` Angular`、`Vue`、`React` 三大框架和 `Webpack` 的使用，组件模块化成为前端开发的主流模式。同时 ESM 规范也原来越成熟，被更多的浏览器支持。

- 以 `React`和 `Webpack` 为例，通常我们会将一个应用涉及到的所有的功能拆分为一个个组件，如路由组件、页面组件、表单组件、表格组件等，一个组件对应一个源文件，然后通过 `Webpack` 将这些源文件打包。在开发过程中，还会通过 `ebpack` 开启一个 `ocal server`，实时查看代码的运行效果。

- `Webpack` 是一个静态模块打包器，它会以 `entry` 指定的入口文件为起点，分析整个项目内各个源文件之间的依赖关系，构建一个模块依赖图 -` module graph`，然后将 `module graph `分离为多个` bundl`e。在构建 `module graph` 的过程中，会使用 `loader` 处理源文件，将它们转化为浏览器可以是识别的`js`、`css`、`image`、音视频等。 随着时间的发展， `Webpack `的功能越来越来强大，也迎来诸多对手。

  ```
  Webpack1
     |
     |
  Rollup 出现(推崇 ESM 规范，可以实现 tree shaking, 打包出来的代码更干净)
     |
     |
  Webpack2(也实现了 tree shaking, 但是配置还是太繁琐了)
     |
     |
  Parcel (号称 0 配置)
     |
     |
  Webpack4(通过 mode 确定 development 和 production 模式，各个模式有自己的默认配置)
     |
     |
  Webpack5(持久化缓存、module federation)
  
  Esbuild(采用 go 语言开发，比 Webpack 更快)
  
  Vite(推崇 ESM 规范，开发模式采用 nobundle，更好的开发体验)
  ```

  

- 丰富的构建工具，形成了百花绽放的局面，可用于不同的情形，给开发人员带来了越来越多的选择。



## 二、模块化的发展的探索

- 模块化其实就是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，每个模块完成一个特定的子功能（单一职责），模块内部私有，对外暴露接口与其他模块通信，所有的模块按某种方法组装起来，成为一个整体，从而完成整个系统所要求的功能。

#### 1、文件划分

- 在早期刀耕火种的前端三件套时代，`HTML` 中通过引入到多个不同逻辑的 `js` 文件，构成了**最原始的模块化实现方式——文件划分模式。**

- 具体做法，就是将每个功能，以及它相关的一些状态数据，单独存放到不同的文件中。约定每个文件就是一个独立的模块，使用这个模块的话，就是将这个模块引入到`html`页面中，一个`script`标签就对应一个模块，然后在代码当中去调用全局成员（变量 / 函数）。

  ```
  // moduleA.js
  let moduleName = "moduleA";
  
  // moduleB.js
  let getModuleName = () => {
    console.log("This is moduleB!");
  };
  
  // entry.js
  console.log(moduleName); // moduleA
  getModuleName(); // This is moduleB!
  
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Document</title>
    </head>
    <body>
      <script src="./moduleA.js"></script>
      <script src="./moduleB.js"></script>
      <script src="./entry.js"></script>
    </body>
  </html>
  
  
  ```

  

- 上述案例代码中，`entry.js` 分别使用了 `moduleA`、`moduleB `的变量与函数，实现了简易的代码分离与组织，但随着代码量的增大及项目复杂度的增加，文件划分方式存在很多问题。
  - **命名冲突:** `moduleA` 和 `moduleB `定义在全局，并没有构造私有空间，如果 `moduleB` 同时定义了 `moduleName`，**两个模块间就会发生变量名的覆盖，引起变量冲突**
  - **依赖模糊:** 无法清晰的确定模块之间的依赖关系和加载顺序。文件划分方式中被依赖项需要引用在前，也就是说script 引入顺序仅仅提供了某些` js` 文件的前后依赖，并不能确切的反应各模块间的依赖关系。
  - **全局作用域污染**：所有模块都直接在全局工作，没有独立的私有空间，**所有成员都可以在模块外部被访问或者修改。**
  - **维护性差:** 代码间组织方式混乱，后期维护难度较高
  - **复用性差**

- 文件划分模式实现模块化的缺点简直可以举一大箩筐，后续模块化的演变正是对缺点的不断优化。

#### 2、命名空间

- **命名空间是另一种模块化的实现方案，其目的在于解决命名冲突问题。**

- **我们约定每个模块只暴露一个全局的对象，所有的模块成员都挂载到这个对象下面。**

- **命名空间的核心实现在于将变量与函数声明为对象的属性，只要外层对象命名不发生冲突，内部的成员就不会发生覆盖。**

  ```
  // moduleA.js
  
  let moduleA = {
    moduleName: "moduleA",
    getModuleName() {
      return this.moduleName;
    },
  };
  ```

  ```
  // moduleB.js
  
  let moduleB = {
    moduleName: "moduleB",
    getModuleName() {
      return this.moduleName;
    },
  };
  ```

  ```
  // entry.js
  
  console.log(moduleA.getModuleName()); // moduleA
  console.log(moduleB.getModuleName()); // moduleB
  ```

- 命名空间的写法一定程度上减少了命名冲突问题，**但其本质写法为对象，并没有构建私有作用域，所有模块的成员可以被外部访问（不能控制模块内那些成员可以被访问哪些不可以），这违背了模块化的设计理念，同时也无法管理模块间的依赖问题。**

  ```
  // entry.js
  
  moduleA.moduleName = "alterModule";
  moduleA.getModuleName(); // alterModule
  ```

- 所以通过命名空间方式减小了命名冲突的可能，但是还是解决不了全局作用域污染和依赖模糊（无法管理模块之间的依赖关系）问题。

#### 3、`IIFE`（立即执行函数）

- **JavaScript 中函数可以生成函数作用域，外部无法访问内部定义的成员，使用闭包思想，可以将内部成员暴露给外部使用**。因此可以借助**函数+闭包特性实现私有数据和共享方法，由于该函数只是为了辅助模块化的实现，因此采用 `IIFE` 立即执行函数的模式。**

- 当外部使用 `IIFE` 构建的模块时，只能通过模块提供的接口进行操作，无法访问私有成员。**这种方式成功的解决了命名冲突以及私有空间的问题，同时也是现代模块化规范的思想来源。**

  ```
  // moduleA.js
  
  let moduleA = (function () { //函数作用域
    const _moduleName = "moduleA";
    const getModuleName = function () { //闭包
      return _moduleName;
    };
    return { getModuleName };
  })();
  ```

  ```
  // moduleB.js
  
  let moduleB = (function () {
    const _moduleName = "moduleB";
    const getModuleName = function () {
      return _moduleName;
    };
    return { getModuleName };
  })();
  ```

  ```
  // entry.js
  
  console.log(moduleA.getModuleName()); // moduleA
  console.log(moduleB.getModuleName()); // moduleB
  
  moduleA._moduleName = "alterModule";
  console.log(moduleA.getModuleName()); // moduleA
  ```

- **疑问：函数里面的变量是私有的，要让外部访问该变量为什么不是直接return而是使用闭包呢？**

  - 直接return

    ```
    // moduleA.js
    
    let moduleA = (function () { //函数作用域
      const _moduleName = "moduleA";
    
      return { _moduleName };
      或者 return _moduleName
    })();
    ```

  - 使用闭包

    ```
    // moduleA.js
    
    let moduleA = (function () { //函数作用域
      const _moduleName = "moduleA";
      const getModuleName = function () { //闭包 + return
        return _moduleName;
      };
      const setModuleName = function (val) { //闭包 + return
         _moduleName  = 3333
      };
      return { 
         getModuleName,
         setModuleName
      };
    })();
    ```

  - **`js`函数执行完毕`return`出来的变量和闭包中`return`的变量之间的区别？**

    - 在JavaScript中，函数执行完毕后通过`return`语句返回的变量和在闭包（Closure）中返回的变量之间有几个关键的区别。这些区别主要涉及作用域、生命周期和如何被访问。下面详细解释这些区别：

      **（1）基本概念**

      - **返回变量**：当函数通过`return`语句返回一个值时，**这个值会被传递给调用该函数的表达式**。例如，`functionExample()`返回一个值，**该值可以被用来赋值给另一个变量或者作为表达式的一部分**。
      - **闭包**：闭包是一个**函数，它记住了自己定义时的词法作用域**，即使这个函数在定义时的词法作用域已经执行完毕。闭包可以访问其父作用域中的变量，即使这些变量在当前作用域中已经不可用。

      **（2）作用域和生命周期**

      - **返回变量**：当函数通过`return`返回一个值时，这个值只在当前的函数调用中被使用。一旦函数执行完毕，除非这个**值**被赋值给某个变量或以其他方式保留，否则它将不再可用。
      - **闭包中的变量**：闭包可以访问其父作用域中的变量，即使这些变量在当前作用域中已经不可用。这是因为**闭包“捕获”了这些变量的引用，而不是它们的值**。这意味着即使原始作用域已经消失，闭包仍然可以访问这些变量的状态。

      **（3）示例对比**

      - **返回变量示例：**

        ```
        function createCounter() {    
        	let count = 0;    
        	return count; // 返回当前count的值
        } 
        const counter = createCounter(); // counter 现在持有 count 的值，即 0
        ```

      - **闭包示例：**

        ```
        function createIncrementor() {    
            let count = 0;    
            return function() { 
                // 返回一个内部函数，这是一个闭包       
                count++; // 访问并修改外部函数的变量        
                return count;    
                };
        } 
        const incrementor = createIncrementor(); // incrementor 是一个闭包，可以多次调用并修改 count 的值
        console.log(incrementor()); // 输出 1
        console.log(incrementor()); // 输出 2
        ```

      **（4）应用场景**

      - **返回变量：**通常用于简单的数据传递或初始化返回值。
      - **闭包：**常用于需要维护状态或延迟执行功能的场景，如事件监听器、异步操作中的回调等。

      **（5）内存管理**

      - **返回变量**：通常生命周期较短，只在函数执行期间存在。

      - **闭包中的变量**：由于闭包可以引用外部函数的局部变量，这些变量在外部函数执行完毕后仍然可以被闭包引用，因此可能会影响内存管理（例如，可能导致外部变量的内存无法被回收）。

        

  - **JavaScript中优先使用闭包而不是直接return变量的原因包括：提供数据封装、维持变量状态、防止全局污染**。其中，**提供数据封装**是闭包的一个重要功能。通过闭包，可以在函数内部创建私有变量，外部代码无法直接访问这些变量，只能通过闭包所返回的函数来间接地读取或修改这些变量的状态。这是一种设计模式，有助于建立更加严格和清晰的接口，封装细节，防止外部的不当访问，保护数据安全性和完整性。

  - **直接 return 返回的是变量，闭包返回的是执行环境；(`return` 语句是函数执行完毕后返回值的机制，而闭包是一种特殊的对象结构，用于存储函数以及函数的词法环境。闭包能够捕获并保持函数中 `return` 语句所返回的值，即使在函数执行结束后，这些值仍然可以被访问。)**

  - **闭包不是为了让函数外部拿到内部变量。而是为了保护私有变量不被随意修改；**

  - **return 出来的是一个值，不是变量本身，此处的 return 是取得私有变量值的一种方法，跟闭包没有严格关系；**

  - **直接return返回的是变量的值，而闭包返回的是可以访问函数内部变量的函数，提供了更多的灵活性。**

  - **闭包作为一个可以访问函数内部变量的函数，更多的是可以在其中添加其他的条件，过滤无效的值。如果直接return 变量，然后赋值的话，还要在后续去判断这个值的有效性。**

  - **闭包让我们可以创建可以携带状态的函数，这些函数可以在不同的上下文中被重复使用，而不需要重新创建所需要的状态。**

    

- **新的问题来了，`IIFE` 方式可以解决依赖问题吗？**

  - 这时可以使用引入依赖，即通过 `IIFE` 的函数参数将依赖传入。

    ```
    // moduleC.js
    
    let moduleC = (function () {
      const _moduleName = "moduleC";
      const _moduleData = { x: 1 };
      const getModuleData = function () {
        console.log("Module: ", _moduleName, " Data: ", _moduleData.x);
      };
      return { getModuleData };
    })();
    ```

    ```
    // moduleA.js
    
    let moduleA = (function (module) {
      const _moduleName = "moduleA";
      const getModuleName = function () {
        console.log(_moduleName);
        console.log(module.getModuleData());
      };
      return { getModuleName };
    })(moduleC);
    ```

    ```
    // entry.js
    
    // Module:  moduleC  Data: 1
    console.log(moduleA.getModuleName()); // moduleA
    ```

#### 4、依赖注入

- 在 `IIFE` 方式之后，后续又出现了多种模块化方案，例如模板定义依赖、注册定义依赖、Sandbox 模式、依赖注入。

- 依赖注入的作为重要的开发思想，解耦大杀器，目前已经遍布前端世界，`vue3`、`react`、`angular`、`nest` 等都有使用，因此本文来特地讲解一下。

- 在解释依赖注入之前，我们要先知道一个定义，控制反转 (`Inverse of Control`)，也就是我们经常听到的` IOC`

- **控制反转（`Inversion of Control`，缩写为`IoC`）**

  - 是一种编程思想，它的主要目的是将程序中组件之间的控制关系颠倒过来。

  - 在传统的编程模式中，每个对象都负责创建或获取它所需要的其他对象，而在`IOC`中，这些对象的创建和管理被转移到一个外部容器中，由容器来管理它们的生命周期并将它们注入到需要使用它们的组件中。 这样可以增强程序的灵活性、可扩展性、可维护性和可测试性。

  - 依赖注入是实现控制反转思想的其中一种实现

- **依赖注入**

  - 依赖注入(`Dependency Injection`) 是一种编程模式，它的主要目的是解耦组件之间的依赖关系。

  - 在依赖注入中，一个对象不再负责创建或获取它所需要的其他对象，而是由外部的容器来负责将这些依赖注入进来。这样可以使得代码更加灵活、可测试和可维护。

- 实现

  ```
  // 具象化三大模块
  function vue() {
    return {
      module: "vue",
      ability: "code module",
    };
  }
  
  function vite() {
    return {
      module: "vite",
      ability: "bunde module",
    };
  }
  
  function server() {
    return {
      module: "server",
      ability: "data module",
    };
  }
  ```

- 假设现在有` vue`、`vite`、`server` 三个模块，我们试图借助这三个模块开发一些有意思的网站，可以将依赖模块借鉴` IIFE `引入依赖的方式以函数参数传入。

  ```
  var developWeb = function (vue, vite, server) {
    let v = vue();
    let vi = vite();
    let s = server();
    console.log(v.ability, vi.ability, s.ability);
  };
  ```

- 但问题来了，依赖的模块该如何进行管理呢，例如后续开发需要依赖新的模块，只能修改函数参数或者构造新的函数，这可是大忌。 这时候，依赖注入闪亮登场，来分析一下实现要点。
  - 可以实现依赖关系的注册(即 `IOC` 容器来存储所有的依赖)
  - 依赖注入器可以接受一个函数，注入成功后返回一个可以获取所有依赖资源的函数
  - 注入应保持被传递函数的作用域
  - 被传递的函数应该能够接受自定义参数，而不仅仅是依赖描述

- 下面来简单实现一个依赖注册器` injector`，`injector` 由依赖容器、注册依赖函数、依赖注入函数三部分组组成。对于 `resolve` 函数，`deps` 代表被依赖 `key` 数组，`func` 代表需要注入依赖的函数，`scope` 代表 `func` 函数作用域。

  ```
  const injector = {
    dependencies: {}, // 依赖管理中心
    register: function (key, value) {
      // 注册依赖关系
      this.dependencies[key] = value;
    },
    resolve: function (deps, func, scope) {}, // 依赖注入
  };
  ```

- `resolve`函数目的在于将 `deps `涉及的依赖注入到` func `函数中，实现并不复杂。首先根据 `deps `数组将所需的依赖从 `dependencies` 取出添加到 `dependModule` 数组中，然后在返回的函数中使用 `apply `方法传递 `scope` 作用域及其他参数。

  ```
  var injector = {
    dependencies: {},
    register: function (key, value) {
      this.dependencies[key] = value;
    },
    resolve(deps, func, scope) {
      const dependModule = [];
      for (let i = 0; i < deps.length; i++) {
        const d = deps[i];
        // 分析依赖是否存在，收集所需依赖
        if (this.dependencies[d]) {
          dependModule.push(this.dependencies[d]);
        } else {
          throw new Error(d + "依赖不存在");
        }
      }
      return function () {
        // 传递函数作用域
        // 接受其他参数
        func.apply(
          scope,
          dependModule.concat(Array.prototype.slice.call(arguments, 0))
        );
      };
    },
  };
  ```

- 来看看使用:

  ```
  injector.register("vue", vue);
  injector.register("vite", vite);
  
  injector.resolve(["vue", "vite"], function (vue, vite) {
    let v = vue();
    let vi = vite();
    console.log(v.ability, vi.ability);
  })();
  
  // 传入其他参数
  injector.resolve(["vue", "vite"], function (vue, vite, other) {
    let v = vue();
    let vi = vite();
    console.log(v.ability, vi.ability, other);
  })("other");
  ```

- 到这里，实现了一个简单的依赖注入，但上述实现并不完美。例如使用时需要重复所需依赖两次，此外由于附加参数的存在，还不能混淆顺序。

- 通过 `IIFE` 我们解决了私有作用域的问题，却无法解决 `script` 标签引入的问题，当 `index.html` 中引入了十几个 `script` 标签，还要维护他们的引入顺序时，那是相当痛苦的。

#### 5.总结

- 首先我们来总结一下早期模块化的探索历程:

- 最初文件划分方式实现简单的代码逻辑划分 --> 命名空间方式减少命名冲突 --> `IIFE` 构建私有作用域 --> `IIFE` 引入依赖实现简单的依赖管理 --> 依赖注入降低模块依赖间的耦合度

- 从早期模块化的探索历程中，大抵可以总结出**模块化的核心诉求: 命名冲突、依赖管理、全局污染**。模块化并非一个孤立概念，不能将模块化脱离工程化，模块化的内涵也要追溯到降本提效上，因此在我看来，一个完善的模块化要具备下列几部分:
  - 隔离作用域
  - 解决命名冲突
  - 增加代码的可维护性
  - 增加代码的复用性
  - 便捷的依赖管理

## 三、模块化规范 

#### 1、`Commonjs `规范

**1.1、`commonjs`概述**

- `Commonjs` 是业界最早提出的模块化规范，`CommonJS`规范最初是为`Node.js`设计的，用于服务器端编程。

- `Commonjs` 模块化规范实现围绕四个核心环境变量:
  
  - `module`: 每个模块内部都存有 `module` 对象代表当前模块
  - `exports`: 通过 `exports`(或 `module.exports`) 暴露模块内部属性
  - `require`: 使用 `require` 来实现模块加载
  
- `global`: 全局上下文环境
  
- 学会核心四大环境变量后，`Commonjs` 规范就简单多了:
  - 每一个文件就是一个模块，拥有自己独立的作用域。
  - 模块内部定义变量以及方法等都是私有的，对外界不可见。
  - `module` 对象的 `exports`(或 `module.exports`) 属性是对外的接口，加载某个模块，实际上就是加载该模块的 `module.exports `属性(不推荐直接使用 `exports`)
  - 使用 `require` 加载模块

- `Commonjs` 使用起来比较简单，下面咱们来尝试一下:

  ```
  // 导出模块
  // moduleA.js
  const moduleName = "moduleA";
  const add = function (a, b) {
    return a + b;
  };
  module.exports = {
    moduleName,
    add,
  };
  
  // 加载模块
  // entry.js
  const moduleA = require("./moduleA");
  console.log(moduleA.moduleName); // moduleA
  console.log(moduleA.add(1, 2)); // 3
  ```


**1.2、`require` 加载模块，本质上就是读取 `module.exports` 属性，`exports` 也可以实现导出功能，但通常不推荐使用**

**1.3、`module.exports` 和 `exports` 在模块中默认情况下指向同一地址空间，等价；但若后续发生地址层面的修改，两者就会产生差异，造成导出内容存在问题。**

```
// Mary.js
const Tom = require("./Tom");
if (Tom.name === "Tom" && Tom.height === 180) {
	console.log("成功找到 Tom");
} else {
	console.log("未能找到 Tom");
}
```

- 第一种情形: `module.exports` 和 `exports` 分别提供了一条线索

  ```
  // Tom.js
  module.exports.name = "Tom";
  exports.height = 180;
  ```
  - 成功找到 `Tom`

- 第二种情形: `module.exports` 指向了另一个重名 `Tom`，而 `exports` 仍指向原来的 `Tom`，`require` 默认读取 `module.exports`， `Mary` 最终只获取了同名 `Tom` 的 `name` 信息。

  ```
  module.exports = {
  	name: "Tom",
  };
  exports.height = 180;
  ```
  - 未能找到 `Tom`

- 第三种情形: `exports` 指向了另一个 `Tom`，而 `require` 获取 `module.exports` 上接口，因此 `exports` 提供的线索一律不予采纳。

  ```
  module.exports.name = "Tom";
  exports = {
    height: 180,
  };
  ```
  - 未能找到 `Tom`

**1.4、`Commonjs` 模块输出的是值的拷贝，对于原始类型，复制其值，模块内部的变化不会影响导出值；对于引用类型为浅复制，属性的变动会影响导出值。**

```
// moduleA.js
let count = 0;
let obj = {
	count: 0,
};
let add = () => {
    count++;
    obj.count++;
};
let alterObj = () => {
    obj = {
        newCount: 0,
    };
};

module.exports = { count, add, obj, alterObj };

// entry.js
const { count, add, obj, alterObj } = require("./moduleA");

console.log("count: ", count, " obj.count:", obj.count); // count:  0  obj.count: 0

add();

console.log("count: ", count, " obj.count:", obj.count); // count:  0  obj.count: 1

console.log("obj", obj); // obj { count: 1 }

alterObj();

console.log("obj", obj); // obj { count: 1 }
```

- 通过上述案例，`Commonjs` 引用的机制非常类似于 `ES6 const` 语法，基本类型不会变化，引用类型只会发生属性级别的变化

**1.5、模块加载相关**

**（1）`MainModule`**

- 当运行 `node index.js` 时，Node 调用 Module 类上的静态方法 `_load(process.argv[1])` 加载这个模块，并标记为主模块，赋值给 `process.mainModule` 和 `require.main`，可以通过这两个字段判断当前模块是主模块还是被 `require` 进来的。
- `CommonJS` 规范是在代码运行时同步阻塞性地加载模块，在执行代码过程中遇到 `require(X)` 时会停下来等待，直到新的模块加载完成之后再继续执行接下去的代码。
- 虽说是同步阻塞性，但这一步实际上非常快，和浏览器上阻塞性下载、解析、执行 `js` 文件不是一个级别，硬盘上读文件比网络请求快得多。
- `Commonjs` 应用于服务端，模块存放在本地磁盘上，不需要进行网络 I/O，读取速度特别快；此外，服务端启动后通常会一直运行，模块读取只发生在服务启动阶段，这种模式并不会影响服务的性能。而在浏览器端则存在大量的异步操作，使用 `Commonjs` 规范会造成浏览器 `JS` 解析过程的阻塞，严重影响页面加载速度。 可见 `Commonjs` 并不适用于浏览器端，因此业界后续又设计出了全新的异步加载规范应用于浏览器端。

**（2）缓存和循环引用**

- 文件模块查找挺耗时的，如果每次 require 都需要重新遍历文件夹查找，性能会比较差；还有在实际开发中，模块可能包含**副作用**代码，例如在模块顶层执行 `addEventListener` ，如果 require 过程中被重复执行多次可能会出现问题。

- `CommonJS` 中的缓存可以解决重复查找和重复执行的问题。模块加载过程中会以模块绝对路径为 `key`, `module` 对象为 `value` 写入 `cache`。在读取模块的时候会优先判断是否已在缓存中，如果在，直接返回 `module.exports`；如果不在，则会进入模块查找的流程，找到模块之后再写入 `cache`。

- **缓存还解决了循环引用的问题。**
  
  - 举个例子，现在有模块 a require 模块 b；而模块 b 又 require 了模块 a。
  
    ```
    // main.js
    const a = require('./a');
    console.log('in main, a.a1 = %j, a.a2 = %j', a.a1, a.a2);
    
    // a.js
    exports.a1 = true;
    const b = require('./b.js');
    console.log('in a, b.done = %j', b.done);
    exports.a2 = true;
    
    // b.js
    const a = require('./a.js');
    console.log('in b, a.a1 = %j, a.a2 = %j', a.a1, a.a2);
    ```
  
  - 程序执行结果如下：
  
    ```
    in b, a.a1 = true, a.a2 = undefined
    in main, a.a1 = true, a.a2 = true
    ```
  
  - 实际上在模块 a 代码执行之前就已经创建了 Module 实例写入了缓存，此时代码还没执行，exports 是个空对象。
  
    ```
    '/Users/evan/Desktop/module/a.js': 
       Module {
         exports: {},
         //...
      }
    }
    ```
  
  - 代码 `exports.a1 = true;` 修改了 `module.exports` 上的 `a1` 为 `true`, 这时候 `a2` 代码还没执行。、
  
    ```
    '/Users/evan/Desktop/module/a.js': 
       Module {
         exports: {
          a1: true
        }
         //...
      }
    }
    ```
  
  - 进入 `b` 模块，`require a.js` 时发现缓存上已经存在了，获取 `a` 模块上的 `exports` 。打印 `a1, a2` 分别是 `true`，和 `undefined`。
  
  - 运行完 `b` 模块，继续执行 `a` 模块剩余的代码，`exports.a2 = true;` 又往 `exports` 对象上增加了 `a2` 属性，此时 `module a` 的 `export` 对象 `a1, a2` 均为 `true`。
  
    ```
    exports: { 
      a1: true,
      a2: true
    }
    ```
  
  - 再回到 `main` 模块，由于 `require('./a.js')` 得到的是 `module a` `export` 对象的引用，这时候打印 `a1, a2` 就都为 `true`。
  
- **小结：**

  - `CommonJS` 模块加载过程是同步阻塞性地加载，在模块代码被运行前就已经写入了 `cache`，同一个模块被多次 `require` 时只会执行一次，重复的 `require` 得到的是相同的 `exports` 引用。
  - **值得留意：** `cache key` 使用的是模块在系统中的绝对位置，由于**模块调用位置的不同**，相同的 `require('foo')` 代码并不能保证返回的是统一个对象引用。我之前恰巧就遇到过，两次 require('egg-core') 但是他们并不相等。

**1.6、`CommonJs`模块化实现原理**

```
name.js:

module.exports = "不要秃头啊";

main.js：

let author = require("./name.js");
console.log(author, "author");
```
- 在看具体打包代码之前，我们先来分析一下。
- 在`name.js`中有一个 `module` 对象，`module` 对象上有一个 `exports` 属性，我们给 `exports` 属性进行了赋值："不要秃头啊"。
- 在`main.js`中，我们调用了 `require` 函数，入参为模块路径（`./name.js`），最后返回值为 `module.exports` 的内容。
- 如果让我们来设计一下这个运行过程，是不是这样就可以了：将`name.js`中的内容转换到一个modules对象中，该对象中key值为该模块路径，value值为该模块代码。在require函数执行时获取导出对象。

```
var modules = {
"./name.js": () => {
    var module = {};
    module.exports = "不要秃头啊";
    return module.exports;
},
};
const require = (modulePath) => {
return modules[modulePath]();
};

let author = require("./name.js");
console.log(author, "author");
```

- 其实源码中的大致思路也是类似的，以上就是`CommonJs`能在浏览器中运行的核心思想。

- 接下来我们看看具体源码中的实现（对打包后的内容进行了调整优化，不影响阅读）。

- 主要分为以下几个部分：
  - 初始化：定义 modules 对象
  - 定义缓存对象cache
  - 定义加载模块函数require
  - 执行入口函数
  
  ```
  //模块定义
  var modules = {
      "./src/name.js": (exports, require, module, __filename, __dirname) => {
          module.exports = "不要秃头啊";
      },
  };
  ```
  
  
  
  ```
  function require(modulePath){
     //1.根据传递的模块路径，得到模块完整的绝对路径
     let moduleId = getModuleId(modulePath)
     
     //2. 判断缓存
     var cachedModule = cache[moduleId]; //获取模块缓存
     if (cachedModule) {
         //如果有缓存则不允许模块内容，直接retuen导出的值
         return cachedModule;
      }
      
     //3.真正引入模块代码的辅助函数 modules[moduleId]
     function _require(exports, require, module, __filename, __dirname) {
      //目标模块的代码在这里
     }
     
     // 4.创建当前模块的 module
     var module = {
       exports: {},
       loaded: false ,
       ...
     };
     
     
    // 5. 缓存 module.exports
    cache[moduleId] = module.exports;
  
     var exports = module.exports; //exports对象和module.exports对象指向同一个内存空间，这个值会以函数参数的方式传入到每一个模块文件里面，所以模块文件既可以使用module.exports导出又可以使用exports导出。
     
    // 得到模块文件的绝对路径
    var __filename = moduleId;
    
    // 得到模块所在目录的绝对路径
    var __dirname = getDirName(__filename);
    
    //6.加载文件，执行文件代码 
    _require.call(exports, exports, require, module, __filename, __dirname);
    //等价于 modules["./src/name.js"].call(exports, exports, require, module, __filename, __dirname);
    //等价于 (exports, require, module, __filename, __dirname) => {
               module.exports = "不要秃头啊";
            }
            
    //7.加载完成 
    module.loaded = true 
    
    //8. 返回 module.exports
    return module.exports; //模块最后导出的是module.exports对象，所以如果改变exports对象的内存指向，module.exports和exports的指向就不一样了，exports就不会影响到module.exports的值了，也就是不会影响到模块文件最后导出内容了
  }
  ```
  
  ```
  //执行入口函数
  (() => {
  
      let author = require("./src/name.js");
      console.log(author, "author"); //不要秃头啊 author
      
  })();
  ```
  
  - 首先`require`函数会接受一个`modulePath`参数，也就是我们传入的文件路径`"./src/name.js"`。根据这个文件路径得到一个唯一的模块ID，这个ID是什么呢？其实就是这个模块的完整绝对路径。
  
  - 根据模块ID判断`cache`中是否已经存在，如果缓存中已经有了，就直接返回缓存结果。
  
  - 接下来就是运行函数了，怎么运行呢？其实就是将`./src/name.js`文件中全部代码放到_require函数里面去执行，也就是下面的形式：
  
    ```
      function _require(exports, require, module, __filename, __dirname) {
      
        //目标模块的代码在这里
         module.exports = "不要秃头啊";
      }
    
    ```
  
- **1.7、`Webpack5`实现`CommonJS`模块化的原理**

  - **准备工作**

    - `src` 目录下新建 `js` 文件夹，`js` 文件夹中新建 `math.js` 文件，使用 `CommonJS` 模块化导出两个简单的函数，代码如下：
  
      ```
      // src/js/math.js
      const sum = (num1, num2) => {
        return num1 + num2
      }
      
      const mul = (num1, num2) => {
        return num1 * num2
      }
      
      module.exports = {
        sum,
      mul
      }
    ```
  
  - `src` 目录下新建 `index.js` 文件，作为 `webpack` 打包入口。在 `index.js` 中，使用 `CommonJS` 方式引入 `math.js` 中的两个函数，代码如下：
  
    ```
      const { sum, mul } = require('./js/math.js')
      console.log(sum(10, 20))
      console.log(mul(10, 20))
    ```
  
  - 在 `webpack.config.js` 中，将 `mode` 设置为 `'development'`，将 `devtool` 设置为 `'source-map'`，以便于我们打包后输出的源码更容易阅读和分析。`webpack.config.js` 代码如下：
  
      ```
      const path = require('path')
    const { CleanWebpackPlugin } = require('clean-webpack-plugin')
      const HtmlWebpackPlugin = require('html-webpack-plugin')
    
      module.exports = {
        mode: 'development',
        entry: './src/index.js',
        devtool: 'source-map',
        output: {
        filename: 'js/bundle.js',
          path: path.resolve(__dirname, './build')
      },
        plugins: [
        new CleanWebpackPlugin(),
          new HtmlWebpackPlugin({
            title: 'webpack'
          })
        ]
      }
      ```
  
    - 代码目录的其他部分和打包过程不做详细展示，下面我们将开始分析打包后的 `bundle.js` 代码。

  - **`bundle.js` 的简要说明**

    - 我们先来简要的看一下打包出来的代码的大致情况，简单的做一个认识，方便我们下文详细分析。代码如下：
  
      ```
      // 最外层使用立即执行函数包裹，分析中可以忽略
      ;(() => {
        // 1.定义了一个 __webpack_modules__ 对象
        var __webpack_modules__ = {
      // 上面调用的时候传入了三个参数，而该函数执行时只写了 module 参数，因为本文案例比较简单，另外两个参数没有用到
          './src/js/math.js': module => {
         // 这里将我们在 math.js 中定义的两个函数，用对象包裹后赋值给 参数传入的 module 变量的 export 属性
            const sum = (num1, num2) => {
              return num1 + num2
            }
            const mul = (num1, num2) => {
              return num1 * num2
            }
            module.exports = {
            sum,
              mul
          }
          }
      }
      
        // 2.定义了一个 __webpack_module_cache__ 空对象
        var __webpack_module_cache__ = {}
      
        // 3.定义 __webpack_require__ 函数
        function __webpack_require__(moduleId) {
        // 从立即执行函数的调用得出，moduleId 的值是'./src/js/math.js'，也就是我们引入模块的路径
          
        // 这一行代码在 __webpack_module_cache__ 缓存对象中
          // 以 moduleId 模块路径为 key 去获取其对应的值，赋值给 cachedModele
        var cachedModule = __webpack_module_cache__[moduleId]
          
          // 如果cachedModule 有值，将 cachedModule 的 export 属性的值直接返回
          if (cachedModule !== undefined) {
            return cachedModule.exports
        }
          
        // 这里是一个连续赋值，将 {exports:{}} 对象既赋值给 缓存对象key为 moduleId（'./src/js/math.js'）的值，也赋值给 module 变量。
          // 因为{exports:{}}是一个对象，也就是说 module 和 __webpack_module_cache__[moduleId] 有了相同的引用，后面如果改了就一起变化
          var module = (__webpack_module_cache__[moduleId] = {
            exports: {}
          })
          
          // 这里使用了第一部分的__webpack_modules__对象，对象key为moduleId（'./src/js/math.js'）
          // 也就是说拿到了了 __webpack_modules__['./src/js/math.js'] 对应的那个函数并将后面三个参数传入并执行。这里进入了上面第一部分中的 __webpack_modules__[moduleId] 函数
          __webpack_modules__[moduleId](module, module.exports, __webpack_require__)
          
          // 执行完后返回
        return module.exports
        }
      
      
        // 定义 __webpack_exports__ 空对象，但并未使用
        var __webpack_exports__ = {}
      
        // 4.一个立即执行函数，去除外层立即执行函数后真正开始执行的地方
        ;(() => {
         // 至此 __webpack_require__('./src/js/math.js') 执行完毕，返回的是非常普通的一个对象
          // 对象中包含了 sum 与 mul 函数，将它们从返回值解构出来我们就可以愉快的使用了
          const { sum, mul } = __webpack_require__('./src/js/math.js')
          console.log(sum(10, 20))
          console.log(mul(10, 20))
      })()
      })()
      
      ```
  
    - 打包后的 `bundle.js` 执行过程：
  
      1. 从外层立即执行函数开始执行，真正执行内部代码的地方是第四部分的立即执行函数
      2. 将 模块路径`'./src/js/math.js'` 作为参数，执行 `__webpack_require__` 方法
      3. `__webpack_require__`函数中将 `{exports:{}}`连续赋值给 `__webpack_module_cache__` 缓存对象以及 `module` 变量。`module`和 `__webpack_module_cache__`引用相同，一变都变
      4. 将 `module` 变量作为参数（以及本案例中未用到的 `module.exports, __webpack_require__`）来执行 `__webpack_modules__`对象中对应的该模块对应的函数，函数执行完之后 `module.exports` 和 `__webpack_module_cache__` 缓存对象中同时都有了原来 CommonJS模块（`'math.js'`）中导出的内容
      5. 至此 `__webpack_require__` 执行完毕，内层立即执行函数中已经拿到了模块中的内容来进行后续操作
      6. 如果其他地方也引用到了 `math.js` 模块，将直接从缓存对象中去拿
  
- **1.8、例题**

  **（1）一道面试题**

  ```
  // 1.js
  this.a = 1;
  
  exports.b = 2;
  
  exports = { c: 3 };
  
  module.exports = { d: 4 };
  
  exports.e = 5;
  
  this.f = 6;
  ```

  - 由上面原理可知，`this = exports = module.exports`，**注意这里的等号指的是它们指向同一个内存空间。**

  - 一开始的时候，`this`、`exports`、`module.exports`都是空对象 `this =  exports =  module.exports = {}`

    1. `this.a = 1;`后变成：

       ```
       this =  exports =  module.exports = { a:1 }
       ```

    2. `exports.b = 2;;`后变成：

       ```
       this =  exports =  module.exports = { a:1, b:2 }
       ```

    3.  `exports = { c: 3 };`,**关键的来了，这里是给`exports`对象重新赋值了**

       ```
       this =  module.exports = { a:1, b:2 }
       
       exports =  { c: 3 }
       ```

       - 这个时候`exports`和`this`、`module.exports`已经不相等了。

    4. `module.exports = { d: 4 };`,**同样的，`module.exports`也被重新赋值了**

       ```
       this = { a:1, b:2 }
       
       exports =  { c: 3 }
       
       module.exports = { d: 4 }
       
       ```

    5.  `exports.e = 5;` 后变成：

       ```
       this = { a:1, b:2 }
       
       exports =  { c: 3, e:5 }
       
       module.exports = { d: 4 }
       ```

    6.  `this.f = 6;` 后变成：

       ```
       this = { a:1, b:2, f:6}
       
       exports =  { c: 3, e:5 }
       
       module.exports = { d: 4 }
       ```

    7. **最后的最后，一定要注意最后一句导出的代码：**

       - 由源码可知，模块最后导出的是`module.exports`对象，所以如果改变`exports`对象的内存指向，`module.exports`和`exports`的指向就不一样了，`exports`就不会影响到`module.exports`的值了，也就是不会影响到模块文件最后导出内容了。

       ```
         // 伪代码
         // ..
         // 6. 返回 module.exports
         return module.exports;
       ```

       - 返回的不是`this`，也不是`exports`，而是` module.exports`

    8. 所以最终的答案就显而易见了：

       ```
       const r = require("./1.js");
       console.log(r);// { d: 4 }
       ```

  **（2）一道循环引用练习题**

  ```
  //a.js
  const getMes = require('./b')
  console.log('我是 a 文件',getMes,getMes())
  exports.say = function(){
      const message = getMes()
      console.log('message',message)
      return message
  }
  ```

  ```
  //b.js
  const say = require('./a')
  console.log('say',say)
  const  object = {
     name:'《React进阶实践指南》',
     author:'我不是外星人'
  }
  console.log('我是 b 文件')
  module.exports = function(){
      return object
  }
  ```

  ```
  //主文件main.js
  const a = require('./a')
  const b = require('./b')
  console.log('node 入口文件','a',a) 
  console.log('node 入口文件','b',b) 
  console.log('node 入口文件',a.say(),b())
  
  node main.js
  //输出
  say {}
  我是 b 文件
  我是 a 文件 [Function (anonymous)] { name: '《React进阶实践指南》', author: '我不是外星人' }
  node 入口文件 a { say: [Function (anonymous)] }
  node 入口文件 b [Function (anonymous)]
  message { name: '《React进阶实践指南》', author: '我不是外星人' }
  node 入口文件 { name: '《React进阶实践指南》', author: '我不是外星人' } { name: '《React进阶实践指南》', author: '我不是外星人' }
  ```

  - 步骤详解：

    - 1、在`Node.js`中执行`main`模块。此时遇到`require`关键字，执行`a.js`中所有代码。

    - 2、由`require`源码可知，`require('./a')`时，会先初始化一个module对象，并会将该对象加入缓存中，所以这个时候，`./a`这个`modulePath`在缓存中已经存在了，值为{}

      ```
       var module = {
           exports: {},
           loaded: false ,
           ...
         };
         
        // 缓存 module.exports
        cache[moduleId] = module.exports;
      
        var exports = module.exports;
      ```

    - 3、在`a.js`文件中遇到`require`关键字引入了`b`模块，执行`b.js`中所有代码，这里和步骤2中的过程一样。

    - 4、在`b.js`文件又遇到`require`关键字，循环引用了`a.js`，由于第二步中，缓存中已经有了`a.js`值为{}，这个时候不会再次去加载`a.js`文件了，直接取缓存里的值，所以第一个输出`say {}`

    - 5、继续执行`b.js`，输出`我是 b.js 文件`，直到`b.js`文件执行完毕。

    - 6、回到`a.js`文件，拿到`b.js`文件的输出值，`我是 a 文件 [Function (anonymous)] { name: '《React进阶实践指南》', author: '我不是外星人' }`，直到`a.js`文件执行完毕。

    - 7、回到`main.js`文件，遇到`require`关键字引入了`b`模块，由于在`a`模块中已经引入过了，所以直接用缓存中的值。到此为止，`a.js`中的代码和`b.js`中的代码都全部执行完毕了。

    - 8、输出`node 入口文件 a { say: [Function (anonymous)] }`

      ```
      //'node 入口文件' 
      //{
      //  say:function(){
      //     const message = getMes()
      //     console.log('message',message)
      //     return message
      //    }
      // }
      ```

    - 9、输出`node 入口文件 b [Function (anonymous)]`

      ```
      //function(){
      //    return {
      //        name:'《React进阶实践指南》',
      //        author:'我不是外星人'
      //     }
      //}
      ```

    - 10、输出`message { name: '《React进阶实践指南》', author: '我不是外星人' }`
      `node 入口文件 { name: '《React进阶实践指南》', author: '我不是外星人' } { name: '《React进阶实践指南》', author: '我不是外星人' }`

  **（3）练习1：导出的变量为值类型**

  ```
  // bar.js
  let name = "时光屋小豪";
  
  setTimeout(() => {
    name = "123123";
  }, 1000);
  
  module.exports = {
    name: name,
    age: "20",
    sayHello: function (name) {
      console.log("你好" + name);
    },
  };
  ```

  ```
  // main.js
  const bar = require("./bar");
  
  console.log("main.js", bar.name); // main.js 时光屋小豪
  
  setTimeout(() => {
    console.log("main.js中2s后", bar.name); // main.js中2s后 时光屋小豪
  }, 2000);
  ```

  **（4）练习2：导出的变量为引用类型**

  ```
  // bar.js
  let info = {
    name: "时光屋小豪",
  };
  
  setTimeout(() => {
    info.name = "123123";
  }, 1000);
  
  module.exports = {
    info: info,
    age: "20",
    sayHello: function (name) {
      console.log("你好" + name);
    },
  };
  
  ```

  ```
  // main.js
  const bar = require("./bar");
  
  console.log("main.js", bar.info.name); // main.js 时光屋小豪
  
  setTimeout(() => {
    console.log("main.js中2s后", bar.info.name); // main.js中2s后 123123
  }, 2000);
  
  ```

- 从`main.js`输出结果来看，定时器修改的`name`变量的结果，并没有影响`main.js`中导入的结果。

  - 因为name为值类型，基本类型，一旦定义之后，就把其属性值，放到了`module.exports`的内存里（练1）
  - 因为info为引用类型，所以`module.exports`里存放的是info的引用地址，所以由定时器更改的变量，会影响`main.js`导入的结果（练2）

**1.9、`CommonJS` 的特性**

- **同步加载**：模块在代码运行时同步加载，适用于服务端，但不适用于浏览器环境，因为浏览器环境中同步加载会阻塞渲染进程。
- **缓存机制**：同一个模块在多次加载时会被缓存，除非明确清除缓存。
- **简单易用**：通过 `require` 和 `module.exports` 实现模块的导入和导出，简单直观。

**2.1、`CommonJS` 可能出现的问题**

- 尽管 `CommonJS` 在服务端开发中被广泛使用，但在前端环境或大型项目中，它也存在一些潜在的问题和局限性：
  - **同步加载的限制**：`CommonJS` 模块是同步加载的，这意味着在模块加载完成之前，代码的执行会被阻塞。在服务端环境中（例如 `Node.js`），这种行为是可行的，因为文件系统读取速度相对较快。然而，在前端浏览器环境中，网络延迟可能导致较长的加载时间，进而阻塞页面渲染并降低用户体验。
  - **循环依赖问题**：`CommonJS` 规范中，模块被加载时执行（运行时加载），如果两个模块互相引用（循环依赖），这可能会导致未定义的行为或部分代码无法执行。虽然大多数情况下，`Node.js` 可以处理这种情况，但会引起意料之外的结果，尤其是当模块依赖链较复杂时。
  - **缺乏静态分析能力**：由于 `CommonJS` 使用动态 `require()` 语句来引入模块，这使得工具很难在编译时进行静态分析。这种动态依赖关系的管理方式，使得打包工具（如 `Webpack`、`Rollup`）难以进行代码优化（如 `Tree Shaking`），从而影响性能和代码体积。
  - **跨平台兼容性**：`CommonJS` 规范设计之初是为了满足服务端 `JavaScript`（`Node.js`）环境的需求，它不适合直接在浏览器环境中使用。虽然可以通过 `Browserify` 等工具将 `CommonJS` 模块转换为浏览器可用的格式，但这增加了开发和构建的复杂性。
- 尽管 `CommonJS` 规范在 `Node.js` 服务端开发中取得了巨大成功，但在前端开发和大型项目中，它也暴露了自身的一些局限性。
- 现代 `JavaScript` 开发逐渐转向 `ES6 Module` 标准，这一标准通过静态分析、异步加载和浏览器原生支持，解决了 `CommonJS` 规范中的许多问题，为开发者提供了更强大和灵活的模块化支持。

#### 2、`AMD` 规范

- `AMD` 全称为 `Asynchronous Module Definition`，即异步模块定义规范。借助该规范，浏览器端可以实现模块异步加载，避免同步加载的页面阻塞。

- `AMD` 规范是一种标准，没有得到浏览器端的原生支持，使用它需要借助第三方实现，`requireJS` 是最经典的库，其完整实现了 `AMD` 规范，后续的使用基于 `requireJS`。 `requireJS` 提供了三个核心方法
  - `define` 定义模块
  - `require` 加载模块
  - `require.config` 指定引用路径

- 下面来建立一个项目，项目结构如下:

```lua
├── index.html
├── scripts
│   ├── utils.js
│   |   └── print.js
│   ├── require.js
│   └── entry.js
```

- 然后看一下具体使用

```lua
// 网页中引入 requirejs 以及模块入口
<script src="./scripts/require.js" data-main="./scripts/entry"></script>;

// entry.js
require.config({
  baseUrl: "scripts/utils",
});

require(["print"], function (printModule) {
  printModule.print("entry");
});

// print.js
define(function () {
  return {
    print: function (msg) {
      console.log("print " + msg);
    },
  };
});
```

- 回看 `requireJS` 的模块加载方式，是不是有几分眼熟，没错，这里的思想类似于上一篇文章中的依赖注入思想。

```lua
require(["print"], function (printModule) {
  printModule.print("entry");
});
```

- 但在 `requireJS` 中，有一个更标准的称呼——依赖前置。依赖前置是 `AMD` 的核心设计思想，`AMD` 通过动态创建 `script` 标签的方式来异步加载模块，加载完成后立即执行该模块，所有的依赖加载并执行完毕后，本模块才会执行。
- 基于依赖前置的 `requireJS` 成功实现了异步模块加载，同时也暴露出很多问题
  - `AMD` 加载依赖模块后会立即执行，并不考虑该该依赖模块后续是否会被使用
  - `AMD` 异步加载模块通过动态创建 script 标签实现，这会提高页面的 js 文件请求量
  - `AMD` 依赖前置的模式要求必须提前写好所需依赖，无法实现按需加载
  - `AMD` 规范使用起来稍显复杂，代码阅读和书写都比较困难
- 综上所述，`AMD` 规范只能说是前端模块化探索过程中的中间方案，距离现代模块化方案还相差甚远。
- **`AMD` 的特性**
  - **异步加载**：通过异步方式加载模块，适合在浏览器环境下使用，避免了浏览器渲染的阻塞问题。
  - **依赖前置**：在定义模块时需要声明所有的依赖模块，这些模块会在代码运行前加载完成。
  - **较复杂的定义方式**：需要使用 `define()` 函数来定义模块，并声明依赖。
- **`AMD` 可能存在的问题**
  - 虽然 `AMD` 规范在解决浏览器环境中模块异步加载方面有显著的优势，但它也存在一些潜在的问题和局限性：
    - **模块定义复杂性增加**：`AMD` 使用 `define()` 函数来定义模块，并且需要提前声明所有的依赖模块。这种显式声明的方式虽然在一定程度上清晰明了，但在大型项目中会显得繁琐复杂，特别是当依赖关系较多时，代码的可读性和维护性会下降。
    - **加载速度较慢**：尽管 `AMD` 通过异步方式加载模块来避免阻塞浏览器渲染进程，但由于模块依赖的前置加载特性，所有依赖模块需要在主模块执行之前全部加载完毕。这在依赖关系复杂或者网络较差的情况下，可能导致模块加载速度变慢，影响页面性能。
    - **过度依赖回调函数**：`AMD` 模块化规范依赖于回调函数，这会导致代码结构的嵌套层级增加，出现俗称的“回调地狱”现象，使得代码的调试和维护变得更加困难。
    - **生态系统和工具支持限制**：相比于 `ES6 Module` 等更现代的模块化标准，`AMD` 的生态系统支持较为有限。虽然 `RequireJS` 等工具对 `AMD` 提供了良好的支持，但相比于现代工具链（如 `Webpack`、`Rollup` 等）对于 `ES6 Module` 的优化和支持，`AMD` 的兼容性和性能优化相对较弱。
- `AMD` 规范通过异步加载的方式有效解决了 `CommonJS` 在浏览器环境下的性能问题，适合用于浏览器端的模块化开发。
- 然而，其复杂的模块定义方式和对回调的过度依赖，使其在大型项目和现代开发中逐渐失去优势。
- 随着 `ES6 Module` 的崛起，开发者们越来越倾向于选择更简单、性能更优的模块化解决方案。

#### 3、`CMD` `规范`

- `CMD(Common Module Definition)`规范是另一种异步模块化解决方案，它出现相对较晚，是在 `SeaJS` 推广过程中产生的，其吸收了 `AMD` 和 `Commonjs` 规范的一些优点。

- `CMD` 规范规定：
  
  - 一个文件就是一个模块
  - `define` 定义模块
- `require` 方法加载模块
  
- `CMD` 规范使用起来非常简单，使用区别就在于 `factory` 的不同。

- 如果 factory 为对象或者字符串，直接就代表该模块的接口

- 如果 `factory` 为函数，则表示模块的构造方法，执行该方法获取可以获取模块导出的接口。

  ```
  define(factory);
  ```

- 当 `factory` 为函数时，其有三个参数: `require`、`exports`、`module`

  ```
  define(function (require, exports, module) {
    // module content
  });
  
  ```

- 通过基础使用部分，可以发现 `CMD` 与 `AMD` 非常类似，下面的案例对比了两者的使用。但两者的设计思想有很大的差异，`AMD` 推崇依赖前置，而 `CMD` 则主张依赖就近，延迟执行。也就是说在 `CMD` 中，加载完依赖模块后不会立即执行，而是基于一种懒加载的思想，只有该模块后续被使用才会执行。

- `CMD` 规范使用依赖就近的规则定义一个模块，会导致模块的加载逻辑偏重，此外对于当前模块的依赖关系也非常不直观。

  ```
  // AMD
  define(["print"], function (printModule) {
    printModule.print("entry");
  });
  
  // CMD
  define(function (require, exports, module) {
    cosnt printModule = require('./print')
    printModule.print("entry");
  });
  ```

#### 4、`ESModule` 规范

- 模块化方案关乎到整个前端生态链，官方在 `ECMAScript6` 标准中增加了 JavaScript 语言层面的模块体系定义，作为浏览器和服务器通用的模块解决方案，也就是 `ES6 Module`(或称为 `ESModule`、`ESM`)。

- `ESModule` 规范并不复杂，使用起来相对也比较简单
  - 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取
  - `import` 命令用于输入其他模块提供的功能
  - `export` 命令用于规定模块的对外接口

**（1）`export`**

- `export` 命令可以单个导出，也可以批量导出。

  ```
  // zcxiaobao.js
  // 单个导出
  export const firstName = "zc";
  export const lastName = "xiaobao";
  export const year = 18;
  
  // 批量导出
  const firstName = "zc";
  const lastName = "xiaobao";
  const year = 18;
  export { firstName, lastName, year };
  
  // 导入
  import { firstName, lastName, year } from "./zcxiaobao.js";
  ```

- 与 `Commonjs` 不同，`ESM` 导出的为值的引用，因此 `export` 命令在导出时需要为接口名和模块内部变量构建一一对应关系。

- `ESModule` 还支持默认导出的功能，即 `export default`。

  ```
  // export-default.js
  export default function () {
    console.log("foo");
  }
  ```

- 上述使用 `export default` 默认输出了一个函数。当然也可以默认导出非匿名函数，但在模块外部并没有任何作用，统统视为匿名函数。

- 这时你可能会有疑惑？`export` 与 `export default` 的导出机制好像有些天差地别，如下面代码，`export default` 使用 `export` 格式导出会抛出错误。

  ```
  // export-default.js
  // throw error
  export default const foo = function () {
      console.log("foo");
  }
  ```

- 其实是基于这样的考虑：`export default` 被设计成模块的默认导出方式，这个默认值只会有一个，但是`const`可以支持这种形式：`const x = 8, y = 10, z = 5;` 所以开发人员可能会这样去写`export default const x = 8, y = 5, z=99;` 这显然是自相矛盾的，不是一个好的语法设计。所以这种形式的语法干脆就被禁止掉了，可以用以下形式替代：

  ```
  const x = 9;
  export default x;
  ```

**（2）import**

```
// zcxiaobao.js
const firstName = "zc";
const lastName = "xiaobao";
const year = 18;
export { firstName, lastName, year };

const male = true;
export default male;
```

- 我们以上面的代码介绍一下 import 的基本使用。

- 对于 `export` 命令，`import` 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。

  ```
  // import-export.js
  import { firstName, lastName, year } from "./zcxiaobao.js";
  console.log(firstName, lastName, year);
  ```

- 由于 `ESModule` 在编译时运行，因此大括号内不支持运行时才能得到结果表达式和变量。

  ```
  // import-error.js
  // throw error
  import { 'first' + 'Name'} from "./zcxiaobao.js";
  ```

- 对于 `export default` 命令，`import` 导入时可以任意为其重新命名，但切记此时不需要大括号。

  ```
  // import-default.js
  import zcMale from "./zcxiaobao.js";
  console.log(zcMale); // true
  
  // 也可以混合导入
  import zcMale, { firstName, lastName } from "./zcxiaobao.js";
  console.log(zcMale, firstName, lastName);
  ```

- 除了指定加载某些值，`import` 还支持整体加载。

  ```
  // import-whole.js
  import * as zcxiaobao from "./zcxiaobao.js";
  console.log(zcxiaobao);
  ```

- 打印结果：

  ```
  [Module]:{
    default:true,
    firstName:"zc",
    lastName:"xiaobao",
    year:18
  }
  ```

- 我们惊喜的发现，`default` 也出现了，同时与 `firstName` 等属性是平级的。

- 上文提过 `export` 命令的本质是在导出时需要为接口名和模块内部变量构建一一对应关系，那是不是意味着 `default` 是 `ESModule` 内置构建的默认接口，缺少的只不过是与内部变量的对应关系。

- 也就是说 `export defau`lt 可以理解为`export` 一个特殊的语法糖，本质就是输出 default 的变量或方法，只不过系统允许随便为它命名。

**（3）import()**

- `ESModule` 在编译时运行，编译时会对 `import` 命令进行静态分析，这也就意味着 `import` 和 `export` 命令只能在模块的顶层，不能在代码块之中。

- 例如下面的代码就会报错

  ```
  if (x !== undefined) {
    import { firstName } from "./zcxiaobao.js";
  }
  ```

- 得益于编译时运行机制，可以实现模块的静态分析，可以实现类似 `TreeShaking` 等功能减少不必要的代码，但这同样也丧失了运行时模块加载的功能。

- `Commonjs` 为运行时加载，`require` 函数可以出现在任何地方，模块的动态加载自由。

- `ES2020` 中，**引入了 `import()` 函数，来实现动态加载模块，该方法返回一个 `Promise` 对象，可以支持按需加载，**大大提高了模块引用的灵活性。

  ```
  // dynamic-import.js
  function getZc() {
    setTimeout(() => {
      import("./zcxiaobao.js").then(({ firstName, lastName }) => {
        console.log(firstName + lastName);
      });
    }, 1000);
  }
  
  getZc(); // zcxiaobao
  ```

- `import()` 函数的可以兼容市面 95% 以上的浏览器份额，可以比较放心的应用于日常开发中。

- **`import()`函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。**

- **另外，`import()`函数与所加载的模块没有静态连接关系，这点也是与`import`语句不相同。`import()`类似于 `Node.js` 的`require()`方法，区别主要是前者是异步加载，后者是同步加载。**

**（4）`import.meta`**

- 开发者开发模块时，有时需要获取模块自身的信息，类似于 `Commonjs` 为模块注入的 `__filename`，`__dirname` 变量等。

- `ES2020` 提案中，为 `import` 命令添加了一个元属性 `import.meta`，返回当前模块的元信息。`import.meta.url` 返回当前模块的 URL 路径。

  ```
  // import-meta.js
  // Nodejs 环境下执行，返回本地路径。
  console.log(import.meta);
  console.log(import.meta.url); // file:URL
  ```

- 从 `caniuse` 可以查到，`import.meta`元属性也达到 95%以上的兼容性。

**（5）ES Module模块化原理**

```
name.js:
const author = "不要秃头啊";

export const age = "18";
export default author;

main.js:
import author, { age } from "./name";

console.log(author, "author");
console.log(age, "age");
```

- 我们还是先来理一理思路。

- 这下可没有`exports`对象给我们赋值了，这可怎么办？

- 换一种思路：我们可不可以将 `name.js` 中导出的内容还是挂载在 `exports` 对象上，如果是通过`export default` 方式导出的，那就在 `exports` 对象加一个 `default` 属性，将 `name.js` 中导出的内容变成这样：

```arduino
const exports = {
  age: "18",
  default: "不要秃头啊",
}
```

- 然后在模块引用时（在 `Webpack` 编译时会将 `import author from "./name"` 代码块转换成 `const exports = require(./name)` 代码块），这样在 `main.js` 中拿到的是还是这个 `exports` 对象，就能够正常取值啦。

- 大致原理就是这么简单，只不过这里给`exports`赋值的方式是通过代理做到的。

  ```
  //模块定义
  var modules = {
    "./src/name.js": (module, exports, require) => {
    
      //给该模块设置tag：标识这是一个ES Module
      require.setModuleTag(exports);
      
      //调用require的defineProperty函数，通过代理给exports设置属性值
      require.defineProperty(exports, {
        age: () => age,
        default: () => DEFAULT_EXPORT,
      });
      const author = "不要秃头啊";
      const age = "18";
      const DEFAULT_EXPORT = author;
    },
  };
  
  //对exports对象做代理
  require.defineProperty = (exports, definition) => {
    for (var key in definition) {
       // 在exports上添加相应的getter
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: definition[key],
      });
    }
  };
  var cache = {};
  function require(modulePath) {
    var cachedModule = cache[modulePath];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (cache[modulePath] = {
      exports: {},
    });
    modules[modulePath](module, module.exports, require);
    return module.exports;
  }
  
  
  ```

- 为了实现`ESM`的规范，它定义了一个`getter`来通过闭包的方式引用了模块里面需要导出的值，这也说明了导出的不是值的拷贝，而是共享的内存空间。
  
- 由于没有定义`setter`，所以也不能修改导出变量的值。
  
- 像这样实现动态绑定的原因，实际上就是为了更好地去支持循环依赖。以导出一个相同的变量`a`为例，如果像`commonJS`一样是值拷贝的方式，且发生了循环依赖，后续程序运行的时候得到的值就只会一直是`undefined`; 而如果是`ESM`，用的是值引用的方式，后续运行时取值的时候，实际上触发的是`getter`，等到所有模块都初始化求值完成后，就不会一直是`undefined`

  ```
  //标识模块的类型为ES Module
  require.setModuleTag = (exports) => {
    Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module",
    });
  
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
  };
  
  //以下是main.js编译后的代码
  //拿到模块导出对象exports
  var _name__WEBPACK_IMPORTED_MODULE_0__ = require("./src/name.js");
  
  console.log(_name__WEBPACK_IMPORTED_MODULE_0__["default"], "author");
  console.log(_name__WEBPACK_IMPORTED_MODULE_0__.age, "age");
  ```

- 这里与 `CommonJS` 模块化原理不同的在于：

- 通过 `require.setModuleTag` 函数来标识这是一个`ES Module`(在现在这个例子中其实没什么作用)

- 给传入的 `exports` 对象通过 `Object.defineProperty` 做了一层代理（这样当访问`default`属性时，其实访问的是`DEFAULT_EXPORT`变量，访问`age`属性时，访问的是`age`变量）。

**（6）`Webpack5`实现`ESModule`模块化的原理**

- **准备工作**

  - `src` 目录下新建 `js` 文件夹，`js` 文件夹中新建 `math.js` 文件，使用 `ES Module` 模块化导出两个简单的函数，代码如下：

    ```
    // src/js/math.js
    export const sum = (num1, num2) => {
      return num1 + num2
    }
    
    export const mul = (num1, num2) => {
      return num1 * num2
    }
    
    export default sum;
    ```

  - `src` 目录下新建 `index.js` 文件，作为 `webpack` 打包入口。在 `index.js` 中，使用 `ES Module` 方式引入 `math.js` 中的两个函数，代码如下：

    ```
    // src/index.js 入口
    import { sum, mul } from './js/math'
    console.log(sum(10, 20))
    console.log(mul(10, 20))
    ```

  - 在 `webpack.config.js` 中，将 `mode` 设置为 `'development'`，将 `devtool` 设置为 `source-map`，以便于我们打包后输出的源码更容易阅读和分析。`webpack.config.js` 代码如下：

    ```
    const path = require('path')
    const { CleanWebpackPlugin } = require('clean-webpack-plugin')
    const HtmlWebpackPlugin = require('html-webpack-plugin')
    
    module.exports = {
      mode: 'development',
      entry: './src/index.js',
      devtool: 'source-map',
      output: {
        filename: 'js/bundle.js',
        path: path.resolve(__dirname, './build')
      },
      plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
          title: 'webpack'
        })
      ]
    }
    ```

  - 代码目录的其他部分和打包过程不做详细展示，下面我们将开始分析打包后的 `bundle.js` 代码。

- **`bundle.js` 的简要说明**

  - 我们先来简要的看一下打包出来的代码的大致情况，简单的做一个认识，方便我们下文详细分析。代码如下：

    ```
    // 最外层使用立即执行函数包裹，分析中可以忽略
    ;(() => {
      // 严格模式
      'use strict'
      // 1.定义了一个 __webpack_modules__ 对象
      var __webpack_modules__ = {
        './src/js/math.js': (
          __unused_webpack_module,
          __webpack_exports__,
          __webpack_require__
        ) => {
        
       // 函数接收了三个参数（CommonJS中只用到了第一个参数，ESModule里都用到了）
       // 第一个参数是 module，第二个参数是 module.exports，第三个参数是 __webpack_require__ 函数
        
      // 执行__webpack_require__的r方法，标记为 ES Module
      // 注意：之前在 8号立即执行函数 里，是给 __webpack_exports__ 标记，这次是给 module.exports 标记，这俩是两个变量
      __webpack_require__.r(__webpack_exports__)
        
      // 执行__webpack_require__的d方法，传入两个参数
      // 第一个参数的值是 module.exports
      // 第二个参数是一个对象，key 是导出的函数名，value是一个箭头函数，返回值是 key 对应的函数
      __webpack_require__.d(__webpack_exports__, {
        sum: () => sum,
        mul: () => mul,
        default: () => __WEBPACK_DEFAULT_EXPORT__ 
      })
        
      // 这是我们在 math.js 中导出的两个函数
      const sum = (num1, num2) => {
        return num1 + num2
      }
    
      const mul = (num1, num2) => {
        return num1 * num2
      }
      
      const __WEBPACK_DEFAULT_EXPORT__ = sum
     }
    }
    
      // 2.定义了一个缓存对象
      var __webpack_module_cache__ = {}
    
      // 3.定义了 webpack 自己的 require 函数
      function __webpack_require__(moduleId) {
        // moduleId 的值是'./src/js/math.js'
        
        // 这一行代码在 __webpack_module_cache__ 缓存对象中，以 moduleId 为 key 去获取其对应的值，赋值给 cachedModele
        
        var cachedModule = __webpack_module_cache__[moduleId]
        
        // 如果cachedModule 有值，将 cachedModule 的 export 属性的值直接返回
        if (cachedModule !== undefined) {
          return cachedModule.exports
        }
        
        // 这里是一个连续赋值，将 {exports:{}} 对象既赋值给 "缓存对象 key为 moduleId（'./src/js/math.js'）的值"，也赋值给 module 变量。
        
        // 因为{exports:{}}是一个对象，也就是说 module 和 __webpack_module_cache__[moduleId] 有了相同的引用，后面如果改了就一起变化
        
        // 此时，__webpack_module_cache__['./src/js/math.js'] 与 module 的值都是{exports: {}}
        var module = (__webpack_module_cache__[moduleId] = {
          exports: {}
        })
        
        // 这里使用了第一部分的__webpack_modules__对象，对象的 key 为 moduleId，也就是'./src/js/math.js'
        
        // 也就是说拿到了 __webpack_modules__['./src/js/math.js'] 对应的那个函数，并将后面三个参数传入并执行。这里进入了上面第一部分中的 __webpack_modules__[moduleId] 函数
        
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__)
        
        // 执行完后返回
        return module.exports
    }
    
    
      // 4.一个立即执行函数
      ;(() => {
      
        // __webpack_require__ 的 d 函数
       // 参数 exports 实际上是 module.exports
       // 参数 definition 实际上是 { sum: () => sum, mul: () => mul}
       
        __webpack_require__.d = (exports, definition) => {
        
      // 遍历 definition 对象
      for (var key in definition) {
      
        // __webpack_require__.o 的作用是判断 prop 是不是 obj 自身的属性
        // 这里判断 key 在 definition 上有，而在 exports 上没有的时候做一个代理操作
        // 在访问 exports[key] 的时候，实际上是去拿 definition[key]
        
        if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          })
        }
      }
    })()
    
      // 5.一个立即执行函数
      ;(() => {
        __webpack_require__.o = (obj, prop) =>
          Object.prototype.hasOwnProperty.call(obj, prop)
      })()
    
      // 6.一个立即执行函数
      ;(() => {
        __webpack_require__.r = exports => {
          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' })
          }
          Object.defineProperty(exports, '__esModule', { value: true })
        }
      })()
    
      // 7.定义__webpack_exports__变量，该变量被初始化一个空对象
      var __webpack_exports__ = {}
    
      // 8.一个立即执行函数
      ;(() => {
        __webpack_require__.r(__webpack_exports__)
        var _js_math_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__('./src/js/math.js')
        console.log((0, _js_math_js__WEBPACK_IMPORTED_MODULE_0__.sum)(10, 20))
        console.log((0, _js_math_js__WEBPACK_IMPORTED_MODULE_0__.mul)(10, 20))
      })()
    })()
    
    
    ```

  - **再来捋一遍大致的过程**

    1. 定义了三个变量（`__webpack_modules__`，`__webpack_module_cache__`，`__webpack_exports__`）
    2. 定义了一个函数（`__webpack_require__`）,并通过三个立即执行函数给该函数对象添加了 `d / o / r`  方法。
    3. 将 模块路径`'./src/js/math.js'` 作为参数，执行 `__webpack_require__` 方法
    4. `__webpack_require__`函数中将 `{exports:{}}`连续赋值给 `__webpack_module_cache__` 缓存对象以及 `module` 变量，`module`和 `__webpack_module_cache__`引用相同，一变都变
    5. 将 `module` 、`module.exports`、`__webpack_require__`作为参数来执行 `__webpack_modules__`对象中对应的该模块对应的函数，函数执行完之后 `module.exports` 和 `__webpack_module_cache__` 缓存对象中同时都有了原来 ES Module 模块（`'math.js'`）中导出的内容
    6. 至此 `__webpack_require__` 执行完毕，内层立即执行函数中已经拿到了模块中的内容进行操作
    7. 如果其他地方也引用到了 `math.js` 模块，将直接从缓存对象中去拿

  - **和`CommonJS`处理方式的对比**

    - 相同点：
      - 大体上的思路和方式都是一样的（感觉说了个废话，大家可以自己品一品）

    - 不同点：
      - 对 `ES Module` 专门增加了标记
      - 对模块导出的内容做了一层代理

**（7）`ES6 Module` 工作原理**

- **`ES6 Module` 工作原理相关概念**

  - **模块记录（`Module Record`）**

    - **模块记录(`Module Record`) 封装了关于单个模块(当前模块)的导入和导出的结构信息**。此信息用于链接模块集的导入和导出。一个模块记录包括四个字段，它们只在执行模块时使用。其中这四个字段分别是:
      - `Realm`: 创建当前模块的作用域;
      - `Environment`：模块的顶层绑定的环境记录,该字段在模块被链接时设置;
      - `Namespace`：模块命名空间对象是模块命名空间外来对象，它提供对模块导出绑定的基于运行时属性的访问。模块命名空间对象没有构造函数;
      - `HostDefined`：字段保留,以按 `host environments` 使用，需要将附加信息与模块关联。

  - **`Module Envionment Record`**

    - `Module Environment Record`主要**用于定义模块内的标识符与变量值和函数值之间的关联关系。它记录了模块中所有的变量声明、函数声明以及通过import语句导入的变量和函数。这种环境记录类型使得模块内的标识符可以在模块的作用域内被正确地解析和访问‌**。

    - `Module Environment Record`由以下几个部分组成：

      - **环境记录**‌：**记录模块内的标识符绑定，包括变量声明、函数声明以及通过import语句导入的变量和函数。**

      - **外部引用**‌：**指向外部词法环境的引用，用于形成多个词法环境在逻辑上的嵌套结构，以实现可以访问外部词法环境变量的能力‌**。

    - 模块环境记录是一种声明性环境记录，用于表示`ECMAScript`模块的外部作用域。除了普通的可变和不可变绑定之外，模块环境记录还提供了不可变的 `import` 绑定，这些绑定提供了对存在于另一个环境记录中的目标绑定的间接访问。

    - **不可变绑定就是当前的模块引入其他的模块,引入的变量不能修改,这就是模块独特的不可变绑定。**

- **`Es Module` 的解析流程**

  - **阶段一：构建(`Construction`)**，根据地址查找 `js` 文件,通过网络下载,并且解析模块文件为 `Module Record`;
  - **阶段二：实例化(`Instantiation`)**，对模块进行实例化，并且分配内存空间，解析模块的导入和导出语句,把模块指向对应的内存地址;
  - **阶段三：运行(`Evaluation`)**，运行代码，计算值，并且将值填充到内存地址中;

- **`Es Module` 的解析流程详解**

  - **构建(`Construction`)**

    - 在构建阶段，每个模块都会经历三件事情：

      - **查找：找出从哪里下载包含该模块的文件（也称为模块解析）**；

        - 通常会有一个入口文件，然后通过`import`代码去寻找与之关联的其他模块，形成一个`依赖关系树（AST）`；

        ```
        // 在 html 中
        <script src="main.js" type="module">
        
        // 在 js 中
        import { count } from './count.js'
        
        ```

        - 例如上例中：`loader` 负责对模块进行寻址及下载。首先我们修改一个入口文件,这在 `HTML` 中通常是一个 <script type="module"></script>的标签来表示一个模块文件。

          ![package22](.\images\package22.png)

        - 模块继续通过 `import`语句声明，在 `import`声明语句中有一个 模块声明标识符(`ModuleSpecifier`)，这告诉 `loader` 怎么查找下一个模块的地址。

          ![package23](.\images\package23.png)

      - **下载：获取文件（从 URL 下载或从文件系统加载）；**

        - 解析文件前，需要一层一层地遍历树，找出它的依赖项，然后找到并加载这些依赖项；

          

      - **解析：将文件解析为模块记录；**

        - 把解析出来的模块构成表 称为 `Module Record` （模块记录）。

        - 每一个模块标识号对应一个 `模块记录(Module Record)`,而每一个 `模块记录` 包含了 `JavaScript代码`、`执行上下文`、`ImportEntries`、`LocalExportEntries`、`IndirectExportEntries`、`StarExportEntries`。其中 `ImportEntries` 值是一个 `ImportEntry Records` 类型,而 `LocalExportEntries`、`IndirectExportEntries`、`StarExportEntries` 是一个 `ExportEntry Records` 类型。

          - `ImportEntry Records`

            一个 `ImportEntry Records` 包含三个字段 `ModuleRequest`、`ImportName`、`LocalName`;

            - `ModuleRequest`: 一个模块标识符(`ModuleSpecifier`);
            - `ImportName`: 由 `ModuleRequest` 模块标识符的模块导出所需绑定的名称。值 `namespace-object` 表示导入请求是针对目标模块的命名空间对象的;
            - `LocalName`: 用于从导入模块中从当前模块中访问导入值的变量;

          - 下面这张表记录了使用 `import` 导入的 `ImportEntry Records` 字段的实例:

            ![package24](.\images\package24.png)

          - **`ExportEntry Records`**

            - 一个 `ExportEntry Records` 包含四个字段 `ExportName`、`ModuleRequest`、`ImportName`、`LocalName`,和 `ImportEntry Records`不同的是多了一个 `ExportName`。

            - `ExportName`: 此模块用于导出时绑定的名称。

            - 下面这张表记录了使用 `export` 导出的 `ExportEntry Records` 字段的实例:

              ![package25](.\images\package25.png)

        - 一旦 `Module Record` 被创建，它会被记录在模块映射`Module Map`中。被记录后，如果再有对相同 `URL` 的请求，`Loader` 将直接采用 `Module Map` 中 `URL` 对应的`Module Record`。

    - 只有当解析完当前的 `Module Record` 之后，才能知道当前模块依赖的是那些子模块，然后需要 `resolve` 子模块，获取子模块，再解析子模块，不断的循环这个流程 resolving -> fetching -> parsing,结果如下图所示:

      ![package26](.\images\package26.png)

    - 在构造过程结束时，从主入口文件变成了一堆模块记录`Module Record`

    - 这个过程也称为 `静态分析`,不会运行JavaScript代码,只会识别 `export` 和 `import` 关键字,所以说不能在非全局作用域下使用 `import`,动态导入除外。

    - 如果多个文件同时依赖一个文件呢,这会不会引起死循环,答案是不会的。

      - `loader` 使用 `Module Map` 对全局的 `MOdule Record` 进行追踪、缓存这样就可以保证模块只被 `fetch` 一次，每个全局作用域中会有一个独立的 `Module Map`。

      - `Module Map` 是由一个 `URL` 记录和一个字符串组成的`key/value`的映射对象。URL记录是获取模块的请求`URL`，字符串指示模块的类型(例如。“`javascript`”)。模块映射的值要么是模块脚本，`null`(用于表示失败的获取)，要么是占位符值“`fetching`(获取中)”。

        ![package27](.\images\package27.png)

  - **实例化**

    - 实例化阶段：将构造的模块实例化并将所有实例链接在一起。

    - 在所有 `Module Record` 被解析完后，接下来 `JS` 引擎需要把所有模块进行链接。

    - **`JS` 引擎以入口文件的 `Module Record` 作为起点，以深度优先的顺序去递归链接模块，为每个 `Module Record` 创建一个 `Module Environment Record`，用于管理 `Module Record` 中的变量。然后它在内存中找到所有导出内容对应的位置。模块环境记录将跟踪内存中导出内容对应的位置与导出内容间的联系。**

    - **此时内存中的这些位置中还不会存放值，只有在计算后才会有值。**

      ![package28](.\images\package28.png)

    - **`Module Environment Record` 中有一个 `Binding`,这个是用来存放 `Module Record` 导出的变量**，如上图所示,在该模块 `main.js` 处导出了一个 `count` 的变量,在 `Module Environment Record` 中的 `Binding` 就会有一个 `count`,在这个时候,就相当于 `V8` 的编译阶段,创建一个模块实例对象,添加相对应的属性和方法,此时值为 `undefined` 或者 `null`,为其分配内存空间。

    - **而在子模块 `count.js` 中使用了 `import` 关键字对 `main.js` 进行导入,而 `count.js` 的 `import` 和 `main.js` 的 `export` 的变量指向的内存位置是一致的,这样就把父子模块之间的关系链接起来了。**如下图所示:

      ![package29](.\images\package29.png)

    - **注意，导出和导入都指向内存中的同一位置。首先链接导出，可确保所有导入都可以链接到匹配的导出。**

    - **ES Module 的这种连接方式被称为 Live Bindings（动态绑定）;**

    - **ES 模块使用称为动态绑定的东西。两个模块都指向内存中的相同位置。这意味着当导出模块更改值时，该更改将显示在导入模块中。导出值的模块可以随时更改这些值，但导入模块不能更改其导入的值，虽然有此限制，但是如果一个模块导入一个对象，导入模块中可以更改该对象上的属性值。**

    - **拥有这样的**动态绑定**可以使我们在不运行任何代码的情况下连接所有模块，实例化结束时，已经连接了`export/import`变量的所有实例和内存位置。**

  - **求值**

    - 最后一步，在内存区中填充绑定的数据的值。
    - `JS` 引擎通过执行顶层代码（函数之外的代码，此处可以理解为模块文件中顶层作用域中的代码）来给内存区的引用赋值。

- **总结**

  ![package30](.\images\package30.png)

  - `ES Module`执行分为三个阶段：构造阶段、实例化阶段、求值阶段。

  - 构造阶段:

    ```
    1、根据入口创建依赖关系的AST;
    2、下载module文件，用于解析；
    3、解析每个module文件，生成 Module Record（包含当前module的AST、变量等）；
    4、将Module Record 映射到 Module Map中，保持每个module文件的唯一性；
    ```

    - 构造阶段最后生成根据依赖关系`AST`的 `Module Record`的依赖树，同时将每个`Module Record`映射保存到`Module Map`中。

  - 实例化阶段：

    ```
    1、生成模每个Module Record的块环境记录(Module Enviroment Record)，用来管理 Module Record 的变量等；
    2、在内存中写入每个Module的数据，同时 Module文件的导出export和引用文件的 import指向该地址；
    ```

    -    实例化阶段确定了 `export和import`内存中的指向，同时该内存空间中定义了`Module`文件的变量（但是还未赋值）；

  - 求值阶段：

    ```
    1、执行对应Module文件中顶层作用域的代码，确定实例化阶段中定义变量的值，放入内存中；
    ```

    - 求值阶段确定了`Module`文件中变量的值，由于 `ES Module`使用的是动态绑定（指向内存地址），`export`中修改数据会映射到内存中，`import`数据相应也会改变。

- **`es6`的`import`函数是怎么实现异步加载组件的**

  - 在浏览器环境中，`import()` 函数的实现依赖于浏览器的模块加载器。当调用 `import()` 函数时，浏览器会发起一个网络请求，加载指定的模块文件。一旦模块文件下载完成，浏览器会将其解析和执行，然后将模块的导出内容传递给 `import()` 函数的 `Promise` 对象，使其得到解决。

- **`Es module` 是如何解决循环引用的**

  - 在 `Es Module` 中有5种状态，分别为 `unlinked`、`linking`、`linked`、`evaluating`和 `evaluated`，用循环模块记录(`Cyclic Module Records`)的 `Status` 字段来表示,正是通过这个字段来判断模块是否被执行过,每个模块只执行一次。这也是为什么会使用 `Module Map` 来进行全局缓存 `Module Record` 的原因了,如果一个模块的状态为 `evaluated`,那么下次执行则会自动跳过,从而包装一个模块只会执行一次。 `Es Module` 采用 `深度优先` 的方法对模块图进行遍历,每个模块只执行一次,这也就避免了死循环的情况了。

  - 深度优先搜索算法（英语：`Depth-First-Search`，`DFS`）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。

    ![package31](.\images\package31.png)

  - 看下面的例子,所有的模块只会运行一次:

    ```
    
    // main.js
    import { bar } from "./bar.js";
    export const main = "main";
    console.log("main");
    
    // foo.js
    import { main } from "./main.js";
    export const foo = "foo";
    console.log("foo");
    
    // bar.js
    import { foo } from "./foo.js";
    export const bar = "bar";
    console.log("bar");
    
    
    ```

    - 通过 `node` 运行 `main.js` ,得出以下结果:

      ![package32](.\images\package32.png)

**（8）`ES6 Module` 的特性**

- **静态依赖分析**： `ES6 Module` 在编译时就可以确定模块的依赖关系，从而实现静态分析和树摇（Tree Shaking）优化。这意味着模块中没有被使用的代码可以在打包阶段被移除，从而减小最终的文件大小。
- **严格模式（`Strict Mode`）**： `ES6 Module` 自动采用 `JavaScript` 严格模式。这意味着模块中不能使用某些不安全的语法（如 `with` 语句），提高了代码的安全性和性能。
- **独立的模块作用域**： 每个模块都有独立的作用域，模块内部的变量、函数不会污染全局作用域，避免了变量命名冲突问题。
- **导入和导出语句（`Import` 和 `Export`）**： `ES6 Module` 使用 `import` 和 `export` 关键字来导入和导出模块成员。导出可以是命名导出（`Named Export`）或默认导出（`Default Export`）。
- **异步加载支持**： `ES6 Module` 可以异步加载模块，避免了阻塞浏览器的渲染进程，从而提升了页面加载性能。
- **浏览器原生支持**： 现代浏览器原生支持 `ES6 Module`，无需额外的加载器（如 `RequireJS`）或打包工具（如 `Webpack`）即可直接使用。

**（9）`ES6 Module` 与其他模块规范的比较**

- `ES6 Module` 相较于 `CommonJS` 和 `AMD` 有显著的优势：
  - **加载方式**： `CommonJS` 使用同步加载，这在服务器端是可行的，但在浏览器中会导致阻塞。而 `ES6 Module` 支持异步加载，不会阻塞浏览器的渲染进程。
  - **模块依赖分析**： `CommonJS` 模块的依赖关系在运行时解析，这可能导致加载时的性能开销。`ES6 Module` 在编译阶段就能确定依赖关系，优化了加载效率和性能。
  - **代码优化**： 由于 `ES6 Module` 支持静态分析工具，构建工具能够对代码进行更有效的优化（如 `Tree Shaking`），减少最终产物的大小。
  - **兼容性**： `ES6 Module` 是现代浏览器和 `Node.js` 官方推荐和支持的模块化标准，未来的兼容性和更新都更有保障。

**（10）`ES6 Module` 的局限性**

- 虽然 `ES6 Module` 在现代开发中具有广泛应用，但它也有一些局限性：
  - **浏览器兼容性**：早期版本的浏览器不支持 `ES6 Module`，不过随着浏览器的更新，这个问题正逐渐消失。
  - **服务端使用限制**：在服务端（如 `Node.js`）环境中，使用 `ES6 Module` 可能需要一些配置和额外的工具支持（如 `Babel`、`Webpack`）。
  - **性能影响**：在非常大量模块导入的场景下，可能会有性能瓶颈。

**（11）`ES6 Module`练习题**

- **普通的导入导出**

  ```
  // module.js
  export let thing = 'initial';
  setTimeout(() => { 
      thing = 'changed';
  }, 500);
  
  // main.js
  import { thing as importedThing } from './module.js';
  const module = await import('./module.js');
  let { thing } = await import('./module.js');
  setTimeout(() => {
      console.log(importedThing); // changed 解释：ES6 Module的动态绑定
      console.log(module.thing); // changed 解释：import()不是动态绑定的，这里是因为对象的浅拷贝
      console.log(thing); // initial 解释：import()不是动态绑定的，输出的是一个普通变量
  }, 1000);
  
  ```

- **默认导入导出表达式**

  ```
  // module.js
  let thing = 'initial';
  export { thing };
  export default thing;
  setTimeout(() => {
      thing = 'changed';
  }, 500);
  
  // main.js
  import { thing, default as defaultThing } from './module.js';
  import anotherDefaultThing from './module.js';
  setTimeout(() => {
      console.log(thing); // changed 解释：ES6 Module的动态绑定
      
      console.log(defaultThing); // initial 解释：获取到的是export default输出值，export                                    // default thing 这句是将变量thing的值赋值给default变量，所以                                // thing变量改变不影响default变量
      
      console.log(anotherDefaultThing); // initial 解释：获取到的是export default输出值，                                         // export default thing 这句是将变量thing的值赋                                           // 值给default变量，所以thing变量改变不影响default变量
   }, 1000);
  
  
  ```

  ```
  let thing = 'initial';
  export { thing, thing as default };
  setTimeout(() => {
      thing = 'changed';
  }, 500);
  
  
  // main.js
  import { thing, default as defaultThing } from './module.js';
  import anotherDefaultThing from './module.js';
  setTimeout(() => {
      console.log(thing); // changed 解释：ES6 Module的动态绑定
      
      console.log(defaultThing); // changed 解释：输出的时候thing被重命名为                                                 // default，所以还是ES6 Module的动态绑定
      
      console.log(anotherDefaultThing); // changed 解释：输出的时候thing被重命名为default，所                                       // 以还是ES6 Module的动态绑定
  }, 1000);
  
  ```

- **默认导出函数**

  ```
  // module.js
  export default function thing() {} 
  setTimeout(() => {
      thing = 'changed'; 
  }, 500);
  
  
  // main.js
  import thing from './module.js';
  setTimeout(() => {
      console.log(thing); // changed 解释：ES6 Module的动态绑定
  }, 1000);
  ```

  ```
  // module.js
  function thing() {}
  export default thing;
  setTimeout(() => {
      thing = 'changed';
  }, 500);
  
  
  // main.js
  import thing from './module.js';
  setTimeout(() => {
      console.log(thing); // function thing() {} 解释：export default                                             // thing 这句是将变量thing的值赋值给default变量，                                          //  所以thing变量改变不影响default变量
  }, 1000);
  ```

- **循环引用**

  ```
  // main.js
  import { foo } from './module.js';
  foo();
  export function hello() {  //解释 函数可以提升
      console.log('hello');
  }
  
  // module.js
  import { hello } from './main.js';
  hello();
  export function foo() {
      console.log('foo'); 
  }
  
  // hello foo
  ```

  ```
  // main.js
  import { foo } from './module.js';
  foo();
  export const hello = () => console.log('hello'); // 解释：不能提升
  
  
  // module.js
  import { hello } from './main.js';
  hello(); // 报错
  export const foo = () => console.log('foo'); 
  
  
  export { hello as default }
  
  // 报错
  
  ```

  

#### 5、`Commonjs` 与 `ESM` 对比

**<1>拷贝 vs 引用**

- 上文讲到`Commonjs` 模块输出的是值的拷贝，对于原始类型，复制其值，模块内部的变化不会影响导出值；对于引用类型为浅复制，属性的变动会影响导出值。

- `ESModule` 运行机制与 `Commonjs` 不同。ESM 导入模块是在编译阶段进行静态分析确定模块的依赖关系，并将 `import` 导入语句提升到模块首部，生成只读引用，链接到引入模块的 `export` 接口，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。也就是说如果模块内代码运行过程中原始值发生变化，`import` 加载值也会发生改变。

**<2>运行 vs 编译**

- `Commonjs` 模块的本质是一个对象，模块加载的过程即 `module.exports` 对象的生成过程，然后 `require` 方法再从对象上读取方法，这种加载被称为运行时加载。最大特性是全部加载，只有运行时才能得到该对象，无法在编译时做静态优化

- `ESModule` 则是通过静态分析 `import` 命令来构建起 `import` 与 `export` 导出的只读引用(该引用不可修改)，后续脚本执行后再沿只读引用获取值。最大特性是按需加载，在编译时就完成模块加载。

- 这也就客观解释了为什么 `require` 可以出现在任何地方，而 `import` 必须在模块顶层。

- 为了能更好的取代 `require` 函数，`ES2020` 引入了 `import()` 函数，支持动态加载模块，`import()` 函数同样也可以出现在任何地方。

- `CommonJs` 可以在模块说明符中使用变量，`EsModule` 需要在执行前构建整个模块图，不可在模块说明符中使用变量，因为这些变量还没有值。

  ![package33](.\images\package33.png)

**<3>同步 vs 异步**

- `Commonjs` 模块读取使用 `Node.js` 的 `fs.readSync` 方法，为同步加载模式，通常应用于服务
- `CommonJs` 从文件系统加载文件，加载时可阻塞主流程，在加载时便进行模块的实例化和执行，意味着在返回模块实例之前，会遍历整个树，加载、实例化和执行任何依赖项。`ESModule` 则通过 `CORS` 的方式请求外部 `js` 模块，为异步加载模式，目前可用于服务端及浏览器端。
- 严格模式: `Commonjs` 默认是非严格模式，而 `ESModule` 默认是严格模式。

**<4>关于循环引用**

```
//main.js

let count = require('./counter.js').count
console.log(count)
exports.message = 'Eval complate'
```

```
//counter.js
let message = require('./main.js').message
exports.count = 5
setTimeout(() => console.log(message),0)
```

- 在 `CommonJs` 中，最终会输出 `undefined`

- 如果是 `Esmodule` 会获取到改变后的值`Eval complate`

  ![package34](.\images\package34.png)

#### 6、`CommonJS` 加载 `ES Module`的原理

```arduino
name.js:
export const age = 18;
export default "不要秃头啊";

main.js:
let obj = require("./name");
console.log(obj, "obj");
```

- 对打包后的代码进行分析（经过优化）：

  ```
  var modules = {
    "./src/name.js": (module, exports, require) => {
      require.setModuleTag(exports);
      require.defineProperty(exports, {
        age: () => age,
        default: () => DEFAULT_EXPORT,
      });
      const age = 18;
      const DEFAULT_EXPORT = "不要秃头啊";
    },
  };
  var cache = {};
  function require(moduleId) {
    var cachedModule = cache[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (cache[moduleId] = {
      exports: {},
    });
    modules[moduleId](module, module.exports, require);
    return module.exports;
  }
  
  require.defineProperty = (exports, definition) => {
    for (var key in definition) {
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: definition[key],
      });
    }
  };
  
  require.setModuleTag = (exports) => {
    Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module",
    });
  
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
  };
  
  (() => {
    let obj = require("./src/name.js");
    console.log(obj, "obj");
  })();
  ```

- 运行结果：

  ```
  { age: [Getter], default: [Getter] } obj
  ```

#### 7、`ES Module`加载`CommonJS`的原理

```
name.js:
module.exports = "不要秃头啊";

main.js：
import author from "./name";

console.log(author, "author");
```

- 这一步的思路其实跟前面基本上相同，唯一的区别在于多了个`require.n`函数，它用来返回模块的默认导出内容，核心思想依旧是将最终模块的内容导出为一个 `exports` 对象。

- 对打包后的代码进行分析（经过优化）：

  ```
  var modules = {
    "./src/name.js": (module) => {
      module.exports = "不要秃头啊";
    },
  };
  var cache = {};
  function require(modulePath) {
    var cachedModule = cache[modulePath];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (cache[modulePath] = {
      exports: {},
    });
    modules[modulePath](module, module.exports, require);
    return module.exports;
  }
  
  require.n = (module) => {
    var getter =
      module && module.__esModule ? () => module["default"] : () => module;
    require.defineProperty(getter, {
      a: getter,
    });
    return getter;
  };
  
  require.defineProperty = (exports, definition) => {
    for (var key in definition) {
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: definition[key],
      });
    }
  };
  
  require.setModuleTag = (exports) => {
    Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module",
    });
  
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
  };
  
  var __webpack_exports__ = {};
  (() => {
    "use strict";
    require.setModuleTag(__webpack_exports__);
    var _name__WEBPACK_IMPORTED_MODULE_0__ = require("./src/name.js");
    var _name__WEBPACK_IMPORTED_MODULE_0___default = require.n(
      _name__WEBPACK_IMPORTED_MODULE_0__
    );
    console.log(_name__WEBPACK_IMPORTED_MODULE_0___default(), "author");
  })();
  ```

#### 8.总结

- 最后，通过一道代码执行题来看看大家到底掌握没有哦！考点是这些模块化规范是如何解决循环依赖的问题的。

  ```
  a.js文件
  const getMes = require('./b')
  console.log('我是 a 文件')
  exports.say = function(){
      const message = getMes()
      console.log(message)
  }
  
  
  b.js文件
  const say = require('./a')
  const  object = {
     name:'从构建产物洞悉模块化原理',
     author:'不要秃头啊'
  }
  console.log('我是 b 文件')
  module.exports = function(){
      return object
  }
  
  
  main.js文件
  const a = require('./a')
  const b = require('./b')
  console.log('node 入口文件')
  ```

- 接下来执行 `main.js` 文件，控制台会输出什么呢？

- 解析

  - 执行`main.js`
    - `require a` 的时候，去加载 `a` 的代码，
    - 在实际执行前，会提前声明一个空对象做为 `export` 的导出值，并赋值给`cache`，cache['./a'] = {}
    - 实际开始加载`a`，`a` 在加载的过程中，碰到 `require('./b')`，然后开始加载 `b`，并且也会提前声明一个空对象赋值给`cache`，`cache['./b'] = {};`
    - 实际开始加载`b`，此时发现要加载`a`，先从缓存中取，取到了（可以在`b` 文件加一行日志，`console.log(say)` 你会发现它就是空对象）。就继续往下执行。输出【我是`b` 文件】
    - `require('./b’)` 执行完成，执行`a` 后续代码，输出【我是`a`文件】
    - `main` 的第一行执行完成，执行第二行 `require('./b')` ，此时直接从缓存中取到了值
    - 最后输出【`node` 入口文件】

