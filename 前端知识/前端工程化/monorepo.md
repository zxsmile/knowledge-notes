# 一、什么是 `Monorepo`？

`Monorepo`是一种**代码管理模式**，`Monorepo`（`Monolithic Repository`）是一种将多个项目（或模块）集中存储在**单一代码仓库**中的管理模式。。与 `Monorepo`相对的是 `Multirepo`（或`Polyrepo`），也就是我们常见的每个模块建一个 仓库。 `Google`、`Facebook`、微软等公司已经使用了很多年，`Vue3`、`Yarn2` 等知名项目现在也改用了 `Monorepo`。

常见的 `Monorepo` 工具有 [Nx](https://link.juejin.cn/?target=https%3A%2F%2Fnx.dev%2F)、[Turborepo](https://link.juejin.cn/?target=https%3A%2F%2Fturborepo.org%2F)、[Lerna](https://link.juejin.cn/?target=https%3A%2F%2Flerna.js.org%2F) 和 [PNPM](https://link.juejin.cn/?target=https%3A%2F%2Fpnpm.io%2F)，它们为项目间依赖管理和构建优化提供了强大支持。

一个 `Monorepo`项目目录可能是这样的：

```go
├── CHANGELOG.md

├── README.md       // `Monorepo`配置，注册子项目

├── package.json                

├── packages                    // 子项目目录

│   ├── package1              

│   │   └── package.json

│   └── package2            

│   │   └── package.json              

│   └── package3             

│       └── package.json
```

# 二、`Polyrepo` 的弊端

## 1. 代码重复

`Polyrepo` 容易导致代码重复，主要是因为不同的项目都有自己的独立代码仓库。

在维护一些基础组件或者工具函数时，会想着直接从 `A` 仓库将代码复制到 `B` 仓库里使用，这样很方便，但是却给后续维护成本带来了很大的负担。一旦出现需要修改的地方，需要在**多个仓库中进行修改**，这可能会导致修改过程出现错误，并可能导致代码的不一致。

那么当然我们可以不进行复制，将公共逻辑抽离出来，单独发包，**作用一个 `npm` 模块引入到项目**中，需要修改时，也只用修改一份代码，然后重新发布即可。

但是这整个流程还是太复杂了，并不是完美的解决方式，仅仅是为了修改一点点东西，就需要去发包、更新，这太麻烦了。

小结：不同仓库之间的割裂感、导致复用代码的成本很高，开发体验差。或者需要在多个仓库中重复编写相同的代码，从而导致代码的**不一致性和冗余性。**

## 2. 版本管理

因为多个仓库分别管理自己的代码，这样会缺乏一个**全局视角去看待所有仓库**，无法清晰的了解到整个项目的结构和状态。当不同仓库中的有依赖关系时，会有依赖管理的问题，时时刻刻都需要注意依赖的版本和代码是否一致

例如：

主项目依赖了子项目提供的组件，如果此时子项目在某次升级时产生了 `breaking change` 版本，和原来的组件使用方式完全不一致，这样主项目就直接寄了。因此我们需要在子项目更新时，及时的更新主项目的依赖，这样就形成了负担。当组件出现异常时，就会开始怀疑包版本是否不正确...

因此，`Polyrepo` 需要有合适的版本管理方法，**保证版本和代码的一致性**

## 3. 工具混乱

每个项目都使用自己的一组命令来运行测试、构建、服务、检查、部署等。不一致会导致记住在不同项目中使用哪些命令的心理负担。

**单独部署、独立工作流**

在多仓库情况下，由于在不同的仓库里，继承测试会变得更加的困难，需要很多步骤才能组合在一起测试。同时每个项目都使用自己的一组命令来运行测试、构建、服务、检查、部署等。不一致会导致记住在不同项目中使用哪些命令的心理负担，维护起来也是问题

例如：

每个项目都会配置自己的 `webpack.config.js` 文件，但是这些配置很多都是一致的。

例如：

`CI`、`CD` 流程很难将多个仓库组合到一起去，测试也比较难处理

再例如：

一些 `linter` 工具也需要每个仓库都写一份，实际上这里是可以统一处理的

## 4. 代码共享

要跨存储库共享代码，可能会为共享代码创建一个存储库。那么必须设置工具和 `CI` 环境，将提交者添加到存储库，并设置包发布以便其他存储库可以依赖它。让我们不要开始跨存储库协调第三方库的不兼容版本....

## 5. 代码管理

基于 `Polyrepo` 管理，每个开发人员的 `commit`都会提交到各个仓库，不利于代码的 `CR`，也不利于管理代码合入机制，导致容易出现逃逸现象。

# 三、`Monorepo` 能解决什么问题？

**`Monorepo` 都能解决以上的问题**

不仅仅在于减少了维护和管理多个代码库的成本，同时还有以下优点：

1. **代码复用**：因为多个项目共享一个代码库，所以避免了在不同项目中重复编写相同功能代码的问题，提高了开发效率。
2. **提升协作效率**：多个项目在同一个代码库中进行开发，可以方便地共享代码和文档，避免不同项目之间的沟通和协调成本。
3. **集中管理**：`Monorepo` 架构中，不同的应用程序都在同一个代码库中，方便管理和监控。这一点非常重要，特别是在需要同时对多个版本进行修改和维护的情况下。
4. **统一构建**：`Monorepo` 的一个重要特点是可以共用一套构建系统和**工具链进行构建和部署**，提升了构建的效率。
5. **可以快速定位问题**：由于所有的代码都在同一个代码库中进行开发，`debugger` 可以很快找出问题所在的代码文件和行数，便于开发人员调试问题。
6. **一个版本**：无需担心因为项目依赖于第三方库的冲突版本而导致的不兼容问题。

# 四、`Monorepo` 和 `Polyrepo` 的不同？

前面说完之后，相信这里已经有了答案，这里再用对比的方式来看看 `Monorepo` 和 `Polyrepo` 相比之下都有哪些优势

## 依赖安装

| `Polyrepo`         | `Monorepo`   |
| ------------------ | ------------ |
| 每个项目都需要安装 | 在主项目安装 |

这里就可以看到 `Monorepo` 的优势在于只需一次安装，即可安装所有子项目的依赖，而 `Polyrepo` 需要每个都单独 install

## CI 构建

| `Polyrepo` | `Monorepo`                                                   |
| ---------- | ------------------------------------------------------------ |
| 各自构建   | 增量构建：根据依赖关系（`DAG`），通过拓扑排序并行构建此次改动涉及到的项目 |

`Monorepo` 的优势在于能够通过有向无环图，清楚的知道依赖关系，并通过拓扑排序进行增量的构建，而 `Polyrepo` 也有一定的优势在于无更改就不需要重新打包

同时在本地开发调试、上线部署上还有着很大的优势...

# 五、为什么选择 `PNPM`？

`PNPM`（`Performant NPM`）是一款高效的 `JavaScript` 包管理工具，采用了去重的依赖管理方式，能够在 `Monorepo` 架构中更好地解决多个项目间的依赖冲突问题。与传统的 `npm` 或 `yarn` 相比，`PNPM` 的安装和构建速度更快，并且节省磁盘空间，适用于大型工程化系统的依赖管理。

# 六、架构演进过程

#### 阶段 1：传统架构痛点

在传统架构中，由于每个项目都独立管理，往往出现以下痛点：

- 依赖版本不一致，导致不可预见的兼容问题。
- 不同项目间难以复用代码，出现重复开发。
- 项目管理难度大，跨项目协作复杂。
- 部署和发布流程难以统一和自动化。

#### 阶段 2：引入 `Monorepo`

引入 `Monorepo` 架构后，所有相关的工程和模块会被集中在一个代码仓库中管理，带来了以下优势：

- **依赖统一管理**：所有项目共享一个 `node_modules` 目录，依赖版本一致，避免了冲突。
- **模块化和复用**：不同项目间可以轻松共享代码，减少重复开发。
- **流程标准化**：部署和发布流程可以统一管理，自动化脚本的复用性提高。
- **提高协作效率**：团队成员之间可以更加高效地协作，减少了跨项目的沟通成本。

#### 阶段 3：优化和自动化

在 `Monorepo` 架构上，进一步进行自动化和优化工作：

- **构建优化**：通过工具如 `Nx` 或 `Turborepo`，可以通过缓存和增量构建来优化构建速度。
- **自动化部署**：统一的 `CI/CD` 流程，确保所有子项目按需构建、测试和发布，自动化程度提高。
- **依赖管理和发布机制**：借助工具（如 `PNPM`），可以在 `Monorepo` 中实现高效的依赖管理和版本控制。

# 七、`PNPM Monorepo` 的关键原理

## 工作空间 (`Workspaces`)

`PNPM` 的工作空间机制允许将多个子包（项目）组织在同一个仓库中，并确保它们之间的依赖关系可以统一管理。通过工作空间，开发者可以在 `Monorepo` 中组织多个子项目，并共享依赖。

## 依赖管理原理

`PNPM` 通过去重的方式管理依赖，确保每个依赖的版本在仓库中只存在一份，并且能被所有项目共享。这种机制有效避免了 `npm/yarn` 中的依赖重复和磁盘浪费问题。

## 子包构建原理

`PNPM` 提供了高效的构建和缓存机制，通过智能的增量构建来优化构建过程。每次构建时，只有发生变化的部分会被重新构建，避免了重复构建整个仓库的浪费。

## 子包发布原理（结合 `NX` 或 `Turborepo`）

子包发布原理依赖于工具（如 `NX` 或 `Turborepo`）的配合，这些工具通过对项目之间的依赖关系进行分析，确保只有发生变化的子包会被发布，从而提高了发布效率。

# 八、`PNPM Monorepo` 的优势

## 优势对比

| 特性           | 传统架构                         | `Monorepo` 架构                |
| -------------- | -------------------------------- | ------------------------------ |
| 依赖管理       | 依赖版本不一致，管理困难         | 统一管理依赖，避免冲突         |
| 跨项目协作     | 复杂，代码难以共享               | 高效，模块间可以共享和复用代码 |
| 部署和发布     | 脚本和流程分散，难以自动化       | 流程统一，自动化部署和发布     |
| 构建和性能优化 | 每个项目单独构建，浪费时间和资源 | 智能增量构建，优化性能         |

## 适用场景

`Monorepo` 架构适用于以下场景：

- **大型前端或全栈项目**：需要管理多个项目和服务（如组件库、用户中心、业务系统等）时，`Monorepo` 提供了很好的组织和协作机制。
- **高效的团队协作**：多个团队需要在同一代码库上工作时，`Monorepo` 可以提升协作效率，减少跨项目沟通成本。
- **自动化构建和发布**：当多个子项目之间存在相互依赖时，`Monorepo` 可以统一管理依赖关系，减少版本冲突，并使构建和发布流程更加自动化。





























**可以放**：`Monorepo`是一种**代码组织策略**，不限制语言或框架。
 ✅ **适合放**：当多个异构项目**业务相关、需要共享代码/类型/协议、由同一团队维护**时，`Monorepo`反而能提升效率。
 ❌ **不适合放**：如果项目完全无关、跨部门协作、权限隔离要求高，则 `Monorepo`会带来管理负担。

> 🌰 举例：
>
> - ✅ 适合：一个平台包含 React 前端、Vue 管理后台、Node.js API、React Native App，它们共用用户模型和 API 类型定义 → 放 Monorepo。
> - ❌ 不适合：公司官网（静态 HTML）、反洗钱系统（Vue）、HR 系统（Angular）由不同部门维护 → 不应强行合并。

**简单说**：`Monorepo`是为“协同”设计的，而独立项目不需要协同。

> **`Monorepo`的边界 = 协作与共享的边界**。
>  不要为了“只有一个仓库”而用 Monorepo，而要为了“更好地协同”而用 Monorepo。   





1、workspaces怎么安装子项目的依赖的

用Monorepo之前想一想：
1.团队能否驾驭？
大仓开发意味着团队每个人有全部项目的代码权限，严格的CR机制，自动化构建、测试流水线、团队整体代码水平这些都得有一定规模和经验。试想某个周五的下午一个公司新人提交了一段神秘代码，然后周末整个公司的项目全都挂了
2.产出是否步调一致？
无论是react还是vue他们采用Monorepo更多是因为他们产出步调一致并且存在相互关联场景，合在一起也能作为一个单独的项目发布。但是在普遍的业务项目开发中产出基本都是独立的项目，没有太多联系。例如，多个项目共用一个组件，如果有一天项目A对该组件有独特需求，这个需求是破坏性的，这时候如果步调不统一，其他项目怎么办？要么其他项目被迫升级，要么公共组件库粘贴复制一份用来满足这个独特需求。

综上所述，Monorepo更适合框架、工具类库开发，业务项目最好还是独立代码仓库的好。





可只下载单独项目的依赖，独立开发