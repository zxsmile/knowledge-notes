# 一、`rollup`定位

`rollup`比`webpack`晚出2年，对比`webpack`肯定是有差异化的。我们可以查看官网，得到以下几个特点：

1、建议开发者使用`esm`写模块，使用`esm`模块的好处有很多：

- 高版本浏览器原生支持（浏览器只有2种方法支持引入`js`模块，1是`script`标签，2就是`esm`模块）
- 可以做`tree shaking`（早期`webpack`版本是不支持`tree shaking`的）
- 可以解决循环引用的问题

2、`esm`最终将在任何地方都可以实现（浏览器+`node`都可以用，是未来的标准），但 `Rollup` 让您今天就可以实现。

- 这句话很重要，也是`rollup`的特点，也是诞生的原因
- 简单的说就是：`ESM - ECMAScript` 模块是未来的官方标准和主流。但是浏览器的版本需要比较高，比如`chorme`都需要63版本以上

**`rollup`的特色是 `ES6` 模块和代码 `Tree-shaking`，这些 `webpack` 同样支持，除此之外 `webpack` 还支持热模块替换、代码分割、静态资源导入等更多功能。**

**当开发应用时当然优先选择的是 `webpack`，但是若你项目只需要打包出一个简单的 `bundle` 包，并是基于 `ES6` 模块开发的，可以考虑使用 `rollup`。**

**`rollup` 相比 `webpack`，它更少的功能和更简单的 api，是我们在打包类库时选择它的原因。**

# 二、`rollup`使用流程

#### 浏览器环境使用的应用程序的话：

- 无需考虑浏览器兼容问题的话
  - 开发者写`esm`代码 -> `rollup`通过**入口**，递归识别`esm`模块 ->  最终打包成一个或多个`bundle.js` -> 浏览器直接可以支持引入

- 需考虑浏览器兼容问题的话
  - 可能会比较复杂，需要用额外的`polyfill`库，或结合`webpack`使用

#### 打包成npm包的话：

- 开发者写`esm`代码 -> `rollup`通过入口，递归识别`esm`模块 -> （可以支持配置输出多种格式的模块，如`esm`、`cjs`、`umd`、`amd`）最终打包成一个或多个`bundle.js`
  - （开发者要写`cjs`也可以，需要插件`@rollup/plugin-commonjs`） 初步看来
- 很明显，`rollup`比较适合打包`js`库（`react`、`vue`等的源代码库都是`rollup`打包的）或 高版本无需往下兼容的浏览器应用程序（现在2022年了，时间越往后，迁移到`rollup`会越多，猜测）
- 这样打包出来的库，可以充分使用上`esm`的`tree shaking`，使源库体积最小

## 举个小🌰简单的对比一下 `webpack`打包和`rollup`打包

此`demo`是纯`esm`的写法

```js
// 入口main。js
import { b } from './test/a'
console.log(b + 1)
console.log(1111)

// './test/a'
export const b = 'xx'
export const bbbbbbb = 'xx'
```

rollup打包效果（非常干净，无注入代码）

```js
const b = 'xx';
console.log(b + 1);
console.log(1111);
```

`webpack`打包效果（有很多注入代码）

- 实际上，我们自己写的代码在最下面。上面注入的大段代码 都是**`webpack`自己的兼容代码**，**目的是自己实现`require`，`modules.exports`，`export`，让浏览器可以兼容`cjs`和`esm`语法**
- （可以理解为，**`webpack`自己实现polyfill支持模块语法，`rollup`是利用高版本浏览器原生支持`esm`(所以`rollup`无需代码注入)**）

```js
/******/ (function(modules) { // webpackBootstrap
/******/   // The module cache
/******/   var installedModules = {};
/******/
/******/   // The require function
/******/   function __webpack_require__(moduleId) {
/******/
/******/    // Check if module is in cache
/******/    if(installedModules[moduleId]) {
/******/     return installedModules[moduleId].exports;
/******/    }
/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/     i: moduleId,
/******/     l: false,
/******/     exports: {}
/******/    };
/******/
/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/    // Flag the module as loaded
/******/    module.l = true;
/******/
/******/    // Return the exports of the module
/******/    return module.exports;
/******/   }
/******/
/******/
/******/   // expose the modules object (__webpack_modules__)
/******/   __webpack_require__.m = modules;
/******/
/******/   // expose the module cache
/******/   __webpack_require__.c = installedModules;
/******/
/******/   // define getter function for harmony exports
/******/   __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/     Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/    }
/******/   };
/******/
/******/   // define __esModule on exports
/******/   __webpack_require__.r = function(exports) {
/******/    if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/     Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/    }
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/   };
/******/
/******/   // create a fake namespace object
/******/   // mode & 1: value is a module id, require it
/******/   // mode & 2: merge all properties of value into the ns
/******/   // mode & 4: return value when already ns object
/******/   // mode & 8|1: behave like require
/******/   __webpack_require__.t = function(value, mode) {
/******/    if(mode & 1) value = __webpack_require__(value);
/******/    if(mode & 8) return value;
/******/    if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/    var ns = Object.create(null);
/******/    __webpack_require__.r(ns);
/******/    Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/    if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/    return ns;
/******/   };
/******/
/******/   // getDefaultExport function for compatibility with non-harmony modules
/******/   __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/     function getDefault() { return module['default']; } :
/******/     function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/   };
/******/
/******/   // Object.prototype.hasOwnProperty.call
/******/   __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/   // __webpack_public_path__
/******/   __webpack_require__.p = "./";
/******/
/******/
/******/   // Load entry module and return exports
/******/   return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/test/a.js
const b = 'xx';
const bbbbbbb = 'xx';

// CONCATENATED MODULE: ./src/main.js
console.log(b + 1);
console.log(1111); 

/***/ })
/******/ ]);
```

# 三、两者处理源代码模块的对比

|           | 纯`esm`            | 纯`cjs`                                           | 两者混用                                          |
| --------- | ------------------ | ------------------------------------------------- | ------------------------------------------------- |
| `webpack` | 支持（有代码注入） | 支持（有代码注入）                                | 支持（有代码注入）                                |
| `rollup`  | **支持（无注入）** | 原生不支持（需增加插件`@rollup/plugin-commonjs）` | 原生不支持（需增加插件`@rollup/plugin-commonjs`） |

**`rollup`的初衷也是希望开发者去写`esm`，而不是`cjs`。因为`esm`是`javascript`的新标准，是未来，有很多优点，高版本浏览器也支持

# 四、两者处理对外暴露模块，非常不一样！！（解释`rollup`为什么适合打包库）

上面的`demo` **加上`export` 导出**

```js
// 入口main。js
import { b } from './test/a'
console.log(b + 1)
console.log(1111)
export { // 新增导出
  b
}

// './test/a'
export const b = 'xx'
export const bbbbbbb = 'xx'
```

`rollup`打包导出（非常干净，无注入代码）

- `rollup`本身不去做`polyfill`

- `rollup`的配置文件无需特殊配置，而且还可以支持多种模块导出（`esm`，`cjs`，`umd`，`amd`）

  ```js
  // rollup.config.js
  const OUTPUT_DIR = 'dist'
  const INPUT_FILE = 'src/main.js'
  export default[
   // esm
    {
      input: INPUT_FILE,
      output: {
        file: OUTPUT_DIR + '/esm/index.js',
        format: 'esm' // 导出esm模块 
      }
    },
    // commonjs
    {
      input: INPUT_FILE,
      output: {
        file: OUTPUT_DIR + '/cjs/index.js',
        format: 'cjs' // 导出cjs模块 
      }
    },
    // umd
    {
      input: INPUT_FILE,
      output: {
        file: OUTPUT_DIR + '/umd/index.js',
        format: 'umd' // 导出umd模块 
      }
    },
  ]
  ```

  打包得到 `esm` 和 `cjs`

  ```js
  // esm
  const b = 'xx';
  console.log(b + 1);
  console.log(1111);
  export { b };
  
  // cjs
  const b = 'xx';
  console.log(b + 1);
  console.log(1111);
  exports.b = b;
  
  // umd （兼容3种写法：cjs，amd，global（global可以初步理解为直接通过window传值））
  (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
      typeof define === 'function' && define.amd ? define(['exports'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.aa = {}));
  })(this, (function (exports) { 'use strict';
      const b = 'xx';
      console.log(b + 1);
      console.log(1111);
      exports.b = b;
      Object.defineProperty(exports, '__esModule', { value: true });
  }));
  ```

`webpack`导出 （区别巨大，注入代码较多，导出`esm`支持的不太好）

- `webpack`需配置 （此处是 `webpack 4.x`）

  ```js
  output: {
    ...,
    library: 'myLib', // 暴露出去的变量的名字
    libraryTarget: 'commonjs',
  }
  ```

  `webpack`暂时只能支持导出 `cjs` 或 更往前兼容的包(`umd`)**不支持`esm`（实验性）**

  ![webpack177](..\images\webpack177.png)

- 我们此处导出 cjs的包， 和`rollup`对比一下

  - 注入代码特别多，比较冗余

  ```js
  exports["myLib"] =
  /******/ (function(modules) { // webpackBootstrap
  /******/   // The module cache
  /******/   var installedModules = {};
  /******/
  /******/   // The require function
  /******/   function __webpack_require__(moduleId) {
  /******/
  /******/    // Check if module is in cache
  /******/    if(installedModules[moduleId]) {
  /******/     return installedModules[moduleId].exports;
  /******/    }
  /******/    // Create a new module (and put it into the cache)
  /******/    var module = installedModules[moduleId] = {
  /******/     i: moduleId,
  /******/     l: false,
  /******/     exports: {}
  /******/    };
  /******/
  /******/    // Execute the module function
  /******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/    // Flag the module as loaded
  /******/    module.l = true;
  /******/
  /******/    // Return the exports of the module
  /******/    return module.exports;
  /******/   }
  /******/
  /******/
  /******/   // expose the modules object (__webpack_modules__)
  /******/   __webpack_require__.m = modules;
  /******/
  /******/   // expose the module cache
  /******/   __webpack_require__.c = installedModules;
  /******/
  /******/   // define getter function for harmony exports
  /******/   __webpack_require__.d = function(exports, name, getter) {
  /******/    if(!__webpack_require__.o(exports, name)) {
  /******/     Object.defineProperty(exports, name, { enumerable: true, get: getter });
  /******/    }
  /******/   };
  /******/
  /******/   // define __esModule on exports
  /******/   __webpack_require__.r = function(exports) {
  /******/    if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/     Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/    }
  /******/    Object.defineProperty(exports, '__esModule', { value: true });
  /******/   };
  /******/
  /******/   // create a fake namespace object
  /******/   // mode & 1: value is a module id, require it
  /******/   // mode & 2: merge all properties of value into the ns
  /******/   // mode & 4: return value when already ns object
  /******/   // mode & 8|1: behave like require
  /******/   __webpack_require__.t = function(value, mode) {
  /******/    if(mode & 1) value = __webpack_require__(value);
  /******/    if(mode & 8) return value;
  /******/    if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
  /******/    var ns = Object.create(null);
  /******/    __webpack_require__.r(ns);
  /******/    Object.defineProperty(ns, 'default', { enumerable: true, value: value });
  /******/    if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
  /******/    return ns;
  /******/   };
  /******/
  /******/   // getDefaultExport function for compatibility with non-harmony modules
  /******/   __webpack_require__.n = function(module) {
  /******/    var getter = module && module.__esModule ?
  /******/     function getDefault() { return module['default']; } :
  /******/     function getModuleExports() { return module; };
  /******/    __webpack_require__.d(getter, 'a', getter);
  /******/    return getter;
  /******/   };
  /******/
  /******/   // Object.prototype.hasOwnProperty.call
  /******/   __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  /******/
  /******/   // __webpack_public_path__
  /******/   __webpack_require__.p = "./";
  /******/
  /******/
  /******/   // Load entry module and return exports
  /******/   return __webpack_require__(__webpack_require__.s = 0);
  /******/ })
  /************************************************************************/
  /******/ ([
  /* 0 */
  /***/ (function(module, __webpack_exports__, __webpack_require__) {
  
  "use strict";
  // ESM COMPAT FLAG
  __webpack_require__.r(__webpack_exports__);
  
  // EXPORTS  这一行是处理esm的导出，因为我们用的是 export { b: xx }， 如果我们用cjs的导出 比如 module.exports = { b: xx }， 此处就会没有，会更简单，直接是 module.exports = { b: xx }
  __webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ b; });
  
  // CONCATENATED MODULE: ./src/test/a.js
  const b = 'xx';
  const bbbbbbb = 'xx';
  
  // CONCATENATED MODULE: ./src/main.js
  console.log(b + 1);
  console.log(1111);
  
  /***/ })
  /******/ ]);
  ```

  注意看  倒数第10多行，有个

  ```java
  // EXPORTS 
  __webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ b; });
  
  这一行是处理esm的导出，因为我们用的是 export { b: xx }，
  如果我们用cjs的导出 比如 module.exports = { b: xx }， 此处就会没有此行，会更简单，直接是 module.exports = { b: xx }   （ webpack会自己模拟实现 module.exports ）
  ```

# 五、为什么`webpack`需要注入这么多代码？

因为`webpack`比`rollup`早出2年，诞生在`esm`标准出来前，`commonjs`出来后，当时的浏览器只能通过`script`标签加载模块，`script`标签加载代码是没有作用域的，只能在代码内 用`iife`的方式 实现作用域效果。**这就是`webpack`打包出来的代码 大结构都是`iife`的原因**，并且**每个模块都要装到`function`里面**，才能保证互相之间作用域不干扰。**这就是为什么 `webpack`打包的代码为什么乍看会感觉乱，找不到自己写的代码的真正原因**。

关于`webpack`的代码注入问题，是因为浏览器不支持`cjs`，所以`webpack`要去自己实现`require`和`module.exports`方法（才有很多注入）（`webpack`自己实现`polyfill`）这么多年了，甚至到现在2022年，浏览器为什么不支持`cjs`

？

- **`cjs`是同步的，运行时的，`node`环境用`cjs`，`node`本身运行在服务器，无需等待网络握手，所以同步处理是很快的**
- **浏览器是 客户端，访问的是服务端资源，中间需要等待网络握手，可能会很慢，所以不能 同步的 卡在那里等服务器返回的，体验太差**

- **后续出来`esm`后，`webpack`为了兼容以前发在`npm`上的老包**（并且当时心还不够决绝，导致这种“丑结构的包”越来越多，以后就更不可能改这种“丑结构了”），所以保留这个`iife`的结构和代码注入，**导致现在看`webpack`打包的产物，乍看结构比较乱且有很多的代码注入，自己写的代码都找不到**

`rollup`诞生于`esm`标准出来后，就是针对`esm`设计的，也没有历史包袱，所以可以做到真正的“打包”（精简，无额外注入）

- （根据`npm`版本上传显示最早上传时间： **`webpack`是2013年左右，`rollup`是2015.5**）

# 六、`rollup`如何打包第三方依赖 和 懒加载模块 和 公共模块？

和`webpack`打包一样，有两种：单`chunk`包 和 多`chunk`包

## 单`chunk`包

无额外配置，一般会把所有`js`打成一个包。打包外部依赖（第三方）也是一样的。比如：

```js
// 入口 main.js
import Axios from 'axios'
Axios.get()
console.log(1111)

------ 打包后的结果 ------
// 最终会把axios的源代码 和 main.js 主代码，打包到一个文件内，无额外代码注入 
// 以下是截取了一头一尾，中间省略
import require$$1$1 from 'http';
import require$$2 from 'https';
import require$$0$1 from 'url';
import require$$3 from 'assert';
import require$$4 from 'stream';
import require$$0 from 'tty';
import require$$1 from 'util';
import require$$7 from 'zlib';

var axios$1 = {exports: {}};

var bind$2 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

...
...
...

axios$1.exports = axios;

// Allow use of default import syntax in TypeScript
axios$1.exports.default = axios;

var _axios_0_18_1_axios = axios$1.exports;
_axios_0_18_1_axios.get();
console.log(1111);
```

**此处`rollup`打包有个注意点**：

- 很多第三方依赖很早就有了，所以用的是**`commonjs`模块导出**，`rollup`打包的话，需要安装插件`@rollup/plugin-node-resolve`。因为是`cjs`的包，所以也不存在`tree shaking`
  - 插件原理是，把`cjs`的包，转成`esm`包，在打包
- 现在比较流行的`monorepo`，就是完全用`esm`写库+`rollup`打包，可以很轻易的做到`tree shaking`，**让核心库变的更小，解析速度更快，还可以对外提供工具，扩大影响力**

## 多个`chunk`包（代码分离）

1. 配置多个入口，此法比较简单，可自行测试

   ```js
   // rollup.config.js
    input: {            
        index: 'src/main.js',            
        other: 'src/other.js',            
    },
   ```

2. 代码分离 （**动态`import`，懒加载， `import(xxx).then(module => {}`)** ）

- 此处有一个官方的例子，再清楚不过了

  ```js
  // 入口 main.js
  /* DYNAMIC IMPORTS 动态import
      Rollup supports automatic chunking and lazy-loading  Rollup支持自动分块和懒加载
      via dynamic imports utilizing the import mechanism   通过dynamic imports动态导入
      of the host system. 
      */
  if (displayMath) {
      import('./maths.js').then(function (maths) {
              console.log(maths.square(5));
              console.log(maths.cube(5));
      });
  }
  
  // './maths.js'
  import square from './square.js';
  export {default as square} from './square.js';
  export function cube (x ) {
          return square(x) * x;
  }
  
  // './square.js'
  export default function square ( x ) {
          return x * x;
  }
  
  
  ---------------- 打包结果 ----------------
  // main.js
  'use strict';
  /* DYNAMIC IMPORTS 动态import
      Rollup supports automatic chunking and lazy-loading  Rollup支持自动分块和懒加载
      via dynamic imports utilizing the import mechanism   通过dynamic imports动态导入
      of the host system. 
      */
  if (displayMath) {
          // 打包成cjs模块的话，import替换成 Promise + require
          // Promise.resolve(require('../chunk-0ee5c472.js')).then(function (maths) {
          import('../chunk-c4d97f01.js').then(function (maths) {
                  console.log(maths.square(5));
                  console.log(maths.cube(5));
          });
  }
  
  // '../chunk-0ee5c472.js'
  'use strict';
  function square ( x ) {
          return x * x;
  }
  function cube (x ) {
          return square(x) * x;
  }
  exports.cube = cube;
  exports.square = square;
  ```

  对于代码分割，还有一种方法可以通过 **`output.manualChunks`** 选项**显式**告诉 `Rollup` 哪些模块要**分割成单独的块**。

## **总结**：

- **动态`import`，`rollup`对比`webpack`打包后的模块格式的支持度**

  | 打包后的模块格式： | `esm`          | `cjs` | `amd` | `umd`  |
  | ------------------ | -------------- | ----- | ----- | ------ |
  | `webpack`          | 不支持，实验中 | 支持  | 支持  | 支持   |
  | `rollup`           | 支持           | 支持  | 支持  | 不支持 |

- 实现原理，对比`webpack`：

  - `webpack`是自己实现的“动态`import`“（借助`promise + script`标签 + `window`对象 + 模拟`import`方法）

  - `rollup`是  （打包成esm模块）利用浏览器（`chorme63` 以上）天然支持

    动态`import`或  （打包成`cjs`模块）`promise + cjs`的`require`

- **此处有个很重要细节点**

  - `rollup`打的包，如果要用 动态`import`（现在`vue`和`react`的单页项目 特别流行用动态`import`加载路由，算硬需求了）

  - 注意如果要在浏览器上跑，首先要是`esm`的包（浏览器不支持`cjs`），然后浏览器版本要注意（`chorme63` 以上），因为`rollup`不做额外代码注入，完全利用高版本浏览器原生支持`import`（所以代码特别干净，`webpack`会做大量的兼容 自己实现`require`和`import`）

    ![webpack178](..\images\webpack178.png)

## `rollup`如何处理公共模块？（比如， `a、b、c` 3个模块 同时依赖 `d`）

**有2种情况：**

1. 源代码内 **不存在 动态`import`**，那么会打成**一个`chunk`**（`a、b、c、d` 4个模块都在一包内，`d`只正常有一份）

2. 源代码内 **存在 懒加载模块，并且懒加载的模块也访问了公共依赖**，比如

   ```js
   // 入口 main.js
   import {deepCopy} from '@xxx/methods/deepCopy.js' // 这是放在公司的npm域内的一个包，可以理解为export一个简单的deepCopy函数
   console.log(deepCopy(a))
   import('./test/a').then(e => {
     console.log(e)
   })
   
   // './test/a' 懒加载模块 也依赖 同一公共模块
   import {deepCopy} from '@xxx/methods/deepCopy.js'
   const a = {a: 1}
   export const b = deepCopy(a)
   
   ---------- 是否会把 公共依赖  打包2份呢?  --------------
   答案是no，rollup还是牛p，公共依赖只会出来一份，然后对外 export  （此处举例是导出esm格式， 亲测导出cjs格式一样的可以，此处就不赘述，有兴趣可以自己test一下）
   
   生成的目录结构，有3个文件
       a-19173be8.js
       main.js
       main-219c2eaf.js
   
   // main.js
   import './main-219c2eaf.js';
   
   // main-219c2eaf.js
   const deepCopy = function (obj) {
     // do ..
   };
   console.log(deepCopy(a));
   import('./a-19173be8.js').then(e => {
     console.log(e);
   });
   
   // a-19173be8.js
   import { d as deepCopy } from './main-219c2eaf.js';
   const a = {a: 1};
   const b = deepCopy(a);
   export { b };
   ```

   总结：**对于公共依赖，`rollup`不会出现重复打包的情况！并且完全无注入代码！无需额外配置。**  对比`webpack`的话，`webpack`需要配置 `optimization.splitChunks` （`webpack4.x` 以上）

# 七、**总结** `rollup vs webpack`

## 1、应用场景不同

对于应用场景而言，`Webpack` 通常用于复杂应用的打包，这种应用大多是由多个单独的模块组成的，并且使用了**多种资源**（例如图片、样式表等）。`Webpack` 适合这种复杂应用的打包，因为它能够处理 `JavaScript` 资源以外的任何文件，同时还支持各种插件，例如代码压缩、代码分离、热更新等等。

另一方面，`Rollup` 更适合用于库的打包，尤其是那些专注于 `ES6` 模块的库。这是因为 `Rollup` 的目标是产生**尽可能小和尽可能快**的代码，而且它能够分析所有的 `ES6` 模块，删除不需要的代码，并将计算合并在一起，从而产生出更小更快的代码，这样的输出可以在所有的现代浏览器中逐字解析。

使用 `Rollup` 的开源项目：

- `react`
- `vue`
- `vuex`
- `vue-router`

![webpack181](..\images\webpack181.png)

使用`webpack`的项目：

- `elemnt-ui`
- `mint-ui`
- `vue scaffold`

![webpack182](..\images\webpack182.png)

可以看出 `Webpack` 更偏向前端工程，`Rollup` 更偏向于 `JavaScript` 库

## 2、打包方式不同

对于打包方式而言，`Webpack` 的打包方式是将所有的文件打包在一起，以形成一个或多个文件，**这些文件包含了所有的 `JavaScript`、样式表、图像和字体等等**。同时还需要处理比较复杂的代码和依赖关系，还需要进行一系列的优化和处理，比如加载和解析模块，分离出共享代码等，所以 `Webpack` 会相对慢一些。

`Rollup` 默认是只生成一个文件，会从入口文件开始**遍历整个依赖图**，并只将项目的所需部分包含在生成的  `JavaScript`文件中。这种方式通常有效地清除了生成文件不需要的部分并生成更小，更快的输出。

> 关键在于只关注 `ES6` 模块处理，并且能够更好地利用 `Tree Shaking` 等技术消除不必要的代码。

## 3、访问速度不同

在访问速度方面，因为 **`Webpack`  打包后的文件较大**，所以它需要花费更长的时间下载。此外，由于其中包含运行时环境，因此它需要时间来解析代码。

`Rollup` 的**输出文件更小**，所以它需要更少的时间去下载，同时它不包含任何多余的代码，因此它可以更快地加载和运行。

下图是 `Rollup` 和 `Webpack` 打出的 `bundle`，可以看到 `Rollup` 非常的简洁

![webpack183](..\images\webpack183.png)

## 4、生态和扩展性不同

对于生态和扩展性而言，`Webpack` 的扩展性非常强大，它有着众多的插件和 `Loader` 可以使用，因此我们可以为我们的应用添加各种功能和特性，而不用自己去实现一个

例如我们用 `CSS loader` 和 `style loader` 来处理 `CSS` 代码，用 `Babel loader` 来处理最新的 `JavaScript` 代码等等

> 在前面我们不断的提到了 `Rollup` 是 `ESModule` 的产物，那么**为什么 `ESModule` 会比 `CommonJS` 快呢？**
>
> `ESModule` 和 `CommonJS`都是模块化的标准化方案，但它们在加载模块时的实现方式不同。
>
> `CommonJS require` 是**同步加载模块**，也就是说，一个模块在被引入后，引入模块的代码会等待模块加载完成才继续往下执行。
>
> `CommonJS`模块是 `ESModule` 提出前的一种暂时性解决方案，未来发展缓慢。
>
> 而 `ESModule import` 是**异步加载模块**，它允许浏览器在解析 `JavaScript` 代码时，将模块的加载放到后台去，让执行线程不被阻塞。这种并行加载的方法能够提高 `JavaScript` 代码的执行效率。
>
> `ESModule` 可以在**编译时进行静态优化**，还支持 `Tree shaking`，可以在代码打包时删除未使用的代码，从而减少打包后代码的体积和加载时间，这也是 `ESModule` 比 `CommonJS`更快的原因之一。同时还提供了一些高级特性，比如循环引用和实时绑定
>
> **最关键的两个原因就是 `TreeShaking` 和 异步加载**
>
> 同时 `ESModule` 的兼容性更佳，在未来将变得更加重要。

## 5、总结

`Webpack` 和 `Rollup`  主要存在以下几个方面的不同

- 打包配置不同
- 不同文件类型的转换不同，`Webpack` 用 `loader`，`Rollup` 用 `plugins`
- `dev-server` 不同，`HMR` 不同（`Rollup` 没有）
- `Tree shaking` 实现不同
- 应用场景不同
- 打包方式不同，
- 访问速度
- 生态和扩展性

在不同场景下，`Webpack`  和 `Rollup` 都能发挥自身优势作用。

`Webpack` 对于**代码分割和静态资源导入**有着“先天优势”，并且支持 `HMR`，而 `Rollup` 并不支持，所以当项目需要用到以上，则可以考虑选择 `Webpack` 。

但是，`Rollup` 对于 `Tree shaking`和 `ES6` 模块有着算法优势上的支持，若你项目只需要打包出一个简单的`bundle`包，可以考虑使用 `Rollup` ，会有以下三点的收益。

- **第一点是构建速度明显快于`Webpack` **
- **第二点是其生成的代码量很小**
- **第三点是其配置方式其实非常简单。**

其实 `Webpack` **也支持`Tree shaking`，并且也能够通过 `Babel-loader` 来打包 `ES6` 代码**，`Rollup` 已经在渐渐地失去了当初的优势了。

但是 `Rollup` 仍然依靠简单的 `API` 和使用方式被许多库开发者青睐，如 `React`、`Vue` 等，都是使用 `Rollup` 作为构建工具的。

而在中大型 `Web` 应用开发下，`Webpack` 会更受青睐，并且会更合适一些。

### `rollup`诞生在`esm`标准出来后

- **出发点就是希望开发者去写`esm`模块**，这样适合做代码静态分析，可以做`tree shaking`减少代码体积，也是浏览器除了`script`标签外，真正让`JavaScript`拥有模块化能力。是`js`语言的未来

- `rollup`完全依赖高版本浏览器原生去支持`esm`模块，所以无额外代码注入，打包后的代码结构也是清晰的

  （不用像`webpack`那样`iife`）

- 目前浏览器支持模块化只有3种方法：
  - ①`script`标签（缺点没有作用域的概念）
  - ②`script`标签 + `iife`+ `window` + 函数作用域（可以解决作用域问题。`webpack`的打包的产物就这样）
  - ③`esm` （什么都好，唯一缺点 需要高版本浏览器）

### `webpack`诞生在`esm`标准出来前，`commonjs`出来后

- 当时的浏览器只能通过`script`标签加载模块，`script`标签加载代码是没有作用域的，只能在代码内 用`iife`的方式 实现作用域效果，**这就是`webpack`打包出来的代码 大结构都是`iife`的原因**，并且**每个模块都要装到`function`里面**，才能保证互相之间作用域不干扰。**这就是为什么 `webpack`打包的代码为什么乍看会感觉乱，找不到自己写的代码的真正原因**
- 关于`webpack`的代码注入问题，是因为浏览器不支持`cjs`，所以`webpack`要去自己实现`require`和`module.exports`方法（才有很多注入）这么多年了，甚至到现在2022年，浏览器为什么不支持`cjs`？
  - **`cjs`是同步的，运行时的，`node`环境用`cjs`，`node`本身运行在服务器，无需等待网络握手，所以同步处理是很快的**
  - **浏览器是 客户端，访问的是服务端资源，中间需要等待网络握手，可能会很慢，所以不能 同步的 卡在那里等服务器返回的，体验太差**
- **后续出来esm后，`webpack`为了兼容以前发在`npm`上的老包**（并且当时心还不够决绝，导致这种“丑结构的包”越来越多，以后就更不可能改这种“丑结构了”），所以保留这个`iife`的结构和代码注入，**导致现在看`webpack`打包的产物，乍看结构比较乱且有很多的代码注入，自己写的代码都找不到**

# 八、最终使用推荐

#### 打包**开源库**：**不用思考，`rollup`会是你更好的选择**

- `rollup`本身也支持很多插件，生态也成熟，各种场景几乎都能照顾到

#### 打包**应用程序**：个人推荐，看您的 应用程序 **需不需要兼容老浏览器**

兼容表如下（其实就是 动态`import`的兼容表 ） 以`chorme`为例，需要`chorme63`以上

![webpack179](..\images\webpack179.png)

**如果不考虑兼容老浏览器，建议用 `vite` 开发应用程序**

- **`dev`开发方面**：`vite`提供`dev`服务器，以及比`webpack`快的多的热更新，`dev`开发的体验更好了
- `prd`生产方面：`vite`打生产包，实际上用的就是`rollup`，打的生产包比用`webpack`小了很多，有不错的性能提升
- **理论上 `chorme63`以上 可以开箱即用，`chorme63`以下也不是完全不能用**，需要自己加`polyfill`或`vite`插件