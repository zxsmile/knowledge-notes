# 一、从源码转换讲起

`JavaScript`脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。

常见的源码转换，主要是以下三种情况：

> 　　（1）压缩，减小体积。比如`jQuery 1.9`的源码，压缩前是`252KB`，压缩后是`32KB`。
>
> 　　（2）多个文件合并，减少`HTTP`请求数。
>
> 　　（3）其他语言编译成`JavaScript`。最常见的例子就是**`CoffeeScript`**。

这三种情况，都使得实际运行的代码不同于开发代码，除错（`debug`）变得困难重重。

通常，`JavaScript`的解释器会告诉你，第几行第几列代码出错。但是，这对于转换后的代码毫无用处。举例来说，`jQuery 1.9`压缩后只有3行，每行3万个字符，所有内部变量都改了名字。你看着报错信息，感到毫无头绪，根本不知道它所对应的原始位置。

这就是`Source map`想要解决的问题。

# 二、什么是`Source map`

简单说，`Source map`就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。

有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。

我们在项目打包时，常常会看到 `.js.map` 的文件，这就是 `sourcemap` 文件。`sourcemap` 记录了源代码和编译后代码的相关信息，可以将编译后代码映射为源代码，以帮助开发人员排查问题代码出现的位置，进而对问题代码进行修复。

![webpack185](..\images\webpack185.png)

# 三、实际使用场景

下面我写了一个 `sort` 函数，它接受一个 `array` 类型的参数并返回其升序排序后的结果，我故意调用不传参数导致其出错：

```js
function sortArrayInAsc(arr) {
  return arr.sort((a, b) => a - b); // 第 5 行调用 sortArrayInAsc 代码时没传 arr 参数，会导致这里出错
}

console.log(sortArrayInAsc());
```

然后我们用 `webpack` 来启动一个开发环境，`html` 中引入这个文件，看一下在开启和关闭 `sourcemap` 的情况下，报错信息的提示位置是什么样子的。

- 不开启 `sourcemap`

  首先我们不设置 `webpack.config.js` 中的 `devtool` 选项，我们发现报错信息指向了压缩混淆后的代码，根据这段代码很难判断出错的源代码是哪里：

  ![webpack159](..\images\webpack159.gif)

- 开启 `sourcemap`

  然后我们将 `webpack.config.js` 中的 `devtool` 选项设置为 `sourcemap`，再来看一下报错位置的结果，发现直接指向了报错的源代码位置，我们可以快速的修复问题：

​         ![webpack1601](..\images\webpack160.gif)

对比发现，通过 `sourcemap`我们可以根据编译后的代码位置找到源代码报错位置，从而快速进行修复。**生产环境下，为了防止别人获取源代码，通常不会将 `sourcemap`文件上传到静态资源服务器，而是上传到内部服务器上。当用户触发 `js` 错误时，通过前端监控系统或者其他手段收集到出错信息，然后根据内部服务器的 `sourcemap`结合出错信息，找到出错的源代码位置。**

# 四、`sourcemap` 设计思路

`sourcemap` 的作用就是将编译后代码映射为编译前源代码，所以**要搞明白 `sourcemap` 的核心原理，就是搞明白如何将编译后代码映射为编译前源代码，下面让我们看一下其具体的设计思路**。

## 映射需要哪些因素

假如我们有如下的代码：

- 编译前 `/src/index.js`：

  ```js
  function print(variable) {
    console.log(variable);
  }
  print(Date.now());
  print(Math.random());
  ```

- 编译后 `/dist/index.js`：

  ```scss
  (()=>{function o(o){console.log(o)}o(Date.now()),o(Math.random())})();
  //# sourceMappingURL=index.js.map
  ```

先让我们想想，我们想通过编译后代码，映射到编译前的代码，都需要哪些信息？我们已知了编译后的代码，那么要做映射，需要知道是哪个编译后文件映射到哪个源文件以及编译后的哪个变量映射到源文件的哪个变量。

例如我们先进行 `print` 函数的映射，通过上述代码，我们大体可以对应编译后的 `o` 函数，那么映射就是：

![webpack186](..\images\webpack186.png)

但是我们发现编译后的代码中，`print` 函数的形参 `variable` 也被编译成了 `o`，那么怎么知道编译后的每个 `o` 对应编译前的哪个变量呢？我们还需要加上编译后和编译前变量的位置，即加上变量所在的行、列的开始位置：

![webpack187](..\images\webpack187.png)

如此一来，我们便知道了确定映射关系需要 8 个要素，这 8 个元素组成了一个映射段: `编译后文件|编译后变量起始行|编译后变量起始列|编译后变量名|源文件|源代码起始行|源代码起始列|源代码变量名`，在 `sourcemap`中，通过一个 `mappings` 字段，将所有映射段以 `,` 链接形成一个字符串，那这个字符串就可以确定完整的代码映射：

![webpack188](..\images\webpack188.png)

## 精简映射所需元素

上面我们已经知道了确定映射关系所需的要素，一共 8 个元素，这 8 个元素组成的段我们暂称为映射段，假如我们一共有 100 个变量的映射，那我们需要写 100 个 `/dist/index.js | 0 | 15 | o | /src/index.js | 0 | 9 | print` 这样的映射段。我们需要尽可能要 `sourcemap`的体积精简，不占用太多的空间，那我们看看能不能想办法精简映射的元素。

- 编译后文件：一个编译后文件只会指向一个 `sourcemap`文件，所以在一个 `sourcemap`文件中，编译后文件名都是一样的，`sourcemap`标准中就是用一个 `file` 字段记录下编译后文件名称，就可以在映射段去除掉编译后文件这个要素。

  ![webpack189](..\images\webpack189.png)

- 编译后变量起始行：我们解析编译后的代码，都是从头到尾按照顺序来的，也就是说行也是从头到尾按照顺序解析的。那么这种顺序结构，我们通常可以用数组记录，例如第一行编译后代码的映射放到数组下标 `0`、第二行放到下标 `1`……而 `sourcemap`标准中所有映射段都放在一个字符串中，采用 `;` 分隔每一行的映射，就可以去掉映射段中的编译后代码起始行。

  ![webpack190](..\images\webpack190.png)

- 编译后变量起始列：许多时候，编译后代码只有一行，列可能达到几万甚至几十万，意味着到了靠后的映射段我们需要一个很大的数字去记录起始列。我们知道编译后的代码是从头到尾按顺序的，那么根据这个思路，我们可以使用增量来记录，即记录的是当前这个变量相对于同一行上一个变量的所在的起始列的增量，例如`function print(variable)`，`print` 起始列下标为 `9`，`variable` 其实列下标是 `11`，那么增量就是 `variable` 相对于 `print` 的起始列增量就是 `2`，我们记录 `2` 来代替 `11`。

  ![webpack191](..\images\webpack191.png)

- 编译后变量名：我们都知道，`js` 变量名都是以字母、数字、`$` 或者 `_` 组成的连续字符串(不能以数字开始)，我们已经有了编译后的代码和编译后变量的起始列，自然知道编译后的变量名是什么，所以不需要再映射段中记录编译后变量名：

  ![webpack192](..\images\webpack192.png)

- 源文件：上面说到我们编译后文件名可以省略，因为一个 `sourcemap` 只对应一个编译后文件，那源文件能省略吗？答案是不能。以 `webpack` 为例，打包过程中可能将多个源文件打包到一个 `chunk` 中(编译后文件)，也就是说一个 `sourcemap` 对应多个编译前文件，所以源文件的信息我们需要记录。但是我们可以不必再每个映射段中都记录源文件，因为通常很多个映射段对于一个源文件，所以我们可以将源文件作为一个数组提出来，`sourcemap` 用 `sources` 字段记录了源文件的数组，然后每个映射段记录的是对应源文件在 `sources` 数组总的下标，和前面列的思路一样，我们可以记录相对前一个映射段中 `sources` 下标的增量：

  ![webpack193](..\images\webpack193.png)

- 源代码起始行：`mappings` 中映射段的顺序是按照编译后代码顺序来的，其对应的编译前代码不一定是按序的，所以源代码的起始行我们无法通过数组或者 `;` 等形式省略，但是我们同样可以用相对于上一个映射段中源代码起始行的相对增量来记录行数，以减小记录的行数位数：

  ![webpack194](..\images\webpack194.png)

- 源代码起始列：同上，我们使用相对增量记录源代码起始列：

  ![webpack195](..\images\webpack195.png)

- 源代码变量名：上面我们通过已知编译后代码和编译后变量的起始位置得到了编译后变量名，所以可以在映射段中省略编译后变量名的记录。但是我们是不知道源代码具体内容的，所以我们无法省略源代码变量名。但是同源文件的思路一样，源代码中同一个变量是被多次使用的，所以 `sourcemap` 用 `names` 字段记录了源代码中的变量数组，然后在映射段中记录对应变量名在 `names` 数组中下标，同样使用增量：

  ![webpack196](..\images\webpack196.png)

经过上述的精简过程，我们一个映射段中记录的内容从 8 个变量 `编译后文件|编译后变量起始行|编译后变量起始列|编译后变量名|源文件|源代码起始行|源代码起始列|源代码变量名` 就缩减到了 5 个变量：`编译后变量起始列(增量)|对应sources源文件下标(增量)|源代码起始行(增量)|源代码起始列(增量)|对应names变量名下标(增量)`，且五个变量都是数字。

## 进一步精简（`base64 VLQ` 编码）

上述步骤中我们将映射段缩减到了五个数字的串，例如有个映射段 `11 | 1 | 0 | 0 | 0`，那我们能否再进一步缩减呢？看到这个字符串，我们可以知道进一步缩减有两个方法：

- 通过 `base64` 编码减少记录的数字位数
- 去掉分隔符 `|`

第一个方法蛮好理解的，第二个去掉分隔符 `|` 能做到吗？例如上面的映射段去掉分隔符就变成了 `111000`，我们如何知道从哪里划分呢？显然 `|` 代表一个部分结束的标识，所以我们如果能给数据带上一个是否该部分结束的标识，那我们就知道该如何划分了，`sourcemap` 通过 `base64 VLQ` 编码实现了这一点。

`VLQ` 通过 6 位二进制数进行存储，第一位表示连续位(`1` 表示连续，`0` 表示不连续，也就是说如果是 `1` 代表这部分还没结束)，最后一位表示是正数还是负数(`1` 是负数，`0` 是正数)，中间的 4 位用了存储数据，所以一个 6 位二进制存储的范围是 `[-15, 15]`，超过就需要用连续 6 位二进制数（连续的 6 位二进制数从第二个开始不需要记录是正负数了，所以第二个之后后 5 位存储数据）。以下面两个例子来理解：

![webpack197](..\images\webpack197.png)

经过转化，十进制的 `-7` 和 `21` 分别被转化成了 `base64 VLQ` 编码的 `P` 和 `qB`。

- 当我们读取一个映射段中读到了 `p` 时，根据上述方法倒推可以得到 6 位二进制数 `001111`，以 `0` 开头，说明这部分不连续，那么 `P` 就代表了映射段中一部分
- 而读到 `q` 时，我们倒推出 `q` 的 6 位二进制数 `101010`，以 `1` 开头，说明这部分是连续的还没结束，要继续读一下个 `B`，而 `B` 的 6 位二进制数 `000001` 以 `0` 开头，说明不连续，`qB` 两个字符构成了映射段中的一部分。

上述 `VLQ` 编码和 `base64` 编码的对应关系如下表：

![webpack198](..\images\webpack198.png)

通过上述的简化关系，`11 | 1 | 0 | 0 | 0` 就可以精简为 `WCAAA`，得到的映射段字符串就非常精简了。

[base64vlq](https://link.juejin.cn/?target=https%3A%2F%2Fwww.murzwin.com%2Fbase64vlq.html) 这个网站可以验证 `base64 VLQ` 转换为 10 进制数的结果。

# 五、`sourcemap` 原理

最后我们看一下一个真实的 `sourcemap` 文件中的内容：

```
{
  "version": 3, // sourcemap 版本
  "file": "index.js", // 编译后文件名
  "mappings": "MAAA,SAASA,EAAMC,GACbC,QAAQC,IAAIF,EACd,CAEAD,EAAMI,KAAKC,OACXL,EAAMM,KAAKC,S", // 映射段字符串
  "sources": [
    "webpack://wp/./src/index.js"
  ], // 源文件数组
  "sourcesContent": [
    "function print(variable) {\n  console.log(variable);\n}\n\nprint(Date.now());\nprint(Math.random());\n"
  ], // 编译前源代码
  "names": [
    "print",
    "variable",
    "console",
    "log",
    "Date",
    "now",
    "Math",
    "random"
  ], // 源代码中变量数组
  "sourceRoot": "" // 源文件根目录
}

```

整个文件就是一个JavaScript对象，可以被解释器读取。它主要有以下几个属性：

```
- version：Source map的版本，目前为3。

- file：转换后的文件名。

- sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。

- sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。

- names：转换前的所有变量名和属性名。

- mappings：记录位置信息的字符串，下文详细介绍。
```

## `mappings`属性

下面才是真正有趣的部分：两个文件的各个位置是如何一一对应的。

关键就是`map`文件的`mappings`属性。这是一个很长的字符串，它分成三层。

> 　　第一层是**行对应**，以分号（`;`）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。
>
> 　　第二层是**位置对应**，以逗号（`,`）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。
>
> 　　第三层是**位置转换**，以`VLQ`编码表示，代表该位置对应的转换前的源码位置。

举例来说，假定`mappings`属性的内容如下：

> 　　`mappings:"AAAAA,BBBBB;CCCCC"`

就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。

## 位置对应的原理

每个位置使用五位，表示五个字段。

从左边算起，

> 第一位，表示这个位置在（转换后的代码的）的第几列。
>
> 第二位，表示这个位置属于`sources`属性中的哪一个文件。
>
> 第三位，表示这个位置属于转换前代码的第几行。
>
> 第四位，表示这个位置属于转换前代码的第几列。
>
> 第五位，表示这个位置属于`names`属性中的哪一个变量。

有几点需要说明。首先，所有的值都是以0作为基数的。其次，第五位不是必需的，如果该位置没有对应`names`属性中的变量，可以省略第五位。再次，每一位都采用`VLQ`编码表示；由于`VLQ`编码是变长的，所以每一位可以由多个字符构成。

如果某个位置是`AAAAA`，由于A在`VLQ`编码中表示0，因此这个位置的五个位实际上都是0。它的意思是，该位置在转换后代码的第0列，对应`sources`属性中第0个文件，属于转换前代码的第0行第0列，对应`names`属性中的第0个变量。