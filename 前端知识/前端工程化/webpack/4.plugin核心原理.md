# 一、`plugin`作用

通过插件我们可以扩展 webpack，加入自定义的构建行为，使 webpack 可以执行更广泛的任务，拥有更强的构建能力。

# 二、`plugin`和`loader`的区别

#### Loader：

Loader本质上是一个函数，负责代码的转译，即对接收到的内容进行转换后将转换后的结果返回 配置Loader通过在` modules.rules`中以数组的形式配置

#### Plugin：

Plugin本质上是一个带有`apply(compiler)`的函数，基于[tapable](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable)这个事件流框架来监听**webpack**构建/打包过程中发布的hooks来通过自定义的逻辑和功能来改变输出结果。 Plugin通过`plugins` 以数组的形式配置

#### 总结：

**Loader**主要负责将代码转译为**webpack** 可以处理的JavaScript代码，而 **Plugin** 更多的是负责通过接入**webpack** 构建过程来影响构建过程以及产物的输出，**Loader**的职责相对比较**单一**简单，而**Plugin**更为丰富多样

`Plugin` 插件是 Webpack 的扩展，执行范围更广，可以在构建过程的各个阶段进行操作和自定义功能。Webpack 会提供一些 API 和 生命周期钩子方便开发者触达到除了编译之外的一些环节来执行操作。

**使用场景**

- 压缩输出的 JavaScript 文件（如使用 TerserPlugin）。
- 提取 CSS 到单独的文件（如使用 MiniCssExtractPlugin）。
- 生成 HTML 文件并自动注入打包后的资源（如使用 HtmlWebpackPlugin）。
- 清理输出目录（如使用 CleanWebpackPlugin）。

# 三、`Plugin` 工作原理

webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。

插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。

站在代码逻辑的角度就是：webpack 在编译代码过程中，会触发一系列 `Tapable` 钩子事件，插件所做的，就是找到相应的钩子，往上面挂上自己的任务，也就是注册事件，这样，当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行了。

![webpack70](..\images\webpack70.png)

plugin可以认为是注册事件的，上图的点是一些事件触发点（实际上的数量多得多），在这些节点可能会触发事件，而plugin可以监听这些事件。

# 四、webpack内部钩子

钩子的本质就是：事件。为了方便我们直接介入和控制编译过程，webpack 把编译过程中触发的各类关键事件封装成事件接口暴露了出来。这些接口被很形象地称做：`hooks`（钩子）。

#### Tapable

`Tapable` 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。webpack 中目前有十种 `hooks`，在 `Tapable` 源码中可以看到，他们是：

```js
js 体验AI代码助手 代码解读复制代码    // https://github.com/webpack/tapable/blob/master/lib/index.js
    exports.SyncHook = require("./SyncHook");
    exports.SyncBailHook = require("./SyncBailHook");
    exports.SyncWaterfallHook = require("./SyncWaterfallHook");
    exports.SyncLoopHook = require("./SyncLoopHook");
    exports.AsyncParallelHook = require("./AsyncParallelHook");
    exports.AsyncParallelBailHook = require("./AsyncParallelBailHook");
    exports.AsyncSeriesHook = require("./AsyncSeriesHook");
    exports.AsyncSeriesBailHook = require("./AsyncSeriesBailHook");
    exports.AsyncSeriesLoopHook = require("./AsyncSeriesLoopHook");
    exports.AsyncSeriesWaterfallHook = require("./AsyncSeriesWaterfallHook");
    exports.HookMap = require("./HookMap");
    exports.MultiHook = require("./MultiHook");
```

`Tapable` 还统一暴露了三个方法给插件，用于注入不同类型的自定义构建行为：

- `tap`：可以注册同步钩子和异步钩子。
- `tapAsync`：回调方式注册异步钩子。
- `tapPromise`：Promise 方式注册异步钩子。

# 五、Plugin 构建对象

## Compiler

**compiler 对象中保存着完整的 Webpack 环境配置，每次启动 webpack 构建时它都是一个独一无二，仅仅会创建一次的对象。**

这个对象会在首次启动 Webpack 时创建，我们可以通过 compiler 对象上访问到 Webapck 的主环境配置，比如 loader 、 plugin 等等配置信息。

> compiler 你可以认为它是一个单例，每次启动 webpack 构建时它都是一个独一无二，仅仅会创建一次的对象。

它有以下主要属性：

- `compiler.options` 可以访问本次启动 webpack 时候所有的配置文件，包括但不限于 loaders 、 entry 、 output 、 plugin 等等完整配置信息。

- `compiler.inputFileSystem` 和 `compiler.outputFileSystem` 可以进行文件操作，相当于 Nodejs 中 fs。

  - 如果我们希望自定义插件的一些输入输出行为能够跟 webpack 尽量同步，那么最好使用 compiler 提供的这两个变量。
  - 需要额外注意的是当 compiler 对象运行在 watch 模式通常是 devServer 下，outputFileSystem 会被重写成内存输出对象，换句话来说也就是在 watch 模式下 webpack 构建并非生成真正的文件而是保存在了内存中。

  > 如果你的插件对于文件操作存在对应的逻辑，那么接下里请使用 compiler.inputFileSystem/outputFileSystem 更换掉代码中的 fs 吧。

- `compiler.hooks` 可以注册 tapable 的不同种类 Hook，从而可以在 compiler 生命周期中植入不同的逻辑。 [compiler hooks 文档](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Fcompiler-hooks%2F)

## Compilation

**compilation 对象代表一次资源的构建，compilation 实例能够访问所有的模块和它们的依赖。**

一个 compilation 对象会对构建依赖图中所有模块，进行编译。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)。

**在 compilation 对象中我们可以获取/操作本次编译当前模块资源、编译生成资源、变化的文件以及被跟踪的状态信息，同样 compilation 也基于 tapable 拓展了不同时机的 Hook 回调。**

> 简单来说比如在 devServer 下每次修改代码都会进行重新编译，此时你可以理解为每次构建都会创建一个新的 compilation 对象。

它有以下主要属性：

- `compilation.modules` 它的值是一个 Set 类型，关于 modules 。简单来说你可以认为一个文件就是一个模块，无论你使用 ESM 还是 Commonjs 编写你的文件。每一个文件都可以被理解成为一个独立的 module。

- `compilation.chunks` 所谓 chunk 即是多个 modules 组成而来的一个代码块，当 Webapck 进行打包时会首先根据项目入口文件分析对应的依赖关系，将入口依赖的多个 modules 组合成为一个大的对象，这个对象即可被称为 chunk 。通过代码分割的模块又是另外的 chunk。

- `compilation.assets` 可以访问本次打包生成所有文件的结果。

- `compilation.hooks` 同样在 compilation 对象中基于 tapable 提供给一系列的 Hook ，用于在 compilation 编译模块阶段进行逻辑添加以及修改。 [compilation hooks 文档](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Fcompilation-hooks%2F)

- > 在 Webpack 5 之后提供了一系列 compilation API 替代直接操作 moduels/chunks/assets 等属性，从而提供给开发者来操作对应 API 影响打包结果。

  具体你可以在[这里查看到](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompilation-object%2F)，比如一些常见的输出文件工作，现在使用 compilation.emitAsset API 来替代直接操作 compilation.assets 对象。

## 生命周期简图

![webpack71](..\images\webpack71.png)

# 六、plugins的结构

plugin的**本质**是一个带有apply方法的对象，apply方法会在该plugin被使用时调用，具体是什么时候呢？

apply的参数compiler（编译器）是一个对象：

- compiler对象是在初始化阶段构建的
- 整个webpack打包期间只有一个compiler对象
- 后续完成打包工作的是compiler对象内部创建的compilation

![webpack72](..\images\webpack72.png)

可以看到，当文件发生变化时，是从编译重新开始的，需要重新创建compilation，但不需要重新创建compiler。

apply方法会在初始化阶段**创建好compiler对象后调用**，并向方法传入一个compiler对象。

这样来看，apply方法只调用一次，但既然plugins能监听各种事件，是怎么监听的呢？

其实，apply方法是用来注册事件的：

```js
class MyPlugin{
    // 
    apply(compiler){ 
        compiler.hooks.事件名称.事件类型(name, function(compilation){
            //事件处理函数
        })
    }
}
```

compiler对象提供了大量的钩子函数: [Compiler Hooks | webpack](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F)

# 七、编写plugin

我们先来看这样一个最简单的插件，它会在 compilation（编译）完成时执行输出 done :

```js
    /*
      1. webpack加载webpack.config.js中所有配置，此时就会new DonePlugin(), 执行插件的constructor
      2. webpack创建compiler对象
      3. 遍历所有plugins中插件，调用插件的apply方法
      4. 执行剩下编译流程（触发各个hooks事件）
    */
class DonePlugin {
  apply(compiler) {
    // 调用 Compiler Hook 注册额外逻辑
    compiler.hooks.done.tap('Plugin Done', () => {
      console.log('compilation done');
    });
  }
}

module.exports = DonePlugin;
```

此时，在 compilation 完成时打包终端会打印出来一行 `compilation done`。

我们可以看到一个 Webpack Plugin 主要由以下几个方面组成:

- 首先一个 Plugin 应该是一个 class，当然也可以是一个函数。
- 其次 Plugin 的原型对象上应该存在一个 apply 方法，当 webpack 创建 compiler 对象时会调用各个插件实例上的 apply 方法并且传入 compiler 对象作为参数。
- 同时需要指定一个绑定在 compiler 对象上的 Hook ， 比如 compiler.hooks.done.tap 在传入的 compiler 对象上监听 done 事件。
- 在 Hook 的回调中处理插件自身的逻辑，这里我们简单的做了 console.log。
- 根据 Hook 的种类，在完成逻辑后通知 webpack 继续进行。

## 一些plugin的练习

#### BannerWebpackPlugin

作用：给打包输出文件添加注释。

开发思路:

- 需要打包输出前添加注释：需要使用 `compiler.hooks.emit` 钩子, 它是打包输出前触发。
- 如何获取打包输出的资源？`compilation.assets` 可以获取所有即将输出的资源文件。 ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/953a2883193d4c4d93c427b4b795d289~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) plugin的实现

```js
 class BannerWebpackPlugin {
      // 插件中传递的配置会放在构造函数中作为参数
      constructor(options = {}) {
        this.options = options;
      }

      apply(compiler) {
        // 在资源输出之前触发
        compiler.hooks.emit.tap("BannerWebpackPlugin", (compilation) => {
          // debugger;
          const extensions = ["css", "js"];
          // 1. 获取即将输出的资源文件：compilation.assets
          // 2. 过滤只保留js和css资源
          const assets = Object.keys(compilation.assets).filter((assetPath) => {
            // 将文件名切割 ['xxxx', 'js'] ['xxxx', 'css']
            const splitted = assetPath.split(".");
            // 获取最后一个文件扩展名
            const extension = splitted[splitted.length - 1];
            // 判断是否保护
            return extensions.includes(extension);
          });

          const prefix = `/*
            * Author: ${this.options.author}
            */
            `;
          // 3. 遍历剩下资源添加上注释
          // console.log(assets);
          assets.forEach((asset) => {
            // 获取原来内容
            const source = compilation.assets[asset].source();
            // 拼接上注释
            const content = prefix + source;

            // 修改资源
            compilation.assets[asset] = {
              // 最终资源输出时，调用source方法，source方法的返回值就是资源的具体内容
              source() {
                return content;
              },
              // 资源大小
              size() {
                return content.length;
              },
            };
          });
        });
      }
    }

    module.exports = BannerWebpackPlugin;
```

#### CleanWebpackPlugin

作用：在 webpack 打包输出前将上次打包内容清空。

开发思路：

- 如何在打包输出前执行？
  - 需要使用 `compiler.hooks.emit` 钩子, 它是打包输出前触发。
- 如何清空上次打包内容？
  - 获取打包输出目录：通过 compiler 对象。
  - 通过文件操作清空内容：通过 `compiler.outputFileSystem` 操作文件。 plugin的实现

```js
 class CleanWebpackPlugin {
      apply(compiler) {
        // 2. 获取打包输出的目录
        const outputPath = compiler.options.output.path;
        const fs = compiler.outputFileSystem;
        // 1. 注册钩子：在打包输出之前 emit
        compiler.hooks.emit.tap("CleanWebpackPlugin", (compilation) => {
          // 3. 通过fs删除打包输出的目录下的所有文件
          this.removeFiles(fs, outputPath);
        });
      }

      removeFiles(fs, filepath) {
        // 想要删除打包输出目录下所有资源，需要先将目录下的资源删除，才能删除这个目录
        // 1. 读取当前目录下所有资源
        const files = fs.readdirSync(filepath);
        // console.log(files); // [ 'images', 'index.html', 'js' ]
        // 2. 遍历一个个删除
        files.forEach((file) => {
          // 2.1 遍历所有文件，判断是文件夹还是文件
          const path = `${filepath}/${file}`;
          const fileStat = fs.statSync(path);
          // console.log(fileStat);
          if (fileStat.isDirectory()) {
            // 2.2 是文件夹，就得删除下面所有文件，才能删除文件夹
            this.removeFiles(fs, path);
          } else {
            // 2.3 是文件，直接删除
            fs.unlinkSync(path);
          }
        });
      }
    }

    module.exports = CleanWebpackPlugin;
```

#### AnalyzeWebpackPlugin

作用：分析 webpack 打包资源大小，并输出分析文件。

开发思路:

- `compiler.hooks.emit`, 它是在打包输出前触发，我们需要分析资源大小同时添加上分析后的 md 文件。

plugin实现

```js
class AnalyzeWebpackPlugin {
      apply(compiler) {
        compiler.hooks.emit.tap("AnalyzeWebpackPlugin", (compilation) => {
          // 1. 遍历所有即将输出文件，得到其大小
          /*
            将对象变成一个二维数组：
              对象：
                {
                  key1: value1,
                  key2: value2 
                }
              二维数组：
                [
                  [key1, value1],
                  [key2, value2]
                ]
          */
          const assets = Object.entries(compilation.assets);

          /*
              md中表格语法：
                | 资源名称 | 资源大小 |
                | --- | --- |
                | xxx.js | 10kb |
          */
          let content = `| 资源名称 | 资源大小 |
    | --- | --- |`;

          assets.forEach(([filename, file]) => {
            content += `\n| ${filename} | ${Math.ceil(file.size() / 1024)}kb |`;
          });

          // 2. 生成一个md文件
          compilation.assets["analyze.md"] = {
            source() {
              return content;
            },
            size() {
              return content.length;
            },
          };
        });
      }
    }

    module.exports = AnalyzeWebpackPlugin;
```

#### InlineChunkWebpackPlugin

作用：webpack 打包生成的 runtime 文件太小了，额外发送请求性能不好，所以需要将其内联到 js 中，从而减少请求数量。

开发思路:

- 我们需要借助 `html-webpack-plugin` 来实现
  - 在 `html-webpack-plugin` 输出 index.html 前将内联 runtime 注入进去
  - 删除多余的 runtime 文件
- 如何操作 `html-webpack-plugin`？[官方文档](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjantimon%2Fhtml-webpack-plugin%2F%23afteremit-hook)

```js
const HtmlWebpackPlugin = require("safe-require")("html-webpack-plugin");

    class InlineChunkWebpackPlugin {
      constructor(tests) {
        this.tests = tests;
      }

      apply(compiler) {
        compiler.hooks.compilation.tap("InlineChunkWebpackPlugin", (compilation) => {
          // 1. 获取html-webpack-plugin的hooks
          const hooks = HtmlWebpackPlugin.getHooks(compilation);
          // 2. 注册 html-webpack-plugin的hooks -> alterAssetTagGroups
          hooks.alterAssetTagGroups.tap("InlineChunkWebpackPlugin", (assets) => {
            // 3. 从里面将script的runtime文件，变成inline script
            assets.headTags = this.getInlineChunk(assets.headTags, compilation.assets);
            assets.bodyTags = this.getInlineChunk(assets.bodyTags, compilation.assets);
          });

          // 删除runtime文件
          hooks.afterEmit.tap("InlineChunkWebpackPlugin", () => {
            // 3. 从里面将script的runtime文件，变成inline script
            Object.keys(compilation.assets).forEach((filepath) => {
              if (this.tests.some((test) => test.test(filepath))) {
                delete compilation.assets[filepath];
              }
            });
          });
        });
      }

      getInlineChunk(tags, assets) {
        /*
          目前：[
            {
              tagName: 'script',
              voidTag: false,
              meta: { plugin: 'html-webpack-plugin' },
              attributes: { defer: true, type: undefined, src: 'js/runtime~main.js.js' }
            },
          ]

          修改为：
            [
              {
                tagName: 'script',
                innerHTML: runtime文件的内容
                closeTag: true 
              },
            ]
        */

        return tags.map((tag) => {
          if (tag.tagName !== "script") return tag;
          // 获取文件资源路径
          const filepath = tag.attributes.src;
          if (!filepath) return tag;

          if (!this.tests.some((test) => test.test(filepath))) return tag;

          return {
            tagName: "script",
            innerHTML: assets[filepath].source(),
            closeTag: true,
          };
        });
      }
    }

    module.exports = InlineChunkWebpackPlugin;
```

# 八、常见的plugin及作用

-`define-plugin`: 定义环境变量（webpack4之后可以通过指定`mode：production/development`实现同样效果）

-`web-webpack-plugin`：为单页面应用输出HTML 性能优于`html-webpack-plugin`

-`clean-webpack-plugin`: 每次打包时删除上次打包的产物, 保证打包目录下的文件都是最新的

-`webpack-merge`： 用来合并公共配置文件,常用（例如分别配置`webpack.common.config.js/ webpack.dev.config.js/webpack.production.config.js`并将其合并）

-`ignore-plugin`: 忽略指定的文件，可以加快构建速度

-`terser-webpack-plugin`：压缩ES6的代码（tree-shaking）

-`uglifyjs-webpack-plugin`: 压缩js代码

-`mini-css-extract-plugin`: 将CSS提取为独立文件，支持按需加载

-`css-minimize-webpack-plugin`：压缩CSS代码

> css文件的压缩需要`mini-css-extract-plugin`和`css-minimize-webpack-plugin `的配合使用 即先使用`mini-css-extract-plugin`将css代码抽离成单独文件，之后使用` css-minimize-webpack-plugin`对css代码进行压缩

-`serviceworker-webpack-plugin`: 为离线应用增加离线缓存功能

-`ModuleconcatenationPlugin`: 开启`Scope Hositing` 用于合并提升作用域， 减小代码体积

-`copy-webpack-plugin`： 在构建的时候，复制静态资源到打包目录。

-`compression-webpack-plugin`: 生产环境采用`gzip`压缩JS和CSS

-`ParalleUglifyPlugin`： 多进程并行压缩js

-`webpack-bundle-analyzer`: 可视化webpack输出文件大小的根据

-`speed-measure-webpack-plugin`: 用于分析各个loader和plugin的耗时，可用于性能分析

-`webpack-dashboard`: 可以更友好地展示打包相关信息

以上便是常见的插件及其作用，接下来讲解我自己使用过的觉得好用的插件/工具

# 九、有没有用过好用的工具/plugin

-`splitChunkPlugin`：用于代码分割

-`webpack-merge`: 提取公共配置，用于分别编写不同环境的配置文件（ `` ）

-`HotModuleReplacementPlugin`:支持模块热替换

-`ignore-plugin`: 忽略指定文件，可以加快构建速度

-`clean-webpack-plugin`: 每次打包时删除上次打包的产物， 保证打包目录下的文件都是最新的

-`speed-measure-webpack-plugin`: 分析出Webpack打包过程中的Loader和Plugin的耗时，用于性能分析

-`mini-css-extract-plugin`: 将CSS代码抽离为独立文件，支持按需加载， 配合 `css-minimize-webpack-plugin`使用

-`terser-webpack-plugin`: 实现更精细的代码压缩功能

-`SourceMapDevtoolPlugin`:精细度配置`SourceMap`， 不能和`devtool`选项同时使用

-`UnusedWebpackPlugin`: 反向查找项目中没被用到的文件，日常工作经常用到，可在重构或者性能分析时使用

-`webpack-dashboard`: [webpack-dashboard](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-dashboard) 是一个命令行可视化工具，能够在编译过程中实时展示编译进度、模块分布、产物信息等相关信息，性能分析时很有用。

-` Webpack Analysis`：[Webpack Analysis](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.github.io%2Fanalyse%2F) 是 webpack 官方提供的可视化分析工具。

-`BundleAnalyzerPlugin`：性能分析插件，可以在运行后查看是否包含重复模块/不必要模块等

