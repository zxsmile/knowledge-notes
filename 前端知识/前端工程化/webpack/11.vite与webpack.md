# 一、定位

前端社区中常谈到的这些工具`webpack`、`rollup`、`parcel`、`esbuild`、`vite`、`vue-cli`、`create-react-app`、`umi`他们之间的关系是怎样的。

- `webpack`、`rollup`、`parcel`、`esbuild`都是打包工具，代码写好之后，我们需要对代码进行`压缩`、`合并`、`转换`、`分割`、`打包`等操作，这些工作需要打包工具去完成。
- `vue-cli`、`create-react-app`、`umi` 是基于`webpack`的上层封装，通过简单的配置就可以快速创建出一个项目，把更多的时间放在业务开发上。
- `vite`开发环境依赖`esbuild`进行预构建，生产环境则依赖`rollup`进行打包，并且充分利用了现代浏览器的特性，比如`http2`、`ES module`，`vite`是站在众多巨人肩膀上的一个产物， 类似`webpack + webpack-dev-server`的结合体，是一个非常棒的前端项目的构建工具。

# 二、`Webpack vs Vite`开发环境运行原理

`Webpack` 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码，这可满满都是 `CPU`、`IO` 操作啊，在 `Node` 运行时下性能必然是有问题。

而 `Vite` 运行 `Dev` 命令后只做了两件事情，一是启动了一个用于承载资源服务的 `service`；二是使用 `esbuild`**预构建** `npm` 依赖包。之后就一直躺着，直到浏览器以 `http` 方式发来 `ESM` 规范的模块请求时，`Vite` 才开始“**「按需编译」**”被请求的模块。

## 1、`Webpack`开发环境运行原理

1、读取`webpack`的配置参数；

2、启动`webpack`，创建`Compiler`对象并开始解析项目；

3、从入口文件（`entry`）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；

4、对不同文件类型的依赖模块文件使用对应的`Loader`进行编译，最终转为`Javascript`文件；

5、根据入口和模块之间的依赖关系，组合成一个个包含多个模块的`Chunk`，再把每个`Chunk`转换成一个单独的文件加入到输出列表。

6、`Webpack`根据配置，确定输出的路径和文件名，把文件内容写入到文件系统，文件内容包括且不限于

- 打包后的 `JavaScript` 文件
- `HTML` 文件
- `CSS` 文件
- 其他资源文件

> 这些文件都是在内存中生成的，目的是为了加快开发过程中的构建和重载速度。这意味着你不会在你的项目目录中看到这些文件，但它们可以通过 `Webpack dev server` 提供的开发服务器访问。这种方式使得开发更加高效，因为内存中的读写速度远快于磁盘。

![webpack158](..\images\webpack158.png)

## 2、`Vite`开发环境运行原理

1. 运行 `Vite` 命令，`Vite` 会启动一个本地开发服务器。这个服务器负责提供静态文件服务、处理 `HTTP` 请求等

2. 当浏览器请求一个页面时，`Vite` 开发服务器会拦截这些请求。对于 `HTML` 页面请求，服务器会处理并返回 `HTML` 内容

   ![webpack159](..\images\webpack159.png)

3. 对于 `JavaScript` 模块的请求，`Vite` 会解析这个模块的依赖关系。如果模块是一个第三方库（位于 `node_modules` 中），`Vite` 会优先检查是否有预构建的缓存，如果没有，会对该库进行预构建并缓存，以提高后续加载速度。

   ![webpack160](..\images\webpack160.png)

4. `Vite` 会按需编译请求的模块。这意味着只有当浏览器实际请求某个模块时，`Vite` 才会编译这个模块
5. `Vite` 支持模块热更新，当源代码发生变化时，`Vite` 会快速重新编译改动的模块，并通过 `WebSocket` 推送更新到浏览器

> 整个流程的核心在于利用现代浏览器支持的 `ES` 模块特性，以及按需编译和模块热更新技术，从而实现快速的开发体验。`Vite` 的这种设计避免了传统前端工具在开发模式下需要打包整个应用的繁琐过程，显著提高了开发效率

![webpack161](..\images\webpack161.png)

## 3、modules 模块

Vite 的实现离不开现代浏览器原生支持的模块功能。如下：

```html
<script type="module">
import { a } from './a.js'
</script>
```

当声明一个 `script` 标签类型为 `module` 时，浏览器将对其内部的 `import` 引用发起 `HTTP` 请求获取模块内容。比如上述，浏览器将发起一个对 `HOST/a.js` 的 HTTP 请求，获取到内容之后再执行。

`Vite` 劫持了这些请求，并在后端进行相应的处理（比如将 `Vue` 文件拆分成 `template`、`style`、`script` 三个部分），然后

```

```

再返回给浏览器。

由于浏览器只会对用到的模块发起 `HTTP` 请求，所以 `Vite` 没必要对项目里所有的文件先打包后返回，而是只编译浏览器发起 `HTTP` 请求的模块即可。这里是不是有点按需加载的味道？

## 4、编译和打包的区别

看到这里，可能有些朋友不免有些疑问，编译和打包有什么区别？为什么 `Vite` 号称「热更新的速度不会随着模块增多而变慢」？

简单举个例子，有三个文件 `a.js`、`b.js`、`c.js`

```js
// a.js
const a = () => { ... }
export { a }

// b.js
const b = () => { ... }
export { b }
```

```
// c.js
import { a } from './a'
import { b } from './b'

const c = () => {
  return a() + b()
}

export { c }
```

如果以 `c` 文件为入口，那么打包就会变成如下（结果进行了简化处理）：（假定打包文件名为 `bundle.js`)

```js
// bundle.js
const a = () => { ... }
const b = () => { ... }
const c = () => {
  return a() + b()
}

export { c }
```

**值得注意的是，打包也需要有编译的步骤。**

`Webpack` 的热更新原理简单来说就是，一旦发生某个依赖（比如上面的 `a.js` ）改变，就将这个依赖所处的 `module` 的更新，并将新的 `module` 发送给浏览器重新执行。由于我们只打了一个 `bundle.js`，所以热更新的话也会重新打这个 `bundle.js`。试想如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢。

而如果是像 Vite 这种只编译不打包会是什么情况呢？

只是编译的话，最终产出的依然是 `a.js`、`b.js`、`c.js` 三个文件，只有编译耗时。由于入口是 `c.js`，浏览器解析到 `import { a } from './a'` 时，会发起 HTTP 请求 `a.js` （b 同理），就算不用打包，也可以加载到所需要的代码，因此省去了合并代码的时间。

在热更新的时候，如果 `a` 发生了改变，只需要更新 `a` 以及用到 `a` 的 `c`。由于 `b` 没有发生改变，所以 Vite 无需重新编译 `b`，可以从缓存中直接拿编译的结果。这样一来，修改一个文件 `a`，只会重新编译这个文件 `a` 以及浏览器当前用到这个文件 `a` 的文件，而其余文件都无需重新编译。所以理论上热更新的速度不会随着文件增加而变慢。

当然这样做有没有不好的地方？有，初始化的时候如果浏览器请求的模块过多，也会带来初始化的性能问题。

## 5、`Vite` 运行 `Web` 应用的实现

上面说了这么多的铺垫，可能还不够直观，我们可以先跑一个 `Vite` 项目来实际看看。

按照官网的说明，可以输入如下命令（`` 为自己想要的目录名即可）

```bash
$ npx create-vite-app <project-name>
$ cd <project-name>
$ npm install
$ npm run dev
```

如果一切都正常你将在 `localhost:3000`（`Vite` 的服务器起的端口） 看到这个界面：

![webpack162](..\images\webpack162.png)

并得到如下的代码结构：

```go
├── App.vue // 页面的主要逻辑
├── index.html // 默认打开的页面以及 Vue 组件挂载
├── node_modules
└── package.json
```

### 拦截 HTTP 请求

接下来开始说一下 Vite 实现的核心——拦截浏览器对模块的请求并返回处理后的结果。

我们知道，由于是在 `localhost:3000` 打开的网页，所以浏览器发起的第一个请求自然是请求 `localhost:3000/`，这个请求发送到 Vite 后端之后经过静态资源服务器的处理，会进而请求到 `/index.html`，此时 Vite 就开始对这个请求做拦截和处理了。

首先，`index.html` 里的源码是这样的：

```html
<div id="app"></div>
<script type="module">
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
</script>
```

但是在浏览器里它是这样的：

![webpack163](..\images\webpack163.png)

注意到什么不同了吗？是的， `import { createApp } from 'vue'` 换成了 `import { createApp } from '/@modules/vue`。

这里就不得不说浏览器对 `import` 的模块发起请求时的一些局限了，平时我们写代码，如果不是引用相对路径的模块，而是引用 `node_modules` 的模块，都是直接 `import xxx from 'xxx'`，由 Webpack 等工具来帮我们找这个模块的具体路径。但是浏览器不知道你项目里有 `node_modules`，它只能通过相对路径去寻找模块。

因此 Vite 在拦截的请求里，对直接引用 `node_modules` 的模块都做了路径的替换，换成了 `/@modules/` 并返回回去。而后浏览器收到后，会发起对 `/@modules/xxx` 的请求，然后被 Vite 再次拦截，并由 Vite 内部去访问真正的模块，并将得到的内容再次做同样的处理后，返回给浏览器。

### `imports` 替换

#### 普通 `JS` `imports` 替换

上面说的这步替换来自 `src/node/serverPluginModuleRewrite.ts`:

```js
// 只取关键代码：
// Vite 使用 Koa 作为内置的服务器
// 如果请求的路径是 /index.html
if (ctx.path === '/index.html') {
  // ...
  const html = await readBody(ctx.body)
  ctx.body = html.replace(
    /(<script\b[^>]*>)([\s\S]*?)<\/script>/gm, // 正则匹配
    (_, openTag, script) => {
      // also inject __DEV__ flag
      const devFlag = hasInjectedDevFlag ? `` : devInjectionCode
      hasInjectedDevFlag = true
       // 替换 html 的 import 路径
      return `${devFlag}${openTag}${rewriteImports(
        script,
        '/index.html',
        resolver
      )}</script>`
    }
  )
  // ...
}
```

如果并没有在 `script` 标签内部直接写 `import`，而是用 `src` 的形式引用的话如下：

```js
<script type="module" src="/main.js"></script>
```

那么就会在浏览器发起对 `main.js` 请求的时候进行处理：

```js
// 只取关键代码：
if (
  ctx.response.is('js') &&
  // ...
) {
  // ...
  const content = await readBody(ctx.body)
  await initLexer
  // 重写 js 文件里的 import
  ctx.body = rewriteImports(
    content,
    ctx.url.replace(/(&|\?)t=\d+/, ''),
    resolver,
    ctx.query.t
  )
  // 写入缓存，之后可以从缓存中直接读取
  rewriteCache.set(content, ctx.body)
}
```

替换逻辑 `rewriteImports` 就不展开了，用的是 `es-module-lexer` 来进行的语法分析获取 `imports` 数组，然后再做的替换。

#### `*.vue` 文件的替换

如果 `import` 的是 `.vue` 文件，将会做更进一步的替换：

原本的 `App.vue` 文件长这样：

```html
<template>
  <h1>Hello Vite + Vue 3!</h1>
  <p>Edit ./App.vue to test hot module replacement (HMR).</p>
  <p>
    <span>Count is: {{ count }}</span>
    <button @click="count++">increment</button>
  </p>
</template>

<script>
export default {
  data: () => ({ count: 0 }),
}
</script>

<style scoped>
h1 {
  color: #4fc08d;
}

h1, p {
  font-family: Arial, Helvetica, sans-serif;
}
</style>
```

替换后长这样：

```js
// localhost:3000/App.vue
import { updateStyle } from "/@hmr"

// 抽出 script 逻辑
const __script = {
  data: () => ({ count: 0 }),
}

// 将 style 拆分成 /App.vue?type=style 请求，由浏览器继续发起请求获取样式
updateStyle("c44b8200-0", "/App.vue?type=style&index=0&t=1588490870523")
__script.__scopeId = "data-v-c44b8200" // 样式的 scopeId

// 将 template 拆分成 /App.vue?type=template 请求，由浏览器继续发起请求获取 render function
import { render as __render } from "/App.vue?type=template&t=1588490870523&t=1588490870523"
__script.render = __render // render 方法挂载，用于 createApp 时渲染
__script.__hmrId = "/App.vue" // 记录 HMR 的 id，用于热更新
__script.__file = "/XXX/web/vite-test/App.vue" // 记录文件的原始的路径，后续热更新能用到
export default __script
```

这样就把原本一个 `.vue` 的文件拆成了三个请求（分别对应 `script`、`style` 和`template`） ，浏览器会先收到包含 `script` 逻辑的 `App.vue` 的响应，然后解析到 `template` 和 `style` 的路径后，会再次发起 `HTTP` 请求来请求对应的资源，此时 `Vite` 对其拦截并再次处理后返回相应的内容。

如下：

![webpack164](..\images\webpack164.png)

这一步的拆分来自 `src/node/serverPluginVue.ts`，核心逻辑是根据 `URL` 的 `query` 参数来做不同的处理（简化分析如下）：

```js
// 如果没有 query 的 type，比如直接请求的 /App.vue
if (!query.type) {
  ctx.type = 'js'
  ctx.body = compileSFCMain(descriptor, filePath, publicPath) // 编译 App.vue，编译成上面说的带有 script 内容，以及 template 和 style 链接的形式。
  return etagCacheCheck(ctx) // ETAG 缓存检测相关逻辑
}

// 如果 query 的 type 是 template，比如 /App.vue?type=template&xxx
if (query.type === 'template') {
  ctx.type = 'js'
  ctx.body = compileSFCTemplate( // 编译 template 生成 render function
    // ...
  )
  return etagCacheCheck(ctx)
}

// 如果 query 的 type 是 style，比如 /App.vue?type=style&xxx
if (query.type === 'style') {
  const index = Number(query.index)
  const styleBlock = descriptor.styles[index]
  const result = await compileSFCStyle( // 编译 style
    // ...
  )
  if (query.module != null) { // 如果是 css module
    ctx.type = 'js'
    ctx.body = `export default ${JSON.stringify(result.modules)}`
  } else { // 正常 css
    ctx.type = 'css'
    ctx.body = result.code
  }
}
```

## @modules/* 路径解析

上面只涉及到了替换的逻辑，解析的逻辑来自 `src/node/serverPluginModuleResolve.ts`。这一步就相对简单了，核心逻辑就是去 `node_modules` 里找有没有对应的模块，有的话就返回，没有的话就报 404：（省略了很多逻辑，比如对 `web_modules` 的处理、缓存的处理等）

```js
// ...
try {
  const file = resolve(root, id) // id 是模块的名字，比如 axios
  return serve(id, file, 'node_modules') // 从 node_modules 中找到真正的模块内容并返回
} catch (e) {
  console.error(
    chalk.red(`[vite] Error while resolving node_modules with id "${id}":`)
  )
  console.error(e)
  ctx.status = 404 // 如果没找到就 404
}
```

## 6、依赖预构建

什么是依赖预构建？

`vite`将代码分为两部分：

- 依赖：例如`react`、`antd`，纯`JS`在开发中不会变动的部分
- 源码：业务代码，非纯`JS`代码（需要转换`JSX/LESS`）并不是所有都需要被加载，开发时经常变化

在首次启动 `Vite` 时，会使用 `Esbuild` 将依赖重新构建一遍并缓存在 `node_modules`。

### 目的

- 浏览器不支持的 `CommonJS` 或 `UMD` 的依赖项转换成 `ESM` 
- 有许多内部模块的 `ESM`  依赖关系转换为单个模块，保证一个依赖最多对应一个 `http` 请求，提高后续加载性能
- 构建的依赖缓存到 `node_modules/.vite`，解析后的依赖会设置 `HTTP` 头 `max-age=31536000,immutable`进行强缓存

![webpack173](..\images\webpack173.png)

### 依赖处理

`Vite` 通过在一开始将应用中的模块区分为 `依赖` 和 `源码` 两类，改进了开发服务器启动时间。依赖 大多为在开发时不会变动的纯 `JavaScript`。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高

![webpack174](..\images\webpack174.png)

可以观察到浏览器请求 `vue.js` 时，被认为是一个 `node_modules` 模块。

平时开发中，`webpack` & `rollup`(`rollup`有对应插件) 等打包工具会帮我们找到模块的路径。

但**浏览器只能通过相对路径去寻找**，若直接使用模块名比如：`import vue from 'vue'`，浏览器就会报错，这个时候就需要一个三方包进行处理。

`Vite` 对 `ESM` 形式的 `js` 文件模块使用了 `ES Module Lexer` 处理。**`Lexer` 会找到代码中以 `import` 语法导入的模块并以数组形式返回**。`Vite` 通过该数组的值获取判断是否为一个 `node_modules` 模块。若是则进行对应改写成 `@modules/:id` 的写法。

重写完路径后，浏览器会发送 `path` 为 `/@modules/:id` 的对应请求，接下来会被 `Vite` 客户端做一层拦截来解析模块的真实位置。

### 依赖预构建

当我们首次启动 `Vite` ，会注意到打印出了以下信息

![webpack175](..\images\webpack175.png)

这个过程就是 `Vite` 的预构建，接下来我们对整个流程进行分析和学习。

### 为什么要进行预构建

`Vite`使用`esbuild`在初次启动开发服务器前把检测到的依赖进行预构建。`Vite` 基于`ESM`，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。

以 `lodash-es` 为例，代码中以 `import { debounce } from 'lodash'` 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。

![webpack165](..\images\webpack165.png)

可以看到一共发送了`651`个请求。一共花费`1.53s`。

`Vite` 为了优化这个情况，利用`esbuild`在启动的时候预先把 `debounce` 用到的所有内部模块全部打包成一个 `bundle`，这样就浏览器在请求 `debounce` 时，便只需要发送一次请求了。预构建后，只发送了14个请求。所以预构建的优势可想而知。

官网

- **兼容其他模块发规范**：开发阶段，`Vite` 的开发服务器将所有代码视为**原生 `ES` 模块**。因此，`Vite` 必须先将作为 `CommonJS` 或 `UMD` 发布的依赖项转换为 `ESM`。
- **性能优化** :  `Vite` 将有许多内部模块的 `ESM` 依赖关系转换为单个模块，以提高后续页面加载性能。

解读

原因：简单来讲就是为了提高本地开发服务器的冷启动速度。按照`Vite` 的说法，当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。随着应用规模的增大，打包速度显著下降，本地服务器的启动速度也跟着变慢。

解决方式：为了加快本地开发服务器的启动速度，`Vite` 引入了预构建机制。在预构建工具的选择上，`Vite` 选择了 `Esbuild` 。`Esbuild` 使用 `Go` 编写，比以 `JavaScript` 编写的打包器构建速度快 10-100倍，有了预构建，再利用浏览器的`esm`方式按需加载业务代码，动态实时进行构建，结合缓存机制，大大提升了服务器的启动速度。

### 预构建流程

#### 第一步 查找依赖

**如果是首次启动本地服务**，那么`vite`会自动抓取源代码，从代码中找到需要预构建的依赖

- 调用 `Esbuild` 的 `Build Api` ，以`index.html`作为查找入口（`entryPoints`），将所有的来自`node_modules`以及在配置文件的`optimizeDeps.include`选项中指定的模块找出来

如果**不是首次启动**

- 首先会去查找缓存目录（默认是 `node_modules/.vite`）下的 `_metadata.json` 文件；然后找到当前项目依赖信息（`xxx-lock` 文件）拼接上部分配置后做哈希编码，最后对比缓存目录下的 `hash` 值是否与编码后的 `hash` 值一致，一致并且没有开启 `force` 就直接返回预构建信息，结束整个流程；

#### 第二步 对查找到的依赖进行构建

- 已经得到了需要预构建的依赖列表。现在需要把他们作为 `Esbuild` 的 `entryPoints` 打包就行了。
- `vite` 并没有将 `Esbuild` 的 `outdir`（构建产物的输出目录）直接配置为`.vite`目录，而是先将构建产物存放到了一个临时目录。当构建完成后，才将原来旧的`.vite`（如果有的话）删除。然后再将临时目录重命名为`.vite`。这样做主要是为了避免在程序运行过程中发生了错误，导致缓存不可用。

### 预构建的缓存策略

`vite` 冷启动之所以快，除了`esbuild`本身构建速度够快外，也与`vite` 做了必要的缓存机制密不可分。

#### 文件系统缓存

![webpack166](..\images\webpack166.png)

`vite` 会将预构建的依赖缓存到 `node_modules/.vite`。它根据几个源来决定是否需要重新运行预构建步骤:

- `package.json` 中的 `dependencies` 列表
- 包管理器的 `lockfile`，例如 `package-lock.json`,`yarn.lock`，或者 `pnpm-lock.yaml`
- 可能在 `vite.config.js` 相关字段中配置过的

只有在上述其中一项发生更改时，才需要重新运行预构建。

如果出于某些原因，你想要强制 `vite` 重新构建依赖，你可以用 `--force` 命令行选项启动开发服务器，或者手动删除 `node_modules/.vite` 目录。

#### 浏览器缓存

![webpack167](..\images\webpack167.png)

意味着这些依赖的过期时间是（即为`max-age`所能设置的最大值）：一年

解析后的依赖请求会以 `HTTP` 头 `max-age=31536000,immutable` 强缓存，以提高在开发时的页面重载性能。一旦被缓存，这些请求将永远不会再到达开发服务器。如果安装了不同的版本（这反映在包管理器的 `lockfile` 中），则附加的版本 `query` 会自动使它们失效。

#### 总结

先查找需要预构建的依赖，然后将这些依赖作为`entryPoints`进行构建，构建完成后更新缓存。`vite` 在启动时为提升速度，会检查缓存是否有效，有效的话就可以跳过预构建环节，缓存是否有效的判定是对比缓存中的`hash`值与当前的`hash`值是否相同。由于hash的生成算法是基于`vite` 配置文件和项目依赖的，所以配置文件和依赖的的变化都会导致`hash`发生变化，从而重新进行预构建。

### 静态资源加载

当请求的路径符合 `imageRE`, `mediaRE`, `fontsRE` 或 `JSON` 格式，会被认为是一个静态资源。静态资源将处理成`ESM`模块返回。

```TS
// src/node/utils/pathUtils.ts
const imageRE = /\.(png|jpe?g|gif|svg|ico|webp)(\?.*)?$/
const mediaRE = /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/
const fontsRE = /\.(woff2?|eot|ttf|otf)(\?.*)?$/i
export const isStaticAsset = (file: string) => {
  return imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file)
}

// src/node/server/serverPluginAssets.ts
app.use(async (ctx, next) => {
  if (isStaticAsset(ctx.path) && isImportRequest(ctx)) {
    ctx.type = 'js'
    ctx.body = export default ${JSON.stringify(ctx.path)} // 输出是path
    return
  }
  return next()
})

export const jsonPlugin: ServerPlugin = ({ app }) => {
  app.use(async (ctx, next) => {
    await next()
    // handle .json imports
    // note ctx.body could be null if upstream set status to 304
    if (ctx.path.endsWith('.json') && isImportRequest(ctx) && ctx.body) {
      ctx.type = 'js'
      ctx.body = dataToEsm(JSON.parse((await readBody(ctx.body))!), {
        namedExports: true,
        preferConst: true
      })
    }
  })
}
```

### `js/ts`处理

`Vite`使用 `esbuild` 将 `ts` 转译到 `js`，约是**`tsc`速度的20～30倍**，同时`HMR`更新反应到浏览器的时间会小于`50ms`。但是，由于`esbuild`转换ts到`js`对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用`tsc --noEmit`。 将`ts`转换成`js`后，浏览器便可以利用ESM直接拿到`js`资源。

## 7、`Vite Hmr`

提及「`HMR`」，不可避免地是会想起现在我们家喻户晓的 `webpack-dev-server` 中的「`HMR`」。而在 `webpack-dev-server` 中实现「`HMR`」的核心就是 **`HotModuleReplacementPlugin`** ，它是「`Webpack`」内置的「`Plugin`」。在我们平常开发中，之所以改一个文件，例如 `.vue` 文件，会触发「`HMR`」，是因为在 `vue-loader` 中已经内置了使用 `HotModuleReplacementPlugin` 的逻辑。

### 整体流程

`Vite` 的热加载原理，其实就是在客户端与服务端建立了一个 `websocket` 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。

- 服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 `websocket` 信息通知客户端去请求新的模块代码。
- 客户端：`Vite` 中客户端的 `websocket` 相关代码在处理 `html` 中时被写入代码中。可以看到在处理 `html` 时，`vite/client` 的相关代码已经被插入。

**简而言之，`Vite`  在启动之前会创建一个为热更新服务定制的 `websocket` 服务器，然后对项目文件进行监听。同时客户端的 `html` 里注入了 `@vite/client` 来与服务端进行配合实现热更新。**

![webpack168](..\images\webpack168.png)

### `HMR API`

```TS
interface ImportMeta {
  readonly hot?: {
    readonly data: any

    accept(): void
    accept(cb: (mod: any) => void): void
    accept(dep: string, cb: (mod: any) => void): void
    accept(deps: string[], cb: (mods: any[]) => void): void

    prune(cb: () => void): void
    dispose(cb: (data: any) => void): void
    decline(): void
    invalidate(): void

    on(event: string, cb: (...args: any[]) => void): void
  }
}
```

其中一个重点 （大家一起理解一下这里，后面会存在计算 `HMR` 边界）

- **`hot.accept(cb)`** 要接收模块自身，应使用 `import.meta.hot.accept`，参数为接收已更新模块的回调函数：

```JS
export const count = 1

if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    console.log('updated: count is now ', newModule.count)
  })
}
```

**“接受” 热更新的模块被认为是 `HMR` 边界**

请注意，`Vite` 的 `HMR`实际上并不替换最初导入的模块：如果 `HMR`边界模块从某个依赖重新导出其导入，则它应负责更新这些重新导出的模块（这些导出必须使用 `let`）。此外，从边界模块向上的导入者将不会收到更新。

### `Vite Hmr Server`

#### 监听变化 触发`HMR`

当文件修改后，会触发文件监听实例 `watcher` 回调

##### 监听文件变更类型

```JS
// 文件改变时触发事件
watcher.on('change', async (file) => {
  // 规范化文件路径，将\\替换成/
  file = normalizePath(file)
  // ...
})

// 添加文件事件
watcher.on('add', (file) => {
  handleFileAddUnlink(normalizePath(file), server)
})

// 删除文件事件
watcher.on('unlink', (file) => {
  handleFileAddUnlink(normalizePath(file), server, true)
})
```

回调中拿到文件路径 file 会进行 `normalizePath`，他的作用是规范化文件路径，将 `\\` 替换成 `/`

假设我们对文件进行修改 `change`, 下面的代码逻辑是这样的

```JS
// 文件改变时触发事件
watcher.on('change', async (file) => {
  // 规范化文件路径，将\\替换成/
  file = normalizePath(file)
  if (file.endsWith('/package.json')) {
    return invalidatePackageData(packageCache, file)
  }
  // invalidate module graph cache on file change
  moduleGraph.onFileChange(file)
  if (serverConfig.hmr !== false) {
    try {
      await handleHMRUpdate(file, server)
    } catch (err) {
      ws.send({
        type: 'error',
        err: prepareError(err)
      })
    }
  }
})
```

这里我们看到了 `onFileChange` 以及 `handleHMRUpdate`

##### `onFileChange`

```JS
onFileChange(file: string): void {
  // 根据文件获取模块信息
  const mods = this.getModulesByFile(file)
  if (mods) {
    const seen = new Set<ModuleNode>()
    mods.forEach((mod) => {
      this.invalidateModule(mod, seen)
    })
  }
}

// 处理模块
invalidateModule(mod: ModuleNode, seen: Set<ModuleNode> = new Set()): void {
  mod.info = undefined
  mod.transformResult = null
  mod.ssrTransformResult = null
  // ...
}
```

其实看到这里很纳闷，为什么要将改变的模块里面的状态都设置为 `null` ，思考了好久，直到看到一行注释

![webpack169](..\images\webpack169.png)

原来，他是想将改变的模块进行初始化的意思，然后再去走热更新流程。

#### 开始热更新

更新模块信息和计算 `HMR` 边界 

##### `handleHMRUpdate`

```JS
export async function handleHMRUpdate(
  file: string,
  server: ViteDevServer
): Promise<any> {
  const { ws, config, moduleGraph } = server
  
  const shortFile = getShortName(file, config.root)

  // 配置文件修改，比如 vite.config.ts
  const isConfig = file === config.configFile
  // 配置文件的依赖
  const isConfigDependency = config.configFileDependencies.some(
    (name) => file === path.resolve(name)
  )
  // 环境变量文件
  const isEnv =
    config.inlineConfig.envFile !== false &&
    (file === '.env' || file.startsWith('.env.'))

  // 如果是配置文件修改了，直接重启服务
  if (isConfig || isConfigDependency || isEnv) {
    // auto restart server
    try {
      await server.restart()
    } catch (e) {
      config.logger.error(colors.red(e))
    }
    return
  }

  // vite 的 client 修改了，全量刷新 -> 刷新页面
  if (file.startsWith(normalizedClientDir)) {
    ws.send({
      type: 'full-reload',
      path: '*'
    })
    return
  }

  // 获取文件关联的模块
  const mods = moduleGraph.getModulesByFile(file)

  // check if any plugin wants to perform custom HMR handling
  const timestamp = Date.now()
  // 热更上下文
  const hmrContext: HmrContext = {
    // 文件
    file,
    // 时间戳
    timestamp,
    // 受更改文件影响的模块数组
    modules: mods ? [...mods] : [],
    // 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发
    // 并 fs.readFile 直接会返回空内容。传入的 read 函数规范了这种行为。
    read: () => readModifiedFile(file),
    // 整个服务对象
    server
  }

  // 遍历插件，调用 handleHotUpdate 钩子
  for (const plugin of config.plugins) {
    if (plugin.handleHotUpdate) {
      const filteredModules = await plugin.handleHotUpdate(hmrContext)

      // 受更改文件影响的模块数组
      if (filteredModules) {
        hmrContext.modules = filteredModules
      }
    }
  }

  // 文件修改没有影响其他模块
  if (!hmrContext.modules.length) {
    // 是 html 的话，直接刷新页面
    if (file.endsWith('.html')) {
      ws.send({
        type: 'full-reload',
        path: config.server.middlewareMode
          ? '*'
          : '/' + normalizePath(path.relative(config.root, file))
      })
    }
    return
  }

  // 核心，执行模块更新
  updateModules(shortFile, hmrContext.modules, timestamp, server)
}
```

`handleHMRUpdate` 主要处理了：

- **如果修改的是 `vite.config.ts` 或它的依赖文件，亦或者是环境变量的定义文件，都直接重启服务；**
- **如果修改的是 `vite` 自带的 `client` 脚本，就刷新页面；**
- **如果上述两种情况都不是，就定义 `hmrContext` 对象， 定义包含了 `file` 当前文件路径、`timestamp` 当前时间戳、`modules` 文件映射的模块、`read` 函数读取该文件内容、`server` 整个服务器对象；有了 `hmrContext`之后，依次调用插件的 `handleHotUpdate` 钩子，钩子可以返回热更需要关联的模块，具体可以查看官方 `HMR API` 。如果没有关联的模块，并且修改的是 `html` 文件，发送 `full-reload` 进行页面刷新；前面几个条件都不满足的话，就调用 `updateModules` 。**

##### `updateModules`

`updateModules`，`propagateUpdate` 的源码就不在这里展示了，我们只看其作用：

`updateModules` 会遍历 `modules`，调用 `invalidate` 更新模块和引用者（`importers`）的信息，声明 `HMR` 边界（“接受” 热更新的模块），调用 `propagateUpdate` 判断模块之前是否存在“死路”，如果存在“死路”就直接发起 `full-reload` 命令刷新页面，否则发起 `update` 命令执行指定模块（`updates`）的更新。

#### `Vite Hmr Server` 运行流程

![webpack170](..\images\webpack170.png)

### `Vite Hmr Client`

![webpack171](..\images\webpack171.png)

引入 `@vite/client` 脚本后，会初始化 `websocket` 连接，收到数据时会触发 `handleMessage` 事件。

我们只对其中 `update` 处理逻辑做个介绍

```JS
case 'update':
  notifyListeners('vite:beforeUpdate', payload)

  if (isFirstUpdate && hasErrorOverlay()) {
    window.location.reload()
    return
  } else {
    clearErrorOverlay()
    isFirstUpdate = false
  }
  payload.updates.forEach((update) => {
    // 以 js  文件更新举例
    if (update.type === 'js-update') {
      queueUpdate(fetchUpdate(update))
    } else {
      //...
    }
  })
  break
```

我们着重去分析一个 `fetchUpdate` 这个方法

```TS
async function fetchUpdate({ path, acceptedPath, timestamp }: Update) {
  const mod = hotModulesMap.get(path)
  if (!mod) {
    return
  }

  const moduleMap = new Map()
  const isSelfUpdate = path === acceptedPath

  // make sure we only import each dep once
  const modulesToUpdate = new Set<string>()
  if (isSelfUpdate) {
    // self update - only update self
    modulesToUpdate.add(path)
  } else {
    // dep update
    for (const { deps } of mod.callbacks) {
      deps.forEach((dep) => {
        if (acceptedPath === dep) {
          modulesToUpdate.add(dep)
        }
      })
    }
  }

  // determine the qualified callbacks before we re-import the modules
  const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => {
    return deps.some((dep) => modulesToUpdate.has(dep))
  })

  await Promise.all(
    Array.from(modulesToUpdate).map(async (dep) => {
      const disposer = disposeMap.get(dep)
      if (disposer) await disposer(dataMap.get(dep))
      const [path, query] = dep.split(`?`)
      try {
        const newMod = await import(
          /* @vite-ignore */
          base +
            path.slice(1) +
            `?import&t=${timestamp}${query ? `&${query}` : ''}`
        )
        moduleMap.set(dep, newMod)
      } catch (e) {
        warnFailedFetch(e, dep)
      }
    })
  )

  return () => {
    for (const { deps, fn } of qualifiedCallbacks) {
      fn(deps.map((dep) => moduleMap.get(dep)))
    }
    const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`
    console.log(`[vite] hot updated: ${loggedPath}`)
  }
}
```

解读：根据 `path` 从 `hotModulesMap` 中获取模块信息，如果模块不存在就直接终止，存在则判断是否“自我接受”，是的话就把自己加入到待更新集合，否则就去遍历全部 `deps` 加入到更新集合并重新获取回调函数。之后遍历待更新队列 `modulesToUpdate`，如果模块有 `dispose` 函数的定义就清除副作用。再就是来到最核心的地方，通过动态 `import` 去加载最新的资源并更新模块信息，保证最后的回调拿到的模块是最新的。

![webpack172](..\images\webpack172.png)

从上图可以看到，每次修改文件都会用最新的时间戳去请求资源。`fetchUpdate` 最后返回一个函数，通过 `queueUpdate` 保证回调函数的执行顺序跟 `http` 请求的一致。

```JS
let pending = false
let queued: Promise<(() => void) | undefined>[] = []

async function queueUpdate(p: Promise<(() => void) | undefined>) {
  // 先将全部回调函数推到 queued
  queued.push(p)
  if (!pending) {
    pending = true
    await Promise.resolve()
    pending = false
    const loading = [...queued]
    queued = []
    ;(await Promise.all(loading)).forEach((fn) => fn && fn())
  }
}
```

至此，`Vite Hmr` 实现流程圆满结束！

# 三、为什么要用 Vite ?

通过上文几个特性的介绍，大姐应该最先脱口而出的一点，那就是极致的开发反应速度（从启动到调试）

| `Webpack`                               | `Vite`                                                       |
| --------------------------------------- | ------------------------------------------------------------ |
| 先打包生成`bundle`，再启动开发服务器    | 先启动开发服务器，利用新一代浏览器的`ESM`能力，无需打包，直接请求所需模块并实时编译 |
| `HMR`时需要把改动模块及相关依赖全部编译 | `HMR`时只需让浏览器重新请求该模块，同时利用浏览器的缓存（源码模块协商缓存，依赖模块强缓存）来优化请求 |

因为： `Vite` 不需要像 `Webpack` 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码。

而是： 在开发环境冷启动无需打包，无需分析模块之间的依赖，同时也无需在启动开发服务器前进行编译，启动时还会使用`esbuild`来进行预构建。

并且： `Vite` 只需执行初始化命令，就可以得到一个预设好的开发环境，开箱即获得一堆功能，包括：`CSS`预处理、`html`预处理、异步加载、分包、压缩、`HMR`等。他使用复杂度介于`Parcel`和`Webpack`的中间，只是暴露了极少数的配置项和`plugin`接口，既不会像`Parcel`一样配置不灵活，又不会像`Webpack`一样需要了解庞大的`loader`、`plugin`生态。

## 注意的是

在生产环境，由于嵌套导入会导致发送大量的网络请求，即使使用 `HTTP2.x`（多路复用、首部压缩），在生产环境中发布未打包的`ESM`仍然性能低下。因此，对比在开发环境`Vite`使用`esbuild`来构建依赖，**生产环境`Vite`则使用了更加成熟的`Rollup`来完成整个打包过程**。==因为`esbuild`虽然快，但针对应用级别的代码分割、`CSS`处理仍然不够稳定，同时也未能兼容一些未提供`ESM`的`SDK`。

为了在生产环境中获得最佳的加载性能，仍然需要对代码进行`tree-shaking`、懒加载以及`chunk`分割（以获得更好的缓存）。

# 四、`webpack`与`vite`优缺点对比



## `webpack`缺点一：缓慢的服务器启动

当冷启动开发服务器时，基于打包器的方式是在提供服务前去急切地抓取和构建你的整个应用。

### `vite`改进

`Vite` 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。依赖 大多为纯 `JavaScript` 并在开发时不会变动。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会以某些方式（例如 `ESM` 或者 `CommonJS`）被拆分到大量小模块中。`Vite` 将会使用 `esbuild` 预构建依赖。`Esbuild` 使用 `Go` 编写，并且比以 `JavaScript` 编写的打包器预构建依赖快 10-100 倍。

源码 通常包含一些并非直接是 `JavaScript` 的文件，需要转换（例如 `JSX`，`CSS` 或者 `Vue/Svelte` 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载。（例如基于路由拆分的代码模块）。`Vite` 以 原生 `ESM` 方式服务源码。这实际上是让浏览器接管了打包程序的部分工作：`Vite` 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。

## `webpack`缺点二：使用的是`node.js`去实现

### `vite`改进

`Vite` 将会使用 `esbuild` 预构建依赖。`Esbuild` 使用 `Go` 编写，并且比以 `Node.js` 编写的打包器预构建依赖快 10-100 倍。

## `webpack`致命缺点三：热更新效率低下

当基于打包器启动时，编辑文件后将重新构建文件本身。显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降。
一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[1]，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（`HMR`）：允许一个模块 “热替换” 它自己，而对页面其余部分没有影响。这大大改进了开发体验 - 然而，在实践中我们发现，即使是 `HMR`更新速度也会随着应用规模的增长而显著下降。

### `vite`改进

在 `vite`中，`HMR`是在原生 ESM 上执行的。当编辑一个文件时，`vite`只需要精确地使已编辑的模块与其最近的 `HMR`边界之间的链失效（大多数时候只需要模块本身），使 `HMR`更新始终快速，无论应用的大小。`vite` 同时利用 `HTTP` 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 `304 Not Modified` 进行协商缓存，而依赖模块请求则会通过 `Cache-Control: max-age=31536000,immutable` 进行强缓存，因此一旦被缓存它们将不需要再次请求。

## `vite`缺点1

生态不如`webpack`，`wepback`牛逼之处在于`loader`和`plugin`非常丰富,不过我认为生态只是时间问题

## `vite`缺点2

`prod`环境的构建，目前用的`Rollup`，原因在于`esbuild`对于`css`和代码分割不是很友好

## `vite`缺点3

1.还没有被大规模使用,很多问题或者诉求没有真正暴露出来，`vite`真正崛起那一天，是跟`vue3`有关系的,当`vue3`广泛开始使用在生产环境的时候，`vite`也就大概率意味着被大家慢慢开始接受了