# 一、`Tree Shaking` 是什么？

其实`Tree Shaking`的概念已经耳熟能详了，所谓的“摇树”就是说将我们代码中的没有用到的代码进行摇晃掉，从而减少包的体积。

其实简单来说这就是所谓的`Tree Shaking`: **基于 `ES Module` 规范的 `Dead Code Elimination` 技术，它会在运行过程中静态分析模块之间的导入导出，确定 `ESM` 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。**

> `Tree-shaking`的本质是消除无用的`js`代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为`DCE`（`dead code elimination`）。
>
> `Tree-shaking` 是 `DCE` 的一种新的实现，`Javascript`同传统的编程语言不同的是，`javascript`绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对`javascript`来说更有意义。
>
> `Tree-shaking` 和传统的 `DCE`的方法又不太一样，传统的`DCE` 消灭不可能执行的代码，而`Tree-shaking` 更关注于消除没有用到的代码。

`**Tree Shaking` 是一种用于移除 `JavaScript` 中未使用代码的优化技术。可以减小打包文件的体积，提高加载性能。**

**它依赖于 `ES6` 模块的静态结构特性（`import` 和 `export`），使得构建工具能够在编译时确定哪些代码是未使用的，并将其移除。**

具体来说，在 `webpack` 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 `tree-shaking`，将没有使用的模块摇掉，这样来达到删除无用代码的目的。

例子:

```
// index.js 入口文件
import { funcHao } from './math'

funcHao()
```

```
// math.js
const funcWang = () => {
  const obj = {};
  return obj;
};

const funcHao = () => {
  console.log('hao');
};

export { funcWang, funcHao };


export {
  funcWang,
  funcHao
}
```

```js
// webpack.config.js
const { resolve } = require('path');

module.exports = {
  mode: 'production',
  entry: resolve(__dirname, './src/index.js'),
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-env'],
            },
          },
        ],
      },
    ],
  },
  output: {
    filename: '[name].js',
  },
};
```

这里我们使用`webpack`新建了一个只有两个文件的项目。

- `src/index.js`: 入口文件，导入`math.js`中的`funcHao`方法。
- `src/math.js`: 导出两个方法`funcHao`和`funcWang`两个方法。

> tip:  这里我们配置`babel`的原因不单单是为了转译箭头函数，稍微我在后边会讲述为什么这里为配置了一个`babel-preset-env`。

让我们运行`webpack`命令打包我们的代码:

```js
// dist/main.js
(()=>{"use strict";console.log("hao")})();
```

我们会发现打包后的代码仅存在`console.log("hao")`，而`funcWang`这个函数的内容并没有被打包进入。

**简单来说`Tree Shaking`就是删除项目中没有使用到的代码从而达到优化代码的效果**。

## 为什么要配置`babel-preset-env`

上文讲到过我刻意配置了`@babel/preset-env`处理我们的代码，了解过它的同学可能会清楚。

`@babel/preset-env`是存在一个`modules`的配置参数，**它的默认值是`auto`。**

> `modules`配置的含义是,在`preset-env`转译时中启用 ES 模块语法到另一种模块类型的转换。

也许你会在很多教程或者网站上看到，由于`Tree Shaking`必须基于`Es Module`模块。

所以如果我们项目中使用到`babel-preset-env`时需要将它的`modules`配置为`false`:相当于告诉`babel`，"嘿，Babel请保留我代码中的`ESM`模块规范"。

没错，你配置为`false`的确没有任何问题，可是**上边我们的配置没有进行任何配置，默认值为`auto`的时候同样进行了`Tree Shaking`。**

你有想过这是为什么吗？ 日常工作中我相信大部分同学使用`preset-env`结合业务时也没有刻意配置`modules:false`吧。

其实根本原因就出现在它的默认参数`auto`中。

> 配置为`auto`,默认情况下，`@babel/preset-env`使用[`caller`](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Foptions%23caller)数据来确定是否`import()`应转换ES 模块和模块功能（例如）。

关于如何理解这段话，比如: 如果我们使用`Babel-Loader`调用`Babel`，那么`modules`将设置为`False`，因为`WebPack`支持`es`模块。

# 二、**Tree-shaking 的前提条件**

1. **使用 `ES6` 模块语法**：Tree-shaking 依赖静态导入/导出（`import/export`），`CommonJS`（`require/module.exports`）不支持，因为其依赖关系是动态的。

2. **代码必须是无副作用的**：如果某个导出函数或模块有副作用（如修改全局变量、发起 `API` 请求），**`Webpack`** 无法安全删除它。例如：

   ```
   // 有副作用的代码（不会被 Tree-shaking）
   export const init = () => {
     localStorage.setItem('init', 'true'); // 副作用：修改存储
   };
   ```

3. **启用生产模式**：`Webpack` 的生产模式默认开启 Tree-shaking 和代码压缩。

## 副作用

副作用在我们项目中，也同样是频繁的出现。知道函数式编程的朋友都会知道这个名词。所谓模块(这里模块可称为一个函数)具有副作用，就是说这个模块是不纯的。这里可以引入纯函数的概念。

> 对于相同的输入就有相同的输出，不依赖外部环境，也不改变外部环境。

符合上述就可以称为纯函数，不符合就是不纯的，是具有副作用的，是可能对外界造成影响的。

#### 配置参数

在项目的 `package.json` 文件中，添加 "`sideEffects`" 属性。`package.json` 有一个特殊的属性 `sideEffects`，就是为处理副作用而存在的 -- 向 `webpack` 的 `compiler` 提供提示哪些代码是“纯粹部分”。它有三个可能的值：

- `true` 是默认值，如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件可以 `tree-shaking`。
- `false` 告诉 `Webpack` 没有文件有副作用，所有文件都可以 `tree-shaking`。
- 第三个值 […] 是文件路径数组。它告诉 `webpack`，除了数组中包含的文件外，你的任何文件都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 `tree-shaking`。

```js
{
  "name": "your-project",
  "sideEffects": false
  // "sideEffects": [ // 数组方式支持相关文件的相对路径、绝对路径和 glob 模式
  //  "./src/some-side-effectful-file.js",
  //  "*.css"
  //]
}
```

 每个项目都必须将 `sideEffects` 属性设置为 `false` 或文件路径数组，如果你的代码确实有一些副作用，那么可以改为提供一个数组，在工作中需要正确配置 `sideEffects` 标记。

#### 代码中标记

可以通过 /*#**PURE***/ 注释可以告诉 `webpack` 一个函数调用是无副作用的。在函数调用之前，用来标记它们是无副作用的(`pure`)。  传到函数中的入参是无法被刚才的注释所标记，需要单独每一个标记才可以。  如果一个没被使用的变量定义的初始值被认为是无副作用的（`pure`），它会被标记为死代码，不会被执行且会被压缩工具清除掉。当 [optimization.innerGraph](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Foptimization%2F%23optimizationinnergraph) 被设置成 `true` 这个行为被会开启，而在 `webpack5.x` 中[optimization.innerGraph](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Foptimization%2F%23optimizationinnergraph) 默认为 `true`。 

```javascript
//test.js
import _ from "lodash-es";

const func1 = function(value){
    return _.isArray(value);
}
const func2 = function(value){
    return value=null;
}

export {
    func1,
    func2,
}
//index.js
import {func2} from './test.js'
func2()
```

上述代码在`test.js`中引入`lodash-es,`在`func1`中使用了`loadsh`，并且这里不符合纯函数的概念，它是具有副作用的。`func2`是一个纯函数。

在`index.js`中只引入了`func2`，并且使用了`func2`，可见整个代码的执行是和`func1`是没有任何关系的。我们通过生产环境打包一下试试看(`Tree-shaking`只在生产环境生效)

![webpack73](..\images\webpack73.png) 

`main.js 91.7KB`，可见这个结果是符合我们的预期的，因为`func1`函数的副作用，`webpack`自身的`Tree-shaking`并没有检测到这里有没必要的模块。

# 三、**Tree-shaking 的局限性与注意事项**

1. **动态导入的影响**：`import('./module.js').then(...)` 形式的动态导入可能导致 `Tree-shaking` 失效。

2. **第三方库的处理**：部分库（如 `Lodash`）需要手动导入 `ESM` 子模块：

   ```javascript
   // 仅导入需要的功能
   import { debounce } from 'lodash-es/debounce';
   ```

3. **`Babel` 配置冲突**：`Babel` 默认会将 `ES6` 模块转换为 `CommonJS`，需禁用此行为：

   ```javascript
   // babel.config.js
   {
     "presets": [
       [
         "@babel/preset-env",
         {
           "modules": false // 保留 ES6 模块语法
         }
       ]
     ]
   }
   ```

4. **调试 `Tree-shaking` 结果**：

   ```bash
   npx webpack --mode production --stats-json > stats.json
   ```

   使用 [Webpack Bundle Analyzer](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-bundle-analyzer) 分析生成的 `stats.json`，查看哪些代码被保留或删除。

# 三、Tree Shaking工作原理

需要额外注意的是:

- **`Tree Shaking`是基于`ESM`模块基础进行处理的。**

#### 至于为什么`Tree Shaking`需要`ESM`模块才能使用呢? 让我们来一起看一看这个问题。

简单来说一段`js`代码的执行过程，需要经历以下三个步骤:

- `V8`通过源码进行词法分析，语法分析生成`AST`和执行上下文。
- 根据`AST`生成计算机可执行的字节码。
- 执行生成的字节码。

在`JS`的执行过程中，**`ES Module`在第一步时就可以确认对应的依赖关系(编译阶段)**，并不需要执行就可以确认模块的导入、导出。

`ES Module`在`js`编译阶段就可以确定模块之间的依赖关系(`import`)以及模块的导出(`export`)，所以我们并不需要代码执行就可以根据`ESM`确定模块之间的规则从而实现`Tree Shaking`，我们称之为**静态分析特性**。

同理，对比`commonjs`模块，它依赖于代码的执行，需要在第三阶段执行完成代码之后才能确认模块的依赖关系，自然也就不支持`Tree Shaking`，不过我们可以通过插件支持 `CommonJS` 转 `ES6` 然后实现 `tree-shaking`。

> 关于`ES Module`中的动态引入`dynamic import`，因为它同样是动态需要`js`执行后才能确认的模块关系。自然也就无法支持`Tree Shaking`。

我们已经了解了 `tree-shaking` 的本质是消除无用的 `js` 代码。那么什么是无用代码？怎么消除无用代码？接下来让我们从 `DCE` 开始揭开它神秘的面纱，一探究竟吧~

## 1、`DCE`（dead code elimination）

无用代码在我们的代码中其实十分常见，消除无用代码也就拥有了自己的专业术语 - `dead code elimination（DCE）`。实际上，编译器可以判断出哪些代码并不影响输出，然后消除这些代码。

`tree-shaking` 是 `DCE` 的一种新的实现，`Javascript` 同传统的编程语言不同的是，`javascript` 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 `javascript` 来说更有意义。`tree-shaking` 和传统的 `DCE` 的方法又不太一样，传统的 `DCE` 消灭不可能执行的代码，而 `tree-shaking` 更关注消除没有用到的代码。

#### **`DCE`**

- 代码不会被执行，不可到达
- 代码执行的结果不会被用到
- 代码只会影响死变量，只写不读

传统编译型的预言都是由编译器将 `Dead Code` 从 `AST` (抽象语法树)中删除，了解即可。 那么 `tree-shaking` 是如何 消除 `javascript` 无用代码的呢？

`tree-shaking` 更关注于消除那些引用了但并没有被使用的模块，这种消除原理依赖于 `ES6` 的模块特性。所以先来了解一下 `ES6` 模块特性：

#### **`ES6 Module`**

- 只能作为模块顶层的语句出现
- `import` 的模块名只能是字符串常量
- `import binding` 是 `immutable` 的

了解了这些前提，让我们动手用代码来验证下吧！

# 四、Tree-shaking 实现机制

## 前言

如果看过 `rollup` 系列的这篇文章 - [无用代码去哪了？项目减重之 rollup 的 Tree-shaking](https://juejin.cn/post/6968262966604988429)，那你一定对 `tree-shaking` 不陌生了。

众所周知，原本不支持 `tree-shaking` 的 `Webpack` 在它的 `2.x` 版本也实现了 `tree-shaking`，好奇心又来了，`rollup` 从一开始就自实现了 `tree-shaking`，而 `Webpack` 则是看到 `rollup` 的打包瘦身效果之后，到了 `2.x` 才实现，那么二者实现 `tree-shaking` 的原理是一样的吗？

快速浏览完官方文档和一众文章后，发现 `webpack` 实现 `tree-shaking` 的方式还不止一种！但是，都与 `rollup` 不同。

早期 `webpack` 的配置使用并不简单，也因此曾有 `webpack` 配置工程师的戏称，虽然现在  `webpack`的配置被极大简化了，`webpack4` 也宣称 0 配置，但如果涉及复杂全面的打包功能，并非是 0 配置可以实现的。了解其功能原理及配置还是极为有用的，接下来就来了解一下  `webpack`实现 tree-shaking 的原理吧。 

## `Tree-shaking -- rollup VS  webpack`

- `rollup` 是在编译打包过程中分析程序流，得益于于 `ES6` 静态模块（`exports` 和 `imports` 不能在运行时修改），我们在打包时就可以确定哪些代码时我们需要的。
- `webpack` 本身在打包时只能标记未使用的代码而不移除，而识别代码未使用标记并完成 `tree-shaking` 的 其实是 `UglifyJS`、`babili`、`terser` 这类压缩代码的工具。简单来说，就是压缩工具读取  `webpack`打包结果，在压缩之前移除 `bundle` 中未使用的代码。

我们提到了标记未使用代码，也提到了 `UglifyJS`、`babili`、`terser` 等压缩工具，那么  `webpack` 与压缩工具是怎么实现 `tree-shaking` 的呢？先来了解下  `webpack`中实现 `tree-shaking` 的前世今生吧！ 

##  `webpack`实现 `Tree-shaking` 的 3 个阶段

#### 第一阶段： `UglifyJS`

 `webpack`标记代码 + `babel` 转译 `ES5`  -->  `UglifyJS` 压缩删除无用代码  关于最早版本的  `webpack`实现 `tree-shaking` 可以参考这篇文章 [如何在 Webpack 2 中使用 tree-shaking](https://link.juejin.cn?target=https%3A%2F%2Fblog.craftlab.hu%2Fhow-to-do-proper-tree-shaking-in-webpack-2-e27852af8b21)，掘金也有翻译版，当然如果不愿意花时间考古，也可以看下面这一段总结：

- `UglifyJS` 不支持 `ES6` 及以上，需要用 `Babel` 将代码编译为 `ES5`，然后再用 `UglifyJS` 来清除无用代码；
- 通过 `Babel` 将代码编译为 `ES5`，但又要让 `ES6` 模块不受 `Babel` 预设（`preset`）的影响：配置 `Babel` 预设不转换 `module`，对应地配置  `webpack` 的 `plugins` 配置；
- 为避免副作用，将其标记为 `pure`（无副作用），以便 `UglifyJS` 能够处理，主要是  `webpack`的编译过程阻止了对类进行 `tree-shaking`，它仅对函数起作用，后来通过支持将类编译后的赋值标记为 @`__PURE__`解决了这个问题。

```js
// .babelrc
{
  "presets": [
    ["env", {
      "loose": true, // 宽松模式
      "modules": false // 不转换 module，保持 ES6 语法
    }]
  ]
}

```

```
// webpack.config.js
module: {
  rules: [
    { test: /\.js$/, loader: 'babel-loader' }
  ]
},

plugins: [
    minimize: true,
    debug: false
  }),
  new webpack.optimize.UglifyJsPlugin({
    compress: {
      warnings: true
    },
    output: {
      comments: false
    },
    sourceMap: false
  })
]
```



#### 第二阶段：`BabelMinify`

`webpack` 标记代码 -->  `Babili`（即 `BabelMinify`）压缩删除无用代码  `Babili` 后来被重命名为 `BabelMinify`，是基于 `Babel` 的代码压缩工具，而 `Babel` 已经通过我们的解析器 `Babylon` 理解了新语法，同时又在 `babili` 中集成了 `UglifyJS` 的压缩功能，本质上实现了和 `UglifyJS` 一样的功能，但使用 `babili` 插件又不必再转译，而是直接压缩，使代码体积更小。

一般使用 `Babili` 替代 `uglify` 有 `Babili` 插件式和 `babel-loader` 预设两种方式。在[官方文档](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fminify)最后有说明，`Babel Minify` 最适合针对最新的浏览器（具有完整的 `ES6+` 支持），也可以与通常的 `Babel es2015` 预设一起使用，以首先向下编译代码。

在 `webpack`  中使用 `babel-loader`，然后再引入 `minify` 作为一个 `preset` 会比直接使用 `BabelMinifyWebpackPlugin` 插件（下一个就讲到）执行得更快。因为 `babel-minify` 处理的文件体积会更小。 

#### 第三阶段： `Terser`

`webpack`  标记代码 --> `Terser` 压缩删除无用代码 （`webpack5` 已内置）  `terser` 是一个用于 `ES6+` 的 `JavaScript` 解析器和 `mangler/compressor` 工具包。如果你看过这个 `issue`，就会知道放弃 `uglify` 而投向 `terser` 怀抱的人越来越多，其原因也很清楚：

- `uglify` 不再进行维护且不支持 `ES6+` 语法
- `webpack`  默认内置配置了 `terser` 插件实现代码压缩  关于副作用，从  `webpack 4` 正式版本扩展了未使用模块检测能力，通过 `package.json` 的 "`sideEffects`" 属性作为标记，向 `compiler` 提供提示，表明项目中的哪些文件是 "`pure`(纯正 `ES2015` 模块)"，由此可以安全地删除文件中未使用的部分。

`webpack4` 的时候还要手动配置一下压缩插件，但最新的  `webpack5` 已经内置实现 `tree-shaking` 啦！在生产环境下无需配置即可实现 `tree-shaking` !

# 五、`Tree-shaking` 实现原理

`Webpack` 中，`Tree-shaking` 的实现一是先**标记**出模块导出值中哪些没有被用过，二是使用 `Terser` 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：

- `Make` 阶段，收集模块导出变量并记录到模块依赖关系图 `ModuleGraph` 变量中
- `Seal` 阶段，遍历 `ModuleGraph` 标记模块导出变量有没有被使用
- 生成产物时，若变量没有被其它模块使用则删除对应的导出语句

> 标记功能需要配置 `optimization.usedExports = true` 开启

也就是说，标记的效果就是删除没有被其它模块使用的导出语句，比如：

![webpack74](..\images\webpack74.png)

示例中，`bar.js` 模块(左二)导出了两个变量：`bar` 与 `foo`，其中 `foo` 没有被其它模块用到，所以经过标记后，构建产物(右一)中 `foo` 变量对应的导出语句就被删除了。作为对比，如果没有启动标记功能(`optimization.usedExports = false` 时)，则变量无论有没有被用到都会保留导出语句，如上图右二的产物代码所示。

注意，这个时候 `foo` 变量对应的代码 `const foo='foo'` 都还保留完整，这是因为标记功能只会影响到模块的导出语句，真正执行“`**Shaking**`”操作的是 `Terser` 插件。例如在上例中 `foo` 变量经过标记后，已经变成一段 `Dead Code` —— 不可能被执行到的代码，这个时候只需要用 `Terser` 提供的 `DCE` 功能就可以删除这一段定义语句，以此实现完整的 `Tree Shaking` 效果。

`webpack` 将我们项目的源文件处理成最后的打包文件，大致需要经历**构建模块依赖图**、**将模块依赖图封装为 `chunks`**、**构建 `chunks` 对应的内容**以及**将输出 `chunks` 的内容到指定位置的流程**。而 `tree shaking` 就发生在**封装 `chunks**`和**构建 `chunks` 对应的内容**的过程中。

接下来我会展开标记过程的源码，详细讲解 `Webpack 5` 中 `Tree Shaking` 的实现过程。

## 1 、收集模块导出

首先，`Webpack` 需要弄清楚每个模块分别有什么导出值，这一过程发生在 make 阶段，大体流程：

> 关于 Make 阶段的更多说明，请参考前文 [[万字总结\] 一文吃透 Webpack 核心原理](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSbJNbSVzSPSKBe2YStn2Zw) 。

1. 将模块的所有 ESM 导出语句转换为 Dependency 对象，并记录到 `module` 对象的 `dependencies` 集合，转换规则：

- 具名导出转换为 `HarmonyExportSpecifierDependency` 对象
- `default` 导出转换为 `HarmonyExportExpressionDependency` 对象

例如对于下面的模块：

```Javascript
export const bar = 'bar';
export const foo = 'foo';

export default 'foo-bar'
```

对应的`dependencies` 值为：

![webpack75](..\images\webpack75.png)

1. 所有模块都编译完毕后，触发 `compilation.hooks.finishModules` 钩子，开始执行 `FlagDependencyExportsPlugin` 插件回调
2. `FlagDependencyExportsPlugin` 插件从 entry 开始读取 `ModuleGraph` 中存储的模块信息，遍历所有 `module` 对象
3. 遍历 `module` 对象的 `dependencies` 数组，找到所有 `HarmonyExportXXXDependency` 类型的依赖对象，将其转换为 `ExportInfo` 对象并记录到 `ModuleGraph` 体系中

经过 `FlagDependencyExportsPlugin` 插件处理后，所有 ESM 风格的 export 语句都会记录在  `ModuleGraph` 体系内，后续操作就可以从  `ModuleGraph`中直接读取出模块的导出值。

> 参考资料：

1. > [[万字总结\] 一文吃透 Webpack 核心原理](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSbJNbSVzSPSKBe2YStn2Zw)

2. > [有点难的 webpack 知识点：Dependency Graph 深度解析](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fkr73Epnn6wAx9DH7KRVUaA)

## 2、 标记模块导出

模块导出信息收集完毕后，`Webpack` 需要标记出各个模块的导出列表中，哪些导出值有被其它模块用到，哪些没有，这一过程发生在 Seal 阶段，主流程：

1. 触发 `compilation.hooks.optimizeDependencies` 钩子，开始执行 `FlagDependencyUsagePlugin` 插件逻辑
2. 在 `FlagDependencyUsagePlugin` 插件中，从 entry 开始逐步遍历 `ModuleGraph` 存储的所有 `module` 对象
3. 遍历 `module` 对象对应的 `exportInfo` 数组
4. 为每一个 `exportInfo` 对象执行 `compilation.getDependencyReferencedExports` 方法，确定其对应的 `dependency` 对象有否被其它模块使用
5. 被任意模块使用到的导出值，调用 `exportInfo.setUsedConditionally` 方法将其标记为已被使用。
6. `exportInfo.setUsedConditionally` 内部修改 `exportInfo._usedInRuntime` 属性，记录该导出被如何使用
7. 结束

上面是极度简化过的版本，中间还存在非常多的分支逻辑与复杂的集合操作，我们抓住重点：标记模块导出这一操作集中在 `FlagDependencyUsagePlugin` 插件中，执行结果最终会记录在模块导出语句对应的 `exportInfo._usedInRuntime` 字典中。

## 3、 生成代码

经过前面的收集与标记步骤后，`Webpack` 已经在 `ModuleGraph` 体系中清楚地记录了每个模块都导出了哪些值，每个导出值又没那块模块所使用。接下来，`Webpack` 会根据导出值的使用情况生成不同的代码，例如：

![webpack76](..\images\webpack76.png)

重点关注 `bar.js` 文件，同样是导出值，`bar` 被 `index.js` 模块使用因此对应生成了 `__webpack_require__.d` 调用 `"bar": ()=>(/* binding */ bar)`，作为对比 `foo` 则仅仅保留了定义语句，没有在 chunk 中生成对应的 export。

> 关于 `Webpack` 产物的内容及 `__webpack_require__.d` 方法的含义，可参考 [Webpack 原理系列六： 彻底理解 Webpack 运行时](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FnkBvbwpzeb0fzG02HXta8A) 一文。

这一段生成逻辑均由导出语句对应的 `HarmonyExportXXXDependency` 类实现，大体的流程：

1. 打包阶段，调用 `HarmonyExportXXXDependency.Template.apply` 方法生成代码
2. 在 `apply` 方法内，读取 `ModuleGraph` 中存储的 `exportsInfo` 信息，判断哪些导出值被使用，哪些未被使用
3. 对已经被使用及未被使用的导出值，分别创建对应的 `HarmonyExportInitFragment` 对象，保存到 `initFragments` 数组
4. 遍历 `initFragments` 数组，生成最终结果

基本上，这一步的逻辑就是用前面收集好的 `exportsInfo` 对象未模块的导出值分别生成导出语句。

## 4、 删除 Dead Code

经过前面几步操作之后，模块导出列表中未被使用的值都不会定义在 `__webpack_exports__` 对象中，形成一段不可能被执行的 `Dead Code` 效果，如上例中的 `foo` 变量：

![webpack77](..\images\webpack77.png)

在此之后，将由 `Terser`、`UglifyJS` 等 `DCE` 工具“摇”掉这部分无效代码，构成完整的 `Tree Shaking` 操作。

## 5 、总结

综上所述，`Webpack` 中 `Tree Shaking` 的实现分为如下步骤：

- 在 `FlagDependencyExportsPlugin` 插件中根据模块的 `dependencies` 列表收集模块导出值，并记录到 `ModuleGraph` 体系的 `exportsInfo` 中
- 在 `FlagDependencyUsagePlugin` 插件中收集模块的导出值的使用情况，并记录到 `exportInfo._usedInRuntime` 集合中
- 在 `HarmonyExportXXXDependency.Template.apply` 方法中根据导出值的使用情况生成不同的导出语句
- 使用 `DCE` 工具删除 `Dead Code`，实现完整的树摇效果

# 六、最佳实践

虽然 `Webpack` 自 `2.x` 开始就原生支持 `Tree Shaking` 功能，但受限于 `JS` 的动态特性与模块的复杂性，直至最新的 5.0 版本依然没有解决许多代码副作用带来的问题，使得优化效果并不如 `Tree Shaking` 原本设想的那么完美，所以需要使用者有意识地优化代码结构，或使用一些补丁技术帮助 `Webpack` 更精确地检测无效代码，完成 `Tree Shaking` 操作。

## 1 、避免无意义的赋值

使用 `Webpack` 时，需要有意识规避一些不必要的赋值操作，观察下面这段示例代码：

![webpack78](..\images\webpack78.png)

示例中，`index.js` 模块引用了 `bar.js` 模块的 `foo` 并赋值给 `f` 变量，但后续并没有继续用到 `foo` 或 `f` 变量，这种场景下 `bar.js` 模块导出的 `foo` 值实际上并没有被使用，理应被删除，但 `Webpack` 的 `Tree Shaking` 操作并没有生效，产物中依然保留 `foo` 导出：

![webpack79](..\images\webpack79.png)

造成这一结果，浅层原因是 `Webpack` 的 `Tree Shaking` 逻辑停留在代码静态分析层面，只是浅显地判断：

- 模块导出变量是否被其它模块引用
- 引用模块的主体代码中有没有出现这个变量

没有进一步，从语义上分析模块导出值是不是真的被有效使用。

更深层次的原因则是 JavaScript 的赋值语句并不**纯**，视具体场景有可能产生意料之外的副作用，例如：

```Javascript
import { bar, foo } from "./bar";

let count = 0;

const mock = {}

Object.defineProperty(mock, 'f', {
    set(v) {
        mock._f = v;
        count += 1;
    }
})

mock.f = foo;

console.log(count);
```

示例中，对 `mock` 对象施加的 `Object.defineProperty` 调用，导致 `mock.f = foo` 赋值语句对 `count` 变量产生了副作用，这种场景下即使用复杂的动态语义分析也很难在确保正确副作用的前提下，完美地 `Shaking` 掉所有无用的代码枝叶。

因此，在使用 `Webpack` 时开发者需要有意识地规避这些无意义的重复赋值操作。

## 2、 使用 `#pure` 标注纯函数调用

与赋值语句类似，`JavaScript` 中的函数调用语句也可能产生副作用，因此默认情况下 `Webpack` 并不会对函数调用做 `Tree Shaking` 操作。不过，开发者可以在调用语句前添加 `/*#__PURE__*/` 备注，明确告诉 `Webpack` 该次函数调用并不会对上下文环境产生副作用，例如：

![webpack80](..\images\webpack80.png)

示例中，`foo('be retained')` 调用没有带上 `/*#__PURE__*/` 备注，代码被保留；作为对比，`foo('be removed')` 带上 Pure 声明后则被 Tree Shaking 删除。

## 3、禁止 Babel 转译模块导入导出语句

`Babel` 是一个非常流行的 `JavaScript` 代码转换器，它能够将高版本的 `JS` 代码等价转译为兼容性更佳的低版本代码，使得前端开发者能够使用最新的语言特性开发出兼容旧版本浏览器的代码。

但 `Babel` 提供的部分功能特性会致使 `Tree Shaking` 功能失效，例如 Babel 可以将 `import/export` 风格的 `ESM` 语句等价转译为 `CommonJS` 风格的模块化语句，但该功能却导致 `Webpack` 无法对转译后的模块导入导出内容做静态分析，示例：

![webpack81](..\images\webpack81.png)

示例使用 `babel-loader` 处理 `*.js` 文件，并设置 Babel 配置项 `modules = 'commonjs'`，将模块化方案从 `ESM` 转译到 `CommonJS`，导致转译代码(右图上一)没有正确标记出未被使用的导出值 `foo`。作为对比，右图 2 为 `modules = false` 时打包的结果，此时 `foo` 变量被正确标记为 Dead Code。

所以，在 `Webpack` 中使用 `babel-loader` 时，建议将 `babel-preset-env` 的 `moduels` 配置项设置为 `false`，关闭模块导入导出语句的转译。

## 4、 优化导出值的粒度

`Tree Shaking` 逻辑作用在 `ESM` 的 `export` 语句上，因此对于下面这种导出场景：

```Javascript
export default {
    bar: 'bar',
    foo: 'foo'
}
```

即使实际上只用到 `default` 导出值的其中一个属性，整个 `default` 对象依然会被完整保留。所以实际开发中，应该尽量保持导出值颗粒度和原子性，上例代码的优化版本：

```ini
const bar = 'bar'
const foo = 'foo'

export {
    bar,
    foo
}
```

## 5 、使用支持 `Tree Shaking` 的包

如果可以的话，应尽量使用支持 `Tree Shaking` 的 `npm` 包，例如：

- 使用 `lodash-es` 替代 `lodash` ，或者使用 `babel-plugin-lodash` 实现类似效果

不过，并不是所有 `npm` 包都存在 `Tree Shaking` 的空间，诸如 `React`、`Vue2` 一类的框架原本已经对生产版本做了足够极致的优化，此时业务代码需要整个代码包提供的完整功能，基本上不太需要进行 `Tree Shaking`。

# 六、图解`Tree-shaking` 实现原理

## 1、配置项

要使用 `webpack` 的 `tree shaking` 功能，我们需要先做一些配置。

`webpack` 提供了两种级别的 `tree shaking` 功能：**`modules-level`** 和 **`statements-level`**。不同级别的 `tree shaking`，对应的配置项也不相同。

- `tree shaking` 有两种 `level：modules-level` 和 `statements-level`。`modules-level` 会将为**未使用的模块**移除， `statements-level` 会将**模块未使用的 `export`** 移除。
- `modules-level` 需要设置 `optimization.sideEffects` 为 `true`。
- `statements-level` 需要配置 `optimization.usedExports`、`optimization.minimize` 为 `true`。

#### **`modules-level`**

**`modules-level`** 级别，即 **`tree shaking` 功能作用于整个模块**。如果模块被引用但未被使用，那么该模块不会出现在最后的打包代码中。

示例代码如下：

```javascript
 // 源文件代码
  // example.1.js
  export default function funA() { console.log('funcA') }

  // index.js
  import funcA from './example.1.js';

  console.log('index');
```

打包以后的代码如下，其中 `example.1` 模块被移除：

```less
// bundle.js
      (self["webpackChunkwebpack_treeshaking"] = self["webpackChunkwebpack_treeshaking"] || []).push([[179],{
      /***/ "./index.js":
      /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                console.log('index');
      /***/ })
          // example.1.js 已经被移除
      },
      0,[["./index.js",303]]]);
```

使用 **`modules-level`** 的 **`tree shaking`** 功能时，我们需要按如下步骤进行配置：

1. 首先，我们需要设置 **`optimization.sideEffects`** 的值为 **`true`**；

   **`optimization.sideEffects`** 的值为 `true`，意味着 `webpack` 的 `tree shaking` 功能被开启。该属性在 `production` 模式下默认为 `true`，不需要配置。

2. 其次，我们需要将 **`package.json`** 文件中的 **`sideEffects`** 属性设置为 **`false`**，或者**不做任何处理**;

   将 `sideEffects` 属性设置为 `false`，意味着 `webpack` 在使用 `tree shaking` 功能时会认为是没有副作用的，可以安全的将未使用的模块移除。如果没有 `sideEffects` 属性或者 `sideEffects` 的属性值为 `true`，`webpack` 会自己分析 `tree shaking` 有没有副作用，如果没有副作用，将移除未使用的模块。

#### **`statements-level`**

**`statements-level`** 级别，即 **`tree shaking`** 功能作用于模块内部的语句。如果模块内部定义的 `export` 没有被引用，或者引用但未被使用，那么该 `export` 将不会出现在最后的打包代码中。

示例代码如下：

```javascript
// example.2.js
export const funcB = () => { console.log('funcB') }
export const funcC = () => { console.log('funcC') }

// index.js
import { funcB, funcC } from './example.2.js';
funcC();    
```

打包以后的代码如下，其中 `example.2` 模块的 `funB` 被移除：

```javascript
// bundle.js
 (self.webpackChunkwebpack_treeshaking=self.webpackChunkwebpack_treeshaking||[]).push([[179],
     	{
         	"./index.js":(e,s,c)=>{"use strict";(0,c("./example.2.js").I)()},
             "./example.2.js":(e,s,c)=>{
             	"use strict";
                 c.d(s,{I:()=>n});
                 const n=()=>{console.log("funcC")}
                 // funcB 已经被移除
              }
          },0,[["./index.js",303]]]);
```

使用 **`statements-level`** 的 **`tree shaking`** 功能时，我们需要按照如下步骤进行配置：

1. 首先，我们需要将 **`optimization.usedExports`** 的属性值设置为 **`true`**(`production` 模式下，默认为 `true`)；
2. 其次，我们需要将 **`optimization.minimize`** 的属性值设置为 **`true`**(`production` 模式下，默认为 `true`)；

在实际的项目中，我们会将 **`modules-level`** 和 **`statements-level`** 的 **`tree shaking`** 功能同时开启，将未使用的模块及模块内部未使用的 `export` 全部移除，缩小打包文件的体积。

## 2、理论依据

了解完 **`tree shaking`** 功能的配置项以后，我们再来了解一下 **`tree shaking`** 功能的理论依据。

使用过 `webpack` 的同学都知道，如果要想 `tree shaking` 功能有效，我们必须使用 `ES6 - import` 的方式引用模块。如果使用 `common.js - require` 的方式引用模块，`tree shaking` 功能则无效。

那是什么原因导致 `ES6 - import` 的方式引用模块可以使用 `tree shaking` 功能，而 `common.js - require` 的方式引用模块却无法`tree shaking` 功能呢？

要解答这个疑问，我们需要先了解两个知识点：**`js` 代码的执行过程** 以及 **`ES6-module` 和 `commonjs-module`的区别**。

- **`js` 代码执行过程**

  关于 `V8` 引擎是如何执行一段 `js` 代码的，要经历如下步骤：

  1. 源代码通过语法分析和词法分析，生成抽象语法树(`AST`)和执行上下文；
  2. 根据抽象语法树(`AST`)生成字节码；
  3. 执行生成的字节码；

- **`ES6-module` 和 `commonjs-module` 对比**

  **`ES6-module`** 和 **`commonjs-module`** 是目前两种通用的 `js` 模块解决方案。

  **`ES6-module`** 的设计思想是尽量的静态化，使得`js` 代码在**编译阶段**，就可以确定模块之间的依赖关系、以及模块的输出。而 **`commonjs-module`** 不同，只有在 `js`代码**真正执行**的时候，我们才能知道模块的输出。

  对比上面 `js`代码的执行过程，**`ES6-module`** 在第一步结束的时候，就可以知道依赖模块的 `export`，而 `commonjs-module` 需要在第三步的时候，才能知道依赖模块的 `export`。

正是基于 **`js`代码执行之前需要先编译** 以及 **`ES6-module`在 `js` 代码编译时就可确定模块之间依赖关系和依赖模块输出** 的特性，使得 `webpack` 可以在打包过程中，静态解析源文件的内容，找到模块之间的依赖关系以及模块被使用的 `export`，然后移除未使用的模块以及模块中未使用的 `export`，达到 `tree shaking` 的目的。

## 3、实现

知道了 `webpack - treeshaking` 的工作原理以后，接下来我们要了解的就是 `webpack`是如何实现 tree shaking 功能的。

`webpack`将我们项目的源文件处理成最后的打包文件，大致需要经历**构建模块依赖图**、**将模块依赖图封装为 `chunks`**、**构建 `chunks`对应的内容**以及**将输出 `chunks`的内容到指定位置的流程**。而`tree shaking` 就发生在**封装`chunks`**和**构建 `chunks`对应的内容**的过程中。

为了能更形象的解释 `tree shaking`，本文会通过一个简单的示例，依次为大家梳理 `webpack`的打包过程和 `tree shaking`。

示例代码如下:

```
// example.1.js

export default function funcA() {
    console.log('funcA');
}
```

```
// example.2.js

export const funcB = () => {
    console.log('funcB');
}

export const funcC = () => {
    console.log('funcC');
}

export const funcD = () => {
    console.log('funcD');
}

export const funcE = () => {
    console.log('funcE');
}
```

```
// example.3.js
import { funcD } from './example.2';
import funcA from './example.1';

export const funcF = () => {
    funcD();
    funcA();
    console.log('funcF');
}

export const funcH = () => {
    console.log('funcH');
}
```

```
// example.4.js
export const funcG = () => {
    console.log('funcG');
}
```

```
// main.js
import funcA from './example.1';
import { funcG } from './example.4';
import { funcB } from './example.2';
import(/* webpackChunkName: "example.3" */'./example.3').then((module) => {
    console.log('123');
});
funcB();
```

相应的 `webpack` 配置如下：

```yaml
const config = {
    mode: 'production',
    entry: path.resolve(__dirname, '../index'),
    optimization: {
        concatenateModules: false,
        minimize: true,
        runtimeChunk: true,
        usedExports: true,
        moduleIds: 'named',
        sideEffects: true,
    }
};
```

#### 构建模块依赖图

首先，我们先了解一下模块依赖图的构建。

`webpack` 在编译打包过程中，会根据项目中各个模块之间的依赖关系，递归的构建一个模块依赖图，具体的过程如下：

![webpack82](..\images\webpack82.png)

示例中各个模块，对应的模块依赖图如下：

![webpack83](..\images\webpack83.png)

在图中，我们发现模块之间的依赖关系是通过三种类型的边来确定的：

- **`HarmonyImportSideEffectDependency`**

  **`HarmonyImportSideEffectDependency`用来表示模块之间的引用关系**。示例中，`main` 模块通过 `ES6 - import` 的方式引用了 `example.1` 模块、`example.2` 模块、`example.4` 模块，那么 `webpack` 就会为 `example.1`、`example.2`、`example.4` 创建一个 `HarmonyImportSideEffectDependency` 类型的 dependency 对象，添加到 main 模块的 dependencies 列表中。

- **`HarmImportSpecifierDependency`**

  **`HarmImportSpecifierDependency`用来表示模块被使用的 `export`**。 示例中， `main` 模块使用了 `example.2` 模块提供的 `funB`， `webpack` 就会为 `example.2` 创建一个 `HarmImportSpecifierDependency`类型的 `dependency` 对象，添加到 `main` 模块的 `dependencies` 列表中。

- **`AsyncDependenciesBolock`**

  **`AsyncDependenciesBolock` 用来表示需要动态加载的模块**。 示例中， `main` 模块以懒加载的方式引入的 `example.3`, `webpack` 会为 `example.3` 创建一个 `AsyncDependenciesBolock`类型的 `dependency` 对象，添加到 `main` 模块的 `blocks` 列表中。

#### 模块依赖图预处理

模块依赖图构建完成以后，接下来就是根据模块依赖图来构建 `chunks`。

不过在构建 `chunks` 前，`webpack` 还需要对模块依赖图进行预处理。

在预处理过程中，`webpack`会做如下操作:

- **确定每个模块的 `usedExports`**

  每个模块的 `usedExports` 代表着模块被使用的 export。只有确定了每个模块的  `usedExports` ，`webpack`才可以将模块未使用的 export 移除。

  在预处理时，`webpack` 是依据模块依赖图中 `HarmImportSpecifierDependency` 类型的边来确定每个模块的  `usedExports` 。

  模块依赖图中的每一条 `HarmImportSpecifierDependency` 边，都对应着依赖模块被使用的 `export`。示例中，`main` 模块和 `example.4` 模块之间没有 `HarmImportSpecifierDependency` 类型的边，说明 `main` 模块只引用了  `example.4`, 但是实际中并未使用 `example.4`的默认输出，那么  `example.4` 模块  `usedExports` 就是 `undefined`。 而 `main` 模块和 `example.2` 模块之间有指向 `funcB` 的 `HarmImportSpecifierDependency` 边、`example.3` 模块和 `example.2` 模块之间有指向 `funcD` 的 `HarmImportSpecifierDependency` 边，说明 `example.2` 模块中的 `funcB`、`funcD` 又被使用，那么 `example.2` 的模块的  `usedExports` 为 `funcB` 和 `funcD`。

  处理以后的示例模块依赖图如下：

![webpack84](..\images\webpack84.png)

> **确定每个模块的 `usedExports`，需要 `optimization.usedExports` 的属性值为 `ture`。如果 `optimization.usedExports` 的值为 `false`，那么每个模块的 `usedExports` 无法确定，`webpack` 也无法将未使用的 `export` 移除。`production` 模式下， `optimization.usedExports` 的值为 `true`。**

**移除未使用的模块**

确定每个模块的实际输出以后，`webpack` 接下来会将 export 未被使用的模块从模块依赖图中移除。

模块可不可以被移除，可以通过模块之间是否同时存在 `HarmonyImportSideEffectDependency` 和 `HarmImportSpecifierDependency` 类型的边来确定。如果模块之间只有 `HarmonyImportSideEffectDependency` 类型的边，那么对应的依赖模块是可以被移除的。

观察示例的模块依赖图，`main` 模块 和 `example.4` 模块之间只有 `HarmonyImportSideEffectDependency` 类型的边，没有 `HarmImportSpecifierDependency` 类型的边，说明 `example.4` 模块只是被 `main` 模块引用，它的输出并没有被 `main` 模块使用，那么 `examale.4` 模块是可以被移除的。而 `main` 模块和 `example.2` 模块之间，既有 `HarmonyImportSideEffectDependency` 类型的边，也有 `HarmImportSpecifierDependency` 类型的边，说明 `example.2` 模块的输出有被 `main` 模块使用，那么 `example.2` 模块不会被删除移除。

处理以后的模块依赖图如下：

![`webpack85`](..\images\webpack85.png)

> 移除 `export` 未被使用的模块，需要 `optimization.sideEffects` 配置项的值为 `true`。如果 `optimization.sideEffects` 的值为 `false`，那么 `export` 未被使用的模块不会被移除。`production` 模式下，`optimization.sideEffects` 的值默认为 `true`。

#### 封装 chunks

预处理结束以后，`webpack` 接下来会将模块依赖图封装成 `chunks`。`webpack`会遍历模块依赖图，找到模块依赖图中 `AsyncDependenciesBolock` 类型的边，然后将模块依赖图分解为各个 `chunks`。

观察示例模块依赖图，`main` 模块和 `example.3` 模块之间存在 `AsyncDependenciesBolock` 类型的边，那么 `webpack` 会根据 `AsyncDependenciesBolock` 边将模块依赖图拆分为 main 和 `example.3` 两个 `chunk`。其中， `main chunk` 包含 `main`、`example.2` 模块， `example.3 chunk` 包含 `example.3`、 `example.1` 模块。

示例对应的 `chunks` 如下：

![webpack86](..\images\webpack86.png)

#### 构建 `chunk` 内容

`chunks` 构建完成以后， `webpack`接下来要做的是为每一个  `chunk`构建输出内容。`webpack` 会先为每个  `chunk`包含的模块构建内容，然后根据模块的内容，生成  `chunk` 的内容。构建模块内容时，`usedExports` 的值(即 `optimization.usedExports` 配置项的值)会影响最后的结果。

示例中 `example.2` 模块依据 `usedExports` 配置项的不同，构建的内容分别如下：

- **`optimization.usedExports: false`**

  此时， `example.2` 的 `usedExports` 为 null，构建内容为：

  ```javascript
  "./example.2.js":((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  	"use strict";
  	__webpack_require__.r(__webpack_exports__);
  	__webpack_require__.d(__webpack_exports__, {
  		"funcB": () => /* binding */ funcB,
  		"funcC": () => /* binding */ funcC,
  		"funcD": () => /* binding */ funcD,
  		"funcE": () => /* binding */ funcE
  	});
          const funcB = () => {
              console.log('funcB');
          }
  
          const funcC = () => {
              console.log('funcC');
          }
  
          const funcD = () => {
              console.log('funcD');
          }
  
          const funcE = () => {
              console.log('funcE');
          }
      })
  }
  ```

- **`optimization.useExports: true`**

  此时， `example.2` 的 `usedExports` 为 `funcB`、`funcD`，构建内容为：

  ```javascript
  "./example.2.js":((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  	"use strict";
  	__webpack_require__.r(__webpack_exports__);
  	__webpack_require__.d(__webpack_exports__, {
  		"funcB": () => /* binding */ funcB,
  		"funcD": () => /* binding */ funcD
  	});
          const funcB = () => {
              console.log('funcB');
          }
  
          const funcC = () => {
              console.log('funcC');
          }
  
          const funcD = () => {
              console.log('funcD');
          }
  
          const funcE = () => {
              console.log('funcE');
          }
      })
  }
  ```

在上面的构建代码中， **`webpack_exports`** 对应 `example.2` 模块在实际应用中 exports。如果 `optimization.usedExports` 的值为 `false`，那么 **`webpack_exports`** 包含`example.2` 定义的所有 `export`，如果 `optimization.usedExports` 的值为 `true`，那么 **`webpack_exports`** 包含 `example.2` 中定义的且被使用的 `export`。

`chunk` 内容构建完成以后，如果我们在配置项中设置了 **`minimize`** 属性为 `true`，`webpack` 会启用 **`terser`**，对构建好的内容进行压缩、混淆处理，并且删除未使用的代码。**`terser`** 也会将要处理的内容解析为一个 **`ast`** 对象,然后分析 **`ast`** 对象, 将模块中未使用的代码移除掉。

> **`production` 模式下， `minimize` 默认为 `true`**。

示例中的 `example.2`模块，当 `optimization.usedExports` 的值为 `ture` 时，**`webpack_exports`** 包含 `funcB` 和 `funcD`，而 `funcA` 和 `funcE` 实际上没有被使用，那么 `funcA` 和 `funcE` 就会被 `terser` 移除掉。 这样， `example.2` 就完成了 `statements - level` 的 `tree-shaking`。

最后，将每个 `chunk` 的构建内容输出到 `output` 配置项指定的位置，`webpack` 的打包就完成了。打包的结果如下：

```javascript
// main.js
(self.webpackChunkwebpack_treeshaking=self.webpackChunkwebpack_treeshaking||[]).push([[179],
    {
        "./index.js":(e,s,c)=>{
            "use strict";
            var n=c("./src/example.2.js");
            c.e(394).then(c.bind(c,"./src/example.3.js")).then((e=>{console.log("123")})),(0,n.Ii)()
        },
        "./src/example.2.js":(e,s,c)=>{
            "use strict";
            c.d(s,{Ii:()=>n,A_:()=>l});
            const n=()=>{console.log("funcB")},l=()=>{console.log("funcD")}
        }
    },0,[["./index.js",303]]]);

```

```
// example.3.js
(self.webpackChunkwebpack_treeshaking=self.webpackChunkwebpack_treeshaking||[]).push([[394],{
    "./src/example.1.js":(e,s,c)=>{
        "use strict";
        function n(){console.log("funcA")}
        c.d(s,{Z:()=>n})
    },
    "./src/example.3.js":(e,s,c)=>{
        "use strict";
        c.r(s),
        c.d(s,{funcF:()=>a,funcH:()=>o});
        var n=c("./src/example.2.js"),l=c("./src/example.1.js");
        const a=()=>{(0,n.A_)(),(0,l.Z)(),console.log("funcF")},o=()=>{console.log("funcH")
    }
}}]);
```



### 写在最后

最后，我们再来做一个总结：

- `tree shaking` 有两种 `level：modules-level` 和 `statements-level`。`modules-level` 会将为未使用的模块移除， `statements-level` 会将模块未使用的 `export` 移除。
- `modules-level` 需要设置 `optimization.sideEffects` 为 `true`。
- `statements-level` 需要配置 `optimization.usedExports`、`optimization.minimize` 为 `true`。
- 必须使用 `ES6 - import` 的方式引用模块，否则 `tree shaking` 不生效；



