⽤`webpack`优化前端性能是指优化`webpack`的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。 

# 一、优化构建速度

`webpack`在启动后，会根据`Entry`配置的入口，递归解析所依赖的文件。这个过程分为**搜索文件**和**把匹配的文件进行分析、转化**的两个过程，因此可以从这两个角度来进行优化配置。

## 1、缩小文件的搜索范围

### 1.1、`resolve`相关配置

`resolve`字段告诉`webpack`怎么去搜索文件，所以首先要重视`resolve`字段的配置：

`resolve`用来**配置模块如何解析**。例如，当在 `ES2015` 中调用 `import 'lodash'`，`resolve` 选项能够对`webpack` 查找`'lodash'` 的方式去做修改。

```
// webpack.config.js

module.exports = {
  //...
  resolve: {
    // configuration options
  }
};
```

```
module.export = {
  resolve: {
    modules:[path.resolve(__dirname, 'node_modules')]
    extensions: ['.js', '.jsx'],
    mainFiles: ['index', 'child']，
    alias: {
       '@/src': path.resolve(__dirname, `../src`),  // 当看到@/src这个路径或字符串的时候，实际上指向的是../src目录
    }
  }
}
```

#### 1.1.1、`resolve.modules`

`resolve.modules`告诉`webpack`去哪些目录下寻找第三方模块，默认值为`['node_modules']`，寻找第三方，默认是在当前项目目录下的`node_modules`里面去找，如果没有找到，就会去上一级目录`../node_modules`找，再没有会去`../../node_modules`中找，以此类推，和`Node.js`的模块寻找机制很类似。

**绝对路径和相对路径**都能使用，相对路径将类似于 `Node` 查找 '`node_modules`' 的方式进行查找。**使用绝对路径，将只在给定目录中搜索**。

```
// webpack.config.js

module.exports = {
  //...
  resolve: {
    modules: ['node_modules'] // 相对路径写法，会按./node_modules, ../node_modules的方式查找
  }
};
```

如果你想要添加一个目录到模块搜索目录，此目录优先于 `node_modules/` 搜索：

```
// webpack.config.js

module.exports = {
  //...
  resolve: {
    modules: [path.resolve(__dirname, 'src'), 'node_modules'] // 绝对路径写法
  }
};
```

**使用绝对路径之后，将只在给定目录中搜索，从而减少模块的搜索层级**

```
// config/webpack.common.js
// ...

const commonConfig = {
  // ...
  resolve: {
    extensions: ['.js', '.jsx'],
    mainFiles: ['index', 'list'],
    alias: {
      alias: path.resolve(__dirname, '../src/alias'),
    },
    modules: [
      path.resolve(__dirname, 'node_modules'), // 指定当前目录下的 node_modules 优先查找
      'node_modules', // 将默认写法放在后面
    ]
  },
  // ...
}
// ...

```

#### 1.1.2、`resolve.alias`

创建 `import` 或 `require` 的别名，能把原导入路径映射成一个新的导入路径，来**确保模块引入变得更简**单。

比如我们项目中可能会有一些相对路径的写法，就可以使用 `alias` 配置来减少查找过程；

还比如我们经常使用的 `react` 库，⼀般存在两套代码：

- `cjs`

  采⽤`commonJS`规范的模块化代码

- umd

  已经打包好的完整代码，没有采⽤模块化，可以直接执⾏

默认情况下，`webpack`会从⼊⼝⽂件`./node_modules/bin/react/index`开始递归解析和处理依赖的⽂件。我们可以直接指定⽂件，这样就能跳过耗时的模块解析，具体示例配置如下：

```
// config/webpack.common.js
// ...
const commonConfig = {
  // ...
  resolve: {
    // ...
    alias: {
      react: path.resolve(__dirname, './node_modules/react/dist/react.min.js'),
      @alias: path.resolve(__dirname, '../src/alias'),
    },
  },
  // ...
}
// ...
```

也可以在给定对象的键后的末尾添加 `$`，以表示精准匹配：

```
module.exports = {
  //...
  resolve: {
    alias: {
      xyz$: path.resolve(__dirname, 'path/to/file.js')
    }
  }
};
```

这将产生以下结果：

```
import Test1 from 'xyz'; // 精确匹配，所以 path/to/file.js 被解析和导入
import Test2 from 'xyz/file.js'; // 非精确匹配，触发普通解析
```

#### 1.1.3、`resolve.extensions`

在导入语句没带文件后缀时，`webpack` 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置 的 `resolve.extensions` 顺序从前到后查找，`webpack` 默认支持的后缀是 `js` 与 `json`。

举个🌰：如果我们配置 `resolve.extensions= ['js', 'json']`，那么 `webpack` 会先找 `xxx.js`

如果没有则再查找 `xxx.json`，所以我们应该把常用到的文件后缀写在前面，或者 **我们导入模块时，尽量带上文件后缀名。**

> 虽然 `extensions` 会优先查找数组内的值，但是我们不要一股脑儿的把所有后缀都往里面塞，这会调用多次文件的查找，这样就会减慢打包速度。

默认值：`extensions:['.js', '.json']`,当导入语句没带文件后缀时，`Webpack`会根据`extensions`定义的后缀列表进行文件查找，所以：

- 列表值尽量少
- 频率高的文件类型的后缀写在前面
- 源码中的导入语句尽可能的写上文件后缀，如`require(./data)`要写成`require(./data.json)`

常用写法：

```
extensions: ['.js', '.json', '.ts', '.tsx', '.scss']
```

#### 1.1.4、`resolve.mainFields`

设置尽量少的值可以减少入口文件的搜索步骤 第三方模块为了适应不同的使用环境，会定义多个入口文件，`mainFields`定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用`main`字段描述入口文件的位置，所以可以设置单独一个`main`值，减少搜索

```
resolve.mainFields:['main']
```

### 1.2、优化`Loader`配置

 由于`Loader`对文件的转换操作很耗时，所以需要让尽可能少的文件被`Loader`处理。配置`Loader`时，通过`test、exclude、include`等缩小搜索范围

```
// config/webpack.common.js
// ...
const commonConfig = {
  // ...
  module: {
    rules: [
      { 
        test: /\.js|jsx$/, 
        exclude: /node_modules/,
        include: path.resolve(__dirname, '../src'),
        use: ['babel-loader']
      },
      // ...
    ]
  },
}
// ...
```

首先我们不加 `exclude` 和 `include` 两个参数，打包一下 `npm run build`，打包时间 `3350ms` 左右：

![webpack199](..\images\webpack199.png)

接着我们加上这两个参数，意思分别是：

- `exclude: /node_modules/`：排除 `node_modules` 下面的文件
- `include: path.resolve(__dirname, '../src')`：只对 `src` 下面的文件使用

重新打包一下，打包时间变成了 `1400ms` 左右：

![webpack200](..\images\webpack200.png)

### 1.3、`module.noParse`

`module.noParse`字段告诉`Webpack`不必解析哪些文件，可以用来排除对非模块化库文件的解析。

如`jQuery、ChartJS`，另外如果使用`resolve.alias`配置了`react.min.js`，则也应该排除解析，因为`react.min.js`经过构建，已经是可以直接运行在浏览器的、非模块化的文件了。`noParse`值可以是`RegExp、[RegExp]、function`

```
module:{ noParse:[/jquery|chartjs/, /react\.min\.js$/]}
```

## 2、分离两套配置

**一般来说在项目开发中，我们会区分开发和生产环境两套配置，各司其职。**

在开发阶段：我们需要 `webpack-dev-server` 来帮我们进行快速的开发，同时需要 **`HMR` 热更新** 帮我们进行页面的无刷新改动，而这些在 **生产环境** 中都是不需要的。

在生产阶段：我们需要进行 **代码压缩**、**目录清理**、**计算 `hash`**、**提取 `CSS`** 等等；

实现起来很简单，我们前面也提到过，就新建三个 `webpack` 的配置文件就行：

- `webpack.dev.js`：开发环境的配置文件
- `webpack.prod.js`：生产环境的配置文件
- `webpack.common.js`：公共配置文件

通过 `webpack-merge` 来整合两个配置文件共同的配置 `webpack.common.js`，具体可以参照源码。

先安装

```js
npm install webpack-merge -D
```

创建`webapck.dev.js`文件

```js
const {merge} = require("webpack-merge")
const commonConfig = require("./webpack.common.js")
const devConfig = {
 ...
}
module.exports = merge(commonConfig,devConfig)
```

创建`webpack.prod.js`文件

```js
const {merge} = require("webpack-merge")
const commonConfig = require("./webpack.common.js")
const prodConfig = {
 ...
}
module.exports = merge(commonConfig,prodConfig)
```

`package.js`

```js
"scripts":{
 "dev":"webpack-dev-server --config ./webpack.dev.js",
 "build":"webpack --config  ./webpack.prod.js"
}
```

#### 基于环境变量区分

借助`cross-env`

```js
npm i cross-env -D
```

`package`⾥⾯配置命令脚本，传⼊参数

```js
"test:build": "cross-env NODE_ENV=production webpack --config ./webpack.test.config.js",
"test:dev": "webpack-dev-server --config ./webpack.test.config.js"
```

在`webpack.config.test.js`⾥拿到参数进行判断

```js
const baseConfig = require("./webpack.config.base.js");
const devConfig = require("./webpack.config.dev.js");
const prodConfig = require("./webpack.config.prod.js");
const {merge} = require("webpack-merge");

console.log(process.env.NODE_ENV)
module.exports = (process.env.NODE_ENV)=>{
 if(process.env.NODE_ENV && process.env.NODE_ENV.production){
 return merge(commonConfig,prodConfig)
 }else{
 return merge(commonConfig,devConfig)
 } }
```

## 3、利用多线程提升构建速度

由于运行在 `Node.js` 之上的 `webpack` 是单线程模型的，所以 `webpack` 需要处理的事情需要一件一件的做，不能多件事一起做。

如果 `webpack`  能同一时间处理多个任务，发挥多核 `CPU` 电脑的威力，那么对其打包速度的提升肯定是有很大的作用的。

#### `HappyPack`

原理：每次 `webapck` 解析一个模块，`HappyPack` 会将它及它的依赖分配给 `worker` 线程中。处理完成之后，再将处理好的资源返回给 `HappyPack` 的主进程，从而加快打包速度。

![webpack209](..\images\webpack209.png)

> 在 `webpack4.0` 中使用 `happypack` 需要使用其 `5.0` 版本。

我们将 `HappyPack` 引入公共配置文件，他的用法就是将相应的 `loader` 替换成 `happypack/loader`，同时将替换的 `loader` 放入其插件的 `loaders` 选项，我们暂且替换一下 `babel-loader`：

```
// config/webpack.common.js
// ...
const makePlugins = (configs) => {
  const plugins = [
    // ...
    new HappyPack({
      loaders: ['babel-loader']
    }),
  ];
  // ...
  return plugins;
}
// ...

const commonConfig = {
  entry: {
    main: "./src/index.js",
    entry2: "./src/entry2.js",
    entry3: "./src/entry3.js",
    entry4: "./src/entry4.js",
    entry5: "./src/entry5.js",
    entry6: "./src/entry6.js",
  },
  // ...
  module: {
    rules: [{ 
      test: /\.jsx?$/, 
      // exclude: /node_modules/,
      // include: path.resolve(__dirname, '../src'), 
      use: [
        'happypack/loader'
        // 'babel-loader'
      ]
    }]
  },
  // ...
}
// ...

```

为了让效果更加明显一点，我们在项目下多增加几个入口文件，在不使用 `happypack` 的情况下，进行一次打包，时间差不多是 `8s` 多：

![webpack210](..\images\webpack210.png)

开启 `happypack` 之后，我们可以从控制台中看到，`happypack` 默认帮我们开启了 `3` 个进程，打包时间变成了`6.5s` 左右：

![webpack211](..\images\webpack211.png)

> 注意：`HappyPack` 的作者现在基本上也不维护这个插件了，因为作者对此项目的兴趣正在减弱。他也推荐我们使用 `webpack` 官方 [thread-loader](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fthread-loader)。

#### `thread-loader`

`webpack` 官方推出的一个多进程方案，用来替代 `HappyPack`。

原理和 `HappyPack` 类似，`webpack` 每次解析一个模块，`thread-loader` 会将它及它的依赖分配给 `worker` 线程中，从而达到多进程打包的目的。

使用很简单，直接在我们使用的 `loader` 之前加上 `thread-loader` 就行，我们需要先注释掉 `HappyPack` 代码：

```
// config/webpack.common.js
// ...
const commonConfig = {
  // ...
  module: {
    rules: [{ 
      test: /\.jsx?$/, 
      // exclude: /node_modules/,
      // include: path.resolve(__dirname, '../src'), 
      use: [
        {
          loader: 'thread-loader',
          options: {
            workers: 3, // 开启几个 worker 进程来处理打包，默认是 os.cpus().length - 1
          }
        },
        'babel-loader'
      ]
    }]
  },
  // ...
}
// ...

```

我们重新运行一下，也是差不多 `6.5s` 左右：

![webpack212](..\images\webpack212.png)

## 4、预先编译资源模块（`DllPlugin`）

我们在打包的时候，一般来说第三方模块是不会变化的，所以我们想只要在第一次打包的时候去打包一下第三方模块，并将第三方模块打包到一个特定的文件中，当第二次 `webpack` 进行打包的时候，就不需要去 `node_modules` 中去引入第三方模块，而是直接使用我们第一次打包的第三方模块的文件就行。

`webpack.DllPlugin` 就是来解决这个问题的插件，使用它可以在第一次编译打包后就生成一份不变的代码供其他模块引用，这样下一次构建的时候就可以节省开发时编译打包的时间。

##### 添加配置文件

我们在配置文件目录 `config` 下新建一个 `webpack.dll.js`，此文件用于将我们的第三方包文件打包到 `dll` 文件夹中去：

```
// config/webpack.dll.js
const path = require('path');
const webpack = require('webpack');

module.exports = {
  mode: 'production', // 环境
  entry: {
    vendors: ['lodash'], // 将 lodash 打包到 vendors.js 下
    react: ['react', 'react-dom'], // 将 react 和 react-dom 打包到 react.js 下
  },
  output: {
    filename: '[name].dll.js', // 输出的名字
    path: path.resolve(__dirname, '../dll'), // 输出的文件目录
    library: '[name]' // 将我们打包出来的文件以全部变量的形式暴露，可以在浏览器变量的名字进行访问
  },
  plugins: [
    // 对生成的库文件进行分析，生成库文件与业务文件的映射关系，将结果放在 mainfest.json 文件中
    new webpack.DllPlugin({
      name: '[name]', // 和上面的 library 输出的名字要相同
      path: path.resolve(__dirname, '../dll/[name].manifest.json'),
    })
  ]
}

```

- 上面的 `library` 的意思其实就是将 `dll` 文件以一个全局变量的形式导出出去，便于接下来引用，如下图：
- `mainfest.json` 文件是一个映射关系，它的作用就是帮助 `webpack` 使用我们之前打包好的 `***.dll.js` 文件，而不是重新再去 `node_modules` 中去寻找。

我们在命令行中打包一下 `dll` 文件，可以看到根目录生成了一个 `dll` 文件夹，并且在下面生成了相应的文件，并且 `loader` 打包到了 `vendor.dll.js` 中，`react` 和 `react-dom` 打包到了 `react.dll.js` 中了：

![webpack213](..\images\webpack213.png)

接着我们需要去修改公共配置文件 `webpack.common.js`，将我们之前生成的 `dll` 文件导入到 `html` 中去，如果我们不想自己手动向 `html` 文件去添加 `dll` 文件的时候，我们可以借助一个插件 `add-asset-html-webpack-plugin`，此插件顾名思义，就是将一些文件加到 `html` 中去。

同时我们需要使用 `webpack` 自带的 `DllReferencePlugin` 插件对 `mainfest.json` 映射文件进行分析。

```
// config/webpack.common.js
const webpack = require('webpack');
const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');

// ...

const commonConfig = {
  // ...
  plugins: [
    // ...
    new AddAssetHtmlWebpackPlugin({
      filepath: path.resolve(__dirname, '../dll/vendors.dll.js')
    }),
    new AddAssetHtmlWebpackPlugin({
      filepath: path.resolve(__dirname, '../dll/react.dll.js')
    }),
    new webpack.DllReferencePlugin({
      manifest: require(path.resolve(__dirname, '../dll/vendors.dll.mainfest.json'))
    }),
    new webpack.DllReferencePlugin({
      manifest: require(path.resolve(__dirname, '../dll/react.dll.mainfest.json'))
    }),
  ],
  // ...
}
// ...

```

我们进行一次打包，可以看到打包耗时为 `1450ms` 左右，同时可以看到库文件打包到的 `vendors.chunk.js` 为 `1.22MB`。

![webpack214](..\images\webpack214.png)

我们注释掉对 `dll` 的引用分析之后，重新打包，打包耗时为 `1950ms` 左右，同时可以看到 `vendors.chunk.js` 为 `5.28MB`。

![webpack215](..\images\webpack215.png)

## 5、缓存 Cache 相关

我们可以开启相应 `loader` 或者 `plugin` 的缓存，来提升二次构建的速度。一般我们可以通过下面几项来完成：

- `babel-loader` 开启缓存
- `terser-webpack-plugin` 开启缓存
- 使用 `cache-loader` 或者 [hard-source-webpack-plugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmzgoddard%2Fhard-source-webpack-plugin)

如果项目中有缓存的话，在 `node_modules` 下会有相应的 `.cache` 目录来存放相应的缓存。

#### `babel-loader`

首先我们开启 `babel-loader` 的缓存，我们修改 `babel-loader` 的参数，将参数 `cacheDirectory` 设置为 `true`：

```
// config/webpack.common.js
// ...
module: {
  rules: [
    { 
      test: /\.jsx?$/, 
      // exclude: /node_modules/,
      // include: path.resolve(__dirname, '../src'), 
      use: [
        {
          loader: 'babel-loader',
          options: {
            cacheDirectory: true,
          }
        },
      ]
    },
  ]
}         
// ...
```

首次打包时间为 `8.5s` 左右，打包完成之后，我们可以发现在 `node_modules` 下生成了一个 `.cache` 目录，里面存放了 `babel` 的缓存文件：

![webpack216](..\images\webpack216.png)

![webpack217](..\images\webpack217.png)

我们重新打包一次，会发现时间变成了 `6s` 左右：

![webpack218](..\images\webpack218.png)

#### `TerserPlugin`

我们通过将 `TerserPlugin` 中的 `cache` 设为 `true`，就可以开启缓存：

```
// config/webpack.common.js
const TerserPlugin = require('terser-webpack-plugin');
// ...
const commonConfig = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1
        cache: true,
      }),
    ],
  },
  // ...
}
```

首次打包时间为 `8-9s` 左右，同时在 `.cache` 目录下生成了 `terser-webpack-plugin` 缓存目录：

![webpack219](..\images\webpack219.png)

![webpack220](..\images\webpack220.png)

我们重新打包一次，会发现时间变成了 `5s` 左右：

![webpack221](..\images\webpack221.png)

#### `HardSourceWebpackPlugin`

这个插件其实就是用于给模块提供一个中间的缓存。

使用如下，我们直接在插件中引入就 `ok` 了：

```
// config/webpack.common.js
const HardSourceWebpackPlugin = require('hard-source-webpack-plugin');
// ...
const plugins = [
  // ...
  new HardSourceWebpackPlugin(),
];
// ...
```

我们打包一下，可以看到在第一次打包的时候 `HardSourceWebpackPlugin` 就帮我们开始生成打包文件了，同时在 `.cache` 目录生成了 `hard-source` 目录，第一次打包耗时 `6.6s` 左右：

![webpack222](..\images\webpack222.png)

![webpack223](..\images\webpack223.png)

我们重新打包一次，会发现时间变成了 `2.7s` 左右：

![webpack224](..\images\webpack224.png)

# 二、优化输出质量-压缩文件体积

`webpack` 是个项目打包工具，一般项目打完包以后，需要发布到服务器上供用户使用，为了用户体验，我们的项目体积需要越小越好，所以 `webpack` 中打包的体积是 `webpack` 中重要的一环。

### 1、区分环境--减小生产环境代码体积

代码运行环境分为**开发环境**和**生产环境**，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的`if else`代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。`Webpack`中使用`DefinePlugin`插件来定义配置文件适用的环境。

### 2、`js` 压缩

`webpack4.0` 默认在生产环境的时候是支持代码压缩的，即 `mode=production` 模式下。

实际上 `webpack4.0` 默认是使用  [terser-webpack-plugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fterser-webpack-plugin) 这个压缩插件，在此之前是使用 [uglifyjs-webpack-plugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fuglifyjs-webpack-plugin)，两者的区别是后者对 `ES6` 的压缩不是很好，同时我们可以开启 `parallel` 参数，使用多进程压缩，加快压缩。

```
// config/webpack.common.js
const TerserPlugin = require('terser-webpack-plugin');
// ...
const commonConfig = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1
      }),
    ],
  },
  // ...
}
```

### 3、`css` 压缩

我们可以借助 `optimize-css-assets-webpack-plugin` 插件来压缩 `css`，其默认使用的压缩引擎是 `cssnano`。 具体使用如下：

```
 体验AI代码助手 代码解读复制代码// config/webpack.prod.js
const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");
// ...
const prodConfig = {
  // ...
  optimization: {
    minimizer: [
      new OptimizeCSSAssetsPlugin({
        assetNameRegExp: /\.optimize\.css$/g,
        cssProcessor: require('cssnano'),
        cssProcessorPluginOptions: {
          preset: ['default', { discardComments: { removeAll: true } }],
        },
        canPrint: true,
      })
    ]
  },
}
```

#### 擦除无用的 `CSS`

使用 `PurgeCSS` 来完成对无用 `css` 的擦除，它需要和 `mini-css-extract-plugin` 配合使用。

```
 // config/webpack.common.js
const PurgecssPlugin = require('purgecss-webpack-plugin');
// ...
const PATHS = {
  src: path.join(__dirname, './src')
};

const commonConfig = {
  // ...
  plugins: [
    // ...
    new PurgecssPlugin({
      paths: glob.sync(`${PATHS.src}/**/*`,  { nodir: true }),
    }),
  ]
  // ...
}
```

在未使用此插件之前，比如我们只用到了 `navcontact` 这个类，其他的都没有用到，我们在未引入之前打包一下，发现未用到的 `css` 还是会被打包进去：

![webpack201](..\images\webpack201.png)

引入插件后，重新进行打包，发现没有用到的 `css` 都被擦除了：

![webpack202](..\images\webpack202.png)

### 4、压缩HTML

借助`html-webpack-plugin`

```js
new htmlWebpackPlugin({
   title: "京东商城",
   template: "./index.html",
   filename: "index.html",
   minify: {
     // 压缩HTML⽂件
     removeComments: true, // 移除HTML中的注释
     collapseWhitespace: true, // 删除空⽩符与换⾏符
     minifyCSS: true // 压缩内联css
  }
 }),
```

### 5、图片压缩

一般来说在打包之后，一些图片文件的大小是远远要比 `js` 或者 `css` 文件要来的大，所以我们首先要做的就是对于图片的优化，我们可以手动的去通过线上的图片压缩工具，如 [tiny png](https://link.juejin.cn?target=https%3A%2F%2Ftinypng.com%2F) 帮我们来压缩图片。

但是这个比较繁琐，在项目中我们希望能够更加自动化一点，自动帮我们做好图片压缩，这个时候我们就可以借助 [image-webpack-loader](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftcoopman%2Fimage-webpack-loader) 帮助我们来实现。它是基于 [imagemin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fimagemin%2Fimagemin) 这个 `Node` 库来实现图片压缩的。

使用很简单，我们只要在 `file-loader` 之后加入 `image-webpack-loader` 即可：

```
// config/webpack.common.js
// ...
module: {
  rules: [
    {
      test: /\.(png|jpg|gif)$/,
      use: [
        {
          loader: 'file-loader',
          options: {
            name: '[name]_[hash].[ext]',
            outputPath: 'images/',
          }
        },
        {
          loader: 'image-webpack-loader',
          options: {
            // 压缩 jpeg 的配置
            mozjpeg: {
              progressive: true,
              quality: 65
            },
            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭
            optipng: {
              enabled: false,
            },
            // 使用 imagemin-pngquant 压缩 png
            pngquant: {
              quality: '65-90',
              speed: 4
            },
            // 压缩 gif 的配置
            gifsicle: {
              interlaced: false,
            },
            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
            webp: {
              quality: 75
            }
          }
        }
      ]
    },
  ]
}         
// ...

```

我们先不使用这个 `loader` 打包一下，图片大小是 `2.1MB`：

![webpack203](..\images\webpack203.png)

使用 `image-webpack-loader` 之后，图片大小是 `666KB`：

![webpack204](..\images\webpack204.png)

### 6、使用`Tree Shaking`剔除`JS`死代码

`Tree Shaking`可以剔除用不上的死代码，它依赖`ES6`的`import、export`的模块化语法，最先在`Rollup`中出现，`Webpack 2.0`将其引入。适合用于`Lodash、utils.js`等工具类较分散的文件。它正常工作的前提是代码必须采用`ES6`的模块化语法，因为`ES6`模块化语法是静态的（在导入、导出语句中的路径必须是静态字符串，且不能放入其他代码块中）。如果采用了`ES5`中的模块化，例如`module.export = {...}、require( x+y )、if (x) { require( './util' ) }`，则`Webpack`无法分析出可以剔除哪些代码。

`tree shaking` 是一个术语，通常用于描述移除 `JavaScript` 上下文中的未引用代码(`dead-code`)。它依赖于 `ES2015`模块语法的 静态结构 特性，例如`import`和 `export`。这个术语和概念实际上是由 `ES2015` 模块打包工具 `rollup` 普及起来的。

`webpack 4`正式版本扩展了此检测能力，通过`package.json`的 `"sideEffects"` 属性作为标记，向 `compiler` 提供提示，表明项目中的哪些文件是 "`pure(纯的 ES2015 模块)`"，由此可以安全地删除文件中未使用的部分。

注意，所有导入文件都会受到`tree shaking` 的影响。这意味着，如果在项目中使用类似`css-loader` 并`import` 一个 `CSS` 文件，则需要将其添加到`side effect`列表中，以免在生产模式中无意中将它删除：

```
{
  "name": "your-project",
  "sideEffects": [
    "./src/some-side-effectful-file.js",
    "*.css"
  ]
}
```

通过 `import` 和 `export`语法，我们已经找出需要删除的“`未引用代码(dead code)`”，然而，不仅仅是要找出，还要在 `bundle` 中删除它们。为此，我们需要将 `mode`配置选项设置为 `production`。

`webpack.config.js`

```
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
- mode: 'development',
- optimization: {
-   usedExports: true
- }
+ mode: 'production'
};

```

```
注意，也可以在命令行接口中使用 --optimize-minimize 标记，来启用 TerserPlugin。
```

准备就绪后，然后运行另一个 `npm script npm run build`，就会看到输出结果发生了改变。

在 `dist/bundle.js` 中，现在整个 `bundle` 都已经被 `minify`(压缩) 和 `mangle`(混淆破坏)，但是如果仔细观察，则不会看到引入 `square` 函数，但能看到 `cube`函数的混淆破坏版本（`function r(e){return e*e*e}n.a=r`）。现在，随着 `minification`(代码压缩) 和`tree shaking`，我们的`bundle` 减小几个字节！虽然，在这个特定示例中，可能看起来没有减少很多，但是，在有着复杂依赖树的大型应用程序上运行 `tree shaking`时，会对 `bundle` 产生显著的体积优化。

> 运行 `tree shaking` 需要 `ModuleConcatenationPlugin`。通过 `mode: "production"` 可以添加此插件。如果你没有使用 `mode` 设置，记得手动添加 `ModuleConcatenationPlugin`。

**结论：** 我们已经知道，想要使用 `tree shaking` 必须注意以下几点：

- 使用 `ES2015`模块语法（即 `import` 和 `export`）。
- 确保没有 `compiler` 将 `ES2015` 模块语法转换为 `CommonJS`模块（这也是流行的 `Babel preset` 中 `@babel/preset-env` 的默认行为 - 更多详细信息请查看 文档）。
- 在项目`package.json` 文件中，添加一个`"sideEffects"` 属性。
- 通过将 `mode`选项设置为 `production`，启用 `minification`(代码压缩) 和`tree shaking`。

你可以将应用程序想象成一棵树。绿色表示实际用到的 `source code(源码)` 和 `library(库)`，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。

### 7、代码分割

#### 单⻚⾯应⽤spa：

打包完后，所有⻚⾯只⽣成了⼀个`bundle.js`。

- 代码体积变⼤，不利于下载
- 没有合理利⽤浏览器资源

#### 多⻚⾯应⽤`mpa`:

如果多个⻚⾯引⼊了⼀些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载⼀次就缓存起来了，避免了重复下载。

假如我们引⼊⼀个第三⽅的⼯具库，体积为`1mb`，⽽我们的业务逻辑代码也有`1mb`，那么打包出来的体积⼤⼩会在`2mb`，这就会导致问题：

- 文件体积⼤，加载时间⻓。
- 业务逻辑会变化，而第三⽅⼯具库不会，所以业务逻辑⼀变更，第三⽅⼯具库也要跟着变。

例如我们使用第三方库`lodash`：

```js
import _ from "lodash";
console.log(_.join(['a','b','c','****']))
```

其实代码分割概念与`webpack`并没有直接的关系，只不过`webpack`中提供了⼀种更加⽅便的⽅法供我们实现代码分割。

```js
optimization: {
   splitChunks: {
      chunks: "all", // 所有的 chunks 代码公共的部分分离出来成为⼀个单独的⽂件
    },
 },
```

打包后dist目录下多了一个文件`vendors~main.js`，这个文件就是分离出来的`lodash`

![webpack205](..\images\webpack205.png)

`splitChunks`的其他可配置项：

```js
optimization: {
splitChunks: {
      chunks: "async", //对同步 initial，异步 async，所有的模块有效 all
      minSize: 30000, //最⼩尺⼨，当模块⼤于30kb
      maxSize: 0, //对模块进⾏⼆次分割时使⽤，不推荐使⽤
      minChunks: 1, //打包⽣成的chunk⽂件最少有⼏个chunk引⽤了这个模块
      maxAsyncRequests: 5, //最⼤异步请求数，默认5
      maxInitialRequests: 3, //最⼤初始化请求书，⼊⼝⽂件同步请求，默认3
      automaticNameDelimiter: "-", //打包分割符号
      name: true, //打包后的名称，除了布尔值，还可以接收⼀个函数function
      cacheGroups: {
        //缓存组
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: "vendor", // 要缓存的 分隔出来的 chunk 名称
          priority: -10, //缓存组优先级 数字越⼤，优先级越⾼
        },
        other: {
          chunks: "initial", // 必须三选⼀： "initial" | "all" | "async"(默认就async)
          test: /react|lodash/, // 正则规则验证，如果符合就提取 chunk,
          name: "other",
          minSize: 30000,
          minChunks: 1,
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true, //可设置是否重⽤该chunk
        },
      },
    },
    }
```

我们可以配置缓存组

```js
splitChunks: {
      chunks: "all", // 所有的 chunks 代码公共的部分分离出来成为⼀个单独的⽂件
      automaticNameDelimiter: '-',//打包分割符号
      cacheGroups: {
        lodash: {
          test:/lodash/,
          name: "lodash"
        },
        react: {
          test: /react|react-dom/,
          name: "react"
        }
      }
    },
```

打包之后

![webpack206](..\images\webpack206.png)

一般使⽤下⾯配置即可：

```js
optimization:{
 //帮我们⾃动做代码分割
 splitChunks:{
  chunks:"all",//默认是⽀持异步，我们使⽤all
 } 
}
```

### 8、`CDN` 服务器加速

> `CDN`（`Content Delivery Network`，内容分发网络）是一种分布式网络服务，旨在通过将内容缓存到离用户更近的服务器上，来加速内容的分发和访问速度，同时提高网站的可用性和性能 
>  `CDN` 通过减少数据在网络中的传输距离，可以显著减少数据传输的延迟时间

####  `CDN`加速的原理

`CDN`通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入`CDN`，需要把网页的静态资源上传到`CDN`服务上，在访问这些资源时，使用`CDN`服务提供的`URL`。

由于`CDN`会为资源开启长时间的缓存，例如用户从`CDN`上获取了`index.html`，即使之后替换了`CDN`上的`index.html`，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：

- `HTML`文件：放在自己的服务器上且关闭缓存，不接入`CDN`
- 静态的`JS、CSS、图片等资源`：开启`CDN`和缓存，同时文件名带上由内容计算出的`Hash`值，这样只要内容变化`hash`就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。

另外，`HTTP1.x`版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在`4~8`个。那么把所有静态资源放在同一域名下的`CDN`服务上就会遇到这种限制，所以可以把他们分散放在不同的`CDN`服务上，例如`JS`文件放在`js.cdn.com`下，将`CSS`文件放在`css.cdn.com`下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过`dns-prefetch`来解决`<link rel='dns-prefetch' href='//js.cdn.com'>` 来缩减域名解析的时间。形如`**//xx.com 这样的URL省略了协议**`，这样做的好处是，浏览器在访问资源时会自动根据当前`URL`采用的模式来决定使用`HTTP`还是`HTTPS`协议。

当浏览器从第三方服务跨域请求资源的时候，在浏览器发起请求之前，这个第三方的跨域域名需要被解析为一个`IP`地址，这个过程就是`DNS`解析，`DNS`缓存可以用来减少这个过程的耗时，`DNS`解析可能会增加请求的延迟，对于那些需要请求许多第三方的资源的网站而言，`DNS`解析的耗时延迟可能会大大降低网页加载性能。

####  总之，构建需要满足以下几点：

- 静态资源导入的`URL`要变成指向`CDN`服务的绝对路径的`URL`
- 静态资源的文件名需要带上根据内容计算出的`Hash`值
- 不同类型资源放在不同域名的`CDN`上

#### 在开发中，我们使用 `CDN` 主要是两种方式：

- 方式一：打包的所有静态资源，放到 `CDN`服务器，用户所有资源都是通过 `CDN`服务器加载的
- 方式二：一些第三方资源放到 `CDN`服务器上

#### 方式一

- 如果所有的资源都放在 `CDN` 服务器上，需要购买自己的 `CDN` 服务器，然后在 `webpack.config.json` 中配置 `CDN`  地址

  ```
  module.exports = {
      output: {
          clean: true,
          path: path.resolve(__dirname, './build'),
          publicPath: 'http://xxx.xxx.cdn.com/'
      }
  }
  ```

- 然后打包后的 `html` 对文件的引入有变化

  ![webpack207](..\images\webpack207.png)

#### 方式二

- 一些比较出名的开源第三方库都会将打包后的源码放在出名且免费的 `CDN` 服务器上

- 在项目中，如果使用可以直接在 `html`模板中引入，然后配置下相关信息即可

  ![webpack208](..\images\webpack208.png)

```
module.exports = {
    // 排除某些包不需要进行打包
      externals: {
          react: "React",
          // key属性名: 排除的框架的名称
          // value值: 从CDN地址请求下来的js中提供对应的名称
          axios: "axios"
      }
}
```

#### 最终配置：

```
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const {WebPlugin} = require('web-webpack-plugin');
//...
output:{
 filename: '[name]_[chunkhash:8].js',
 path: path.resolve(__dirname, 'dist'),
 publicPatch: '//js.cdn.com/id/', //指定存放JS文件的CDN地址
},
module:{
 rules:[{
     test: /\.css/,
     use: ExtractTextPlugin.extract({
         use: ['css-loader?minimize'],
         publicPatch: '//img.cdn.com/id/', //指定css文件中导入的图片等资源存放的cdn地址
     }),
 },{
    test: /\.png/,
    use: ['file-loader?name=[name]_[hash:8].[ext]'], //为输出的PNG文件名加上Hash值 
 }]
},
plugins:[
  new WebPlugin({
     template: './template.html',
     filename: 'index.html',
     stylePublicPath: '//css.cdn.com/id/', //指定存放CSS文件的CDN地址
  }),
 new ExtractTextPlugin({
     filename:`[name]_[contenthash:8].css`, //为输出的CSS文件加上Hash
 })
]


```

