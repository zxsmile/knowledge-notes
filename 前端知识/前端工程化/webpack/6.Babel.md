# 一、Babel 的出身

babel 最开始叫 6to5，顾名思义是 es6 转 es5，但是后来随着 es 标准的演进，有了 es7、es8 等， 6to5 的名字已经不合适了，所以改名为了 babel。

babel 是巴别塔的意思，来自圣经中的典故：

> 当时人类联合起来兴建希望能通往天堂的高塔，为了阻止人类的计划，上帝让人类说不同的语言，使人类相互之间不能沟通，计划因此失败，人类自此各散东西。此事件，为世上出现不同语言和种族提供解释。这座塔就是巴别塔。

这很符合 babel 的转译器的定位。所以就命名为 Babel。

# 二、Babel 是什么？

**Babel 是一个 JavaScript 编译器。**

上面这句话就是Babel的本质，更简单的说，Babel可以把使用ES6/ES7等“高级”语法编写的Javascript代码转换为ES5/ES3的“通俗”语法（也可以把JSX语法转为Javascript）。

随着ECMAScript 标准规范发展越来越快，新语法层出不穷，然而浏览器更新却存在着滞后性，对ECMAScript新标准支持程度不一，Web前端开发者眼巴巴看着各种“高大上”、“简洁”、“实用”的语法和API，却不敢在实际项目中直接使用，以免由于浏览器不兼容导致各种问题，于是Babel诞生了！

从此以后，我们也可以尽情地使用“高大上”的ES6+高级语法了，只要经过Babel转换，最终输出的代码是啥样的我们不再那么关心，只要浏览器能读懂并执行就行。

也许你会担心经过Babel转换后的代码太过难以阅读，调试起来会非常困难。幸好Babel支持了一个叫做Source map的特性，使我们调试起来也和直接写ES5/ES3代码的调试方式一样简单，而这对我们来说，只需要启用一个配置项就可以做到。

# 三、Babel在前端工程流中的角色定位

我们知道，如今前端工程流中最耳熟能详的一个词是：`Webpack`. 现在很多前端项目脚手架都内置依赖了webpack，且提供了一套默认配置，做到开箱即用。我们只需要按照官网文档给出的步骤，一个命令一个命令去执行，如`npm run serve`、`npm run build`...，即可实现大部分开发场景需求，在需要定制化的情况下，甚至自己建一个`vue.config.js`文件去按照文档说明扩展配置即可，不再需要了解webpack的具体用法就能“叱咤Vue界”。

这是前端工程化发展的必然，有句话说得好，“懒人改变世界”，技术的发展造福了更多的懒人。在这样的大背景下，Webpack的细节被隐藏和弱化，更别提Babel了。我们可以在项目看到一个`.babelrc`文件，却大部分时间都不会注意到它，更别说打开它和编辑它了。

但就是这么一个低存在感的小透明，却承担起了巨大的责任，在背后默默工作，辛苦地把你新编写的ES6 `class`转换成了平凡的构造函数，在你`Ctrl + S`之后看到浏览器页面焕然一新的瞬间，你可会想到这个小透明做的事情有多么伟大？当然，这一切也离不开老大哥Webpack的提携，在Webpack的Loader机制下，Babel在这里作为**Webpack loader角色**的一员勤勤恳恳工作着。

除了作为Webpack loader，Babel当然也能孤军奋战，独当一面。

# 四、Babel的编译流程

## 1、编译过程解析

一般编译器（Compiler） 是指高级语言到低级语言的转换工具，特殊的，高级语言到高级语言的转换工具，被叫做转换编译器，简称转译器 (Transpiler)。

**高级语言**：有很多用于描述逻辑的语言特性，比如分支、循环、函数、面向对象等，接近人的思维，可以让开发者快速的通过它来表达各种逻辑。比如 c++、javascript。

**低级语言**：与硬件和执行细节有关，会操作寄存器、内存，具体做内存与寄存器之间的复制，需要开发者理解熟悉计算机的工作原理，熟悉具体的执行细节。比如汇编语言、机器语言。

**babel 就是一个 Javascript Transpiler。**

![webpack87](..\images\webpack87.png)

由此可以看到babel的核心就是 **parse（解析）**、**transform（转化）** 和 **generator（生成）** 三个部分

#### parse

`babylon`（babel 内部使用的解析类库叫做 `babylon`，现在改名叫`@babel/parser`） 负责将es6代码进行语法分析和词法分析后转换成抽象语法树AST

#### transform

其中第二步的转化是重中之重，babel的插件机制也是在这一步发挥作用的。也就是说，`babel`是依赖于`babel插件`进行代码转换的，默认`babel`是没有插件的，**没有安装插件的`babel`只是会将源码生成`AST`树，然后在通过生成器生成和原来的源码一摸一样的代码**，这样`babel`没有起到代码转换的效果！所以如果没有这些plugins进驻平台，那么babel这个“平台”是不具备任何能力的。

`babel`插件发挥作用的地方基本都是在tranfrom这个阶段，只要安装好`babel`转换类插件就可以转换出想要的代码。 plugin插件使用 `@babel/traverse` 来遍历 AST 并进行节点的操作，用它提供的 API（调用 visitor 函数修） 来编写对 AST 的遍历和修改逻辑，修改 AST 自然涉及到 AST 的判断、创建、修改等，这时候就需要 @babel/types 了，当需要批量创建 AST 的时候可以使用 @babel/template 来简化 AST 创建逻辑，由此来将一种AST转换为另一种AST，再交给第三步的`@babel/generator`。 

**在 transform 阶段，会应用各种内置的插件来完成 AST 的转换。内置插件做的转换包括两部分，一是把不支持的语法转成目标环境支持的语法来实现相同功能，二是不支持的 api 自动引入对应的 polyfill。**

#### generator

`@babel/generator`负责通过AST树生成ES5代码，同时生成 sourcemap。

而这整个过程，由`@babel/core` 负责编译过程的控制和管理。基于上面的包完成 babel 整体的编译流程，并实现插件功能。

## 2、访问者模式

转换器会遍历 AST 树，找出自己感兴趣的节点类型, 再进行转换操作. 这个过程和我们操作`DOM`树差不多，只不过目的不太一样。AST 遍历和转换一般会使用[`访问者模式`](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1f1049d0a0f4)。

想象一下，Babel 有那么多插件，如果每个插件自己去遍历AST，对不同的节点进行不同的操作，维护自己的状态。这样子不仅低效，它们的逻辑分散在各处，会让整个系统变得难以理解和调试， 最后插件之间关系就纠缠不清，乱成一锅粥。

**所以转换器操作 AST 一般都是使用`访问器模式`，由这个`访问者(Visitor)`来 ① 进行统一的遍历操作，② 提供节点的操作方法，③ 响应式维护节点之间的关系；而插件(设计模式中称为‘具体访问者’)只需要定义自己感兴趣的节点类型，当访问者访问到对应节点时，就调用插件的访问(visit)方法**。

### 2.1、节点的遍历

假设我们的代码如下:

```
 码function hello(v) {
  console.log('hello' + v + '!')
}
```



解析后的 AST 结构如下:

```
 File
  Program (program)
    FunctionDeclaration (body)
      Identifier (id)  #hello
      Identifier (params[0]) #v
      BlockStatement (body)
        ExpressionStatement ([0])
          CallExpression (expression)
            MemberExpression (callee)  #console.log
              Identifier (object)  #console
              Identifier (property)  #log
            BinaryExpression (arguments[0])
              BinaryExpression (left)
                StringLiteral (left)  #'hello'
                Identifier (right)  #v
              StringLiteral (right)  #'!'
```

访问者会以`深度优先`的顺序, 或者说递归地对 AST 进行遍历，其调用顺序如下图所示:

![webpack107](..\images\webpack107.png)

上图中`绿线`表示进入该节点，`红线`表示离开该节点。下面写一个超简单的'具体访问者'来还原上面的遍历过程:

```
const babel = require('@babel/core')
const traverse = require('@babel/traverse').default

const ast = babel.parseSync(code)

let depth = 0
traverse(ast, {
  enter(path) {
    console.log(`enter ${path.type}(${path.key})`)
    depth++
  },
  exit(path) {
    depth--
    console.log(`  exit ${path.type}(${path.key})`)
  }
})
```

代码执行结果

```
 enter Program(program)
   enter FunctionDeclaration(0)
     enter Identifier(id)
     exit Identifier(id)
     enter Identifier(0)
     exit Identifier(0)
     enter BlockStatement(body)
       enter ExpressionStatement(0)
         enter CallExpression(expression)
           enter MemberExpression(callee)
             enter Identifier(object)
             exit Identifier(object)
             enter Identifier(property)
             exit Identifier(property)
           exit MemberExpression(callee)
           enter BinaryExpression(0)
             enter BinaryExpression(left)
               enter StringLiteral(left)
               exit StringLiteral(left)
               enter Identifier(right)
               exit Identifier(right)
             exit BinaryExpression(left)
             enter StringLiteral(right)
             exit StringLiteral(right)
           exit BinaryExpression(0)
         exit CallExpression(expression)
       exit ExpressionStatement(0)
     exit BlockStatement(body)
   exit FunctionDeclaration(0)
 exit Program(program)

```



当访问者进入一个节点时就会调用 `enter(进入)` 方法，反之离开该节点时会调用 `exit(离开)` 方法。 一般情况下，插件不会直接使用`enter`方法，只会关注少数几个节点类型，所以具体访问者也可以这样声明访问方法:

```
traverse(ast, {
  // 访问标识符
  Identifier(path) {
    console.log(`enter Identifier`)
  },
  // 访问调用表达式
  CallExpression(path) {
    console.log(`enter CallExpression`)
  },
  // 上面是enter的简写，如果要处理exit，也可以这样
  // 二元操作符
  BinaryExpression: {
    enter(path) {},
    exit(path) {},
  },
  // 更高级的, 使用同一个方法访问多种类型的节点
  "ExportNamedDeclaration|Flow"(path) {}
})
```



**那么 Babel 插件是怎么被应用的呢？**

Babel 会按照插件定义的顺序来应用访问方法，比如你注册了多个插件，babel-core 最后传递给访问器的数据结构大概长这样：

```
{
  Identifier: {
    enter: [plugin-xx, plugin-yy,] // 数组形式
  }
}
```



当进入一个节点时，这些插件会按照注册的顺序被执行。大部分插件是不需要开发者关心定义的顺序的，有少数的情况需要稍微注意以下，例如`plugin-proposal-decorators`:

```
{
  "plugins": [
    "@babel/plugin-proposal-decorators",     // 必须在plugin-proposal-class-properties之前
    "@babel/plugin-proposal-class-properties"
  ]
}
```



所有插件定义的顺序，按照惯例，应该是新的或者说实验性的插件在前面，老的插件定义在后面。因为可能需要新的插件将 AST 转换后，老的插件才能识别语法（向后兼容）。下面是官方配置例子, 为了确保先后兼容，`stage-*`阶段的插件先执行:

```
 {
  "presets": ["es2015", "react", "stage-2"]
}
```

> 注意Preset的执行顺序相反，详见官方[文档](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fnext%2Fplugins%23plugin-ordering)



### 2.2、节点的上下文

访问者在访问一个节点时, 会无差别地调用 `enter` 方法，我们怎么知道这个节点在什么位置以及和其他节点的关联关系呢？

通过上面的代码，读者应该可以猜出几分，每个`visit`方法都接收一个 `Path` 对象, 你可以将它当做一个‘上下文’对象，类似于`JQuery`的 `JQuery`(`const $el = $('.el')`) 对象，这里面包含了很多信息：

- 当前节点信息
- 节点的关联信息。父节点、子节点、兄弟节点等等
- 作用域信息
- 上下文信息
- 节点操作方法。节点增删查改
- 断言方法。isXXX, assertXXX

下面是它的主要结构:

```
export class NodePath<T = Node> {
    constructor(hub: Hub, parent: Node);
    parent: Node;
    hub: Hub;
    contexts: TraversalContext[];
    data: object;
    shouldSkip: boolean;
    shouldStop: boolean;
    removed: boolean;
    state: any;
    opts: object;
    skipKeys: object;
    parentPath: NodePath;
    context: TraversalContext;
    container: object | object[];
    listKey: string; // 如果节点在一个数组中，这个就是节点数组的键
    inList: boolean;
    parentKey: string;
    key: string | number; // 节点所在的键或索引
    node: T;  // 🔴 当前节点
    scope: Scope; // 🔴当前节点所在的作用域
    type: T extends undefined | null ? string | null : string; // 🔴节点类型
    typeAnnotation: object;
    // ... 还有很多方法，实现增删查改
}
```

你可以通过这个[手册](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md%23toc-visitors)来学习怎么通过 Path 来转换 AST. 后面也会有代码示例，这里就不展开细节了



### 2.3、副作用的处理

实际上访问者的工作比我们想象的要复杂的多，上面示范的是静态 AST 的遍历过程。而 AST 转换本身是有副作用的，比如插件将旧的节点替换了，那么访问者就没有必要再向下访问旧节点了，而是继续访问新的节点, 代码如下。

```
traverse(ast, {
  ExpressionStatement(path) {
    // 将 `console.log('hello' + v + '!')` 替换为 `return ‘hello’ + v`
    const rtn = t.returnStatement(t.binaryExpression('+', t.stringLiteral('hello'), t.identifier('v')))
    path.replaceWith(rtn)
  },
}
```



上面的代码, 将`console.log('hello' + v + '!')`语句替换为`return "hello" + v;`, 下图是遍历的过程：

![webpack108](..\images\webpack108.png)

我们可以对 AST 进行任意的操作，比如删除父节点的兄弟节点、删除第一个子节点、新增兄弟节点... **当这些操作'污染'了 AST 树后，访问者需要记录这些状态，响应式(Reactive)更新 Path 对象的关联关系, 保证正确的遍历顺序，从而获得正确的转译结果**。



### 2.4、作用域的处理

访问者可以确保正确地遍历和修改节点，但是对于转换器来说，另一个比较棘手的是对作用域的处理，这个责任落在了插件开发者的头上。插件开发者必须非常谨慎地处理作用域，不能破坏现有代码的执行逻辑。

```
const a = 1, b = 2
function add(foo, bar) {
  console.log(a, b)
  return foo + bar
}
```

比如你要将 `add` 函数的第一个参数 `foo` 标识符修改为`a`, 你就需要**递归**遍历子树，查出`foo`标识符的所有`引用`, 然后替换它:

```
traverse(ast, {
  // 将第一个参数名转换为a
  FunctionDeclaration(path) {
    const firstParams = path.get('params.0')
    if (firstParams == null) {
      return
    }

    const name = firstParams.node.name
    // 递归遍历，这是插件常用的模式。这样可以避免影响到外部作用域
    path.traverse({
      Identifier(path) {
        if (path.node.name === name) {
          path.replaceWith(t.identifier('a'))
        }
      }
    })
  },
})

console.log(generate(ast).code)
// function add(a, bar) {
//   console.log(a, b);
//   return a + bar;
// }
```



🤯慢着，好像没那么简单，替换成 `a` 之后, `console.log(a, b)` 的行为就被破坏了。所以这里不能用 `a`，得换个标识符, 譬如`c`.



这就是转换器需要考虑的作用域问题，**AST 转换的前提是保证程序的正确性**。 我们在添加和修改`引用`时，需要确保与现有的所有引用不冲突。Babel本身不能检测这类异常，只能依靠插件开发者谨慎处理。



Javascript采用的是词法作用域, 也就是根据源代码的词法结构来确定作用域：

![webpack109](..\images\webpack109.png)

在**词法区块(block)\中，由于新建变量、函数、类、函数参数等创建的标识符，都属于这个区块作用域. 这些标识符也称为\**绑定(Binding)**，而对这些绑定的使用称为**引用(Reference)**

在Babel中，使用`Scope`对象来表示作用域。 我们可以通过Path对象的`scope`字段来获取当前节点的`Scope`对象。它的结构如下:

```
{
  path: NodePath;
  block: Node;         // 所属的词法区块节点, 例如函数节点、条件语句节点
  parentBlock: Node;   // 所属的父级词法区块节点
  parent: Scope;       // ⚛️指向父作用域
  bindings: { [name: string]: Binding; }; // ⚛️ 该作用域下面的所有绑定(即该作用域创建的标识符)
}
```



`Scope` 对象和 `Path` 对象差不多，**它包含了作用域之间的关联关系(通过parent指向父作用域)，收集了作用域下面的所有绑定(bindings), 另外还提供了丰富的方法来对作用域仅限操作**。

我们可以通过`bindings`属性获取当前作用域下的所有绑定(即标识符)，每个绑定由`Binding`类来表示：

```
export class Binding {
  identifier: t.Identifier;
  scope: Scope;
  path: NodePath;
  kind: "var" | "let" | "const" | "module";
  referenced: boolean;
  references: number;              // 被引用的数量
  referencePaths: NodePath[];      // ⚛️获取所有应用该标识符的节点路径
  constant: boolean;               // 是否是常量
  constantViolations: NodePath[];
}
```

**通过`Binding`对象我们可以确定标识符被引用的情况**。

Ok，有了 `Scope` 和 `Binding`, 现在有能力实现安全的变量重命名转换了。 为了更好地展示作用域交互，在上面代码的基础上，我们再增加一下难度：

```
const a = 1, b = 2
function add(foo, bar) {
  console.log(a, b)
  return () => {
    const a = '1' // 新增了一个变量声明
    return a + (foo + bar)
  }
}
```

现在你要重命名函数参数 `foo`, 不仅要考虑`外部的作用域`, 也要考虑`下级作用域`的绑定情况，确保这两者都不冲突。

上面的代码作用域和标识符引用情况如下图所示:

![webpack110](..\images\webpack110.png)

来吧，接受挑战，试着将函数的第一个参数重新命名为更短的标识符:

```
// 用于获取唯一的标识符
const getUid = () => {
  let uid = 0
  return () => `_${(uid++) || ''}`
}

const ast = babel.parseSync(code)
traverse(ast, {
  FunctionDeclaration(path) {
    // 获取第一个参数
    const firstParam = path.get('params.0')
    if (firstParam == null) {
      return
    }

    const currentName = firstParam.node.name
    const currentBinding = path.scope.getBinding(currentName)
    const gid = getUid()
    let sname

    // 循环找出没有被占用的变量名
    while(true) {
      sname = gid()

      // 1️⃣首先看一下父作用域是否已定义了该变量
      if (path.scope.parentHasBinding(sname)) {
        continue
      }

      // 2️⃣ 检查当前作用域是否定义了变量
      if (path.scope.hasOwnBinding(sname)) {
        // 已占用
        continue
      }

      //  再检查第一个参数的当前的引用情况,
      // 如果它所在的作用域定义了同名的变量，我们也得放弃
      if (currentBinding.references > 0) {
        let findIt = false
        for (const refNode of currentBinding.referencePaths) {
          if (refNode.scope !== path.scope && refNode.scope.hasBinding(sname)) {
            findIt = true
            break
          }
        }
        if (findIt) {
          continue
        }
      }
      break
    }

    // 开始替换掉
    const i = t.identifier(sname)
    currentBinding.referencePaths.forEach(p => p.replaceWith(i))
    firstParam.replaceWith(i)
  },
})

console.log(generate(ast).code)
// const a = 1,
//       b = 2;

// function add(_, bar) {
//   console.log(a, b);
//   return () => {
//     const a = '1'; // 新增了一个变量声明

//     return a + (_ + bar);
//   };
// }
```



上面的例子虽然没有什么实用性，而且还有Bug(没考虑`label`)，但是正好可以揭示了作用域处理的复杂性。



Babel的 `Scope` 对象其实提供了一个`generateUid`方法来生成唯一的、不冲突的标识符。我们利用这个方法再简化一下我们的代码:

```
traverse(ast, {
  FunctionDeclaration(path) {
    const firstParam = path.get('params.0')
    if (firstParam == null) {
      return
    }
    let i = path.scope.generateUidIdentifier('_') // 也可以使用generateUid
    const currentBinding = path.scope.getBinding(firstParam.node.name)
    currentBinding.referencePaths.forEach(p => p.replaceWith(i))
    firstParam.replaceWith(i)
  },
})
```



能不能再短点!

```
traverse(ast, {
  FunctionDeclaration(path) {
    const firstParam = path.get('params.0')
    if (firstParam == null) {
      return
    }
    let i = path.scope.generateUid('_') // 也可以使用generateUid
    path.scope.rename(firstParam.node.name, i)
  },
})
```

查看generateUid的实现代码

```
generateUid(name: string = "temp") {
  name = t
    .toIdentifier(name)
    .replace(/^_+/, "")
    .replace(/[0-9]+$/g, "");

  let uid;
  let i = 0;
  do {
    uid = this._generateUid(name, i);
    i++;
  } while (
    this.hasLabel(uid) ||
    this.hasBinding(uid) ||
    this.hasGlobal(uid) ||
    this.hasReference(uid)
  );

  const program = this.getProgramParent();
  program.references[uid] = true;
  program.uids[uid] = true;

  return uid;
}

```



非常简洁哈？作用域操作最典型的场景是代码压缩，代码压缩会对变量名、函数名等进行压缩... 然而实际上很少的插件场景需要跟作用域进行复杂的交互，所以关于作用域这一块就先讲到这里。

### 2.5、写插件

模仿[babel-plugin-import](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fbabel-plugin-import), 写一个极简版插件，来实现模块的按需导入. 在这个插件中，我们会将类似这样的导入语句:

```
import {A, B, C as D} from 'foo'
```

转换为:

```
import A from 'foo/A'
import 'foo/A/style.css'
import B from 'foo/B'
import 'foo/B/style.css'
import D from 'foo/C'
import 'foo/C/style.css'
```

首先通过 [AST Explorer](https://link.juejin.cn?target=https%3A%2F%2Fastexplorer.net) 看一下导入语句的 AST 节点结构:

![webpack111](..\images\webpack111.png)

通过上面展示的结果，我们需要处理 `ImportDeclaration` 节点类型，将它的`specifiers`拿出来遍历处理一下。另外如果用户使用了`默认导入`语句，我们将抛出错误，提醒用户不能使用默认导入.

基本实现如下:

```
// 要识别的模块
const MODULE = 'foo'
traverse(ast, {
  // 访问导入语句
  ImportDeclaration(path) {
    if (path.node.source.value !== MODULE) {
      return
    }

    // 如果是空导入则直接删除掉
    const specs = path.node.specifiers
    if (specs.length === 0) {
      path.remove()
      return
    }

    // 判断是否包含了默认导入和命名空间导入
    if (specs.some(i => t.isImportDefaultSpecifier(i) || t.isImportNamespaceSpecifier(i))) {
      // 抛出错误，Babel会展示出错的代码帧
      throw path.buildCodeFrameError("不能使用默认导入或命名空间导入")
    }

    // 转换命名导入
    const imports = []
    for (const spec of specs) {
      const named = MODULE + '/' + spec.imported.name
      const local = spec.local
      imports.push(t.importDeclaration([t.importDefaultSpecifier(local)], t.stringLiteral(named)))
      imports.push(t.importDeclaration([], t.stringLiteral(`${named}/style.css`)))
    }

    // 替换原有的导入语句
    path.replaceWithMultiple(imports)
  }
})
```



逻辑还算简单，`babel-plugin-import`可比这复杂得多。



接下来，我们将它封装成标准的 Babel 插件。 按照规范，我们需要创建一个`babel-plugin-*`前缀的包名：

```
mkdir babel-plugin-toy-import
cd babel-plugin-toy-import
yarn init -y
touch index.js
```



> 你也可以通过 [generator-babel-plugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fgenerator-babel-plugin%2Ftree%2Fmaster%2Fgenerators%2Fapp%2Ftemplates) 来生成项目模板.



在 `index.js` 文件中填入我们的代码。`index.js`默认导出一个函数，函数结构如下:

```
// 接受一个 babel-core 对象
export default function(babel) {
  const {types: t} = babel
  return {
    pre(state) {
      // 前置操作，可选，可以用于准备一些资源
    },
    visitor: {
      // 我们的访问者代码将放在这里
      ImportDeclaration(path, state) {
        // ...
      }
    },
    post(state) {
      // 后置操作，可选
    }
  }
}
```



**我们可以从访问器方法的第二个参数`state`中获取用户传入的参数**。假设用户配置为:

```
{
  plugins: [['toy-plugin', {name: 'foo'}]]
}
```

我们可以这样获取用户传入的参数:

```
export default function(babel) {
  const {types: t} = babel
  return {
    visitor: {
      ImportDeclaration(path, state) {
        const mod = state.opts && state.opts.name
        if (mod == null) {
          return
        }
        // ...
      }
    },
  }
}
```

发布!

```
 yarn publish # good luck
```

## 3、babel的Api介绍

### 3.1、@babel/parser

babel parser 叫 babylon，是基于 acorn 实现的，扩展了很多语法，可以支持 esnext、jsx、flow、typescript 等语法的解析，其中 jsx、flow、typescript 这些非标准的语法的解析需要指定语法插件。

```js
require("@babel/parser").parse("code", {
    sourceType: “module”,
    plugins: [
        "jsx",
        "typescript"
    ]
});
```

### 3.2、@babel/traverse

遍历 AST，并在遍历过程中调用 visitor 函数进行 AST 的增删改，提供了 path 的 api

```js
traverse(ast, {
    visitor: {
        Identifier (path, state) {},
        StringLiteral: {
            enter (path, state) {},
            exit (path, state) {}
        }
    }
})
```

![webpack105](..\images\webpack105.png)

```js
// 进入 FunctionDeclaration 节点时调用
traverse(ast, {
    FunctionDeclaration: {
        enter(path, state) {}
    }
})

// 默认是进入节点时调用，和上面等价
traverse(ast, {
    FunctionDeclaration(path, state) {}
})

// 进入 FunctionDeclaration 和 VariableDeclaration 节点时调用
traverse(ast, {
    'FunctionDeclaration|VariableDeclaration'(path, state) {}
    })

// 通过别名指定离开各种 Declaration 节点时调用
traverse(ast, {
    Declaration: {
        exit(path, state) {}
    }
})
```

!![webpack106](..\images\webpack106.png)

**path** 是遍历过程中的路径，会保留上下文信息，有很多属性和方法，比如:

- path.node 指向当前 AST 节点
- path.parent 指向父级 AST 节点
- path.getSibling、path.getNextSibling、path.getPrevSibling 获取兄弟节点
- path.get、path.set 获取和设置当前节点属性的 path

上述属性和方法是获取当前节点以及它的关联节点的。

- path.scope 获取当前节点的作用域信息

上述属性可以获取作用域的信息。

- path.isXxx 判断当前节点是不是 Xxx 类型
- path.assertXxx 判断当前节点是不是 Xxx 类型，不是则抛出异常

上述 isXxx、assertXxx 系列方法可以用于判断 AST 类型。

- path.insertBefore、path.insertAfter 插入节点
- path.replaceWith、path.replaceWithMultiple、replaceWithSourceString 替换节点
- path.remove 删除节点

上述方法可以对 AST 进行增删改。

- path.skip 跳过当前节点的子节点的遍历
- path.stop 结束后续遍历

上述方法可以跳过一些遍历。

### 3.3、@babel/types

遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型，这时候就需要 @babel/types 包。

```js
t.ifStatement(test, consequent, alternate);
t.isIfStatement(node, opts);
t.assertIfStatement(node, opts);
t.isIdentifier(node, { name: "paths" }
```

### 3.4、@babel/template

通过 @babel/types 创建 AST 还是比较麻烦的，要一个个的创建然后组装，如果 AST 节点比较多的话需要写很多代码，这时候就可以使用 @babel/template 包来批量创建。

```js
const ast = template(code, [opts])(args);
const ast = template.ast(code, [opts]);
const ast = template.program(code, [opts]);
const ast = template.expression(code, [opts]);
const ast = template.statement(code, [opts]);

const fn = template(`console.log(NAME)`);

const astArr = template.statements(code, [opts]);
const ast = fn({
    NAME: t.stringLiteral("guang"),
});
```

### 3.5、@babel/generator

AST 转换完之后就要打印成目标代码字符串，通过 @babel/generator 包的 api。

```js
const { code, map } = generate(ast, { sourceMaps: true })
```

### 3.6、@babel/code-frame

当有错误信息要打印的时候，需要打印错误位置的代码，可以使用 @babel/code-frame。

```js
const { codeFrameColumns } = require("@babel/code-frame");

try {
    throw new Error("xxx 错误");
} catch (err) {
    console.error(codeFrameColumns(`const name = guang`, {
        start: { line: 1, column: 14 }
    }, {
        highlightCode: true,
        message: err.message
    }));
}
```

### 3.7、@babel/core

@babel/core 包则是基于前面的包完成整个编译流程，从源码到目标代码，生成 sourcemap

```js
transformSync(code, options); // => { code, map, ast }
transformFileSync(filename, options); // => { code, map, ast }
transformFromAstSync(
    parsedAst,
    sourceCode,
    options
); // => { code, map, ast }

transformAsync("code();", options).then(result => {})
transformFileAsync("filename.js", options).then(result => {})
transformFromAstAsync(parsedAst, sourceCode, options).then(result => {})
```

### 3.8、@babel/cli

```
babel`与`webpack`类似，都把 **CLI命令行工具** 单独拆分出来，便于维护和按需导入，webpack命令行工具包是`webpack-cli
```

#### 介绍

`babel`官方提供的CLI命令行工具，主要是提供`babel`这个命令

#### 作用

提供了一种通过命令来使用`babel`的方式，简称命令方式，其实现在很多工具也提供这类方式，例如：`webpack`提供的`webpack-cli`等

> `注意`： 虽然提供了这种命令方式来使用babel，但由于**命令方式选项过于繁多，编写起来不方便**，所以不适合开发和生产使用，一般只是学习时使用，开发和生产一般使用**集成方式**，后面会讲

#### 安装

```css
// 必须作为开发依赖
npm i @babel/cli -D 
```

## 4、`polyfill`

关于`polyfill`，我们先来解释下何谓`polyfill`。

首先我们来理清楚这三个概念:

- 最新`ES`语法，比如：箭头函数，`let/const`。
- 最新`ES Api`，比如`Promise`
- 最新`ES`实例/静态方法，比如`String.prototype.include`

`babel-prest-env`仅仅只会转化最新的`es`语法，并不会转化对应的`Api`和实例方法，比如说`ES 6`中的`Array.from`静态方法。`babel`是不会转译这个方法的，如果想在低版本浏览器中识别并且运行`Array.from`方法达到我们的预期就需要额外引入`polyfill`进行在`Array`上添加实现这个方法。

其实可以稍微简单总结一下，**语法层面的转化`preset-env`完全可以胜任。但是一些内置方法模块，仅仅通过`preset-env`的语法转化是无法进行识别转化的，所以就需要一系列类似”垫片“的工具进行补充实现这部分内容的低版本代码实现。这就是所谓的`polyfill`的作用**

> polyfill在英文中有垫片的意思，意为兜底的东西。

针对于`polyfill`方法的内容，`babel`中涉及两个方面来解决：

- `@babel/polyfill`
- `@babel/runtime`
- `@babel/plugin-transform-runtime`

我们理清了何谓`polyfill`以及`polyfill`的作用和含义后，让我们来逐个击破这两个`babel`包对应的使用方式和区别吧。我们理清了何谓`polyfill`以及`polyfill`的作用和含义后，让我们来逐个击破这两个`babel`包对应的使用方式和区别吧。

### 4.1、`@babel/polyfill`

首先我们来看看第一种实现`polyfill`的方式：

#### `@babel/polyfill`介绍

通过[babelPolyfill](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-polyfill)通过往全局对象上添加属性以及直接修改内置对象的`Prototype`上添加方法实现`polyfill`。

比如说我们需要支持`String.prototype.include`，在引入`babelPolyfill`这个包之后，它会在全局`String`的原型对象上添加`include`方法从而支持我们的`Js Api`。

我们说到这种方式本质上是往全局对象/内置对象上挂载属性，所以这种方式难免会造成全局污染。

#### 应用`@babel/polyfill`

在`babel-preset-env`中存在一个`useBuiltIns`参数，这个参数决定了如何在`preset-env`中使用`@babel/polyfill`。

```json
{
    "presets": [
        ["@babel/preset-env", {
            "useBuiltIns": false
        }]
    ]
}
```

- `useBuiltIns`--`"usage"`| `"entry"`| `false`

##### `false`

当我们使用`preset-env`传入`useBuiltIns`参数时候，默认为`false`。它表示仅仅会转化最新的`ES`语法，并不会转化任何`Api`和方法。

##### `entry`

当传入`entry`时，需要我们在项目入口文件中**手动引入一次`core-js`，**它会根据我们配置的浏览器兼容性列表(`browserList`)然后**全量**引入不兼容的`polyfill`。

> Tips:  在`Babel 7.4。0`之后，`@babel/polyfill`被废弃它变成另外两个包的集成。`"core-js/stable"; "regenerator-runtime/runtime";`。你可以在这里看到[变化](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-polyfill)，但是他们的使用方式是一致的，只是在入口文件中引入的包不同了。

> [浏览器兼容性列表配置方式简介你可以在这里看到](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist)。

```javascript
// 项目入口文件中需要额外引入polyfill
// core-js 2.0中是使用"@babel/polyfill" core-js3.0版本中变化成为了上边两个包
import "@babel/polyfill"

// babel
{
    "presets": [
        ["@babel/preset-env", {
            "useBuiltIns": "entry"
        }]
    ]
}
```

> 同时需要注意的是，在我们使用`useBuiltIns:entry/usage`时，需要额外指定`core-js`这个参数。默认为使用`core-js 2.0`，所谓的`core-js`就是我们上文讲到的“垫片”的实现。它会实现一系列内置方法或者`Promise`等`Api`。

> `core-js 2.0`版本是跟随`preset-env`一起安装的，不需要单独安装哦～

##### `usage`

上边我们说到配置为`entry`时，`perset-env`会基于我们的浏览器兼容列表进行全量引入`polyfill`。所谓的全量引入比如说我们代码中仅仅使用了`Array.from`这个方法。但是`polyfill`并不仅仅会引入`Array.from`，同时也会引入`Promise`、`Array.prototype.include`等其他并未使用到的方法。这就会造成包中引入的体积太大了。

此时就引入出了我们的`useBuintIns:usage`配置。

当我们配置`useBuintIns:usage`时，会根据配置的浏览器兼容，以及代码中 **使用到的`Api` 进行引入`polyfill`按需添加。**

当使用`usage`时，**我们不需要额外在项目入口中引入`polyfill`了**，它会根据我们项目中使用到的进行按需引入。

```json
{
    "presets": [
        ["@babel/preset-env", {
            "useBuiltIns": "usage",
            "core-js": 3
        }]
    ]
}
```

###### **关于`usage`和`entry`存在一个需要注意的本质上的区别。**

我们以项目中引入`Promise`为例。

当我们配置`useBuintInts:entry`时，仅仅会在入口文件全量引入一次`polyfill`。你可以这样理解:

```js
// 当使用entry配置时
...
// 一系列实现polyfill的方法
global.Promise = promise

// 其他文件使用时
const a = new Promise()
```

而当我们使用`useBuintIns:usage`时，`preset-env`只能基于各个模块去分析它们使用到的`polyfill`从而进入引入。

`preset-env`会帮助我们智能化的在需要的地方引入，比如:

```js
// a. js 中
import "core-js/modules/es.promise";

...
```

```
// b.js中

import "core-js/modules/es.promise";
...
```



- 在`usage`情况下，如果我们存在很多个模块，那么无疑会多出很多冗余代码(`import`语法)。
- 同样在使用`usage`时因为是模块内部局部引入`polyfill`所以按需在模块内进行引入，而`entry`则会在代码入口中一次性引入。

`usageBuintIns`不同参数分别有不同场景的适应度，具体参数使用场景还需要大家结合自己的项目实际情况找到最佳方式。

### 4.2、`@babel/runtime`

上边我们讲到`@babel/polyfill`是存在污染全局变量的副作用，在实现`polyfill`时`Babel`还提供了另外一种方式去让我们实现这功能，那就是`@babel/runtime`。

简单来讲，`@babel/runtime`更像是一种**按需加载的解决方案**，比如哪里需要使用到`Promise`，`@babel/runtime`就会在他的文件顶部添加`import promise from 'babel-runtime/core-js/promise'`。

同时上边我们讲到对于`preset-env`的`useBuintIns`配置项，我们的`polyfill`是`preset-env`帮我们智能引入。

而`babel-runtime`则会将引入方式由智能完全交由我们自己，我们需要什么自己引入什么。

它的用法很简单，只要我们去安装`npm install --save @babel/runtime`后，在需要使用对应的`polyfill`的地方去单独引入就可以了。比如：

```js
// a.js 中需要使用Promise 我们需要手动引入对应的运行时polyfill
import Promise from 'babel-runtime/core-js/promise'

const promsies = new Promise()
```

总而言之，`babel/runtime`你可以理解称为就是一个运行时“哪里需要引哪里”的工具库。

> 针对`babel/runtime`绝大多数情况下我们都会配合`@babel/plugin-transfrom-runtime`进行使用达到智能化`runtime`的`polyfill`引入。

### 4.3、`@babel/plugin-transform-runtime`

#### `babel-runtime`存在的问题

`babel-runtime`在我们手动引入一些`polyfill`的时候，它会给我们的代码中注入一些类似`_extend()， classCallCheck()`之类的工具函数，这些工具函数的代码会包含在编译后的每个文件中，比如：

```js
class Circle {}
// babel-runtime 编译Class需要借助_classCallCheck这个工具函数
function _classCallCheck(instance, Constructor) { //... } 
var Circle = function Circle() { _classCallCheck(this, Circle); };
```

如果我们项目中存在多个文件使用了`class`，那么无疑在每个文件中注入这样一段冗余重复的工具函数将是一种灾难。

所以针对上述提到的两个问题:

- `babel-runtime`无法做到智能化分析，需要我们手动引入。
- `babel-runtime`编译过程中会重复生成冗余代码。

我们就要引入我们的主角`@babel/plugin-transform-runtime`。

#### `@babel/plugin-transform-runtime`作用

`@babel/plugin-transform-runtime`插件的作用恰恰就是为了解决上述我们提到的`babel-runtime`存在的问题而提出的插件。

- `babel-runtime`无法做到智能化分析，需要我们手动引入。

`@babel/plugin-transform-runtime`插件会智能化的分析我们的项目中所使用到需要转译的`js`代码，从而实现模块化从`babel-runtime`中引入所需的`polyfill`实现。

- `babel-runtime`编译过程中会重复生成冗余代码。

`@babel/plugin-transform-runtime`插件提供了一个`helpers`参数。具体你可以在[这里查阅它的所有配置参数](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-plugin-transform-runtime%23helpers)。

这个`helpers`参数开启后可以将上边提到编译阶段重复的工具函数，比如`classCallCheck, extends`等代码转化称为`require`语句。此时，这些工具函数就不会重复的出现在使用中的模块中了。比如这样：

```js
// @babel/plugin-transform-runtime会将工具函数转化为require语句进行引入
// 而非runtime那样直接将工具模块代码注入到模块中
var _classCallCheck = require("@babel/runtime/helpers/classCallCheck"); 
var Circle = function Circle() { _classCallCheck(this, Circle); };
```

#### 配置`@babel/plugin-transform-runtime`

其实用法原理部分已经在上边分析的比较透彻了，配置这里还有疑问的同学可以评论区给我留言或者移步`babel`[官网查看](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-plugin-transform-runtime)。

这里为列一份目前它的默认配置:

```json
{
  "plugins": [
    [
      "@babel/plugin-transform-runtime",
      {
        "absoluteRuntime": false,
        "corejs": false,
        "helpers": true,
        "regenerator": true,
        "version": "7.0.0-beta.0"
      }
    ]
  ]
}
```

**这种方式目前不支持设置 targets，所以不会考虑目标环境是否已经支持，它是通过局部变量的方式实现了所有被用到的 built-in 类型语法，不会污染全局。**

### 4.4、总结`polyfill`

在`babel`中实现`polyfill`主要有两种方式：

- 一种是通过`@babel/polyfill`配合`preset-env`去使用，这种方式可能会存在污染全局作用域。
- 一种是通过`@babel/runtime`配合`@babel/plugin-transform-runtime`去使用，这种方式并不会污染作用域。
- 全局引入会污染全局作用域，但是相对于局部引入来说。它会增加很多额外的引入语句，增加包体积。

在`useBuintIns:usage`情况下其实和`@babel/plugin-transform-runtime`情况下是类似的作用，

两者的选择：

- 如果项目对打包**体积要求很高，或者想要避免全局污染**，推荐使用 @babel/plugin-transform-runtime + @babel/runtime。

- 如果想要**快速方便地启用所有可能需要的 polyfills，并且不需要担心打包体积**，可以使用 useBuiltIns + @babel/polyfill。

  

## 5、插件（Plugin）

`babel`默认不内置代码转换功能，代码转换全依赖`babel`插件（转化类）实现，所以插件对于`babel`非常重要。 我们一般不会自己开发`babel`转换类插件，实际项目中往往都是直接使用现成插件（官方或第三方）。从[官网插件列表](https://link.juejin.cn?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fplugins-list)中，我们发现插件是非常丰富的

PS：下面所讲的 ***插件*** 都是指 ***转换类插件***

### 5.1、安装与使用

安装很简单，在官方插件列表中找到需要的插件，使用下面命令就可以了

```java
// 需要把箭头函数转译成ES5的普通函数，需要安装
npm i @babel/plugin-transform-arrow-functions --save-dev

// 需要把ES6的函数参数转译成ES5的函数参数，需要安装
npm i @babel/plugin-transform-parameters -D
```

安装完，马上使用，使用有2钟方式

**1、命令方式** 
 **2、配置方式**（推荐）

```java
/* 命令方式 */
npx babel src -d lib --plugins=@babel/plugin-transform-arrow-functions

// 两个以上插件一起用的话，用","隔开
npx babel src -d lib --plugins=@babel/plugin-transform-arrow-functions,
@babel/plugin-transform-parameters

/* 配置方式 */

// 在项目根目录下，新建babel.config.json配置文件
{
    "plugins": [
        "@babel/plugin-transform-arrow-functions",
        "@babel/plugin-transform-parameters"
    ]
}
```

### 5.2、省略前缀写法

每个插件都是以`plugin-`作为前缀，每次使用插件时，都要重复编写挺麻烦的，所以`babel`官方提供了**省略`plugin-`前缀**的简易写法

上面2钟方式的省略写法如下：

```java
/* 命令方式 */
npx babel src -d lib --plugins=@babel/transform-arrow-functions

// 两个以上插件一起用的话，用","隔开
npx babel src -d lib --plugins=@babel/transform-arrow-functions,@babel/transform-parameters

/* 配置方式 */

// 在项目根目录下，新建babel.config.json配置文件
{
    "plugins": [
        "@babel/transform-arrow-functions",
        "@babel/transform-parameters"
    ]
}
```

### 5.3、执行顺序

当配置多个插件时（命令方式一样），按书写从前到后的顺序执行，例如：

```perl
// babel.config.json配置文件
{
    "plugins": [
        "@babel/transform-arrow-functions",
        "@babel/transform-parameters"
    ]
}
```

执行顺序为：先执行`@babel/transform-arrow-functions`，然后执行`@babel/transform-parameters`

### 5.4、配置选项

在`Babel`配置文件中，除了声明所用到的`Babel`插件外，还可以对用到的`Babel`插件进行配置（前提条件是该插件提供可配置项啦，否则配置个寂寞？），写法如下：

```json
// 在babel.config.json中
{
    "plugins": [ 
        [ 
            "transform-async-to-module-method", 
            { 
                "module": "bluebird", 
                "method": "coroutine" 
            }
        ] 
    ]
}
```

### 5.5、问题

我们已经学会安装使用插件，`babel`对`ES6+`语法转换，都是靠一个个plugins完成的。再看一眼插件列表，~ ~突然懵逼了，**这么多插件难道要我一个一个安装使用吗？**

答案：当然不会啦，如果要一个个安装使用，估计没人会使用`babel`来代码转换，`babel`官方给出了一个解决方案 —— 预设（`preset`），后面会讲解

### 5.6、注意事项

**转换类插件** 按 *功能* 进行分类，大概分为三类：

**1、ES6+语法转换插件** 

这种插件是最常用的 
 **主要对ES6+最新的语法糖进行转换，并不负责转换ES6+新增的api和全局对象。** 例如：`let/const`就可以被转换，而`includes/Object.assign`等新API并不能被转换，常用的ES6+语法转换插件有：`@babel/plugin-transform-arrow-functions`、`@babel/plugin-transform-parameters`等

**2、补充转换插件** 

对上面ES6+语法转换插件的一种补充，解决它不能解决的问题 
 **主要对ES6+新增的api和全局对象进行转换** 例如：`babel-plugin-transform-runtime`这个插件能够转换`Object.assign`，同时也可以引入`@babel/polyfill`，进一步对`includes`这类新API保证在浏览器的兼容性。

> 一般项目使用 `@babel/polyfill` 补充包，而 工具/库 才使用 `babel-plugin-transform-runtime` 插件

**3、其他转换插件**

TS、Flow、React(JSX)转换插件，转译`JSX语法`和`TS语法`，移除类型声明



## 6、预设（Preset）

`bel`插件尽可能拆成小的粒度，开发者可以按需引入。比如对ES6转ES5的功能，Babel官方拆成了20+个插件。但在实际开发中，逐个插件引入不仅效率低下，而且很容易出错。为此，`Babel`官方提供了一个`Babel`插件集合 —— 预设（Preset），只要安装导入一个预设，就相当于把多个`Babel`插件安装导入了

### 6.1、安装与使用

安装很简单，在官方找到需要的预设，使用下面命令安装

```css
// 安装把ES6+语法转成ES5的预设
npm i @babel/preset-env -D
```

> 已被纳入规范的语法（ES2015, ES2016, ...., ES2021, Modules）所需要使用的`plugins`都包含在`@babel/preset-env`中

安装完，马上使用，使用有2钟方式

**1、命令方式** 
 **2、配置方式**（推荐）

```css
/* 命令方式 */
npx babel src -d lib --presets=@babel/preset-env

// 使用两个以上预设的话，用","隔开
npx babel src -d lib --presets=@babel/preset-env，@babel/preset-typescript

/* 配置方式 */

// 在项目根目录下，新建babel.config.json配置文件
{
    "presets": [
       [ 
       "@babel/preset-env", 
           { 
               targets: { 
                   edge: "17", 
                   chrome: "64",
                   firefox: "60", 
                   safari: "11.1",
                   ie: "10"
               } 
           } 
        ]
    ]
}
```

### 6.2、省略前缀写法

每个预设都是以`preset-`作为前缀，每次使用预设时，都要重复编写挺麻烦的，所以`babel`官方提供了**省略`preset-`前缀**的简易写法

上面2钟方式的省略写法如下：

```css
/* 命令方式 */
npx babel src -d lib --presets=@babel/env

// 两个以上预设一起用的话，用","隔开
npx babel src -d lib --presets=@babel/env，@babel/typescript

/* 配置方式 */

// 在项目根目录下，新建babel.config.json配置文件
{
    "presets": [
       [ 
       "@babel/env", 
           { 
               targets: { 
                   edge: "17", 
                   chrome: "64",
                   firefox: "60", 
                   safari: "11.1",
                   ie: "10"
               } 
           } 
        ]
    ]
}
```

### 6.3、配置选项

在`Babel`配置文件中，除了声明所用到的`Babel`预设外，还可以对用到的`Babel`预设进行配置（前提条件是该预设提供可配置项啦，否则配置个寂寞？），写法与插件的配置选项一样！

- **targets**

用于指定编译后能运行在的目标浏览器（最低版本），以便可以按需引入 `plugin` 和 `ployfill`

```css
{
    "presets": [
       [ 
       "@babel/env", 
           { 
               targets: { 
                   edge: "17", 
                   chrome: "64",
                   firefox: "60", 
                   safari: "11.1",
                   ie: "10"
               } 
           } 
        ]
    ]
}
```

> targets 和 browerslist 合并取最低版本

- **modules**

用于指定代码转换后的模块化类型（ES模块化转成什么类型），默认值是`auto`，最终转成CommonJS模块化

如果想转成（保留）ES模块化，可设置为`false`

- **useBuiltIns**

用于指定加载`ployfill`的方式，默认是`false`

可选值有3种：`"usage"` | `"entry"` | `false`

1、`"entry"`：去掉目标浏览器已支持的`ployfill`模块，将浏览器不支持的都引入对应的`ployfill`模块。
 2、`"usage"`：打包时会自动根据实际代码的使用情况，结合`targets`按需引入代码里实际用到部分`polyfill`模块。
 3、`false`：不加载任何`ployfill`

推荐使用`"usage"`

```arduino
arduino 体验AI代码助手 代码解读复制代码// 使用entry时，在入口main.js中引入

（babel v7.0版之前，推荐使用） 
//import '@babel/polyfill'; 

（babel v7.4版之前，推荐使用） 
import "core-js/stable"; 
import "regenerator-runtime/runtime";

（babel v7.4版之后，推荐使用） 
import "core-js";
```

### 6.4、执行顺序

和插件执行顺序刚好相反，多个`Preset`按照声明次序逆序执行。

例如：需要将react中的jsx转为js，然后将js在转换为es5，所以需要将react的插件放在后面，让他先执行。

```perl
// 在babel.config.json中配置
{
    presets: ["@babel/env", "@babel/react"]
}
```

> *如果既有`Babel`插件，又有`Babel`预设，那么执行顺序如何呢？* 
>
> **答案：** **插件** 的优先级高于 **预设**，先执行插件（按照声明的插件顺序执行），再执行预设（按照声明的预设逆序执行）

### 6.5、按需加载插件

`@babel/preset-env`包含 `ES2015`、`ES2016`、....... 等最新ES6+特性转换插件，但现在很多最新浏览器也支持ES6+部分新特性，如果你的代码只需运行在这些高级（新）浏览器上，那已支持的ES6+新特性就无需对应的`Babel`插件转换，**大大提高代码转译性能**

`@babel/preset-env`已支持按需加载功能，只要我们指定目标浏览器及其版本，`@babel/preset-env`就会根据目标浏览器的特性（未支持ES6+特性）加载对应`Babel`插件进行代码转换

> 目标浏览器指定有2种方式: 
>  1、在`Babel`配置文件中通过targets属性指定 
>  2、使用`.browserslistrc`文件来指定 （推荐）
>
> PS：指定目标浏览器，除了用于`@babel/preset-env`按需加载对应转换插件外，还用于`autoprefixer`根据目标浏览器添加的 CSS 浏览器前缀（**CSS3兼容处理**）

[查看 browserslist 的更多配置](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist)

```arduino
arduino 体验AI代码助手 代码解读复制代码// .browserslistrc 配置案例
ie >= 8
Firefox >= 3.5
chrome  >= 35
opera >= 11.5
```

### 6.6、注意事项

1、`@babel/preset-env`**完全替代**`babel-preset-es2015/es2016/es2017/......`（以前使用的ES6+转换插件），说白了就是把`babel-preset-es2015/es2016/es2017/......`废弃掉。另外`@babel/preset-env`默认不支持`stage-x`预设（已废弃）

2、从`Babel7`开始，官方就把`stage-x`(预设`babel-preset-stage-0/1/2/3/4`)废弃掉，[请看](https://link.juejin.cn?target=https%3A%2F%2Fwww.babeljs.cn%2Fblog%2F2018%2F07%2F27%2Fremoving-babels-stage-presets)

3、预设只是插件的一个集合，默认`@babel/preset-env`只会对ES6+新语法进行转换，也就是我们看到的箭头函数、const/let这类。如果进一步需要转换内置对象、实例方法（api），那就需要接下来介绍的`polyfill`补充。

*PS*：为何开头是说 “**默认**” 两字呢？因为`polyfill`与`@babel/preset-env`有关联的，所以只要在`@babel/preset-env`内配置`useBuiltIns`选项就可以启用`polyfill`，默认是禁用`polyfill`，详细的内容下面会讲



## 7、补充（polyfill）

> 官方的'polypill'是`@babel/polyfill`，**Babel 7.4.0 开始**，`@babel/polyfill`这个包已经废弃

上文也提到了，比如像`Promise`、`Generator`、`Symbol`这种新内置对象、数组`includes()`新API，咱们的 **babel** 并没有给转译，那是因为 **babel插件** 默认是只会去转译`ES6+`语法的。这个时候就要出动`@babel/polyfill`补充包来模拟`ES6+`环境:

### 7.1、安装与使用

安装命令如下：

```css
npm i @babel/polyfill -S   // 要生产安装 -S
```

> 为何要用`-S`而不是`-D`安装 ？ 看下使用`polyfill`转换后的代码，你就能明白原因了

```scss
// 原来的代码 
var hasTwo = [1, 2, 3].includes(2); 

// 转后的代码 
require("core-js/modules/es7.array.includes"); 
require("core-js/modules/es6.string.includes"); 
var hasTwo = [1, 2, 3].includes(2);
```

使用非常简单，只要给`@babel/preset-env`配置一个`useBuiltIns`选项就可以了，其中`useBuiltIns`选项可选值有3种：`"usage"`、`"entry"` 、 `false`，默认是`false`

一般我们把`useBuiltIns`设为`"usage"`，那么`babel`转换代码时，就会根据以下2个条件进行 **按需导入** 补充

1. 目标浏览器 
2. 代码（含ES6+的新API和内置新对象等）

```css
// babel.config.json配置
{
    "presets": [
       [ 
       "@babel/env", 
           { 
               targets: { 
                   edge: "17", 
                   chrome: "64",
                   firefox: "60", 
                   safari: "11.1",
                   ie: "10"
               },
               useBuiltIns: "usage"
           } 
        ]
    ]
}
```

### 7.2、已废弃

由于 **Babel 7.4.0 开始** ，`@babel/polyfill`这个包已经废弃，通过 core-js 替代。上面介绍的内容仅适合 **Babel 7.4.0 之前版本**，但即使是`7.4.0`之前的版本，也建议你不要用`@babel/polyfill`，因为`@babel/polyfill`一年没更新了，但ES6+新语法每年都在新增，换句话说，就是今年最新的JS语法`@babel/polyfill`已不支持了

#### 前置知识

`@babel/polyfill`是由`core-js2`和`regenerator-runtime`组成的一个集成包 
 (即`@babel/polyfill` = `core-js@2` + `regenerator-runtime`)

> regenerator-runtime：用于对`generator`、`async`新特性提供补充 （es6 异步关键词的实现）
>  core-js：用于对`ES6+`新特性（例如：`includes()`、`Array.from`等）提供补充（es6 的对象和方法实现）

#### 解决方案

**官方推荐单独使用`core-js`和`regenerator-runtime`包，然后设置`@babel/preset-env`的`corejs`选项为`3`**

> 如果你安装了`@babel/polyfill`包，你可以先卸载：`npm uninstall @babel/polyfill`

安装`core-js`和`regenerator-runtime`补充包，当前最新版本是**3.17.3**

```css
npm i core-js regenerator-runtime --save  // 记住必须用 --save 安装
```

而`regenerator-runtime`包可以不按装，因为`@babel/preset-env`已经内置了，手动安装只是更新下包版本，万事俱备只剩下配置了

```css
// babel.config.json配置
{
    "presets": [
       [ 
           "@babel/env", 
           { 
               targets: { 
                   edge: "17", 
                   chrome: "64",
                   firefox: "60", 
                   safari: "11.1",
                   ie: "10"
               },
               useBuiltIns: "usage",
               corejs: 3
           } 
        ]
    ]
}
```

到此，就完美解决`@babel/polyfill`废弃问题

#### 为何使用core-js@3，而不是core-js@2 ?

> `@babel/polyfill`内置`core-js`包版本默认是 **2**

说一下使用 `core-js@3` 的原因，`core-js@2` 分支中已经不会再添加新特性，新特性都会添加到 `core-js@3`。例如你使用了 `Array.prototype.flat()`，如果你使用的是 `core-js@2`，那么其不包含此新特性。为了可以使用更多的新特性，建议大家使用 `core-js@3`。

> 为何不再推荐使用`@babel/polyfill`呢？

1、`@babel/polyfill`已经一年多没更新了，而`core-js@3`不断在更新，`core-js@3`取代了`@babel/polyfill`

2、因为`@babel/polyfill`不支持从`core-js@2`平滑的过渡到`core-js@3`。所以`core-js`官方现在推荐我们使用`polyfill`的时候直接引入`core-js`和`regenerator-runtime/runtime`这两个包完全取代 **@babel/polyfil** 来为了防止重大更改

### 注意事项

对于**库/工具**, 如果不需要用到像`Array.prototype.includes`这样的实例方法, 可以使用`transform runtime`插件, 而不是使用污染全局的`@babel/polyfill`

对于**应用程序**, 我们建议安装使用`@babel/polyfill`（**Babel 7.4.0+** 之后版本用上面的方式）

## 8、开发工具库/组件库

如果需要开发工具库或者组件库，就不能使用`@babel/polyfill`，因为`@babel/polyfill`会导致全局污染， 这时需要用到`@babel/runtime-corejs3`和`@babel/plugin-transform-runtime`。

只需要配置 `@babel/plugin-transform-runtime` 的参数 `corejs`。该参数默认为 `false`，可以设置为 2 或者 3，分别对应 `@babel/runtime-corejs2` 和 `@babel/runtime-corejs3`。

**`corejs: 2`仅支持全局变量（例如`Promise`）和静态属性（例如`Array.from`），`corejs: 3`还支持实例属性（例如`[].includes`）。**

### 8.1、@babel/runtime-corejs3

这个包主要提供所有语法转换会用到的辅助函数，安装如下

```css
npm i --save @babel/runtime-corejs3
```

> ```
> @babel/runtime`最大的问题就是无法模拟实例上的方法，比如数组的`includes`方法，但使用新增的`@babel/runtime-corejs3`之后支持了，所以直接安装`@babel/runtime-corejs3`取代`@babel/runtime
> ```

这样就解决了代码复用和最终文件体积大的问题。不过，这么多辅助函数要一个个记住并手动引入，平常人是做不到的。这个时候，`Babel`插件`@babel/plugin-transform-runtime`就来帮我们解决这个问题。

### 8.2、@babel/plugin-transform-runtime

这个包主要解决2个问题 1、辅助函数按需引入问题 2、解决全局污染问题

安装如下：

```css
npm i @babel/plugin-transform-runtime -D
```

优化配置如下：

```css
// babel.config.json配置
{
    "presets": [
       [ 
           "@babel/env", 
           { 
               targets: { 
                   edge: "17", 
                   chrome: "64",
                   firefox: "60", 
                   safari: "11.1",
                   ie: "10"
               }
           } 
        ]
    ],
    "plugins": [
        ["@babel/plugin-transform-runtime", {
            "corejs": 3
        }]
    ]
}
```

PS： 
 默认corejs为false，意思是按需加载`@babel/runtime`包中辅助函数 
 corejs为2，意思是按需加载`@babel/runtime-corejs2`包中辅助函数 
 corejs为3，意思是按需加载`@babel/runtime-corejs3`包中辅助函数 



# 五、babel版本

babel 的编译流程和目的从没有变过，但是完成这个目的的方式却变化很大，我们来回顾一下 `babel 6`，`babel 7` 都是怎么设计的，`babel 8` 又会怎么做，或许能帮你真正理解 babel。

## 1、babel 6

es 的标准一年一个版本，也就意味着 babel 插件要实时的去跟进，一年实现一系列插件。

ECMAScript（简称 ES）是 JavaScript 的标准化版本，它的新特性通常会经过一个由 TC39（ECMA 技术委员会）管理的提案过程，分为五个阶段，分别是 Stage 0 到 Stage 4。这些阶段代表了新特性从最初的提议到最终成为标准的过程。 具体各个阶段的含义如下：

1. Stage 0 - Strawman（草案）：此阶段是为了提出初步想法而设立的，通常由个人或小组提出，而不是由 TC39 委员会批准的提案。这些提案可能只是一个想法的草图，并不具有实际应用性。
2. Stage 1 - Proposal（提案）：在这个阶段，提案已经详细说明了设计、语法和语义，并且经过了初步讨论。该阶段要求提供详细的说明文档，以及实现和用户反馈等。
3. Stage 2 - Draft（草案）：在这个阶段，提案已经完整地描述了其语法和语义，并且有了初步的实现。这意味着提案已经成为一个可供实际使用的草案。
4. Stage 3 - Candidate（候选）：在这个阶段，提案已经基本完成，所有方面都已经得到了充分的讨论和评审，并且已经有了至少一个实现。这意味着提案已经足够成熟，可以供开发者使用和提供反馈。
5. Stage 4 - Finished（完成）：在这个阶段，提案已经通过了所有的评审流程，并且已经被加入到了 ECMAScript 的标准中。这意味着该特性已经成为了 JavaScript 的一部分，并且可以在任何支持该版本标准的环境中使用。

因此，当说一个特性处于 Stage 3 时，意味着它已经相对成熟，具有可用性，并且很可能会最终成为 ECMAScript 标准的一部分。

有这么多特性要 babel 去转换，每个特性用一个 babel 插件来做。但是特性多啊，也就是说插件多，总不能让用户自己去配一个个插件吧，所以 babel 6 引入了 preset 的概念，就是 plugin 的集合。

如果我们想用 es6 语法就用 babel-preset-es2015，es7 就在引入 babel-preset-es2016 等等。如果是想用还没加入标准的特性，则分别用 babel-preset-stage0、babel-preset-stage1 等来引入。这样通过选择不同的 preset，加上手动引入一些插件，就是所有 babel 会做的转换。

可以把这个过程理解为集合求并集的过程。

![webpack88](..\images\webpack88.png)

并集的结果就是所有支持的特性。

babel 6 就是通过这样的方式来支持各种目标环境不支持的特性转换的配置。

**细想一下，这样的方式有没有问题？**

这样虽然能达到目的，但是是有问题的，主要有两点：

- es 的标准每年都在变，现在的 stage-0 可能很快就 stage-2 了，那 preset 怎么维护，要不要跟着变，用户怎么知道这个 stage-x 都支持什么特性？
- 只能转成 es5，那目标环境支持一些 es6 特性了，那这些转换和 polyfill 岂不是无用功？ 而且还增加了产物的体积。
- polyfill 手动引入，比较麻烦，有没有更好的方式

这两个问题是 babel 6 的时候一直存在的。所以这种方案算是及格，但是还是有问题的，我们给 70 分不过分吧。 （能完成功能就可以给 60 分，多加 10 分是给 babel 6 引入的 preset，确实简化了很多配置）

那怎么解决 babel 6 的问题呢？babel 7 给出了答案。

## 2、babel 7

babel 7 改动挺大的，比如所有的包都迁移到了 @babel 的 scope 下，也就是 @babel/xxx，这些我们不管，只看 babel 7 是怎么解决 babel 6 的问题的，

babel 7 废弃了 preset-20xx 和 preset-stage-x 的 preset 包，而换成了 preset-env，preset-env 默认会支持所有 es 标准的特性，如果没进入标准的，不再封装成 preset，需要手动指定 plugin-proposal-xxx。

它的集合是这样的：

![webpack89](..\images\webpack89.png)

是不是比起 babel 6 更简单了。

（preset-react 等不是 es 标准语法，也没有啥变化，就不包括在里面了）。

但是 preset 和 plugin proposal 的改变只是解决了之前的 preset 经常变的问题。那么多转换了一些环境支持的特性，这个问题是怎么解决的呢？

答案是 compat-table，它给出了每个特性在不同浏览器或者 node 环境中的最低支持版本，babel 基于这个自己维护了一份数据库，在 [@babel/compat-data](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-compat-data%2Fdata%2Fplugins.json) 下。

其中有每个特性在不同环境的什么版本支持的数据：

![webpack90](..\images\webpack90.png)

有了这些数据，那么只要用户指定他的目标环境是啥就可以了，这时候可以用 browserslist 的 query 来写，比如 last 1 version，> 1% 这种字符串，babel 会使用 brwoserslist 来把它们转成目标环境具体版本的数据。

![webpack91](..\images\webpack91.png)

有了不同特性支持的环境的最低版本的数据，有了具体的版本，那么过滤出来的就是目标环境不支持的特性，然后引入它们对应的插件即可。这就是 preset-env 做的事情。

![webpack92](..\images\webpack92.png)

配置方式比如：

```javascript
{
    "presets": [["@babel/preset-env", { "targets": "> 0.25%, not dead" }]]
}
```

这样就通过 preset-env 解决了转换了目标环境已经支持的特性的问题。其实 polyfill 也可以通过 targets 来过滤。

![webpack93](..\images\webpack93.png)

不再手动引入 polyfill，那么怎么引入？ 当然是用 preset-env 自动引入了。但是也不是默认就会启用这个功能，需要配置。

```javascript
{
    "presets": [["@babel/preset-env", { 
        "targets": "> 0.25%, not dead",
        "useBuiltIns": "usage",// or "entry" or "false"
        "corejs": 3
    }]]
}
```

配置下 corejs 和 useBuiltIns。

- corejs 就是 babel 7 所用的 polyfill，需要指定下版本，corejs 3 才支持实例方法（比如 Array.prototype.fill ）的 polyfill。
- useBuiltIns 就是使用 polyfill （corejs）的方式，是在入口处全部引入（entry），还是每个文件引入用到的（usage），或者不引入（false）。

配置了这两个 option 就可以自动引入 polyfill 了。

![webpack94](..\images\webpack94.png)

polyfill 默认是全局引入的，有的时候不想污染全局变量就要用 @babel/plugin-transform-runtime 转换下。（这个插件 babel 6 就有了）。

![webpack95](..\images\webpack95.png)

这样就不再污染全局环境了，而是使用一个唯一的标识符来引入。

看起来，babel 7 好像已经很完美了，可以打 90 多分了？

不是的，babel 7 有 babel 7 的问题。

**babel 7 的问题**

@babel/plugin-transform-runtime 是不支持配置 targets 的，因为不知道目标环境支持啥，它只能全部做转换。你可能说不是有 preset-env 么？

babel 中插件的应用顺序是：先 plugin 再 preset，plugin 从左到右，preset 从右到左，这样 plugin-transform-runtime 是在 preset-env 前面的。

等 @babel/plugin-transform-runtime 转完了之后，再交给 preset-env 这时候已经做了无用的转换了。

我们来试验一下：

我们先看一下 Array.prototype.fill 的环境支持情况：

![webpack96](..\images\webpack96.png)

可以看到在 Chrome 45 及以上支持这个特性，而在 Chrome 44 就不支持了。

我们先单独试一下 preset-env：

当指定 targets 为 Chrome 44 时，应该自动引入polyfill：

![webpack97](..\images\webpack97.png)

当指定 targets 为 Chrome 45 时，不需要引入polyfill：

![webpack98](..\images\webpack98.png)

结果都符合预期，44 引入，45 不引入。

我们再来试试 @babel/plugin-transform-runtime：

![webpack99](..\images\webpack99.png)

是不是发现问题了，Chrome 45 不是支持 Array.prototype.fill 方法么，为啥还是引入了 polyfill。

于是去问了下作者，提了个 [feature request](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fissues%2F13226)，作者说可以用最新的 babel polyfill 系列包解决了这个问题.

去看了下，这个包还在试验阶段，确实解决了这个问题。

这个包估计在 babel 8 会内置到 babel。

那么给 babel 7 打个分吧，本来 preset-env 的引入使我们能更精准的转换代码和引入 polyfill，想给 90 分，但是 plugin-transform-runtime 的问题让我给它减了 10 分，综合给 80 分吧。

## 3、babel 8

babel 8 还没出来，但是我们知道 babel 再怎么更新也是围绕主线来的，也就是对目标环境不支持的特性自动进行精准的转换和 polyfill。每个版本都是解决了上个版本的问题的，babel 8 的 @babel/polyfills 包就解决了 babel 7 的 @babel/plugin-transform-runtime 的遗留问题，可以通过 targets 来按需精准引入 polyfill 了。

它支持配置一个 polyfill provider，也就是说你可以指定 corejs2、corejs3、es-shims 等的polyfill，还可以自定义 polyfil，也就是你可以使用自己的 polyfill。

然后有了 polyfill 源之后，使用 polyfill 的方式也把之前 transform-runtime 做的事情内置了，也就是从之前的 useBuiltIns: entry、 useBuiltIns: usage 的两种，变成了 3 种：

这个方案实现后，Babel 的配置会是下面的样子：

```
// babel.config.js
const targets = [
  '>1%'
]
const presets = [
  [
    '@babel/env',
    {
      debug: true
    }
  ]
]
const plugins = [
  '@babel/plugin-proposal-class-properties'
]
const polyfills = [
  [
    'corejs3',
    {
      method: 'usage-pure'
    }
  ]
]

module.exports = { targets, presets, plugins, polyfills }
```



- entry-global: 这个和之前的 useBuiltIns: entry 对标，就是全局引入 polyfill。

  ![webpack100](..\images\webpack100.png)

- usage-entry: 这个和 useBuiltIns: usage 对标，就是具体模块引入用到的 polyfill。

  ![webpack101](..\images\webpack101.png)

- usage-pure：这个就是之前需要 transform-runtime 插件做的事情，使用不污染全局变量的 pure 的方式引入具体模块用到的 polyfill.

  ![webpack102](..\images\webpack102.png)

其实这三种方式 babel 7 也支持，但是现在不再需要插件了，而且还支持了 polyfill provider 的配置，所以到了 babel 8 的阶段， @babel/preset-env 才是功能完备的。

**那么插件如果想用 targets 该怎么用呢？**

@babel/helper-compilation-targets ，helper 是用于插件之间复用代码的方式，也就是给插件开发用的库。

![webpack103](..\images\webpack103.png)

我看了下，这个库提供了 3 个 api：

- 根据 query 查询目标环境版本： getTargets
- 过滤目标环境: filterItems
- 判断某个插件是否需要：isRequired

分别对应我们前面聊到的需要 先**通过 query 确定目标环境**，然后**对目标环境做过滤**，之后**判断某个插件是否需要**的 3个阶段。

插件里面通过 api.targets() 拿到环境的配置，然后通过 isRequired 来确定某个插件有没有必要用。

![webpack104](..\images\webpack104.png)

这样，不管是内置 plugin 和 preset 的实现方式也好，还是插件所能用的 api 也好，都完美支持了 targets，到了这个阶段 targets 才算真正融入进了 babel 中。

这个阶段的 babel，我觉得已经可以给出 90 分的分数了：

支持按照配置的目标环境按需进行 polyfill 和 transform，支持 polyfill 的切换和自定义，配置方式也足够简单，插件中也可以用 targets，而且提供了方便的 helper 包。