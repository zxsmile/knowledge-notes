# 一、前言

> 在旧开发的时代，前端项目在开发的过程中修改代码，很有可能是手动切到浏览器刷新页面来看到改动效果。操作不方便且页面之前的编辑记录也都丢失，体验可以说为0。想象一下一个表达你努力填满了所有输入项，结果因为调了一下样式就丢失了所有输入内容，你的心情如何？

随后变出现`live reload`自动刷新，解决了手动切的尴尬操作但页面的状态问题仍未解决。

随着前端工程化的推进，`HMR`（`Hot Module Replace`）热模块替换的技术的出现急不可耐，我们可以很简单的配置便能感受这优雅的开发体验。

下面就让我们一起分析`HMR`是如何工作的吧！

# 二、什么是热更新

什么是浏览器的热更新？有些同学可能认为是保存自动编译、或者是自动刷新浏览器就叫热更新；又或者代码能够热替换就是热更新。

这些说的都对，但不全面。浏览器热更新技术严格的讲，指的是我们开发时能够在浏览器页面中实时看到我们代码的变化产生效果的流程。热更新技术包含了监听本地文件、增量编译构建、代码热替换、socket通信等技术点。

模块热替换(`hot module replacement 或 HMR`)是 `webpack` 提供的最有用的功能之一。它允许在运行时更新所有类型的模块，而无需完全刷新

一般的刷新我们分两种：

- 一种是页面刷新，不保留页面状态，就是简单粗暴，直接 `window.location.reload()`。
- 另一种是基于 `WDS (Webpack-dev-server)` 的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。

可以看到相比于第一种，热更新对于我们的开发体验以及开发效率都具有重大的意义

`HMR ` 作为一个 `Webpack` 内置的功能，可以通过 `HotModuleReplacementPlugin` 或 `--hot` 开启。

# 三、`HMR`最简单的理解

相信你已经或多或少看到过一些监听开发代码改动，浏览器与静态服务器`socket`通信的一些`HMR`相关点。

![webpack112](..\images\webpack112.png)

这个图描绘了大致的工作原理。能够帮助你站在更高的角度去俯视这个过程中的流转、以及关键角色。 接下来就是对其中的流程一步一步进行剖析。

# 四、`HMR`流程原理

### 1、先了解`webpack`热更新的重要插件

#### `webpack-dev-middleware`

本质上是一个容器，最主要是能够将`webpack`编译产物提交给服务器，并且他将产物放置在内存中【这也是为啥我们在开发过程中在文件夹中找不到我们的打包代码】。

`webpack-dev-middleware` 是一个 `express` 中间件，核心实现两个功能：第一通过`file-loader`内部集成了`node`的 `monery-fs/memfs` 内部文件系统，直接**将资源存储在内存**；第二是通过**`watch`监听文件的变化，动态编译**。

#### `webpack-hot-middleware`

**核心是给`webpack`提高服务端和客户端之间的通信机制**，用于将文件变化的信息推送给浏览器，内部使用`EventSocurce`实现。

在`webpack`第一次打包的时候，除了代码本身之外，还包含一部分`HMRruntime`订阅服务代码，`HMRruntime` 订阅服务端的更新变化，触发`HMR runtime API`拉取最新的资源模块。

`webpack-hot-middleware`实现页面的热重载。**这个插件在新版本中似乎已经不再需要了**

#### `webpack-dev-server`

内置了`webpack-dev-middleware`和`node-express`[启动服务] 服务器，利用`webpack-dev-middleware`提供文件的监听和编译，利用`express`提供`http`服务，底层利用`websocket`代替`EventSource`实现了`webpack-hot-middleware`提供的客户端和服务器之间的通信机制。

有了他，你就可以方便的启动一个具有热更新功能的本地服务器。不用你自己手写什么`let app = new express();app.listen(8080);`这样的启动服务代码了。

#### 知识点扩充：`EventSource`

`EventSource` 是服务器推送的一个网络事件接口。一个`EventSource`实例会对`HTTP`服务开启一个持久化的连接，以`text/event-stream` 格式发送事件, 会一直保持开启直到被要求关闭。

一旦连接开启，来自服务端传入的消息会以事件的形式分发至你代码中。如果接收消息中有一个事件字段，触发的事件与事件字段的值相同。如果没有事件字段存在，则将触发通用事件。

与 `WebSockets`，不同的是，`EventSource`服务端推送是单向的。数据信息被单向从服务端到客户端分发. 当不需要以消息形式将数据从客户端发送到服务器时，这使它们成为绝佳的选择。例如，对于处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如`IndexedDB`或`Web`存储）之类的，`EventSource`无疑是一个有效方案。

再补充一些知识点：

- `webSocket`：长连接双向通信【让服务器与浏览器连接起来，方便通信】
- `webpack`的构建可以选择`watch`模式，他自身已经具备了监听文件变化，持续构建的能力。但还未有将自动刷新客户端的能力，并且对新构建的文件未有进行热替换的能力。
- 而`webpack-dev-server`则是提供自动刷新客户端的能力，他启动一个静态资源托管服务器，客户端访问该服务器，并且通过`socket`与客户端长连接以便在新构建后通知到客户端进行更新
- 而`webpack`内置插件`HotModuleReplacement.plugin`插件则是提供热替换的能力：在客户端拿到新代码后，将新代码与旧代码替换

**tips: `webpack`热更新的过程中涉及到比较多的角色，一定要区分好各个角色在过程中发乎着不同的作用。**

**让我们运行`npm run serve`，开始分析这个过程吧！**

`package.json`

```js
...
  "scripts": {
    "build": "webpack",
    "serve": "webpack-dev-server"
  },
...
```

## 2、`HMR`流程分析

### 第一阶段：初始化环境

兜兜转转便来到了`webpack-dev-server/lib/Server.js`

`webpack-dev-server`做了非常关键的3个动作：

- 启动静态服务器
- 开通长连接
- 为打包产物注入`HMR`代码【使得客户端具备热更新能力】

启动静态服务器、开通长连接这两个动作很好理解，也可以对应上图去理解。 那么【 为打包产物注入`HMR`代码【使得客户端具备热更新能力】是啥意思呢？

想象一下，当你的代码在浏览器运行的时候，怎么跟服务器进行长连接呢？这部分代码你肯定是没有写过。这是由`webpack-dev-server`插件注入到我们产物代码中的。此外除了长连接代码，还有热更新的代码替换等代码都是要被注入的。

**我们来看看插件是如何在我们的产物中注入代码的？**

过程比想象的要简单，通过在我们的`webpack`入口`entry`中新增文件，在`webpack`进行构建的时候从`entry`开始顺藤摸瓜组织代码便一同打包进来。

我们可以看到注入了两个文件：

- `webpack-dev-server/client` 【`socket`管理】
- `webpack/hot/dev-server` 【热更新能力】

![webpack113](..\images\webpack113.png)

紧接着构建过程以`compiler.watch()`的方式运行，这种模式下打包完不会结束掉打包进程，而是持续运行，监听文件变化后进行增量构建【前面有提到这是`webpack`的能力之一】。一般`npm run build`的方式就是执行`compiler.run()`打包一次就结束了。

`compiler.watch()`构建后的产物通过`webpack-dev-middleware`插件提交到服务器。

而`webpack`提供的持续监控文件变化的能力是基于`node`的`fs.watch()`实现的。他的原理是通过轮询文件的修改时间比对去判断该文件是否发生变化。

至此我们的项目处于一种运行的状态，能够对代码改动触发增量构建并更新到服务器。

以上的过程可以理解为 环境初始化阶段。

### 第二阶段：客户端热更新

接着我们打开一个浏览器访问：`localhost:XXX`时，就能够访问到我们的页面。

![webpack114](..\images\webpack114.png)

我们可以看到浏览器已经跟服务器进行了长连接。

先来看看我们的项目代码：

入口文件`index.js` // 导入`writeA.js`并处理`writeA.js`的热更新逻辑

```js
import './writeA'
if(module.hot) {
    module.hot.accept('./writeA.js', () => {
        console.log('index.js 捕获到writeA.js的变化...');
        let writeAEl = document.getElementById('ttt');
        if(writeAEl) {
            writeAEl.parentNode.removeChild(writeAEl)
        }
    })
}
```

`writeA.js`  // 给`body`插入元素

```js
let myElement = document.createElement('div')
myElement.innerText = 'writeA.js 123456'
myElement.id = 'ttt'
document.body.appendChild(myElement);
console.log('writeA.js run...');
```

代码很简单，`module.hot.accept`的意思就是捕获`writeA.js`的改动，如果他改动了就触发逻辑。`module.hot.accept`的触发时机会在后面提到。

然后修改`writeA.js`文件并保存，可以看到浏览器请求了两个文件：

![webpack115](..\images\webpack115.png)

在修改文件后，触发`webpack`增量构建【只构建了`writeA.js`模块，所以速度极快】，当构建结束后会提交到服务器，服务器通过`socket`通知给浏览器，浏览器收到通知后下载更新文件，下载后对文件进行热替换。大概就是这么一个过程。

这里补充一个知识点：如何知道构建结束并调用`socket`通知浏览器的？

![webpack116](..\images\webpack116.png)

代码层面也很好理解，`webpack-dev-server`插件监听`hooks.done`【这里需要你对`webpack`的`tapable`机制有一定了解，类似于发布订阅模式，当编译完成就会触发钩子`hooks.done`,插件可以监听钩子做自己的逻辑】，触发则调用`socket`发送消息给客户端，此时会把本次构建生成的`hash`一起传给客户端。

这里重点关注浏览器收到这个构建`hash`后的动作，也是热更新过程的重中之重。

客户端`socket`收到`hash`消息后，先将`hash`值保存起来。再收到`ok`消息后调用`reloadApp()`

伪代码：

```js
// 路径 webpackd-dev-server/client/reloadApp.js
reloadApp() {
  if(hot) {
      hotEmitter.emit("webpackHotUpdate", hash); // 走这里
  }esle {
      window.location.reload()
  }
}
```

发出一个通知事件`hotEmitter.emit(""webpackHotUpdate)`,这时候`webpack/hot/dev-server.js`【这个文件是上面提到被注入到客户端的代码】监听到该事件：

![webpack117](..\images\webpack117.png)

他最主要要是执行了`module.hot.check()`函数，那个这个函数又是哪里来的？ 这是`webpack/lib/hmr/HotModuleReplacement.runtime.js`在构建的过程中给`module`对象添加`hot`属性，对应上面`webpack-dev-server`插件的能力：为打包产物注入`HMR`代码。

`module.hot.check`函数调用`hmrDownloadManifest`利用fetch下载我们常见到的`XXX.hot-update.json`更新清单

```js
// XXX.hot-update.json
  {
    "c":["index"], // 更新chunk
    "r":[],
    "m":[]
    // 有些是有"h":hash,版本不同略微不一样
  }
```

然后回调`hmrDownloadUpdateHandlers`通过插入标签的方式下载并执行**`XXX.hot-update.js`文件

// `XXX.hot-update.js`

![webpack118](..\images\webpack118.png)

`xxx.hot-update.js`文件执行了一个函数`window.webpackHotUpdatewebpack_study_1`，该函数也是`webpack`注入代码执行的过程中给`window`添加的函数，他的作用大致就是将更新的`chunk`、`modules`信息保存下来先，以便后续处理这些信息。

```
module.hot.check()函数代码:
```

![webpack119](..\images\webpack119.png)

在下载完更新`XXX.hot-update.js`完成后，最后就是应用上这些新代码：

![webpack120](..\images\webpack120.png)

应用新代码的核心方法：

![webpack121](..\images\webpack121.png)

这个函数大致就是替换并运行模块代码，执行热替换函数【`module.hot.accept`】!

替换的过程涉及到`webpack`的关于`module`、`chunk`、`chunkGraph`、`moduleGraph`这样的知识，没有再去深入讲解`module`如何被替换。建议看之前写过的一篇文章全面的了解`webpack`的构建原理[# webpack原理解析【长文万字】](https://juejin.cn/post/7125696644435148831)。

可以看到，修改后的`writeA.js`重新运行一次，然后`index.js`对`writeA.js`的`hot.accept()`被触发。

![webpack122](..\images\webpack122.png)

至此整个热更新的过程结束！！！

下面我们再梳理一遍客户端从收到`socket`消息`ok`之后的调用流程：

![webpack123](..\images\webpack123.png)

## 3、上帝视角看流程

![webpack124](..\images\webpack124.png)

## 4、热更新原理总结

![webpack125](..\images\webpack125.png)

第一步，在 `webpack` 的 watch 模式下，文件系统中某一个文件发生修改，`webpack` 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 `JavaScript` 对象保存在内存中。

第二步是 `webpack-dev-server` 和 `webpack` 之间的接口交互，而在这一步，主要是 `dev-server` 的中间件 `webpack-dev-middleware` 和 `webpack`之间的交互，`webpack-dev-middleware` 调用 `webpack`暴露的 `API`对代码变化进行监控，并且告诉 `webpack`，将代码打包到内存中。

第三步是 `webpack-dev-server` 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了`devServer.watchContentBase` 为 `true` 的时候，`Server` 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 `live reload`。注意，这儿是浏览器刷新，和 `HMR` 是两个概念。

第四步也是 `webpack-dev-server` 代码的工作，该步骤主要是通过 `sockjs`（`webpack-dev-server` 的依赖）在浏览器端和服务端之间建立一个 `websocket` 长连接，将 `webpack`编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 `Server` 监听静态文件变化的信息。浏览器端根据这些 `socket` 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 `hash` 值，后面的步骤根据这一 `hash` 值来进行模块热替换。

`webpack-dev-server/client` 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 `webpack`，`webpack/hot/dev-server` 的工作就是根据 `webpack-dev-server/client` 传给它的信息以及 `dev-server` 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。

`HotModuleReplacement.runtime` 是客户端 `HMR` 的中枢，它接收到上一步传递给他的新模块的 `hash` 值，它通过 `JsonpMainTemplate.runtime` 向 `server` 端发送 `Ajax` 请求，服务端返回一个 `json`，该 `json` 包含了所有要更新的模块的 `hash` 值，获取到更新列表后，该模块再次通过 `jsonp` 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。

而第 10 步是决定 `HMR` 成功与否的关键步骤，在该步骤中，`HotModulePlugin` 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 `HMR` 失败后，回退到 `live reload` 操作，也就是进行浏览器刷新来获取最新打包代码。

在初步体会了`webpack`的热更新之后，可能需要思考以下的问题

思考💡：为什么需要热更新？

`Hot Module Replacement`（以下简称 `HMR`）是 `webpack` 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，`webpack`将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。例如，在开发 `Web` 页面过程中，当你点击按钮，出现一个弹窗的时候，发现弹窗标题没有对齐，这时候你修改 `CSS` 样式，然后保存，在浏览器没有刷新的前提下，标题样式发生了改变。感觉就像在 `Chrome` 的开发者工具中直接修改元素样式一样。

思考💡：`HMR`是怎样实现自动编译的？

`webpack`通过`watch`可以监听文件编译完成和监听文件的变化，`webpack-dev-middleware`可以调用`webpack`的`API`监听代码的变化，`webpack-dev-middleware`利用`sockjs`和`webpack-dev-server/client`建立`webSocket`长连接。将`webpack`的编译编译打包的各个阶段告诉浏览器端。主要告诉新模块`hash`的变化，然后`webpack-dev-server/client`是无法获取更新的代码的，通过`webpack/hot/server`获取更新的模块，然后`HMR`对比更新模块和模块的依赖。

思考💡：模块内容的变更浏览器又是如何感知的？

`webpack-dev-middleware`利用`sockjs`和`webpack-dev-server/client`建立`webSocket`长连接。将`webpack`的编译编译打包的各个阶段告诉浏览器端。

思考💡：以及新产生的两个文件又是干嘛的？

**`d04feccfa446b174bc10.hot-update.json`**

告知浏览器新的`hash`值，并且是哪个`chunk`发生了改变

![webpack126](..\images\webpack126.png)

**`main.d04feccfa446b174bc10.hot-update.js`**

告知浏览器，`main` 代码块中的`/src/title.js`模块变更的内容

![webpack127](..\images\webpack127.png)

首先是通过`XMLHttpRequest`的方式，利用上一次保存的`hash`值请求`hot-update.json`文件。这个描述文件的作用就是提供了修改的文件所在的`chunkId`。

然后通过`JSONP`的方式，利用`hot-update.json`返回的`chunkId` 及 上一次保存的`hash` 拼接文件名进而获取文件内容。

思考💡：怎么实现局部更新的？

当`hot-update.js`文件加载好后，就会执行`window.webpackHotUpdate`，进而调用了`hotApply`。`hotApply`根据模块`ID`找到旧模块然后将它删除，然后执行父模块中注册的`accept`回调，从而实现模块内容的局部更新。

思考💡：`webpack`可以将不同的模块打包成 `bundle` 文件或者几个 `chunk` 文件，但是当我通过 w`ebpack HMR` 进行开发的过程中，我并没有在我的 `dist` 目录中找到 `webpack`打包好的文件，它们去哪呢？

原来 `webpack`将 `bundle.js` 文件打包到了内存中，不生成文件的原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销，这一切都归功于`memory-fs`，`memory-fs` 是 `webpack-dev-middleware` 的一个依赖库，`webpack-dev-middleware` 将 `webpack`原本的 `outputFileSystem` 替换成了`MemoryFileSystem` 实例，这样代码就将输出到内存中。

思考💡：通过查看 `webpack-dev-server` 的 `package.json` 文件，我们知道其依赖于 `webpack-dev-middleware` 库，那么 `webpack-dev-middleware` 在 `HMR` 过程中扮演什么角色？

`webpack-dev-middleware`扮演是中间件的角色，一头可以调用`webpack`暴露的`API`检测代码的变化，一头可以通过`sockjs`和`webpack-dev-server/client`建立`webSocket`长连接，将`webpack`打包编译的各个阶段发送给浏览器端。

思考💡：使用 `HMR` 的过程中，通过 `Chrome` 开发者工具我知道浏览器是通过 `websocket` 和 `webpack-dev-server` 进行通信的，但是 `websocket` 的 `message` 中并没有发现新模块代码。打包后的新模块又是通过什么方式发送到浏览器端的呢？为什么新的模块不通过 `websocket` 随消息一起发送到浏览器端呢？

功能块的解耦，各个模块各司其职，`dev-server/client` 只负责消息的传递而不负责新模块的获取，而这些工作应该有 `HMR runtime` 来完成，`HMR runtime` 才应该是获取新代码的地方。再就是因为不使用 `webpack-dev-server` 的前提，使用 `webpack-hot-middleware` 和 `webpack`配合也可以完成模块热更新流程，在使用 `webpack-hot-middleware` 中有件有意思的事，它没有使用 `websocket`，而是使用的 `EventSource`。综上所述，`HMR` 的工作流中，不应该把新模块代码放在 `websocket` 消息中。

思考💡：浏览器拿到最新的模块代码，`HMR` 又是怎么将老的模块替换成新的模块，在替换的过程中怎样处理模块之间的依赖关系？

思考💡：当模块的热替换过程中，如果替换模块失败，有什么回退机制吗？

模块热更新的错误处理，如果在热更新过程中出现错误，热更新将回退到刷新浏览器

面试题：说一下`webpack`的热更新原理？

`webpack`通过watch可以监测代码的变化；`webpack-dev-middleware`可以调用`webpack`暴露的`API`检测代码变化，并且告诉`webpack`将代码保存到内存中；`webpack-dev-middleware`通过`sockjs`和`webpack-dev-server/client`建立`webSocket`长连接，将`webpack`打包阶段的各个状态告知浏览器端，最重要的是新模块的`hash`值。`webpack-dev-server/client`通过`webpack/hot/dev-server`中的`HMR`去请求新的更新模块，`HMR`主要借助`JSONP`。先拿到`hash`的`json`文件，然后根据`hash`拼接出更新的文件`js`，然后`HotModulePlugin`对比新旧模块和模块依赖完成更新。