# 一、Loader概念



Loader本质上是一个函数，负责代码的转译，即对接收到的内容进行转换后将转换后的结果返回配置Loader通过在` modules.rules`中以数组的形式配置。

`Loader` 转换器，用于转换模块的源代码。可以将不同类型的文件（如 CSS、图像、TypeScript 等）转换为 JavaScript 模块，从而使它们能够被 Webpack 处理。以下是 CSS 转换的例子：

```JS
// css-loader 转换后的 JavaScript 模块
module.exports = {
  // CSS 内容被转换为字符串
  css: "body { background-color: lightblue; } h1 { color: navy; }"
};

// style-loader 会将这些样式注入到 DOM 中
const style = document.createElement('style');
style.textContent = module.exports.css;
document.head.appendChild(style);
```

`webpack`中通过`compilation`对象进行模块编译时，会首先进行匹配`loader`处理文件得到结果`(string/buffer)`,之后才会输出给`webpack`进行编译。



# 二、`webpack`中配置`loader`的三种方式

通常我们在配置时都是直接使用直接使用`loader`名称的方式，比如:

```js
// webpack.config.js
module.exports = {
    ...
    module: {
        rules: [
            {
                test:/\.js$/,
                loader: 'babel-loader'
            }
        ]
    }
}
```

上边的配置文件中，相当于告诉`webpack`关于`js`结尾的文件使用`babel-loader`去处理。**可是这里我们明明只写了一个`babel-loader`的字符串，它是如何去寻找到`babel-loader`的真实内容呢？**

带着这个疑问，接下来让我们一起来看看在`webpack`中配置`loader`的三种方式。

## 1、绝对路径

**第一种方式在项目内部存在一些未发布的自定义`loader`时比较常见，直接使用绝对路径地址的形式指向`loader`文件所在的地址。** 比如:

```js
const path = require('path')
// webpack.config.js
module.exports = {
    ...
    module: {
        rules: [
            {
                test:/\.js$/,
                // .js后缀其实可以省略，后续我们会为大家说明这里如何配置loader的模块查找规则
                loader: path.resolve(__dirname,'../loaders/babel-loader.js')
            }
        ]
    }
}
```

这里我们在`loader`参数中传入一个绝对路径的形式，直接去该路径查找对应的`loader`所在的`js`文件。

## 2、`resolveLoader.alias`

第二种方式我们可以通过`webpack`中的`resolveLoader`的别名`alias`方式进行配置，比如：

```js
const path = require('path')
// webpack.config.js
module.exports = {
    ...
    resolveLoader: {
        alias: {
            'babel-loader': path.resolve(__dirname,'../loaders/babel-loader.js')
        }
    },
    module: {
        rules: [
            {
                test:/\.js$/,
                loader: 'babel-loader'
            }
        ]
    }
}
```

此时，当`webpack`在解析到`loader`中使用`babel-loader`时，查找到`alias`中定义了`babel-loader`的文件路径。就会按照这个路径查找到对应的`loader`文件从而使用该文件进行处理。

当然在我们定义`loader`时如果每一个`loader`都需要定义一次`resolveLoader.alias`的话无疑太过于冗余了，情况在真实业务场景下通常我们都很少自己定义`resolveLoader`选项但是`webpack`也可以自动的帮我们找到对应的`loader`，这就要引出我们的另一个参数了。

## 3、`resolveLoader.modules`

我们可以通过`resolveLoader.modules`定义`webpack`在解析`loader`时应该查找的目录，比如:

```js
const path = require('path')
// webpack.config.js
module.exports = {
    ...
    resolveLoader: {
        modules: [ path.resolve(__dirname,'../loaders/') ]
    },
    module: {
        rules: [
            {
                test:/\.js$/,
                loader: 'babel-loader'
            }
        ]
    }
}
```

上述代码中我们将`resolveLoader.modules`配置为` path.resolve(__dirname,'../loaders/')`，此时在`webpack`解析`loader`模块规则时就会去`path.resolve(__dirname,'../loaders/')`目录下去寻找对应文件。

当然**`resolveLoader.modules`的默认值是`['node_modules']`，自然在默认业务场景中我们通过`npm install`按照的第三方`loader`都是存在于`node_modules`内，所以配置`mainFields`默认就可以找到对应的`loader`入口文件。**

> 关于`resolveLoader`有些同学可能会非常眼熟，它和`resolve`正常模块解析的配置参数是一模一样的。只不过`resolveLoader`是相对于`loader`的模块加载规则的，具体更多的配置手册[你可以在这里看到](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fresolve%2F%23resolveloader)。

**同时需要注意的是`modules`字段中的相对路径查找规则是类似于 Node 查找 'node_modules' 的方式进行查找。比如说`modules:['node_modules']`，即是在当前目录中通过查看当前目录以及祖先路径（即 `./node_modules`, `../node_modules` 等等）进行规则查找。**

# 三、`Loader`配置相关`API`

## 1、常用基础配置参数

我们来看一段最简单的`webpack`配置文件:

```js
module.exports = {
  module: {
    rules: [
      { test: /.css$/, use: 'css-loader',enforce: 'post' },
      { test: /.ts$/, use: 'ts-loader' },
    ],
  },
};
```

相信这段配置代码大家已经耳熟能详了，我们通过`module`中的`rules`属性来配置`loader`。

其中:

#### test参数

`test`是一个正则表达式，我们会对应的资源文件根据`test`的规则去匹配。如果匹配到，那么该文件就会交给对应的`loader`去处理。

#### use参数

`use`表示匹配到`test`中匹配对应的文件应该使用哪个`loader`的规则去处理，`use`可以为一个字符串，也可以为一个数组。

> 注意，如果`use`为一个数组时表示有多个`loader`依次处理匹配的资源，按照 **从右往左(从下往上)** 的顺序去处理。

#### enforce参数

`loader`中存在一个`enforce`参数标志这`loader`的顺序,比如这样一份配置文件:

```js
js 体验AI代码助手 代码解读复制代码module.exports = {
  module: {
    rules: [
      { test: /.css$/, use: 'sass-loader', enforce: 'pre' },
      { test: /.css$/, use: 'css-loader' },
      { test: /.css$/, use: 'style-loader', enforce: 'post' },
    ],
  },
};
```

针对`.css`结尾的资源文件，我们在打包过程中`module.rules`分别有三条规则匹配到，也就是对于同一个`.css`文件我们需要使用匹配到的三个`loader`分别进行处理。

**那么此时，如果我们希望三个`loader`的顺序可以不根据书写时的顺序去处理，那么`enforce`就会大显身手**。

# 四、loader的种类

**在`webpack`配置文件中，我们可以通过`module`对象上的`rule.enforce`配置项可以将`loader`分为三种类型：`pre loader`、`normal loader`、`post noraml`，分别代表了三种不同的执行顺序：**

- 当`enforce`为`pre`时，该配置项目内的`loader`为前置`pre loader`。
- 当`enforce`为`post`时，该配置项目内的`loader`为后置`post loader`。
- 当`enforce`什么都不配置时，该配置项目内的`loader`为默认`normal loader`。

## inline loader

在 **配置文件中根据`loader`的执行顺序，我们可以将`loader`分为三种类型**，**同时`webpack`还支持一种内联的方式配置`loader`**, 比如我们在引用资源文件时:

```
import Styles from 'style-loader!css-loader?modules!./styles.css';
```

通过上述的方式，我们在引用`./styles.css`时候，调用了`css-loader`、`style-loader`进行提前处理文件，同时给`css-loader`传递了`modules`的参数。

我们将引用资源时，通过`!`分割使用`loader`的方式称为**行内`loader`**。

`inline loader`的执行顺序同样是从右往左，也就是`inline-loader`执行时会先执行`css-loader`处理文件，再会执行`style-loader`处理。

#### 关于`inline loader`还有一些**特殊的前置参数**：

通过为内联 `import` 语句添加前缀，可以覆盖配置中的所有 `normalLoader`, `preLoader` 和 `postLoader`：

- 使用 `!` 前缀，将禁用所有已配置的 normal loader(普通 loader)

  ```js
  import Styles from '!style-loader!css-loader?modules!./styles.css';
  ```

- 使用 `!!` 前缀，将禁用所有已配置的 loader（preLoader, loader, postLoader）

  ```js
  import Styles from '!!style-loader!css-loader?modules!./styles.css';
  ```

- 使用 `-!` 前缀，将禁用所有已配置的 preLoader 和 loader，但是不禁用 postLoaders

  ```js
  import Styles from '-!style-loader!css-loader?modules!./styles.css';
  ```

## 总结

至此，**我们清楚关于`loader`的种类存在四种类型的`loader`，分别是`pre loader`、`normal loader`、`inline loader`、`post loader`四种类型：**

- **4 类 loader 的执行优级为：`pre > normal > inline > post` 。**
- **相同优先级的 loader 执行顺序为：`从右到左，从下到上`。**

- **使用 loader 的方式：**
  - **配置方式：**在 `webpack.config.js` 文件中指定 loader。（pre、normal、post loader）
  - **内联方式：**在每个 `import` 语句中显式指定 loader。（inline loader）

# 五、Loader的执行顺序

在了解了我们将`loader`分为了`pre loader`、`normal loader`、`inline loader`、`post loader`四种`loader`。

其实这四种`loader`通过命名我们也可以看出来他们的执行顺序，在**默认的`Loader`执行阶段**这四种`loader`会按照如下顺序执行:

![webpack42](..\images\webpack42.png)

在`webpack`进行编译文件前，资源文件匹配到对应`loader`:

- 执行`pre loader`前置处理文件。
- 将`pre loader`执行后的资源链式传递给`normal loader`正常的`loader`处理。
- `normal loader`处理结束后交给`inline loader`处理。
- 最终通过`post loader`处理文件，将处理后的结果交给`webpack`进行模块编译。

> 注意这里我们强调的是默认`loader`的执行阶段，那么什么是非默认呢？接下来让我们一起来看看所谓的`pitch loader`阶段。

## 1、normal loader & pitch loader

`loader`在处理文件资源时分为两个阶段: `pitch`阶段和`nomral`阶段。

- 在处理资源文件之前，首先会经历`pitch`阶段。
- `pitch`结束后，读取资源文件内容。
- 经过`pitch`处理后，读取到了资源文件，此时才会将读取到的资源文件内容交给正常阶段的`loader`（`nomral`阶段）进行处理。

**关于`normal loader`本质上就是`loader`函数本身。**

```js
// loader函数本身 我们称之为loader的normal阶段
function loader(source) {
    // dosomething
    return source
}
```

**关于`pitch loader`就是`normal loader`上的一个`pitch`属性，它同样是一个函数:**

```js
// pitch loader是normal上的一个属性
loader.pitch = function (remainingRequest,previousRequest,data) {
    // ...
}
```

简单来说这就是`pitch loader`和`normal loader`。

**我们将`loader`的`pitch`属性称为`loader`的`pitch loader`。**

**自然而然，我们将`loader`函数本身称为`noraml loader`。**

## 2、执行阶段

让我们来看这样一个例子:

```js
// webpack.config.js

module.exports = {
  module: {
    rules: [
      // 普通loader
      {
        test: /\.js$/,
        use: ['normal1-loader', 'normal2-loader'],
      },
      // 前置loader
      {
        test: /\.js$/,
        use: ['pre1-loader', 'pre2-loader'],
        enforce: 'pre',
      },
      // 后置loader
      {
        test: /\.js$/,
        use: ['post1-loader', 'post2-loader'],
        enforce: 'post',
      },
    ],
  },
};
```

```
// 入口文件中
import something from 'inline1-loader!inline2-loader!./title.js';
```

这里，我们在`webpack`配置文件中对于`js`文件配置了三种处理规则6个`loader`。同时在入口文件引入`./title.js`使用了我们之前讲到过的`inline loader`。

让我们用一张图来描述下所谓`loader`的执行顺序:

![webpack43](..\images\webpack43.png)

图中我们有8个`loader`，它们分别存在对应的种类，**`webpack`中对于一次文件的引入首先会进入`loader`处理文件的阶段，`loader`处理完成才会交给`webpack`进行编译。**

通过上图我们可以看到：

- 首先在一次`webpack`中引入一次资源(无论是通过`import`还是`require`)，首先会进入`loader`处理阶段。
- `loader`处理阶段首先会经历**`loader.pitch`阶段，`pitch`阶段结束后才会读取文件而后进行`normal`阶段处理**。
  - **Pitching** 阶段: loader 上的 pitch 方法，按照 `后置(post)、行内(inline)、普通(normal)、前置(pre)` 的顺序调用。
- 在`pitch`阶段全部处理完成后，**这一步才会读取引入的资源文件内容**。
- 将读取到的资源文件内容交给`noraml-loader`函数，一层一层传递处理。
  - **Normal** 阶段: loader 上的 常规方法，按照 `前置(pre)、普通(normal)、行内(inline)、后置(post)` 的顺序调用。
- 最终将`loader`处理后的资源返回给`webpack`进行编译处理。

### 3、`pitch loader`的熔断效果

上边我们通过一张图描述了`webpack`中`loader`的执行顺序。我们了解到除了正常的`loader`执行阶段还额外存在一个`loader.pitch`阶段。

`pitch loader`本质上也是一个函数,比如:

```js
function loader() {
    // 正常的loader执行阶段...
}
loader.pitch = function () {
    // pitch loader
}
```

关于`pitch loader`的需要特别注意的就是`Pitch Loader`带来的**熔断**效果。

假设我们在上边配置的8个`loader`中，为`inline1-loader`添加一个`pitch`属性使它拥有`pitch`函数，**并且，我们让它的`pitch`函数随便返回一个非`undefined`的值**。

```js
js 体验AI代码助手 代码解读复制代码// inline1-loader normal
function inline1Loader () {
    // dosomething
}
// inline1-loader pitch
inline1Loader.pitch = function () {
    // do something
    return '19Qingfeng'
}
```

这里我们在`inline1-loader pitch`阶段返回了一个字符串`19Qingfeng`，我们上边说到过在`loader`的执行阶段是会按照这张图进行执行(`pitch`阶段全部返回`undefined`情况下)：

![webpack44](..\images\webpack44.png)

**但是一旦在某一个`loader`的`pitch`阶函数中返回一个非`undefined`的值就会发生熔断的效果：**

![webpack45](..\images\webpack45.png)

我们可以看到当我们在`inline1-loader`的`pitch`函数中返回了一个字符串`19Qingfeng`时，`loader`的执行链条会被阻断--立马掉头执行，直接掉头执行上一个已经执行的`loader`的`normal`阶段并且将`pitch`的返回值传递给下一个`normal loader`，简而言之这就是`loader`的熔断效果。

#### 这里有两点需要额外说明：

- **`pitch`阶段返回的非`undefeind`的值会造成`loader`打破原有顺序掉头执行，这就叫做熔断效果。**

- **正常执行时是会读取资源文件的内容交给`normal loader`去处理，但是`pitch`存在返回值时发生熔断并不会读取文件内容了。此时`pitch`函数返回的值会交给将要执行的`normal loader`。**

## 4、`normal loader & pitch loader`参数详解

### (1) Normal Loader

`normal loader`默认接受一个参数，这个参数是需要处理的文件内容。在存在多个`loader`时，它的参数会受上一个`loader`的影响。

同时`nomral loader`存在一个返回值,这个返回值会链式调用给下一个`loader`作为入参，当最后一个`loader`处理完成后，会讲这个返回值返回给`webpack`进行编译。

```js
// source为需要处理的源文件内容 
function loader(source) {
    // ...
    // 同时返回本次处理后的内容
    return source + 'hello !'
}
```

> 关于`normal loader`中其实有非常多的属性会挂载在函数中的`this`上，比如通常我们在使用某个`loader`时会在外部传递一些参数，此时就可以在函数内部通过`this.getOptions()`方法获取。

> 关于`loader`中的`this`被称作上下文对象，[更多的属性你可以在这里看到](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Floaders%2F%23the-loader-context)

![webpack46](..\images\webpack46.png)

### (2) Pitch Loader

```js
// normal loader
function loader(source) {
    // ...
    return source
}

// pitch loader
loader.pitch = function (remainingRequest,previousRequest,data) {
    // ...
}
```

`Loader`的`Pitch`阶段也是一个函数，它接受3个参数，分别是:

- **remainingRequest**
- **previousRequest**
- **data**

#### remainingRequest

`remainingRequest`表示**剩余需要处理的`loader`的绝对路径以`!`分割组成的字符串**。

![webpack47](..\images\webpack47.png)

同样我们在上边的`loader`中为每个`normal loader`分别添加一个`pitch`属性，我们以`loader2.pitch`来举例:

在`loader.pitch`函数中`remainingRequest`的值为`xxx/loader3.js`的字符串。如果说后续还存在多个`loader`，那么他们会以`!`进行分割。

> 需要注意的是`remainingRequest`与剩余`loader`有没有`pitch`属性没有关系，无论是否存在`pitch`属性`remainingRequest`都会计算`pitch`阶段还未处理剩余的`loader`。

##### previousRequest

在理解了`remainingRequest`的概念之后，那么`pitch loader`的第二个参数就很好理解了。

**它表示`pitch`阶段已经迭代过的`loader`按照`!`分割组成的字符串**。

> 注意同样`previousRequest`和有无`pitch`属性没有任何关系。同时`remainingRequest`和`previousRequest`都是不包括自身的(也就是我们例子中都不包含`loader2`自身的绝对路径)。

#### data

现在让我们来看看`pitch loader`最后一个参数。这个参数默认是一个空对象`{}`。

在`normalLoader`与`pitch Loader`进行交互正是利用了第三个`data`参数。

同样我们以上图中的`loader2`来举例:

![webpack48](..\images\webpack48.png)

- 当我们在`loader2.pith`函数中通过给`data`对象上的属性赋值时，比如`data.name="19Qingfeng"`。
- 此时在`loader2`函数中可以通过`this.data.name`获取到自身`pitch`方法中传递的`19Qingfeng`。

### (3) `loader`的`raw`属性

值得一提的是日常我们在开发一些`loader`时，`normal Loader`的参数我们讲到过它会接受前置`normal loader` or 对应资源文件(当它为第一个`loader`还未经过任何`loader`处理时) 的内容。这个内容默认是一个`string`类型的字符串。

但是在我们开发一些特殊的`loader`时，比如我们需要处理图片资源时，此时对于图片来说将图片变成字符串明显是不合理的。针对于图片的操作**通常我们需要的是读取图片资源的`Buffer`类型而非字符串类型**。

此时我们可以通过`loader.raw`标记`normal loader`的参数是`Buffer`还是`String`:

- 当`loader.raw`为`false`时，此时我们`normal loader`的`source`获取的是一个`String`类型，这也是默认行为。
- 当`loader.raw`为`true`时，此时这个`loader`的`normal`函数接受的`source`参数就是一个`Buffer`类型。

```js
function loader2(source) {
    // 此时source是一个Buffer类型 而非模型的string类型
}

loader2.raw = true

module.exports = loader2
```

## 5、Normal Loader & Pitch Loader 返回值

- `Normal`阶段，`loader`函数的返回值会在`loader chain`中进行一层一层传递直到最后一个`loader`处理后传递将返回值给`webpack`进行传递。
- `Pitch`阶段，任意一个`loader`的`pitch`函数如果返回了非`undefined`的任何值，会发生**熔断**效果同时将`pitch`的返回值传递给`normal`阶段`loader`的函数。

> 需要额外注意的是，在`normal`阶段的最后一个`loader`一定需要返回一个`js`代码(一个`module`的代码，比如包含`module.exports`语句)。

# 六、Loader源码分析

