

# 一、微前端背景

## 概念

微前端概念是从微服务概念扩展而来的，摒弃大型单体方式，将前端整体分解为小而简单的块，这些块可以独立开发、测试和部署，同时仍然聚合为一个产品出现在客户面前。可以理解微前端是一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格。

微前端是借鉴了微服务的理念，将一个庞大的应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发，独立运行，独立部署，还可以随意组合，这样就降低了耦合度，从而更加灵活。

## 微前端特性

- **技术栈无关** 主框架不限制接入应用的技术栈，子应用可自主选择技术栈（`vue`，`react`，`jq`，`ng`等）
- **独立开发/部署** 各个团队之间仓库独立，单独部署，互不依赖
- **增量升级** 当一个应用庞大之后，技术升级或重构相当麻烦，而微应用具备渐进式升级的特性
- **独立运行时** 微应用之间运行时互不依赖，有独立的状态管理

## 适用场景

- 技术栈切换又不想重构已有业务。
- 历史包袱项目，比如历史项目内部强耦合，但是又运行稳定的。（既要保证旧项目的稳定且不变，又能将新需求聚合为一个产品）
- 旧项目的业务页面在新项目中复用，开发周期短。举例：假设`JQ`写了很多用户信息相关的页面，每个页面的初始化只要传用户`ID`就能获取其它数据，再用`React`写新项目时要复用这些页面的场景。

## 实现方案

### 1、基于`single-spa`的微前端方案`qiankun`

#### 优点

1. `qiankun`使用 `HTML entry` 及 `css`沙箱 实现了 `dom` 和样式隔离
2. 实现`js`隔离，并提供了父子通信及全局状态的方法
3. 实现了资源预加载能力，预先子应用`html`、`js`、`css`资源缓存下来，加快子应用的打开速度

#### 缺点

1. 子应用基于路由匹配，父子应用共用一个路由，缺乏灵活性，无法实现多应用激活
2. 需要改造子应用，改造成本大
3. 开启严格模式后会出现各种问题

其中共用一个路由是让我无法接受的，比如`qiankun`子应用在layout中，主应用切换页面时还要保持子应用匹配的部分不动。我认为的微前端就应该把子应用当成组件一样嵌入到主应用，除了父子通信外不做其他耦合。直到无界横空出世，我认为这就是我梦寐以求的微前端框架。

### 2、`iframe`方案

#### 优点

1. `iframe`将`web`应用完美隔离，无论是`dom`、`css`还是`js`都完全的隔离了起来
2. 使用简单，一个`iframe`标签加一个`src`属性即可将子应用嵌入进来的

#### 缺点

1. `dom`隔离太严重，子应用的`dom`无法突破`iframe`的限制，比如一个fixed定位的元素也只能在`iframe`区域展示
2. 路由无法保活，每次浏览器刷新`iframe`里的页面就会重置
3. 通信困难，全局上下文完全隔离

### 3、基于`webcomponent`容器+`iframe`沙箱的微前端方案无界

无界是腾讯团队开源的微前端框架，是一款基于 `Web Components + iframe` 微前端框架，具备成本低、速度快、原生隔离、功能强等一系列优点

#### 优点

1. 使用`iframe`作为天然的 `js` 沙箱，不会污染主应用环境
2. 使用 `Web Components` 来隔离`html`、`css`，这是一个浏览器原生支持的组件封装技术，可以有效隔离元素之间的样式
3. 提供了事件总线和`props`传参，弥补了`iframe`通信困难的缺点
4. 子应用无需做任何改造，接入更简单
5. 实现了多应用激活、应用保活功能
6. 提供了`vue`和`react`组件的封装，开箱即用

无界用起来感觉和`iframe`差不多，`js`沙箱直接使用`iframe`，dom和样式使用`Web Components`，巧妙的避开了`iframe`的缺点 感觉无界就是个缝合怪，这很`Tencent`

#### 缺点

1. `Web Components`兼容性有限，在不支持`Web Components`的浏览器中，无界提供了降级处理，`html`和`css`的隔离会使用`iframe`替代，降级后的无界其实就是个`iframe`了

其实无界的适配问题无伤大雅，就算有些浏览器不支持`Web Components`，那我们就当是用了个`iframe`就好了。毕竟`qiankun`和`iframe`相比，我还是觉得`iframe`更友好一点，更何况是拥有事件总线的`iframe`呢。

### 4、基于`webcomponent`+`qiankun sandbox`的微前端方案`micro-app`

### 5、基于`webpack5`的微前端方案`module federation`

# 二、`single-spa` 微前端方案

**`spa` 单页应用时代，我们的页面只有 `index.html` 这一个 `html` 文件，并且这个文件里面只有一个内容标签 ，用来充当其他内容的容器，而其他的内容都是通过 `js` 生成的。也就是说，我们只要拿到了子项目的容器 和生成内容的 `js`，插入到主项目，就可以呈现出子项目的内容。**

```html
<link href=/css/app.c8c4d97c.css rel=stylesheet>
<div id=app></div>
<script src=/js/chunk-vendors.164d8230.js> </script>
<script src=/js/app.6a6f1dda.js> </script> 
```

**我们只需要拿到子项目的上面四个标签，插入到主项目的 `HTML` 中，就可以在父项目中展现出子项目。**

这里有个问题，**由于子项目的内容标签是动态生成的，其中的 `img/video/audio` 等资源文件和按需加载的路由页面 `js/css` 都是相对路径，在子项目的 `index.html` 里面，可以正确请求，而使用`single-spa`方案，子项目需要插入到主项目的 `index.html` 里面，所以在主项目的 `index.html` 里面，则不能。**

举个例子，假设我们主项目的网址是 `www.baidu.com` ，子项目的网址是 `www.taobao.com` ，在子项目的 `index.html` 里面有一张图片 ，那么这张图片的完整地址是`www.taobao.com/logo.jpg`，现在将这个图片的 `img` 标签生成到了父项目的 `index.html`，那么图片请求的地址是 `www.baidu.com/logo.jpg`，很显然，父项目服务器上并没有这张图。

**解决思路：**

1. 这里面的 `js/css/img/video` 等都是相对路径，能否通过 `webpack` 打包，将这些路径全部打包成绝对路径？这样就可以解决文件请求失败的问题。
2. 能否手动（或借助 `node` ）将子项目的文件全部拷贝到主项目服务器上，`node` 监听子项目文件有更新，就自动拷贝过来，并且按 `js/css/img` 文件夹合并
3. 能否像 `CDN` 一样，一个服务器挂了，会去其他服务器上请求对应文件。或者说服务器之间的文件共享，主项目上的文件请求失败会自动去子服务器上找到并返回。

**通常做法是动态修改 `webpack` 打包的 `publicPath`，然后就可以自动注入前缀给这些资源。**

这里可以将`vue-cli3`的 `publicPath`设置为`https://www.my-app.com/my-app/`，然后代码里面的`js/css/img/video`路径都会变成绝对路径，前缀是`https://www.my-app.com/my-app/`，这样就解决了`url`路径的问题。

`single-spa` 是一个微前端框架，基本原理如上，在上述呈现子项目的基础上，还新增了 `bootstrap` 、 `mount` 、 `unmount` 等生命周期。

**相对于 `iframe`，`single-spa` 让父子项目属于同一个 `document`，这样做既有好处，也有坏处。好处就是数据/文件都可以共享，公共插件共享，子项目加载就更快了，缺点是带来了 `js/css` 污染。**

**`single-spa` 上手并不简单，也不能开箱即用，开发部署更是需要修改大量的 `webpack` 配置，对子项目的改造也非常多。**

# 三、`qiankun` 微前端方案

`qiankun` 是蚂蚁金服开源的一款框架，它是基于 `single-spa` 的。他在 `single-spa` 的基础上，实现了开箱即用，除一些必要的修改外，子项目只需要做很少的改动，就能很容易的接入。如果说 `single-spa` 是自行车的话，`qiankun` 就是个汽车。

微前端中子项目的入口文件常见的有两种方式：`JS entry` 和 `HTML entry`

纯 `single-spa` 采用的是 `JS entry`，而 `qiankun` 既支持 `JS entry`，又支持 `HTML entry`。

`JS entry` 的要求比较苛刻：

（1）将 `css` 打包到 `js` 里面

（2）去掉 `chunk-vendors.js`，

（3）去掉文件名的 `hash` 值

（4）将 `single-spa` 模式的入口文件( `app.js` )放置到 `index.html` 目录，其他文件不变，原因是要截取 `app.js` 的路径作为 `publicPath`

| APP entry    | 优点                                                         | 缺点                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `JS entry`   | 可以配合 `systemJs`，按需加载公共依赖( `vue` , `vuex` , `vue-router` 等) | 需要各种打包配置配合，无法实现预加载                         |
| `HTML entry` | 打包配置无需做太多的修改，可以预加载                         | 多一层请求，需要先请求到 `HTML` 文件，再用正则匹配到其中的 `js` 和 `css` |

其实 `qiankun` 还支持 `config entry` ：

```js
{
   entry: {
        scripts: [
          "app.3249afbe.js"
          "chunk-vendors.75fba470.js",
        ],
        styles: [
          "app.3249afbe.css"
          "chunk.75fba470.css",
        ],
        html: `<!doctype html>
        		  <html>
        			...
               `
    }
}
```

建议使用 `HTML entry` ，使用起来和 `iframe` 一样简单，但是用户体验比 `iframe` 强很多。`qiankun` 请求到子项目的 `index.html` 之后，会先用正则匹配到其中的 `js/css` 相关标签，然后替换掉，它需要自己加载 `js` 并运行，然后去掉 `html/head/body` 等标签，剩下的内容原样插入到子项目的容器中 ：

![webpack243](.\images\webpack243.png)

使用 `qiankun` 的好处：

1. `qiankun` 自带 `js/css` 沙箱功能，`singles-spa` 可以解决 `css` 污染，但是需要子项目配合
2. `single-spa` 方案只支持 `JS entry` 的特点，限制了它只能支持 `vue` 、 `react` 、 `angular` 等技术开发的项目，对一些 `jQuery` 老项目则无能为力。`qiankun` 则没有限制
3. `qiankun` 支持子项目预请求功能。

## `js`沙箱（`sandbox`）是如何实现的

我们知道所有的全局的方法（`alert`，`setTimeout`，`isNaN`等）、全局的变/常量（`NaN`，`Infinity`，`var`声明的全局变量等）和全局对象（`Array`，`String`，`Date`等）都属于`window`对象，而能导致`js`污染的也就是这些全局的方法和对象。

所以`qiankun`解决`js`污染的办法是：在子系统加载之前对`window`对象做一个快照（拷贝），然后在子系统卸载的时候恢复这个快照，即可以保证每次子系统运行的时候都是一个全新的`window`对象环境。

那么如何监测`window`对象的变化呢，直接将`window`对象进行一下深拷贝，然后深度对比各个属性显然可行性不高，`qiankun`框架采用的是`ES6`新特性，`proxy`代理方法。

具体代码如下(源代码是`ts`版的，我简化修改了一些)：

```js
// 沙箱期间新增的全局变量
const addedPropsMapInSandbox = new Map();
// 沙箱期间更新的全局变量
const modifiedPropsOriginalValueMapInSandbox = new Map();
// 持续记录更新的(新增和修改的)全局变量的 map，用于在任意时刻做 snapshot
const currentUpdatedPropsValueMap = new Map();
const boundValueSymbol = Symbol('bound value');
const rawWindow = window;
const fakeWindow = Object.create(null);
const sandbox = new Proxy(fakeWindow, {
    set(target, propKey, value) {
      if (!rawWindow.hasOwnProperty(propKey)) {
        addedPropsMapInSandbox.set(propKey, value);
      } else if (!modifiedPropsOriginalValueMapInSandbox.has(propKey)) {
        // 如果当前 window 对象存在该属性，且 record map 中未记录过，则记录该属性初始值
        const originalValue = rawWindow[propKey];
        modifiedPropsOriginalValueMapInSandbox.set(propKey, originalValue);
      }
      currentUpdatedPropsValueMap.set(propKey, value);
      // 必须重新设置 window 对象保证下次 get 时能拿到已更新的数据
      rawWindow[propKey] = value;
      // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，
      // 在沙箱卸载的情况下应该忽略错误
      return true;
    },
    get(target, propKey) {
      if (propKey === 'top' || propKey === 'window' || propKey === 'self') {
        return sandbox;
      }
      const value = rawWindow[propKey];
      // isConstructablev :监测函数是否是构造函数
      if (typeof value === 'function' && !isConstructable(value)) {
        if (value[boundValueSymbol]) {
          return value[boundValueSymbol];
        }
        const boundValue = value.bind(rawWindow);
        Object.keys(value).forEach(key => (boundValue[key] = value[key]));
        Object.defineProperty(value, boundValueSymbol, 
            { enumerable: false, value: boundValue }
        )
        return boundValue;
      }
      return value;
    },
    has(target, propKey) {
      return propKey in rawWindow;
    },
});
```

大致原理就是记录`window`对象在子系统运行期间新增、修改和删除的属性和方法，然后会在子系统卸载的时候复原这些操作。

这样处理之后，全局变量可以直接复原，但是事件监听和定时器需要特殊处理：用`addEventListener`添加的事件，需要用`removeEventListener`方法来移除，定时器也需要特殊函数才能清除。所以它重写了事件绑定/解绑和定时器相关函数。

重写定时器(`setInterval`)部分代码如下：

```js
const rawWindowInterval = window.setInterval;
const hijack = function () {
  const timerIds = [];
  window.setInterval = (...args) => {
    const intervalId = rawWindowInterval(...args);
    intervalIds.push(intervalId);
    return intervalId;
  };
  return function free() {
    window.setInterval = rawWindowInterval;
    intervalIds.forEach(id => {
      window.clearInterval(id);
    });
  };
}
```

小细节：切换子系统不能立马清除子系统的延时定时器，比如说子系统有一个`message`提示，3秒钟后自动关闭，如果你立马清除掉了，就会一直存在了。那么延迟多久再清除子系统的定时器合适呢？5s？7s？10s？似乎都不太理想，作者最终决定不清除`setTimeout`，毕竟使用了一次之后就没用了，影响不大。

> 由于`qiankun`在`js`沙箱功能中使用了`proxy`新特性，所以它的兼容性和`vue3`一样，不支持`IE11`及以下版本的`IE`。不过作者说可以尝试禁用沙箱功能来提高兼容性，但是不保证都能运行。去掉了`js`沙箱功能，就变得索然无味了。

补充：`qiankun 2.x` 更新，对于不支持 `proxy` 的浏览器，支持 `diff` 方法来实现沙箱，就是子项目加载前浅拷贝一下 `window`，子项目卸载后 `for` 循环之前浅拷贝的 `window`，恢复之前的状态，但是多个子项目同时运行，他们共用一个沙箱，这等于没有沙箱。

#### 补充： 全局函数的影响如何消除

`function`关键字直接声明一个全局函数，这个函数属于`window`对象，但是无法被`delete`:

```js
function a(){}
Object.getOwnPropertyDescriptor(window, "a")
//控制台打印如下信息
/*{
    value: ƒ a(),
    writable: true,
    enumerable: true,
    configurable: false
}*/
delete window.a // 返回false，表示删除失败
```

> `configurable`：当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为`true`

既然无法被`delete`，那么`qiankun`的`js`沙箱是如何做的呢，它是怎样消除子系统的全局函数的影响的呢?

声明全局函数有两种办法，一种是`function`关键字在全局环境下声明，另一种是以变量的形式添加：`window.a = () => {}`。我们知道`function`声明的全局函数是无法删除的，而变量的形式是可以删除的，`qiankun`直接避免了`function`关键字声明的全局函数。

首先，我们编写在`.vue`文件或者`main.js`文件中`function`声明的函数都不是全局函数，它只属于当前模块的。只有`index.html`中直接写的全局函数，或者不被打包文件里面的函数是全局的。

在`index.html`中编写的全局函数，会被处理成局部函数。 源代码：

```html
<script>
    function b(){}
    //测试全局变量污染
    console.log('window.b',window.b)
</script>
```

`qiankun`处理后：

```js
(function(window){;
    function b(){}
    //测试全局变量污染
    console.log('window.b',window.b)
}).bind(window.proxy)(window.proxy);
```

那他是如何实现的呢？首先用正则匹配到`index.html`里面的外链`js`和内联`js`，然后外链`js`请求到内容字符串后存储到一个对象中，内联`js`直接用正则匹配到内容也记录到这个对象中：

```js
const fetchScript = scriptUrl => scriptCache[scriptUrl] ||
		(scriptCache[scriptUrl] = fetch(scriptUrl).then(response => response.text()));
```

然后运行的时候，采用`eval`函数：

```js
//内联js
eval(`;(function(window){;${inlineScript}\n}).bind(window.proxy)(window.proxy);`)
//外链js
eval(`;(function(window){;${downloadedScriptText}\n}).bind(window.proxy)(window.proxy);`))
```

同时，他还会考虑到外链`js`的`async`属性，即考虑到`js`文件的先后执行顺序，不得不说，这个作者真的是细节满满。

## `css`污染他是如何解决的

它解决`css`污染的办法是：在子系统卸载的时候，将子系统引入`css`使用的``、``标签移除掉。移除的办法是重写标签的`appendChild`方法，办法类似定时器的重写。

子系统加载时，会将所需要的`js/css`文件插入到标签，而重写的`appendChild`方法会记录所插入的标签，然后子系统卸载的时候，会移除这些标签。

## 预请求是如何实现的

解决子系统预请求的的根本在于，我们需要知道子系统有哪些`js/css`需要加载，而借助`systemJs`加载子系统，只知道子系统的入口文件(`app.js`)。`qiankun`不仅支持`app.js`作为入口文件，还支持`index.html`作为入口文件，它会用正则匹配出`index.html`里面的`js/css`标签，然后实现预请求。

网络不好和移动端访问的时候，`qiankun`不会进行预请求，移动端大多是使用数据流量，预请求则会浪费用户流量，判断代码如下：

```js
const isMobile = 
   /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const isSlowNetwork = navigator.connection
  ? navigator.connection.saveData || /(2|3)g/.test(navigator.connection.effectiveType)
  : false;
```

请求`js/css`文件它采用的是`fetch`请求，如果浏览器不支持，还需要`polyfill`。

以下代码就是它请求`js`并进行缓存：

```js
const defaultFetch = window.fetch.bind(window);
//scripts是用正则匹配到的script标签
function getExternalScripts(scripts, fetch = defaultFetch) {
    return Promise.all(scripts.map(script => {
	if (script.startsWith('<')) {
	    // 内联js代码块
	    return getInlineCode(script);
	} else {
	    // 外链js
	    return scriptCache[script] ||
	           (scriptCache[script] = fetch(script).then(response => response.text()));
	}
    }));
}
```

## 总结

1. `js`沙箱并不能解决所有的`js`污染，例如我给添加了一个点击事件，`js`沙箱并不能消除它的影响，所以说，还得靠代码规范和自己自觉。
2. 抛开兼容性，我觉得`qiankun`真的太好用了，无需对子项目做过多的修改，开箱即用。也不需要对子项目的开发部署做任何额外的操作。
3. `qiankun`框架使用`index.html`作为子项目的入口，会将里面的`style/link/script`标签以及注释代码解析并插入，但是他没有考虑`meta`和`title`标签，如果切换系统，其中`meta`标签有变化，则不会解析并插入，当然了，`meta`标签不影响页面展示，这样的场景并不多。而切换系统，修改页面的`title`，则需要通过全局钩子函数来实现。
4. `qiankun`框架不好实现`keep-alive`需求，因为解决`css/js`污染的办法就是删除子系统插入的标签和劫持`window`对象，卸载时还原成子系统加载前的样子，这与`keep-alive`相悖：`keep-alive`要求保留这些，仅仅是样式上的隐藏。
5. 微前端中子项目的入口文件常见的有两种方式：`JS entry` 和 `HTML entry`

# 四、`iframe`

## 概念

`iframe`是 `HTML` 中的一个标签，它允许在当前网页中嵌入另一个网页。通过设置 `iframe`的`src`属性，可以指定要嵌入的网页地址。被嵌入的网页在一个独立的窗口中显示，与主页面相对隔离，有自己独立的 `DOM` 树、`CSS` 样式和 `JavaScript` 执行环境

## 场景

- **第三方内容嵌入**：很多网站会使用 `iframe`来嵌入第三方的地图、视频播放器等内容。例如，在一个旅游网站的酒店介绍页面，通过 `iframe`嵌入百度地图，让用户可以直观地看到酒店的地理位置；在视频分享网站中，使用 `iframe`嵌入视频播放代码，方便用户在不离开当前页面的情况下观看视频。
- **广告嵌入**：广告商通常会提供一段包含在 `iframe`中的广告代码，网站所有者只需将这段代码插入到自己的页面中，就可以在指定位置展示广告。这样可以保证广告内容的独立性和安全性，同时也便于广告商进行管理和统计。

## 优点

- **内容隔离**：`iframe`中的内容与主页面的内容相互隔离，包括 `CSS` 样式、`JavaScript` 代码和 `DOM` 结构等。这意味着嵌入的内容不会影响主页面的布局和功能，也不会被主页面的代码所干扰，大大降低了样式和脚本冲突的风险。
- **易于集成**：只需要一个标签和一个`src`属性，就可以将外部内容嵌入到当前页面中，非常简单方便。对于一些简单的嵌入需求，几乎不需要额外的开发工作。

## 缺点

### 1、路由状态丢失

当浏览器刷新页面时，`iframe`的当前路由状态会丢失。比如，你在页面中使用了一个 ，`iframe`内部加载了某个子页面。这个`iframe`的 `URL` 有一段路由路径：

```js
http://your-domain.com/container
       └── iframe src="http://child-app.com/#/dashboard"
```

你在 `iframe`内部导航到了一个`profile`页面，路由状态变成了

```js
http://your-domain.com/container
       └── iframe src="http://child-app.com/#/profile"
```

这时候你刷新整个浏览器页面（即父页面），**`iframe`又重新加载了它最初的 `src URL`，原来的路由状态（比如 `/profile`）会丢失**，`iframe`的路由状态又回到了`http://child-app.com/#/dashboard`

#### 为什么路由状态会丢失？

`iframe`加载的是一个子页面，它自己内部维护自己的路由状态。**当你刷新父页面时，整个 `DOM` 被重建**，包括 `iframe`标签本身。所以它的 `src` 会重新被设置成你原先的值（比如 `http://child-app.com/#/dashboard`），不会记得你用户之前在 `iframe`里导航到了 `/profile`

#### 解决办法

把 `iframe`的路由状态同步到父应用的 URL，在`iframe`加载时同步回`iframe`。

让父页面记录 `iframe`的状态，比如：

```bash
http://your-domain.com/container?childRoute=/profile
```

然后在加载 `iframe`时拼接这个路由:

```html
<iframe src={`http://child-app.com/#${childRoute}`}></iframe>
```

- 你可能会问，`iframe`的路由状态怎么同步到父应用的URL上呢？

  我们可以重写掉`iframe window`上的`pushState/replaceState`方法，以及监听`hashchange/popstate`事件，把`iframe`的路由状态作为参数写到主应用的URL上。伪代码如下：

```js
const iframeWindow = iframe.contentWindow;
 const history = iframeWindow.history;
 history.pushState = function (data, title, url: string) {
  syncUrlToWindow(iframeWindow);  // syncUrlToWindow 负责把iframe路由写到主应用的URL上
 }
 history.replaceState = function (data, title, url: string) {
  syncUrlToWindow(iframeWindow);
 }
 iframeWindow.addEventListener("hashchange", () => syncUrlToWindow(iframeWindow));
 iframeWindow.addEventListener("popstate", () => {
    syncUrlToWindow(iframeWindow);
  });
```

### 2、前进后退处理

需要特别注意的是，`iframe`页面内部的跳转虽然不会让浏览器地址栏发生变化，但是却会产生一个看不见的“`history`记录”，也就是点击前进或后退按钮（`history.forward()`或`history.back()`）可以让`iframe`页面也前进后退，但是地址栏无任何变化。

所以准确来说前进后退无需我们做任何处理，我们要做的就是让浏览器地址栏同步更新即可。

> 如果要禁用浏览器的上述默认行为，一般只能在`iframe`跳转时通知父页面更新整个`DOM`节点。

#### `URL`的同步更新

让`URL`同步更新需要处理2个问题，一个是什么时候去触发更新的动作，一个是`URL`更新的规律，即父页面的URL地址（`A`系统）与`iframe`的`URL`地址（`B`系统）映射关系的维护。

保证`URL`同步更新功能正常需要满足这3种情况：

- `case1`: 页面刷新，`iframe`能够加载正确页面；
- `case2`: 页面跳转，浏览器地址栏能够正确更新；
- `case3`: 点击浏览器的前进或后退，地址栏和`iframe`都能够同步变化；

#### 什么时候更新`URL`地址

首先想到的肯定是在`iframe`加载完发送一个通知给父页面，父页面通过`history.replaceState`去更新URL。

> 为什么不是`history.pushState`呢？因为前面提到过，浏览器默认会产生一条历史记录，我们只需要更新地址即可，如果用`pushState`会产生2条记录。

B系统：

```xml
<script>
var postMessage = function(type, data) {
    if (window.parent !== window) {
        window.parent.postMessage({
            type: type,
            data: data,
        }, '*');
    }
}
// 为了让URL地址尽早地更新，这段代码需要尽可能前置，例如可以直接放在document.head中
postMessage('afterHistoryChange', { url: location.href });
</script>
```

A系统：

```typescript
window.addEventListener('message', e => {
    const { data, type } = e.data || {};
    if (type === 'afterHistoryChange' && data?.url) {
        // 这里先采用一个兜底的URL承接任意地址
        const entry = `/fin/base.html?entry=${encodeURIComponent(data.url)}`;
        // 地址不一样才需要更新
        if (location.pathname + location.search !== entry) {
            window.history.replaceState(null, '', entry);
        }
    }
});
```

#### 优化`URL`的更新速度

按照上面的方法实现后可以发现，`URL`虽然可以更新但是速度有点慢，点击跳转后一般需要等待7-800毫秒地址栏才会更新，有点美中不足。可以把地址栏的更新在“跳转后”基础之上再加一个“跳转前”。为此我们必须有一个全局的`beforeRedirect`钩子，先不考虑它的具体实现：

B系统：

```php
function beforeRedirect(href) {
    postMessage('beforeHistoryChange', { url: href });
}
```

A系统：

```typescript
window.addEventListener('message', e => {
    const { data, type } = e.data || {};
    if ((type === 'beforeHistoryChange' || type === 'afterHistoryChange') && data?.url) {
        // 这里先采用一个兜底的URL承接任意地址
        const entry = `/fin/base.html?entry=${encodeURIComponent(data.url)}`;
        // 地址不一样才需要更新
        if (location.pathname + location.search !== entry) {
            window.history.replaceState(null, '', entry);
        }
    }
});
```

加上上述代码之后，点击`iframe`中的跳转链接，`URL`会实时更新，浏览器的前进后退功能也正常。

> 为什么需要同时保留跳转前和跳转后呢？因为如果只保留跳转前，只能满足前面的`case1`和`case2`，`case3`无法满足，也就是点击后退按钮只有`iframe`会后退，`URL`地址不会更新。

### 3、`DOM`割裂严重，弹窗只能在`iframe`内部展示

每个`iframe`或子应用有自己独立的`window`，`document`，`CSS`样式表，`JS`作用域。当你在 `iframe`内部调用代码，比如：

```js
document.body.appendChild(modalElement);
```

弹窗只会出现在`iframe`内部，无法穿透`iframe`显示在整个主页面（父页面）上方。你想要一个弹窗遮罩整个页面（全局），结果它只遮住了小小的 `iframe`区域。

#### 为什么无法覆盖？

**`iframe` 是一个完整的独立页面（`document`）** ，和父页面是两个完全分离的 `DOM` 世界。弹窗的定位和层级（如 `position: fixed`、`z-index`）只能作用在当前 document，即`iframe`的`document`上。

#### 解决办法

弹窗放在主应用，由子应用触发。子应用通过 `postMessage` 或全局事件总线发出事件或消息，主应用监听并渲染弹窗，**弹窗 `DOM` 节点实际挂在主应用 `DOM` 上**

```js
// 子应用发消息
window.parent.postMessage({ type: 'OPEN_MODAL', data: {...} }, '*');
```

```
// 主应用监听
window.addEventListener('message', (event) => {
  if (event.data.type === 'OPEN_MODAL') {
    showGlobalModal(event.data.data);
  }
});
```

### 4、`iframe web`应用之间通信困难

浏览器出于安全目的实施了同源策略，**同源**是指协议、域名、端口都相同。当`iframe`的协议、域名和端口与主页面都相同时，我们把它叫做同源`iframe`，否则，叫做跨越`iframe`。

同源策略给`iframe`与主页面之间的通信带来了困难，尤其是跨域`iframe`。主页面无法直接访问跨域`iframe`页面的 `DOM`、`JS` 对象等，会抛出安全错误。

#### 跨域`iframe`与主页面的通信

虽然困难，但不是不可能。我们可以使用`HTML5`提供的官方跨域通信机制`postMessage API`。

**`postMessage API`**

由主页面调用`postMessage`发出消息：

```js
iframe.contentWindow.postMessage('hello', 'https://iframe-domain.com');
```

被嵌入的 `iframe` 页面监听消息：

```js
window.addEventListener('message', (event) => {
  // 安全校验
  if (event.origin === 'https://your-main-domain.com') {
    console.log(event.data);
  }
});
```

#### 同源`iframe`与主页面的通信

主页面和同源`iframe`之间的通信是比较简单的，**可以直接通过 `JavaScript` 访问彼此的对象和方法**，没有跨域限制。

**主页面访问`iframe`**

```html
<!-- 主页面 -->
<iframe id="myIframe" src="/child.html"></iframe>
```

主页面 `JavaScript`：

```ini
const iframe = document.getElementById('myIframe');

// 调用 iframe 中暴露的方法
iframe.onload = () => {
  iframe.contentWindow.sayHelloFromParent && iframe.contentWindow.sayHelloFromParent();
};
```

`iframe` 页面（`/child.html`）：

```html
<script>
  // 被主页面调用的方法
  function sayHelloFromParent() {
    alert('Hello from parent!');
  }
</script>
```

**`iframe`调用主页面方法（向主页面发送消息）** 主页面定义方法：

```html
<script>
  window.sayHelloFromIframe = function () {
    alert('Hello from iframe!');
  };
</script>
```

`iframe` 页面中访问：

```js
// iframe 中的 JS
window.parent.sayHelloFromIframe && window.parent.sayHelloFromIframe();
```

### 5、`iframe` 加载`SPA`应用白屏时间过长

这个问题常见于基于 `iframe` 的微前端架构或嵌入式系统中。对于 `SPA`（`Single Page Application`）应用来说，`iframe` 每次加载都重新初始化一整个应用，导致白屏时间长、用户体验差。

下面是一些常见的优化方案，可以有效减少 `iframe` 白屏时间：

#### 预加载 `iframe` 

提前创建隐藏的 `iframe` 并加载目标页面，等用户点击或需要显示时再展示。示例：

```ini
<iframe id="app-frame" src="about:blank" style="display: none;"></iframe>

<script>
  const iframe = document.getElementById("app-frame");
  iframe.src = "https://your-spa-app.com"; // 提前加载
  iframe.onload = () => {
    // 等加载完成后再展示
    iframe.style.display = "block";
  };
</script>
```

#### 使用 `Loading Skeleton` / 占位动画

在 `iframe` 加载时展示骨架屏或 `loading` 动画，减少“白屏感知”。我们可以分两步来实现：

- `iframe` 容器层级内加一层 `loading` 遮罩层；
- 监听 `iframe.onload` 后移除遮罩。

#### 使用 `keep-alive iframe` 或 `sandbox` 缓存技术

如果使用微前端框架（如 `Qiankun`、`Wujie`），可以启用 **子应用保活** 机制：

- 子应用第一次加载后，把`iframe`相关的`DOM`保持在内存中；
- 后续切换时直接切回 `DOM`，不重新初始化。

# 五、无界

使用`iframe`有三个难以解决的问题，

- **路由状态丢失**，刷新一下，`iframe`的url状态就丢失了
- **`dom`割裂严重**，弹窗只能在`iframe`内部展示，无法覆盖全局
- **通信非常困难**，只能通过`postmessage`传递序列化的消息

无界微前端框架通过继承`iframe`的优点，解决`iframe`的缺点，打造一个接近完美的`iframe`方案

在应用A中构造一个shadow和iframe，然后将应用B的html写入shadow中，js运行在iframe中，**注意** **iframe** **的** **url**，iframe保持和主应用同域但是保留子应用的路径信息，这样子应用的js可以运行在iframe的location和history中保持路由正确。

在iframe中拦截document对象，统一将dom指向shadowRoot，此时比如新建元素、弹窗或者冒泡组件就可以正常约束在shadowRoot内部。

- dom割裂严重的问题，主应用提供一个容器给到shadowRoot插拔，shadowRoot内部的弹窗也就可以覆盖到整个应用A
- 路由状态丢失的问题，浏览器的前进后退可以天然的作用到iframe上，此时监听iframe的路由变化并同步到主应用，如果刷新浏览器，就可以从url读回保存的路由
- 通信非常困难的问题，iframe和主应用是同域的，天然的共享内存通信，而且无界提供了一个去中心化的事件机制

iframe+ web component

- 接入简单：安装一个组件即可 wujie-vue
- css隔离
- js 隔离