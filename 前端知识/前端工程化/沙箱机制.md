一、什么是沙箱？

前端沙箱（`Sandbox`）机制是指在浏览器环境中，**对不可信或独立运行的代码（如微前端子应用、插件、第三方脚本）进行隔离**，防止其污染全局环境、干扰主应用或其他模块的行为。由于浏览器本身缺乏完善的原生沙箱能力（除 `Web Worker` 和 `iframe` 外），前端社区发展出多种“模拟沙箱”方案。

在 `JavaScript` 中，沙箱（`sandbox`）是一个安全机制，用于隔离运行代码，以防止代码对其它部分的应用程序或系统造成不必要的影响或安全风险。沙箱提供了一个受控环境，在这个环境中，代码可以被执行而不影响外部环境，从而保护用户数据和系统安全。

在浏览器中，沙箱通常指的是浏览器为每个标签页提供的隔离环境。这种隔离保证了一个标签页中的 `JavaScript` 代码无法访问另一个标签页中的内容，除非两个页面遵循同源策略（即协议、域名和端口号都相同）或者通过 `CORS`（跨源资源共享）明确允许了跨源访问。网页 `web` 代码内容必须通过 `IPC` 通道才能与浏览器内核进程通信，通信过程会进行安全的检查。沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源。

# 二、`js` 中沙箱的使用场景有什么

在 `JavaScript` 中，沙箱通常用于隔离和控制代码执行的环境，以确保代码运行在一个安全的、受限制的环境中，避免对主环境造成潜在的损害。

1. **执行第三方 `js`：**当你有必要执行第三方 `js` 的时候，而这份 `js` 文件又不一定可信的时候；
2. **在线代码编辑器：**相信大家都有使用过一些在线代码编辑器，而这些代码的执行，基本都会放置在沙箱中，防止对页面本身造成影响；
3. **`Web` 应用安全:** 在浏览器中运行来自不同来源的 `JavaScript` 代码时，沙箱可以限制这些代码的权限，防止恶意代码访问敏感资源或执行危险操作。
4. **插件和第三方脚本:** 当 `Web` 应用需要加载和执行第三方插件或脚本时，通过沙箱可以限制这些脚本的访问权限，保护主应用的安全和数据。
5. **`jsonp`：**解析服务器所返回的 `jsonp` 请求时，如果不信任 `jsonp` 中的数据，可以通过创建沙箱的方式来解析获取数据；
6. **微前端架构：**子应用修改 `window`、全局事件、`CSS` 样式，影响主应用
7. **低代码/可视化平台：**用户编写的 `JS` 代码可能破坏编辑器

> 🎯 沙箱目标：**隔离副作用，保障主应用稳定性与安全性**

# 三、前端沙箱的核心挑战

浏览器环境天然“开放”，以下行为难以完全拦截：

- 修改 `window` / `document` 全局对象
- 注册全局事件监听器（`addEventListener`）
- 启动定时器（`setTimeout`）
- 动态插入 `<script>` / `<style>`
- 操作 DOM（尤其是 `body`、`head`）
- 使用 `eval`、`new Function` 等动态执行代码

# 四、`JS` 沙箱

## 1、常见 `JS` 沙箱实现方式

### (1)、`Proxy` 沙箱（现代浏览器推荐）

#### ✅ 原理：

为每个沙箱创建一个 `Proxy(window)`，拦截对全局对象的读写操作。

```
function createProxySandbox() {
  const fakeWindow = Object.create(null); // 私有存储空间
  const proxy = new Proxy(window, {
    set(target, prop, value) {
      // 所有赋值写入 fakeWindow
      fakeWindow[prop] = value;
      return true;
    },
    get(target, prop) {
      // 优先从 fakeWindow 读取
      if (prop in fakeWindow) return fakeWindow[prop];
      // 否则从真实 window 读取
      const val = target[prop];
      // 函数需 bind 到真实 window，避免 this 指向错误
      if (typeof val === 'function') {
        return val.bind(target);
      }
      return val;
    }
  });
  return { proxy, fakeWindow };
}
```

#### 🧪 使用示例：

```
const { proxy: sandbox } = createProxySandbox();

// 在沙箱中执行代码
with (sandbox) {
  eval(`
    window.myVar = 'hello';
    console.log(myVar); // 'hello'
  `);
}

// 主应用不受影响
console.log(window.myVar); // undefined
```

#### ✅ 优点：

- 支持多实例并行；
- 性能较好；
- 完全隔离 `window` 变量。

#### ❌ 缺点：

- 无法拦截 `eval('window.leak = 1')`（逃逸到真实 window）；
- 无法阻止直接操作 `document.body`；
- 函数 `bind(window)` 可能导致隐式污染（非严格模式下）。

> 🔸 **`qiankun` 默认使用此方案**

### (2)、 快照沙箱（`Snapshot Sandbox`，兼容 `IE`）

#### ✅ 原理：

- 激活前：记录 `window` 快照；
- 运行时：直接修改真实 `window`；
- 卸载时：恢复快照，删除新增属性。

```
function createSnapshotSandbox() {
  let snapshot = {};
  let modifiedProps = new Set();

  return {
    activate() {
      // 记录当前 window 状态
      snapshot = { ...window };
    },
    exec(code) {
      // 直接执行（污染真实 window）
      eval(code);
      // 记录新增/修改的属性（简化版）
      Object.keys(window).forEach(k => {
        if (!(k in snapshot)) modifiedProps.add(k);
      });
    },
    deactivate() {
      // 恢复快照
      Object.keys(window).forEach(k => {
        if (!snapshot.hasOwnProperty(k)) {
          delete window[k]; // 清理新增
        }
      });
      Object.assign(window, snapshot); // 恢复修改
    }
  };
}
```

#### ✅ 优点：

- 兼容 `IE11`；
- 实现简单。

#### ❌ 缺点：

- **不支持多实例**（同一时间只能激活一个）；
- 无法隔离 `DOM/CSS` 操作；
- 性能差（深拷贝开销大）。

> 🔸 **`qiankun` 在 `IE` 下自动降级为此方案**

### (3)、 `iframe` 沙箱（最强隔离）

#### ✅ 原理：

将代码放入 `<iframe>` 中执行，天然拥有独立的 `window` 和 `document`。

```
function createIframeSandbox() {
  const iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  document.body.appendChild(iframe);

  const sandboxWindow = iframe.contentWindow;
  const sandboxDoc = iframe.contentDocument;

  return {
    exec(code) {
      sandboxWindow.eval(code);
    },
    getGlobal(key) {
      return sandboxWindow[key];
    },
    destroy() {
      document.body.removeChild(iframe);
    }
  };
}
```

#### ✅ 优点：

- **完全隔离**，无任何污染；
- 原生支持，无需模拟。

#### ❌ 缺点：

- `URL/history` 不同步；
- 通信需 `postMessage`，复杂；
- 无法共享 DOM 布局；
- 内存开销大。

> 💡 适用：高安全插件、在线代码编辑器（如 `CodePen`）

### (4)、`with + new Function`（简易沙箱，不推荐生产）

```
function simpleSandbox(context, code) {
  with (context) {
    return (new Function(...Object.keys(context), code))(...Object.values(context));
  }
}

// 使用
const ctx = { console, Math };
simpleSandbox(ctx, 'console.log(Math.random())');
```

#### ❌ 严重问题：

- 无法访问全局 `API`（除非手动传入）；
- `with` 已被严格模式禁止；
- 无法处理异步/副作用；
- **极易逃逸**（如 `Function('return this')()` 获取真实 window）。

> ⚠️ 仅用于教学演示，**切勿用于生产环境**

## 2、`JS` 沙箱必须处理的副作用

即使隔离了 `window`，以下行为仍会污染全局：

| 副作用                                 | 解决方案                                          |
| -------------------------------------- | ------------------------------------------------- |
| `setTimeout(() => {}, 1000)`           | 劫持 `setTimeout`，记录 ID，卸载时 `clearTimeout` |
| `window.addEventListener('click', fn)` | 劫持 `addEventListener`，记录监听器，卸载时移除   |
| `document.createElement('script')`     | 劫持 DOM API，限制插入位置                        |
| `console.log`                          | 不处理（应由构建工具移除）                        |
| 修改 `localStorage`                    | 无法隔离，需命名空间约定                          |

> 🔸 `qiankun` 通过 **`Patchers` 机制** 自动处理这些副作用。

## 3、如何评估一个 `JS` 沙箱？

| 维度           | 说明                                   |
| -------------- | -------------------------------------- |
| **隔离性**     | 是否防止全局污染？                     |
| **多实例支持** | 能否多个沙箱同时运行？                 |
| **副作用控制** | 能否清理定时器、事件等？               |
| **性能开销**   | `Proxy` / 快照 / `iframe` 的成本       |
| **兼容性**     | 是否支持 `IE`？                        |
| **逃逸风险**   | 是否可被 `eval`、`new Function` 绕过？ |

## 4、实际应用场景

| 场景                        | 推荐方案                     |
| --------------------------- | ---------------------------- |
| 微前端子应用                | `Proxy` 沙箱（`qiankun`）    |
| 低代码平台用户脚本          | `iframe` + 白名单 `API`      |
| 在线 `IDE`（如 `JSFiddle`） | `iframe`+ 通信桥接           |
| 广告/第三方 `SDK`           | `iframe`或严格 `Proxy + CSP` |
| 内部可信插件                | `Proxy` + 副作用清理         |

## 5、安全提醒：`JS` 沙箱 ≠ 安全沙箱

> 🚨 **重要**：前端 `JS` 沙箱**不能防御恶意代码**！

- 用户仍可通过 `fetch` 发送数据；
- 可通过 `document.cookie` 窃取信息；
- 可发起 `CSRF` 请求。

✅ 真正的安全需依赖：

- **后端权限控制**
- **`CSP`（内容安全策略）**
- **代码审核 / 白名单机制**

## 6、总结

| 方案                      | 隔离强度 | 多实例 | 兼容性     | 适用场景            |
| ------------------------- | -------- | ------ | ---------- | ------------------- |
| **`Proxy` 沙箱**          | 中高     | ✅      | 现代浏览器 | 微前端（`qiankun`） |
| **快照沙箱**              | 中       | ❌      | `IE11+`    | 兼容旧浏览器        |
| **`iframe`**              | 极高     | ✅      | 全浏览器   | 高安全插件          |
| **`with + new Function`** | 极低     | -      | 全浏览器   | ❌ 不推荐            |

> 🔑 **最佳实践**：
>  **“用 `Proxy` 沙箱隔离变量，用 `Patchers` 清理副作用，用团队规范杜绝危险操作”**

# 三、`css`沙箱

## 1、`CSS` 沙箱是什么？

`CSS` 沙箱（`CSS Sandbox`）是指在前端开发中，**对 `CSS`  样式进行作用域隔离**，防止不同模块（如微前端子应用、组件库、第三方插件）之间的样式相互污染。由于浏览器原生缺乏完善的 `CSS`  作用域机制（`Shadow DOM` 除外），`CSS`  沙箱通常通过**构建时处理**或**运行时重写**实现。

## 2、为什么需要 `CSS` 沙箱？

#### 类名冲突

主应用和子应用都定义了 `.button { color: red; }`，互相覆盖。

#### 全局选择器污染

子应用使用 `* { box-sizing: border-box; }` 或 `body { margin: 0; }` 影响主应用布局。

#### `UI` 库样式冲突

多个子应用引入不同版本的 `Ant Design`，全局类名（如 `.ant-btn`）互相干扰。

#### 动态插入样式残留

子应用卸载后，`<style>` 标签未移除，样式持续生效。

> 🎯 目标：**让每个模块的样式只作用于自身，不影响他人**

## 3、常用的`css`沙箱实现方式

### (1)、`CSS Modules`（构建时隔离）✅ 推荐

#### 原理：

通过构建工具配置（详见 [webpack 启用 css-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Floaders%2Fcss-loader%2F)）在构建过程中自动生成唯一的类名。对了，`vue3` 中`<style module>` 标签也会被编译为 `CSS Module`，

在构建阶段（`Webpack/Vite`）将 `CSS` 类名哈希化，生成唯一标识。

```
/* button.module.css */
.primary {
  color: blue;
}
```

```
import styles from './button.module.css';
// styles.primary → 'button_primary_xK2d'
<div className={styles.primary}>按钮</div>
```

#### 优点：

- ✅ 完全隔离，无冲突；
- ✅ 支持所有 `CSS` 特性（包括 `@keyframes`）；
- ✅ 无运行时开销。

#### 缺点：

- ❌ 需要改造子应用构建流程；
- ❌ 不适用于已打包的第三方库（如 `CDN` 引入的 `CSS`）。

> 💡 适用：新项目、可控子应用

### (2)、`Scoped CSS`（`Vue/ Svelte` 等框架内置）

#### 原理：

- **`Vue`**：`<style scoped>` 自动为组件内元素添加 `data-v-xxxx` 属性，并重写 `CSS` 选择器；

#### 示例（`Vue`）：

```
<template>
  <div class="header">Hello</div>
</template>
<style scoped>
.header { color: red; }
</style>
```

编译后：

```
<div class="header" data-v-f3f3eg9>...</div>
<style>
.header[data-v-f3f3eg9] { color: red; }
</style>
```

#### 优点：

- ✅ 框架自动处理，开发者无感；
- ✅ 隔离效果好。

#### 缺点：

- ❌ 仅限特定框架；
- ❌ 动态插入的 `<style>` 不受控。

> 📌 在微前端中，**要求所有子应用使用 `CSS Modules` 或 `scoped CSS` 是一种规范约束型方案**，但无法强制

### (3)、 运行时 `CSS` 重写（如 `qiankun` 的 `experimentalStyleIsolation`）

#### 原理：

在加载子应用 `CSS` 时，**动态重写所有选择器**，加上唯一属性前缀：

```
/* 原始 */
.header { color: red; }
.ant-btn:hover { ... }

/* 重写后 */
[data-qiankun="app1"] .header { color: red; }
[data-qiankun="app1"] .ant-btn:hover { ... }
```

同时，子应用挂载容器自动添加该属性：

```
<div id="container" data-qiankun="app1"></div>
```

#### 实现方式：

- 使用正则表达式解析 `CSS` 文本（非 `AST`，性能较好但有局限）；
- 在 `import-html-entry` 或沙箱 `patcher` 中完成。

#### 优点：

- ✅ 无需子应用改造；
- ✅ 兼容现有 `HTML Entry` 微前端架构。

#### 缺点：

- ❌无法处理以下情况：
  - 全局标签选择器：`html`, `body`, `*`
  - `@keyframes fade { ... }`（动画名全局注册）
  - `@font-face { font-family: MyFont; }`
  - `:root { --color: red; }`（`CSS` 变量）
  - 内联样式 `<style style="color: blue">`
  - 第三方库动态插入的样式（可能逃逸）

> 🔸 **`qiankun` 默认不开启，需手动配置**：
>
> ```
> start({ sandbox: { experimentalStyleIsolation: true } });
> ```

### (4)、`Shadow DOM`（原生最强隔离）

#### 原理：

利用浏览器原生 `Shadow DOM` 创建独立的 `DOM` 和 `CSS` 作用域。

```
const shadow = container.attachShadow({ mode: 'open' });
shadow.innerHTML = `
  <style>.header { color: red; }</style>
  <div class="header">子应用内容</div>
`;
```

#### 优点：

- ✅ **完全隔离**，`CSS`、`DOM`、事件均独立；
- ✅ 原生支持，无模拟成本。

#### 缺点：

- ❌ **兼容性**：`IE` 不支持；
- ❌ `UI` 库兼容性差：`Ant Design`、`Element Plus` 等依赖全局样式/`Portal` 的组件会失效；
- ❌ **事件冒泡中断**：需手动处理跨 `Shadow` 边界事件；
- ❌ **调试困难**：`DevTools` 中需展开 `Shadow Root`。

> 💡 适用：高隔离需求、轻量子应用（如图表、表单）

```
// 伪代码
function loadStyles(cssText, container) {
  const style = document.createElement('style');
  style.textContent = cssText;
  container.appendChild(style);
  return () => container.removeChild(style); // 卸载函数
}
```

> ✅ 这是**样式生命周期管理**，配合命名空间使用效果更佳。

### (5)、命名空间约定（人工规范）

#### 方案：

团队约定所有样式必须包裹在唯一根类名下：

```
/* app1 */
.app1-root .btn { ... }
.app1-root .header { ... }

/* app2 */
.app2-root .btn { ... }
```

```
<div class="app1-root">...</div>
```

#### 优点：

- ✅ 简单、通用；
- ✅ 无技术成本。

#### 缺点：

- ❌ 依赖开发者自律；
- ❌ 第三方库无法控制。

> 📌 可作为**兜底规范**配合其他方案使用。

## 4、`CSS` 沙箱能力对比

| 方案              | 隔离强度 | 是否需改造子应用 | 支持 `@keyframes` | 兼容 IE     | 适用场景            |
| ----------------- | -------- | ---------------- | ----------------- | ----------- | ------------------- |
| **`CSS Modules`** | ⭐⭐⭐⭐⭐    | ✅                | ✅                 | ✅（转译后） | 新项目、模块化应用  |
| **`Scoped CSS`**  | ⭐⭐⭐⭐     | ✅（用对应框架）  | ✅                 | ✅           | `Vue/Svelte` 项目   |
| **运行时重写**    | ⭐⭐       | ❌                | ❌                 | ✅           | 微前端（`qiankun`） |
| **`Shadow DOM`**  | ⭐⭐⭐⭐⭐    | ✅                | ✅                 | ❌           | 高安全插件          |
| **命名空间**      | ⭐        | ❌                | ✅                 | ✅           | 团队规范兜底        |

## 5、最佳实践建议

### ✅ 组合策略（推荐）

1. **子应用内部**：使用 `CSS Modules` 或 `Scoped CSS`；
2. **`UI` 库**：启用 `prefixCls`（如 `Ant Desig`n）避免全局类名；
3. **微前端集成**：开启 `experimentalStyleIsolation` 作为兜底；
4. **团队规范**：禁止使用 `body`、`*`、`:root` 等全局选择器；
5. **构建增强**：用 `PostCSS` 插件（如 `postcss-prefixwrap`）自动加命名空间。

### 🛠️ `PostCSS` 自动加前缀示例

```
// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-prefixwrap')('.my-app-root')
  ]
};
```

输入：

```
.btn { color: red; }
```

输出：

```
.my-app-root .btn { color: red; }
```

## 6、验证 `CSS` 隔离是否生效

1. **检查选择器是否带前缀**
    `DevTools` → `Elements` → 查看 `` 内容。
2. **测试冲突场景**
   - 主应用：`.title { color: red; }`
   - 子应用：`.title { color: blue; }`
   - 隔离成功：主应用标题红，子应用标题蓝。
3. **检查卸载后是否残留**
    卸载子应用后，`<head>` 中不应存在其 `<style>` 标签。

## 7、未来方向

- **`CSS` `@scope` 规范**（`Chrome` 已实验性支持）

  ```
  @scope (.my-app) {
    .btn { color: red; }
  }
  ```

  原生 `CSS` 作用域，无需构建或运行时处理。

- **`Web Components + Shadow DOM` 普及**
   随着框架对 `Web Components` 支持增强，`Shadow DOM` 将更易用。

## 8、总结

> 🔑 **`CSS` 沙箱没有银弹，只有“组合拳”**：

- **构建时隔离（`CSS Modules`）** 是最可靠方案；
- **运行时重写（`qiankun`）** 适合渐进式微前端；
- **`Shadow DOM`** 是终极隔离，但生态尚不成熟；
- **团队规范** 是成本最低的防线。

> 📣 **记住**：
>  **“最好的 `CSS` 沙箱，是开发者写的每一行 `CSS` 都知道自己属于谁。”**