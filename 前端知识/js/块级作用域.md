#### 一、作用域分类 ####

在JavaScript的世界里，作用域可以分为三种，分别是全局作用域，函数作用域，块级作用域。

**1.全局作用域**

- 全局作用域是指在代码中任何地方都可以访问的变量，即定义在最外层的变量。全局作用域中的变量可以被程序中的任何函数访问。

**优势：**

- 变量在全局作用域中定义后，在整个程序中都可以访问，方便在不同的函数或模块中共享数据。

- 适用于需要在整个应用中共享的配置信息或常量定义。

**劣势：**

- 全局变量容易被不同部分的代码修改，可能导致不可预测的错误和混乱。

- 可能产生变量名冲突，特别是在大型应用或多人合作项目中。

**2.函数作用域**

- 函数作用域是指在函数内部定义的变量，只能在该函数内部访问。函数作用域可以防止变量污染全局作用域。

**优势：**

- 函数作用域可以避免变量的污染，确保变量仅在函数内部可见，增强了程序的封装性和安全性。

- 可以使用闭包特性，实现函数间的数据共享和保护私有数据。

**劣势：**

- 嵌套的函数作用域可能导致过多的闭包，增加了内存消耗和性能压力。

- 函数作用域只适用于函数内部，无法在不同函数间直接共享数据。

**3.块级作用域（ES6引入）**

- 块级作用域是指在花括号（{}）中定义的变量，例如在 if 语句或 for 循环中。**在 ES6 之前，JavaScript 没有块级作用域，而是使用函数作用域，但在 ES6 中引入了 let 和 const 关键字，可以用于创建块级作用域的变量。**

**优势：**

- 块级作用域可以避免变量的污染，确保变量仅在块级内部可见，提高了程序的可维护性和可读性。

- 可以使用 let 和 const 声明变量，有效解决了 var 带来的变量提升和重定义问题。

**劣势：**

- 旧版本浏览器可能不支持块级作用域，需要使用 Babel 等工具进行转换。

- 在循环中使用块级作用域时，可能会导致变量无法在循环外部访问的问题。

#### 二、块级作用域内的默认变量 ####

	例一：console.log(b) 

	     {
	       b = 50
	     }

     运行结果是index.html:14 Uncaught ReferenceError: b is not defined
    
     why?b不是默认相当于var了吗？
  

	例二：{
	       console.log(b) 
	       b = 50
	     }

     运行结果是index.html:14 Uncaught ReferenceError: b is not defined


    例三：{
	       b = 50
           console.log(b) //50
	     }

         console.log(b) //50

      运行成功，输出 50，通过断点调试我发现，一旦 b =50执行后window上就有b这个属性了

    **这说明块内定义的默认变量和块外访问的都是一个，也就是说块内定义的默认变量只有等到定义默认变量的那行代码执行后才会往window上挂载属性，这个行为跟var声明变量有点区别**
 
    例四：console.log(b) //undefined
         {
	       console.log(b) //undefined
           var b = 50
           console.log(b) //50
	     }

         console.log(b) //50

    可以看到在块内用var声明变量后行为符合我们的一般认知，b被提升到全局，一开始是undefined,直到执行赋值代码后才有值，var还是那个var，从来没变过

**总结：**

   1.在块级作用域内部声明的默认变量（**不使用let,var,const修饰的情况下**），只有等到执行过你定义那个变量的那行代码后才可以访问，才给window赋值这个属性，在那行代码之前访问会报错。

   2.块内的默认变量依旧是全局变量

   3.在块内的默认变量（**不使用let,var,const修饰的情况下**）没执行之前不可以访问这个变量

#### 三、块级作用域内的函数声明 ####

       例一：console.log(a);//undefined
	        {
	           function a(){}
	        }
     
        输出 undefined 还记得上面的块内的默认变量吗？它如果这样子写会报错的，但是函数声明就不会。

原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大的影响，为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

    - 允许在块级作用域内声明函数
    - **函数声明类似于var，即会提升到全局作用于或函数作用域的头部**
    - **同时，函数声明还会提升到所在的块级作用域的头部**

**注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理**

**根据这三条规则，浏览器的ES6环境中，块级作用域声明的函数，行为类似于var声明的变量**

       例二：console.log(`${window.a},${a}`); // undefined undefined
	        {
	           console.log(`${window.a},${a}`);// undefined function a(){}
	           function a(){}
	        }
	        console.log(`${window.a},${a}`);//function a(){} function a(){}

        上例中，第一个console符合预期，第二个console似乎为啥window.a是undefiend,而a是有值呢？

回想上面的结论，**块级作用域的函数声明会提升到块级作用域的顶部**，那此时执行第二个console的时候在块内的顶部其实已经有了声明，所以此时a有值。

而此时window.a没有值，因为window.a是提前在外面var a的那个a,而这个似乎也跟块内的默认变量有点相似，**就是块外的这个a只有等块内定义a的那行代码执行了才会赋值，**这个赋值行为跟块内直接访问a是不同的，直接访问a相当于访问块内提升到顶部的函数声明，执行的时候就有值了。

**总结：**

   1.块内的函数声明会提升到块内的顶部，同时**也会在全局作用域用var声明一个同名的变量，初始值为undefined**

   2.**这个块外的全局同名变量的赋值时机是执行完块内那行函数声明语句后才赋值**

   3.块内的函数声明会提升到块内顶部，区别提升到块外，它并不会用var去声明一个同名的变量

#### 四、块内同时有同名的默认变量和函数声明 ####

        例一：console.log(`${window.a},${a}`); //undefined undefined
	         {
	            a = 50;
	            console.log(`${window.a},${a}`);//undefined 50
	           function a(){}
	          
	         }
	         console.log(`${window.a},${a}`);//50 50

1.按照前面的总结，**块内有函数声明，此时在全局var了一个同名的变量a,也等于window.a** ，第一行输出没毛病，var a没赋值，默认是undefined

2.执行默认的变量 a =50,由于函数的优先级高于变量，所以不会给window挂载属性a，直接跳过。此时执行a = 50只是相当于赋值操作，没有任何声明。给a赋值的时候会查找作用域链有没有声明a,刚好函数声明提升到顶部了一个a,所以就把块内的a赋值为50，所以第二行打印winddow.a仍然是undefined,而a属于块内，此时被赋值为50了

3.按照前面的总结，**块外的那个跟块内函数声明同名的变量只有在函数声明那段代码执行后才会赋值**，所以最后一行代码执行时window.a已经被赋值了，**并且诡异的是块外的那个变量的值似乎跟块内函数声明的函数绑定着，当执行function(){}的时候会给外面的那个变量赋值，因为块内那个函数声明被a =50覆盖了，所以当执行完 function a(){}之后块外的那个变量就被赋值为50了，而非还是function(){}**


        例二：console.log(`1 ${window.a},${a}`);//undefined undefined
	         {
	           console.log(`2 ${window.a},${a}`);//undefined function a(){}
	           function a(){}
	           a = 50;
	           console.log(`3 ${window.a},${a}`);//function a(){} 50
	         }
	          console.log(`4 ${window.a},${a}`);//function a(){} function a(){}


第四个输出为什么window.a不是50?为什么没有被覆盖呢，按照上面所说的 a= 50的时候好像这个a跟外面的那个同名变量绑定着，其实这里你注意到function a(){}和 a= 50的顺序了吗？是先写的function a(){},再写的a =50;

**只有执行function a(){}这段语句时才会影响外面的那个同名变量，其他时候不会影响，一旦执行过后，外面的那个变量的值就定死了，所以包括第三行，第四行输出的window.a已经不受a =50影响了，

我又测试了下

        例三：console.log(`1 ${window.a},${a}`);//undefined undefined
	         {
	    
	           console.log(`2 ${window.a},${a}`);//undefined function a(){}
	           function a(){}
	           a = 50;
	           function a(){} // 再增加个
	           console.log(`3 ${window.a},${a}`);//50 50
	         }
	         console.log(`4 ${window.a},${a}`);//50 50

正如上面所说，**只有执行function a (){}的时候会触发改变外部的那个同名的全局变量，每执行一次就会触发改变外部的那个变量，并且对外部变量赋的值是跟内部同名的函数名绑定着。**

**小结**

**1.块内的函数声明每次执行的时候都会给全局那个同名的变量赋值一次，并且，只有执行那个定义函数声明的代码才会触发赋值，你写的函数声明就相当于setter,每执行一次就给外部的那个同名的变量赋值一次**

**2.如果块内同时有同名的函数声明和默认的变量声明，那给默认的变量赋值时其实相当于赋值给那个同名的函数，因为查找块内的作用域链时找到了,就不会往全局声明了**
