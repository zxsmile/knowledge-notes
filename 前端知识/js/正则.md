https://juejin.im/post/5965943ff265da6c30653879

#### 一、什么是正则表达式？ ####

- **正则表达式描述了一种字符串匹配模式**，包括普通字符（如a-z之间的字母）和特殊字符（比如.、^、$等有特殊意义的专用字符）。

- **典型的搜索和替换操作要求我们提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。**

   - 比如，需要验证用户输入的电话号码符合 ###-###-#### 格式（#表示一个数字）时，如果不使用正则表达式，则需要遍历用户输入的每个字符，确保#位置输入的是数字，非#位置输入的是-。而使用正则表达式的话，一行语句就可以完成验证功能。

- 此外，一个好的正则表达式可以比非正则表达式更快地完成验证工作

#### 二、正则表达式的主要功能 ####

1.进行数据验证：验证一个字符串是否符合某种模式，如电话号码模式或信用卡号码模式。

2.替换文本：可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。

3.基于模式匹配从字符串中提取子字符串。

#### 三、正则引擎 ####

- 正则引擎主要可以分为两大类：一种是**DFA(Deterministic Finite Automatons/确定性有限自动机—)**，一种是**NFA(Nondeterministic Finite Automatons/非确定性有限自动机)**。总的来说，

   - **DFA可以称为文本主导的正则引擎**

   - **NFA可以称为表达式主导的正则引擎**

- **确定型与非确定型**：假设有一个字符串（text=abc）需要匹配，在没有编写正则表达式的前提下，就直接可以确定字符匹配顺序的就是确定型，不能确定字符匹配顺序的则为非确定型

- **有穷**：有穷即表示有限的意思，这里表示有限次数内能得到结果。

- **自动机**：自动机便是自动完成，在我们设置好匹配规则后由引擎自动完成，不需要人为干预！

**1.NFA与DFA工作的区别**

- 我们常常说用正则去匹配文本，这是NFA的思路，DFA本质上其实是用文本去匹配正则。

    'for tonight's'.match(/to(nite|knite|night)/);

     - **如果是NFA引擎，表达式占主导地位。**在字符串先查找字符串中的t，然后依次匹配，如果是o，则继续(以此循环)。匹配到to后，到n，就面临三种选择，每一种都去尝试匹配一下（它也不嫌累），**第一个分支也是依次匹配，到t这里停止(nite分到t这里直接被淘汰)；同理，接着第二个分支在k这里也停止了；终于在第三个分支柳暗花明，找到了自己的归宿。** **NFA 工作方式是以正则表达式为标准，反复测试字符串，这样同样一个字符串有可能被反复测试了很多次！**

     - **如果是DFA引擎呢，文本占主导地位。**从整个字符串第一个字符开始f开始查找t，查找到t后，定位到t，已知其后为o，则去查看正则表达式其相应位置后是否为o，如果是，则继续（以此循环)，再去查正则表达式o后是否为n（此时淘汰knite分支），再后是否为g(淘汰nite分支)，这个时候只剩一个分支，直接匹配到终止即可。

- **只有正则表达式才有分支和范围（NFA），文本仅仅是一个字符流(DFA)。这带来什么样的后果？就是NFA引擎在匹配失败的时候，如果有其他的分支或者范围，它会返回去尝试其他的分支。而DFA引擎一旦匹配失败，就结束了，它没有退路。**

- 这就是它们之间的本质区别。其他的不同都是这个特性衍生出来的。

**2.NFA VS DFA**

（1）编译阶段，首先，正则表达式在计算机看来只是一串符号，正则引擎首先肯定要解析它。

      - **NFA引擎只需要编译就好了；**
      
      - **而DFA引擎则比较繁琐，编译完还不算，还要遍历出表达式中所有的可能。**因为对DFA引擎来说机会只有一次，它必须得提前知道所有的可能，才能匹配出最优的结果。所以，在编译阶段，NFA引擎比DFA引擎快

**所以，在编译阶段，NFA引擎比DFA引擎快。**

（2）运行阶段

      - **DFA引擎在匹配途中一遍过，溜得飞起。**
      
      - **相反NFA引擎就比较苦逼了，它得不厌其烦的去尝试每一种可能性，可能一段文本它得不停返回又匹配，重复好多次。当然运气好的话也是可以一遍过的。**

**所以，在运行阶段，NFA引擎比DFA引擎慢。**

（3）表达能力上

     - **因为NFA引擎是表达式占主导地位，所以它的表达能力更强，开发者的控制度更高，也就是说开发者更容易写出性能好又强大的正则来，当然也更容易造成性能的浪费甚至撑爆CPU。**
     
     - **DFA引擎下的表达式，只要可能性是一样的，任何一种写法都是没有差别(可能对编译有细微的差别)的，因为对DFA引擎来说，表达式其实是死的。**
     
     - **NFA引擎下的表达式，高手写的正则和新手写的正则，性能可能相差10倍甚至更多。也正是因为主导权的不同，正则中的很多概念，比如非贪婪模式、反向引用、零宽断言等只有NFA引擎才有。**
     - 
**所以，在表达能力上，NFA引擎秒杀DFA引擎。**


#### 四、回溯 ####

**1.概述**

- NFA引擎是用表达式去匹配文本，而表达式又有若干分支和范围，一个分支或者范围匹配失败并不意味着最终匹配失败，正则引擎会去尝试下一个分支或者范围。正是i那位这样的机制，引申出了NFA引擎的核心特点------回溯。

- 回溯的原理类似我们走迷宫时走过的路**设置一个标志物**，走到尽头发现是条死路，只好原路返回尝试另一条路。**这个原路返回的过程叫回溯，它在正则中的含义是吐出已经匹配过的文本。**

- **回溯机制不但需要重新计算正则表达式和文本的对应位置，也需要维护括号内的子表达式所匹配文本的状态。**

		const reg = /ab{1,3}c/;
		
		const str = 'abbc';
		
		// 第1步：匹配/a/，得到'a'
		// 第2步：匹配/ab{1}/，得到'ab'
		// 第3步：匹配/ab{2}/，得到'abb'
		// 第4步：匹配/ab{3}/，匹配失败，需要进行回溯
		// 第5步：回溯到/ab{2}/,继续匹配/ab{2}c/，得到'abbc'
		// 第6步：正则表达式匹配完成，得到'abbc'

- 如果我们把正则表达式的各个分支都整理成一棵树的话，**正则表达式的匹配其实就是一个深度优先搜索算法。而回溯其实就是在进行深度优先匹配失败后的后退正常操作逻辑。**

- **如果退回到了根节点仍然无法匹配的话，就会将index向后移动一位，重新构建匹配数。**即/bc/在'abc'时，由于第一个字符'a'无法匹配，则移动到'b'开始匹配。


**2.回溯法产生场景**

- 出现回溯的场景主要有以下几种：

  （1）**贪婪量词（贪婪匹配）**

        const reg = /ab{1,3}c/;

		const str = 'abbc';
		
		// 第1步：匹配/a/，得到'a'
		// 第2步：匹配/ab{1}/，得到'ab'
		// 第3步：匹配/ab{2}/，得到'abb'
		// 第4步：匹配/ab{3}/，匹配失败，需要进行回溯
		// 第5步：回溯到/ab{2}/,继续匹配/ab{2}c/，得到'abbc'
		// 第6步：正则表达式匹配完成，得到'abbc'

     - 这个例子就是尽可能多的匹配B从而导致了回溯

  （2）**惰性量词（非贪婪匹配）**

        const reg = /ab{1,3}?c/;

		const str = 'abbc';
		
		// 第1步：匹配/a/，得到'a'
		// 第2步：匹配/ab{1}/，得到'ab'
		// 第3步：匹配/ab{1}c/，匹配失败，需要进行回溯
		// 第4步：回溯到/ab{1}/，继续匹配/ab{2}/，得到'abb'
		// 第5步：匹配/ab{2}c/，得到'abbc'
		// 第6步：正则表达式匹配完成，得到'abbc'

     - 与贪婪匹配类似，非贪婪匹配虽然每次都是去最小匹配数目，但是也会出现回溯的情况。
    
  （3）**分支结构（分支匹配）**

        const reg = /(ab|abc)d/;

		const str = 'abcd';
		
		// 第1步：匹配/ab/，得到'ab'
		// 第2步：匹配/abd/，匹配失败，需要进行回溯
		// 第3步：回溯到//，继续匹配/abc/，得到'abc'
		// 第4步：匹配/abcd/，得到'abcd'
		// 第5步：正则表达式匹配完成，得到'abcd'

    - 通过上面的示例我们可以看到，分支结构在出现两个分支情况类似的时候，也会出现回溯的情况，在这种情况下，**如果一个分支无法匹配，则会回到这个分支的最初情况来重新进行匹配。**

#### 五、正则表达式操作符优先级 ####

- 从上到下，优先级依次降低：

   （1） 转义符: \ 

   （2） 小括号和中括号: (…)、(?:…)、(?=…)、(?!…)、[…]

   （3） 量词限定符: {m}、{m,n}、{m,}、?、*、+
 
   （4） 位置和序列: ^、$、\元字符、一般字符

   （5） 管道符: |

		const reg = /ab?(c|de*)+|fg/;
		
		// 第一步，根据优先级先考虑(c|de*)+，再根据优先级拆分得到c de*，即匹配c或者de*（注意，位置和序列的优先级高于管道符|，所以是c或de*而不是c或d和e*）
		// 第二步，得到ab?，根据优先级拆分得到a和b?
		// 第三步，得到fg，这个内容和第一步+第二步的结果为或的关系


#### 六、回溯解决方案 ####

1.优化正则表达式本身

  - 第一个解决方案就是尽可能的去优化这个正则表达式本身，去尽可能消除里面一些回溯的情况。这个也是我们一般最常用的一个解决方案。具体有以下2个操作：

      - **在明确匹配规则的情况下，使用\d{1, 30}来替换.*，尽可能的去明确我们需要匹配的类型与长度。**

      - **在需要进行不明确数量匹配的时候，尽可能的使用非贪婪匹配，而不是使用贪婪匹配。**

  - 同时，还有个规则：**在不需要捕获组的情况下，括号尽可能的使用非捕获组（与回溯无关），但能提高性能。**

  - 总体上来说就是：如果一个正则表达式越精确，捕获的元素越少，那么它的性能就会越好。反之，如果有大量的模糊匹配跟回溯的情况，那么它的性能大概率就不怎么好。


2.优化正则表达式匹配顺序

 - 如果我们继续要匹配比较复杂的正则，同时这个正则又没有办法避免回溯的情况，我们应该怎么去优化这个性能的？

 - 在正则没有办法修改的情况下，我们可以做正则匹配的分级，尽可能使用一些性能比较高的正则表达式，先进行一些过滤匹配。在命中我们需要匹配的条件以后，再使用比较复杂的正则表达式进行匹配。从而避免复杂的正则表达式频繁的被调用。

        let str = 'xxxxxx'; //长文本

		const LINE_REG = /\n(—){10}\n/m;
		const QUOTED_MSG_REG = /([^「]*?)「((?:[a-zA-Z0-9\u4E00-\u9FBF_\.\s]{0,40})\：(?:.|\n)*)」\n(—){10}\n((?:\S|\s)*)$/m;
		
		if(LINE_GER.test(str)) {
			let result = str.match(QUOTED_MSG_REG);
			// do something
		}


    - 上例中，这个正则表达式没有办法再进行进一步优化了情况下，我们可以先把他的一些特定的规则摘取出来，进行一个前置校验。