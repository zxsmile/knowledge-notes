 # 一、进程和线程

进程：进程是系统分配的独立资源，是`CPU`资源分配的最小单位，进程是由一个或多个线程组成

线程：线程是进程的执行流，是`CPU`调度和分配的基本单位，同个进程之中的多个线程之间共享该进程的资源

# 二、浏览器是多进程的

浏览器是多进程的，每打开一个`tab`页，就相当于创建了一个独立的浏览器进程(也不一定，因为多个空白 `tab` 标签会合并成一个进程)

浏览器包含的进程：

- **1个``Browser``进程**：浏览器的主进程(主要负责协调、主控)，只有一个，作用有：
  - 负责浏览器界面的显示，与用户交互，如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将`Rendered`进程得到的内存中的`Bitmap`，绘制到用户界面上
  - 网络资源的管理、下载

- **多个第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建

- **1个`GPU`进程**：最多一个，用于`3D`绘制等

- **多个浏览器渲染进程(浏览器内核)(``render``进程，内部是多线程的)**：默认情况下每打开一个 `Tab` 页签，`Chrome` 都会为其创建一个渲染进程，互不影响，主要作用为：
  - 页面渲染，脚本执行，事件处理等                 

- **1个网络进程**：负责页面的网络资源加载。

# 二、浏览器渲染进程

## 浏览器是多进程的，浏览器渲染进程是多线程的

#### (1)`GUI`线程

负责渲染浏览器界面，解析``HTML``,`CSS`,构建`DOM`树和`RenderObject`树，布局和绘制等。

当界面需要重绘或由于某种操作引发回流时，该线程就会执行。

注意，`GUI`渲染线程与``JS``引擎线程是互斥的，当``JS``引擎执行时`GUI`线程会被挂起（相当于冻结了）,`GUI`更新会被保存在一个队列中等到``JS``引擎空闲时立即被执行

#### (2)``JS``引擎线程

也称为``JS``内核，负责处理`JavaScript`脚本程序。（例如`V8`引擎）。

`JS`引擎线程负责解析`JavaScript`脚本，运行代码。

`JS`引擎一直等待着任务队列中任务的到来，然后加以处理，一个`Tab`页（``render``进程）中无论什么时候都只有一个`JS`线程在运行``JS``程序。

同样注意，`GUI`渲染线程与``JS``引擎线程是互斥的，所以如果``JS``执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

#### (3)事件触发线程

归属于浏览器而不是``JS``引擎，用来控制事件循环（可以理解成``JS``引擎自己都忙不过来，需要浏览器另开线程协助）。

当`JS`引擎执行代码块如``setTimeout``时（也可来自浏览器内核的其它线程，如鼠标点击，`AJAX`异步请求等），会将对应任务添加到事件线程中。

当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待`JS`引擎的处理。

> 注意，由于`JS`的单线程关系，所以这些待处理队列中的事件都得排队等待`JS`引擎处理（当`JS`引擎空闲时才会去执行）

#### (4)定时触发器线程

传说中的``setTimeout``和``setInterval``所在的线程

浏览器定时计数器并不是由`JavaScript`引擎计数的，（因为`JavaScript`引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）

因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待`JS`引擎空闲后执行）

注意，`W3C`在`HTML`标准中规定，规定要求``setTimeout``中低于`4ms`的时间间隔算为`4ms`

#### (5)异步`HTTP`请求线程

在`XMLHttpRequest`在连接后是通过浏览器新型一个线程请求

将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由`JavaScript`引擎

**渲染进程中的异步`HTTP`请求线程负责处理异步 `HTTP` 请求，那浏览器的另一个进程-网络进程是干嘛呢？两个有什么区别？**

- **渲染进程中的异步 `HTTP` 请求线程**是专门用来处理 `JavaScript` 层面的异步网络请求的，例如使用`XMLHttpRequest` 对象或 `Fetch API`。而**网络进程**就比较全面了，它负责处理所有的网络操作，包括页面导航、处理主页面的请求、子页面的请求、资源加载等。

- 另外**他们两个是协同工作的**，例如 `JS` 发起的异步网络请求，要经历：`DNS` 解析：-> 建立连接 -> 发送请求 -> 接收响应。**当`HTTP` 异步请求线程处理 `JS` 代码发起的请求时，`DNS` 解析和建立连接通常在网络进程中执行，`HTTP` 异步请求线程则负责发送请求和接收响应。**

## 浏览器主进程(``Browser``)和渲染进程(浏览器内核)之间的通信过程

打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开`Tab`页的渲染进程）

   (1)`Browser`主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源），随后将该任务通过`RendererHost`接口传递给``render``渲染进程

   (2)``render``渲染进程的`Renderer`接口收到消息，简单解释后，交给渲染线程`GUI`，然后开始渲染
    
   (3)`GUI`渲染线程接收请求，加载网页并渲染网页，这其中可能需要`Browser`主进程获取资源和需要`GPU`进程来帮助渲染
    
   (4)当然可能会有`JS`线程操作`DOM`（这可能会造成回流并重绘）
    
   (5)最后``render``渲染进程将结果传递给`Browser`主进程
    
   (6)`Browser`主进程接收到结果并将结果绘制出来

# 三、`JS`引擎是单线程的

`JavaScript`引擎是单线程，也就是说每次只能执行一项任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务

## `WebWorker`

创建`worker`时，`JS`引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作`DOM`），`JS`引擎线程与`worker`线程间通过特定的方式通信（`postMessage API`，需要通过序列化对象来与线程交互特定的数据），所以，如果有非常耗时的工作，请单独开一个`Worker`线程，这样里面不管如何翻天覆地都不会影响`JS`引擎主线程，只待计算出结果后，将结果通信给主线程即可

> 而且注意下，`JS`引擎是单线程的，这一点的本质仍然未改变，`Worker`可以理解是浏览器给`JS`引擎开的外挂，专门用来解决那些大量计算问题
>

## `WebWorker`和`ShareWorker`

`WebWorker`只属于某个页面，不会和其他页面的`render`进程（浏览器内核进程）共享，所以`Chrome`在`render`进程中（每一个`Tab`页就是一个`render`进程）创建一个新的线程来运行`Worker`中的`JavaScript`程序。

`sharedWorker`是浏览器所有页面共享的，不能采用与`Worker`同样的方式实现，因为它不隶属于某个`render`进程，可以为多个`render`进程共享使用，所以`Chrome`浏览器为`SharedWorker`单独创建一个进程来运行`JavaScript`程序，在浏览器中每个相同的`JavaScript`只存在一个`SharedWorker`进程，不管它被创建多少次

所以本质上就是进程和线程的区别，`SharedWorker`由独立的进程管理，`WebWorker`只是属于`render`进程下的一个线程

# 三、`JavaScript`事件循环机制

`JS`分为同步任务和异步任务，同步任务在主线程上执行，形成一个执行栈。主线程之外，事件触发线程管理着一个任务列队，只要异步任务有了运行结果，就在任务队列中放置一个事件，一旦执行栈中的所有同步任务执行完毕(此时`JS`引擎空闲)，系统就会读取任务列队，将可运行的异步任务添加到可执行栈，开始执行。

#### `Event Loop`

调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环

#### 定时器

上面`JS`事件循环机制的核心是：`JS`引擎线程和事件触发线程。

调用`setTimeout`后，是由定时器线程控制等到特定时间后添加到事件队列的，因为`JS`引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时

当使用`setTimout`或`setInterval`时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中,定时器指定的延时毫秒数其实并不准确，因为**定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行**

##### ``setInterval``

用`setTimeout`模拟定期计时和`setInterval`是有区别的：

  * 每次`setTimeout`计时到后就会去执行，然后执行一段时间后才会继续`setTimeout`,中间就多了误差
  
  * **而`setInterval`则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）**

而且`setInterval`有一些比较致命的问题：

  * 累积效应，如果`setInterval`代码在`setInterval`再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个`setInterval`的代码执行时间可能会比预期小（因为代码执行需要一定时间）

  * 比如你`ios`的`webview`，或者`safari`等浏览器中都有一个特点，在滚动的时候是不执行`JS`的，如果使用了`setInterval`，会发现在滚动结束后会执行多次由于滚动不执行`JS`积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（`setInterval`自带的优化，如果当前事件队列中有`setInterval`的回调，不会重复添加回调）

  * 而且把浏览器最小化显示等操作时，`setInterval`并不是不执行程序，它会把`setInterval`的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行

#### `Promise`时代的`microtask`与`macrotask` 

(1)除了广义的同步任务和异步任务，`JavaScript` 单线程中的任务可以细分为宏任务和微任务。

 * **`macro-task`(宏任务)包括**：`script`(整体代码), `setTimeout`, `setInterval`, `setImmediate`, `I/O`, `UI rendering`

 * **`micro-task`(微任务)包括**：`process.nextTick`, `Promise.[then/catch/finally]`, `Object.observe`, `MutationObserver`(浏览器环境)，`process.nextTick`(`Node`环境),`queueMicrotask`

##### (2)`macro-task`(宏任务)

事件列队中的每一个事件都是一个宏任务，可以理解是每次执行的代码都是一次宏任务(包括每次从时间列队中获取一个事件回调并放到执行栈中执行),第一个宏任务会从头到尾将这个任务执行完毕，不会执行其它

##### (3)`micro-task`(微任务)

* 可以理解是在当前宏任务执行结束后立即执行的任务,也就是说在当前宏任务后，下一个宏任务之前，在渲染之前。所以它的响应速度相比`setTimeout`(`setTimeout`是宏任务)会更快因为无需等待渲染。也就是说，在某一个宏任务执行完成后，就会将在它执行期间产生的所有微任务都执行完毕（在渲染前）。

* 注意：在`Node`环境下，`process.nextTick`的优先级高于`promise`.也就是：在宏任务结束后会先执行微任务队列中的`nextTick`部分，然后才会执行微任务中的`promise`部分

* `setImmediate`则是规定：在下一次`Event Loop`（宏任务）时触发（所以它是属于优先级较高的宏任务），（`Node.JS`文档中称，`setImmediate`指定的回调函数，总是排在`setTimeout`前面），所以，`setImmediate`如果嵌套的话，是需要经过多个`Loop`才能完成的，而不会像`process.nextTick`一样没完没了

##### (4)有了宏任务和微任务之后的`JS`执行顺序

	如：
	
		console.log(1);
		`setTimeout`(function() {
		    console.log(2);
		})
		var promise = new Promise(function(resolve, reject) {
		    console.log(3);
		    resolve();
		})
		promise.then(function() {
		    console.log(4);
		})
		console.log(5);
	
	`setTimeout` 和 Promise被称为任务源，来自不同的任务源注册的回调函数会被放入到不同的任务队列中
	new Promise里的函数是直接执行的算做主程序里，而且.then后面的才会放到微任务中

*  第一次事件循环中，`JavaScript` 引擎会把整个 `script` 代码当成一个宏任务执行，执行过程中如果遇到微任务，就将它添加到微任务的任务队列中，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务。当前宏任务执行完毕，开始检查渲染，然后`GUI`线程接管渲染。渲染完毕后，`JS`线程继续接管。开始下一个宏任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。`JS` 的执行顺序就是每次事件循环中的宏任务-微任务

* 上面代码执行过程：

    * 第一次事件循环，整段代码作为宏任务进入主线程执行。
    * 遇到了 `setTimeout` ，就会等到过了指定的时间后将回调函数放入到宏任务的任务队列中。
    * 遇到 `Promise`，将 `then` 函数放入到微任务的任务队列中。
    * 整个事件循环完成之后，会去检测微任务的任务队列中是否存在任务，存在就执行。
    * 第一次的循环结果打印为: 1,3,5,4。
    * 接着再到宏任务的任务队列中按顺序取出一个宏任务到栈中让主线程执行，那么在这次循环中的宏任务就是 `setTimeout` 注册的回调函数，执行完这个回调函数，发现在这次循环中并不存在微任务，就准备进行下一次事件循环。
    * 检测到宏任务队列中已经没有了要执行的任务，那么就结束事件循环。
    * 最终的结果就是 1,3,5,4,2。

nnnn























