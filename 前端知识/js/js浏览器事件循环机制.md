 # 一、进程和线程

1.进程：进程是系统分配的独立资源，是CPU资源分配的最小单位，进程是由一个或多个线程组成

2.线程：线程是进程的执行流，是CPU调度和分配的基本单位，同个进程之中的多个线程之间共享该进程的资源

# 二、浏览器是多进程的

1.浏览器是多进程的，每打开一个tab页，就相当于创建了一个独立的浏览器进程(也不一定，因为多个空白 tab 标签会合并成一个进程)

2.浏览器包含的进程：

   (1)**1个Browser进程**：浏览器的主进程(主要负责协调、主控)，只有一个，作用有：

                      * 负责浏览器界面的显示，与用户交互，如前进，后退等
                      * 负责各个页面的管理，创建和销毁其他进程
                      * 将Rendered进程得到的内存中的Bitmap,绘制到用户界面上
                      * 网络资源的管理、下载

   (2)**多个第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建

   (3)**1个GPU进程**：最多一个，用于3D绘制等

   (4)**多个浏览器渲染进程(浏览器内核)(Render进程，内部是多线程的)**：默认情况下每打开一个 Tab 页签，Chrome 都会为其创建一个渲染进程，互不影响，主要作用为：

                      * 页面渲染，脚本执行，事件处理等

  (5)**1个网络进程**：负责页面的网络资源加载。

# 二、浏览器渲染进程

1.浏览器是多进程的，浏览器渲染进程是多线程的

(1)GUI线程

   * 负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等。
   * 当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
   * 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于冻结了）,GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行

(2)js引擎线程

   * 也称为JS内核，负责处理JavaScript脚本程序。（例如V8引擎）。
   * JS引擎线程负责解析JavaScript脚本，运行代码。
   * JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（render进程）中无论什么时候都只有一个JS线程在运行JS程序。
   * 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

(3)事件触发线程

   * 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解成JS引擎自己都忙不过来，需要浏览器另开线程协助）。
   * 当JS引擎执行代码块如setTimeout时（也可来自浏览器内核的其它线程，如鼠标点击，AJAX异步请求等），会将对应任务添加到事件线程中。
   * 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
   * 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

(4)定时触发器线程

   * 传说中的setTimeout和setInterval所在的线程
   * 浏览器定时计数器并不是由JavaScript引擎计数的，（因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）
   * 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
   * 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms

(5)异步http请求线程

   * 在XMLHttpRequest在连接后是通过浏览器新型一个线程请求
   
   * 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎
   
   * **渲染进程中的异步HTTP请求线程负责处理异步 HTTP 请求，那浏览器的另一个进程-网络进程是干嘛呢？两个有什么区别？**

       - **渲染进程中的异步 HTTP 请求线程**是专门用来处理 JavaScript 层面的异步网络请求的，例如使用XMLHttpRequest 对象或 Fetch API。而**网络进程**就比较全面了，它负责处理所有的网络操作，包括页面导航、处理主页面的请求、子页面的请求、资源加载等。

       - 另外**他们两个是协同工作的**，例如 JS 发起的异步网络请求，要经历：DNS 解析：-> 建立连接 -> 发送请求 -> 接收响应。**当HTTP 异步请求线程处理 JS 代码发起的请求时，DNS 解析和建立连接通常在网络进程中执行，HTTP 异步请求线程则负责发送请求和接收响应。**

2.浏览器主进程(Browser)和渲染进程(浏览器内核)之间的通信过程

打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开Tab页的渲染进程）

   (1)Browser主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过RendererHost接口传递给Render渲染进程
   
   (2)Render渲染进程的Renderer接口收到消息，简单解释后，交给渲染线程GUI，然后开始渲染
    
   (3)GUI渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser主进程获取资源和需要GPU进程来帮助渲染
    
   (4)当然可能会有JS线程操作DOM（这可能会造成回流并重绘）
    
   (5)最后Render渲染进程将结果传递给Browser主进程
    
   (6)Browser主进程接收到结果并将结果绘制出来

# 三、js引擎是单线程的

1.JavaScript引擎是单线程，也就是说每次只能执行一项任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务

2.WebWorker

(1)创建worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM），JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据），所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可

(2)而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题

3.WebWorker和ShareWorker

(1)WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享,所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。

(2)SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用,所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次

(3)所以本质上就是进程和线程的区别，SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程

# 三、JavaScript事件循环机制

1.js分为同步任务和异步任务

2.同步任务在主线程上执行，形成一个执行栈

3.主线程之外，事件触发线程管理着一个任务列队，只要异步任务有了运行结果，就在任务队列中放置一个事件

4.一旦执行栈中的所有同步任务执行完毕(此时js引擎空闲)，系统就会读取任务列队，将可运行的异步任务添加到可执行栈，开始执行

5.Event Loop

调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环

6.定时器

(1)上面js事件循环机制的核心是：js引擎线程和事件触发线程

(2)调用setTimeout后，是由定时器线程控制等到特定时间后添加到事件队列的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时

(3)当使用setTimout或setInterval时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中,定时器指定的延时毫秒数其实并不准确，因为**定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行**

(4)setInterval

  * 用setTimeout模拟定期计时和setInterval是有区别的：

        * 每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout,中间就多了误差
        
        * **而setInterval则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）**
  
  * 而且setInterval有一些比较致命的问题：

        * 累积效应，如果setInterval代码在setInterval再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）

        * 比如你ios的webview，或者safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（setInterval自带的优化，如果当前事件队列中有setInterval的回调，不会重复添加回调）

        * 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行

7.Promise时代的microtask与macrotask 

(1)除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。

     * macro-task(宏任务)包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering

     * micro-task(微任务)包括：process.nextTick, Promises, Object.observe, MutationObserver

(2)macro-task(宏任务)

事件列队中的每一个事件都是一个macro-task，可以理解是每次执行的代码都是一次宏任务(包括每次从时间列队中获取一个事件回调并放到执行栈中执行),第一个macrotask会从头到尾将这个任务执行完毕，不会执行其它

(3)micro-task(微任务)

* 可以理解是在当前macrotask执行结束后立即执行的任务,也就是说在当前macrotask任务后，下一个macrotask之前，在渲染之前。所以它的响应速度相比setTimeout(setTimeout是macrotask)会更快因为无需等待渲染。也就是说，在某一个macrotask执行完成后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。

* 注意：在Node环境下，process.nextTick的优先级高于promise.也就是：在宏任务结束后会先执行微任务队列中的nextTick部分，然后才会执行微任务中的promise部分

* setImmediate则是规定：在下一次Event Loop（宏任务）时触发（所以它是属于优先级较高的宏任务），（Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面），所以，setImmediate如果嵌套的话，是需要经过多个Loop才能完成的，而不会像process.nextTick一样没完没了

(4)有了宏任务和微任务之后的js执行顺序

	如：

		console.log(1);
		setTimeout(function() {
		    console.log(2);
		})
		var promise = new Promise(function(resolve, reject) {
		    console.log(3);
		    resolve();
		})
		promise.then(function() {
		    console.log(4);
		})
		console.log(5);

    setTimeout 和 Promise被称为任务源，来自不同的任务源注册的回调函数会被放入到不同的任务队列中
    new Promise里的函数是直接执行的算做主程序里，而且.then后面的才会放到微任务中

* 第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行过程中如果遇到微任务，就将它添加到微任务的任务队列中，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务。当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染。渲染完毕后，JS线程继续接管。开始下一个宏任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务

* 上面代码执行过程：

    * 第一次事件循环，整段代码作为宏任务进入主线程执行。
    * 遇到了 setTimeout ，就会等到过了指定的时间后将回调函数放入到宏任务的任务队列中。
    * 遇到 Promise，将 then 函数放入到微任务的任务队列中。
    * 整个事件循环完成之后，会去检测微任务的任务队列中是否存在任务，存在就执行。
    * 第一次的循环结果打印为: 1,3,5,4。
    * 接着再到宏任务的任务队列中按顺序取出一个宏任务到栈中让主线程执行，那么在这次循环中的宏任务就是 setTimeout 注册的回调函数，执行完这个回调函数，发现在这次循环中并不存在微任务，就准备进行下一次事件循环。
    * 检测到宏任务队列中已经没有了要执行的任务，那么就结束事件循环。
    * 最终的结果就是 1,3,5,4,2。

























