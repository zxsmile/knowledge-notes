# 一、简介

防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案

# 二、函数防抖

## 1.概念

让事件触发时的回调在一定的延时后执行。如果在计时期间又触发了事件，则重新开始计时

## 2、原理：

> **在事件被频繁触发时，只在“最后一次触发后等待指定时间无新触发”才执行函数。**

- 就像电梯：有人进来就重新计时，直到一段时间没人进才关门。
- 如果持续触发，函数永远不会执行；只有“安静下来”后才执行一次。

## 3、实现

	function debounce(fn, delay){
	  
	     var time = null
	
	     return function(){
	         if(time!==null){
	           clearTimeout(time)
	        }
	        
	       time = setTimeout(fn,delay)
	        
	     }
	}


​	 
	function handle(){
	    console.log('666')
	}
	
	window.addEventListener('scroll', debounce(handle, 1000));

## 4、 典型应用场景：

####  搜索框输入联想（`Search Suggestion`）

```
// 用户每输入一个字就发请求？太浪费！
const debouncedSearch = debounce((query) => {
  fetch(`/api/search?q=${query}`);
}, 300);

input.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});
```

✅ 效果：用户停止输入 `300ms` 后才发起请求，避免无效请求。

#### 窗口 `resize / scroll` 事件中的布局计算（需最终状态）

```
const handleResize = debounce(() => {
  console.log('窗口尺寸稳定了，现在更新布局');
  adjustLayout();
}, 250);

window.addEventListener('resize', handleResize);
```

✅ 适用：你只关心**最终窗口大小**，而不是中间过程。

> ⚠️ 注意：如果需要实时响应（如动画），则不适合用防抖。

#### 表单提交（防止重复点击）

```
const submitForm = debounce(async () => {
  await api.submit(data);
}, 1000, { leading: true }); // 立即执行一次，之后1秒内不再响应

button.addEventListener('click', submitForm);
```

✅ 防止用户疯狂点击“提交”按钮导致多次提交。

#### 自动保存草稿（如编辑器）

```
const saveDraft = debounce(() => {
  localStorage.setItem('draft', editor.getContent());
}, 1000);

editor.on('change', saveDraft);
```

✅ 用户停止编辑 1 秒后自动保存，避免频繁写入。

# 三、函数节流

## 1.概念

当触发事件时，让事件的回调一定时间间隔只执行一次

## 2.原理：

> **在指定时间间隔内，函数最多只执行一次。**

- 就像水龙头：无论你怎么拧，水流每隔 1 秒滴一滴。
- 高频触发时，函数会**定期执行**，不会完全被抑制。

## 3.实现

有两种方法：

(1)时间戳

	function throttle(fn, delay) {
	    var pre = Date.now();
	    return function () {
	        var now = Date.now(),
	            that = this
	            args = arguments;
	        // 距离上次执行回调超过延时
	        if(now - pre >= delay) {
	            fn.apply(that, args);
	            pre = now;
	        }
	    }
	}


	function handler(){
	    console.log('666')
	}
	
	window.addEventListener('scroll', throttle(handle, 1000));


(2)定时器

	function throttle(fn, delay) {
	    var timer = null;
	    return function () {
	        var that = this
	            args = arguments;
	        if(!timer) {
	            timer = setTimeout(function() {
	                fn.apply(that, args);
	                timer = null;
	            }, delay);
	        }
	    }
	}


	function handler(){
	    console.log('666')
	}
	
	window.addEventListener('scroll', throttle(handle, 1000));


(3)时间戳+节流

当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。比较精确

	var throttle = function(func, delay) {     
	    var timer = null;     
	    var startTime = Date.now();     
	    return function() {             
	        var curTime = Date.now();             
	        var remaining = delay - (curTime - startTime);             
	        var context = this;             
	        var args = arguments;             
	        clearTimeout(timer);              
	        if (remaining <= 0) {                    
	            func.apply(context, args);                    
	            startTime = Date.now();              
	        } else {                    
	            timer = setTimeout(function(){
	                         func.apply(context,args)
	                      }, remaining);              
	        }      
	    }
	}
	function handle() {      
	    console.log(Math.random());
	} 
	window.addEventListener('scroll', throttle(handle, 1000));

在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，当remaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态

## 4、典型应用场景：

####  滚动加载（`Infinite Scroll`）

```
const loadMore = throttle(() => {
  if (isNearBottom()) {
    fetchData();
  }
}, 200); // 每200ms最多检查一次

window.addEventListener('scroll', loadMore);
```

✅ 避免 `scroll` 事件每帧都触发，造成性能卡顿。

------

#### 鼠标移动跟踪（如拖拽、画图）

```
const trackMouse = throttle((e) => {
  updateCursorPosition(e.clientX, e.clientY);
}, 16); // ≈60fps

canvas.addEventListener('mousemove', trackMouse);
```

✅ 控制更新频率，避免过度渲染。

------

#### 按钮高频点击（如点赞、抢购）

```
const like = throttle(() => {
  api.like(postId);
}, 1000); // 1秒内只能点一次

likeButton.addEventListener('click', like);
```

✅ 防止用户手快连点导致多次请求（比 `disable` 更友好）。

------

####  游戏中的技能冷却 / 移动控制

```
const movePlayer = throttle((direction) => {
  player.move(direction);
}, 100); // 每100ms响应一次方向键
```

✅ 避免角色因高频按键而“抽搐”。

# 四、对比总结

| 特性             | 防抖（`Debounce`）       | 节流（`Throttle`）   |
| ---------------- | ------------------------ | -------------------- |
| **执行时机**     | 事件停止后执行           | 固定间隔执行         |
| **是否保证执行** | 只要不停止，可能永不执行 | 一定会定期执行       |
| **适用逻辑**     | “等用户做完再说”         | “定期做，别太频繁”   |
| **典型场景**     | 搜索、保存、提交         | 滚动、拖拽、点击限制 |
| **类比**         | 电梯关门                 | 水龙头滴水           |

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在`delay`时间后触发函数，但是在`delay`时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 `Ajax` 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现

# 五、高级技巧

## 1. 防抖 + 节流结合使用

某些场景需要两者兼顾，例如：

- 搜索框：**防抖**（停止输入后搜索）
- 但也要**节流兜底**：即使用户一直输入，每 5 秒也强制搜一次

## 2. 使用 Lodash 工具库

```
import { debounce, throttle } from 'lodash';

const debouncedFn = debounce(fn, 300);
const throttledFn = throttle(fn, 200);
```

## 3. React 中的注意事项

防抖/节流函数应在 `useCallback` 或组件外定义，避免每次渲染重建

```
const search = useCallback(debounce((q) => api.search(q), 300), []);
```

## 总结口诀

> - **防抖**：**“等你停手我才干”** → 适用于**结果导向**的场景（搜索、保存）
> - **节流**：**“我定期干，别催”** → 适用于**过程控制**的场景（滚动、拖拽、限频）

合理使用防抖和节流，能显著提升用户体验和系统性能！