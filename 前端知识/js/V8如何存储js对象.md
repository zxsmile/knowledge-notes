#### 一、前言 ####

- JS对象存储在堆中，它更像一个字典，字符串作为键名，任意对象都可以作为键值，通过键名读写键值。然而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8 为了提升存储和查找效率，采用了一套复杂的存储策略。线性结构是一块连续的内存，如线性表和数组，非线性结构一般占用非连续性内存，如链表和树
- 在V8中对象主要由三个指针构成，Element、property、隐藏类。其中Element、property用于存放对象的属性，隐藏类用于描述对象的结构，隐藏类的出现主要是为了提高存取对象属性的效率

#### 二、Element和property ####

先看下下面的一个实例：

	function Foo() {
	    this[100] = 'test-100'
	    this[1] = 'test-1'
	    this["B"] = 'bar-B'
	    this[50] = 'test-50'
	    this[9] =  'test-9'
	    this[8] = 'test-8'
	    this[3] = 'test-3'
	    this[5] = 'test-5'
	    this["A"] = 'bar-A'
	    this["C"] = 'bar-C'
	}
	var bar = new Foo()
	
	for(key in bar){
	    console.log(`index:${key}  value:${bar[key]}`)
	}
	
	console.log(bar)   

    输出：index:1  value:test-1
		 index:3  value:test-3    
		 index:5  value:test-5    
		 index:8  value:test-8    
		 index:9  value:test-9    
		 index:50  value:test-50  
		 index:100  value:test-100
		 index:B  value:bar-B     
		 index:A  value:bar-A     
		 index:C  value:bar-C  

明显看结果没按顺序我们设置的顺序来，这是为什么呢？

- 在 V8 的对象中有两种属性，排序属性 (elements)和常规属性 (properties)。

   - 把对象中的数字属性称为排序属性，在 V8 中被称为 elements。数字属性应该按照索引值大小升序排列。
   - 字符串属性就被称为常规属性，在 V8 中被称为 properties，字符串属性根据创建时的顺序升序排列。
   - 两个属性都有时，排序属性 (elements)先于常规属性(properties)。

- 在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构 来分别保存排序属性和常规属性。分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。
- element默认应该采用连续的存储结构，通过浪费空间换取时间，直接下标访问，提升访问速度。 但当element的序号十分不连续时，会优化成为hash表，因为要浪费的空间太大了，不合算。

	function Foo() {}
	var bar = new Foo()
	for (let i = 0; i < 10; i++) {
	    bar[i] = 'bar' + i
	}
	// bar[1111] = 'bar1111'

    当我们添加了 bar[1111] 之后，数组会变成稀疏数组。为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。


#### 三、快属性和慢属性 ###

- V8将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行 obj.B这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)。
- 采用对象内属性之后，常规属性就被保存到 testObj 对象本身了，这样当再次使用testObj.B来查找 B 的属性值时，V8 就可以直接从 testObj 对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。
- 不过 对象内属性的数量是固定的，默认是 10 个，如果添加的属性 超出了对象分配的空间，则它们将被保存在常规属性存储中。相较于对象内属性，在properties中的常规属性需要额外多一次 properties 的寻址时间，之后便是与对象内属性一致的线性查找（properties 的属性是有规律的类似数组、链表存放）。虽然属性存储多了一层间接层，但可以自由地扩容。
- 通常，我们将保存在线性数据结构中的属性称之为“【快属性】”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。
- 因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“【慢属性】”策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。
- 实例分析对象在内存中是如何布局的

    - 小于等于10个

        function testObj() {}

		var test10 = new testObj()
		
		for (var i = 0; i < 10; i++) {
		  test10[i+'x'] = 'xxx'
		}

      - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内;
      - 并没有 properties 属性 而是直接保存在对象内的，为了减少查找这些属性查找流程，在对象内直接生成映射，快速查找，但是最多 10 个。

    - 大于 10 个

		function testObj() {}
		
		var test20 = new testObj()
		
		for (var i = 0; i < 20; i++) {
		  test20[i+'x'] = 'xxx'
		}

       - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内，其他常规属性以线性数据结构方式存放在 properties 属性里面;
       - 当对象内属性放满（属性超过了 10 个）之后，会以快属性的方式，在 properties 下按创建顺序存放（0、1...9），注意因为 properties 中只有 10 个属性，所以依然是线性的数据结构，我们可以看其都是按照创建时的顺序来排列的。
       - 相较于对象内属性，快属性需要额外多一次 properties 的寻址时间，之后便是与对象内属性一致的线性查找（properties 的属性是有规律的类似数组、链表存放）

    - 大于 20 个
    
		function testObj() {}
		
		var test50 = new testObj()
		
		for (var i = 0; i < 50; i++) {
		  test50[i+'x'] = 'xxx'
		}

       - 这时候属性的内存布局：10 属性直接存放在 testObj 的对象内;其他常规属性以非线性字典的数据结构方式存放在 properties 属性里面;
       - 我们可以看到，当数据量大起来以后，在 properties 里的属性已经不线性（119、120），而是以非线性的散列表（字典）（哈希-分离链路）形式存储的。
       - 附：分离链路是哈希 key+链表 value 的结构

#### 四、隐藏类 ####

- JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类

1. 为什么静态语言的效率更高?

- 静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。引擎就可以通过这个数据来提前计算好该属性相对于对象地址的偏移值，在后面需要用到该对象的属性时，可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。
- JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。

2. 将静态的特性引入到 V8

- V8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的。
具体地讲，V8 对每个对象做如下两点假设：

  - 对象创建好了之后就不会添加新的属性；
  - 对象创建好了之后也不会删除属性。
  
- 符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：

  - 对象中所包含的所有的属性；
  - 每个属性相对于对象的偏移量。

- 有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。
- 在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类；
- map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。

3. 多个对象共用一个隐藏类

- 在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：

   - 减少隐藏类的创建次数，也间接加速了代码的执行速度；
   - 减少了隐藏类的存储空间。

- 那么，什么情况下两个对象的形状是相同的，要满足以下条件

   - 从相同的起点，以相同的顺序，添加结构相同的属性（除 Value 外，属性的 Attribute 一致）。

     let a = {};
	 a.name = 'thorn1'
	 let b = { name: 'thorn2' }

     上例中a和b的隐藏类不一样，那是因为在创建 b 的对象时，省略了下创建空对象这一步，所以a和b的起点不一样

4. 重新构建隐藏类

- 给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。

5. 对象操作的最佳实践

- 前文我们知道频繁改变对象的属性或属性值的数据类型会导致频道重新构建隐藏类的性能问题，基于此我们可以推测出操作对象的最佳实践。

  - 使用字面量初始化对象时，尽量保证属性的顺序一致。

	// bad
	let point = {x:100,y:200};
	let point2 = {y:100,x:200};
	
	// good
	let point = {x:100,y:200};
	let point2 = {x:100,y:200};
	
	为什么不推荐第一种做法呢？因为两个对象的形状不同，会生成不同的隐藏类。
 
 - 尽量使用字面量一次性初始化完整对象属性。
 
   - 因为每次为对象添加属性时V8都需要为该对象重新设置隐藏类。

 - 避免使用delete方法

  - 同样的，删除对象的属性会导致V8会重新构建隐藏类。


#### 五、内联缓存 ####

- 首先我们来看一个代码片:

	function loadX(o) { 
	    return o.x
	}
	var o = { x: 1,y:3}
	var o1 = { x: 3 ,y:6}
	for (var i = 0; i < 90000; i++) {
	    loadX(o)
	    loadX(o1)
	}

- 我们定义了一个 loadX 函数，它有一个参数 o ，该函数只是返回了 o.x 。
- 通常 V8 获取 o.x 的流程是这样的： 查找对象 **o** 的隐藏类，再通过隐藏类查找 **x** 属性偏移量，然后根据偏移量获取属性值 ，在这段代码中 loadX 函数会被反复执行，那么获取 o.x 流程也需要反复被执行。我们有没有办法再度简化这个查找过程，最好能一步到位查找到 x 的属性值呢？答案是，有的。

- V8通过内联缓存策略压缩这个查找过程，提升对象的查找效率。那什么是内联缓存呢？它具体是怎么工作的呢？
 
   - 内联缓存(Inline Cache)，简称IC。在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。
   
   - 接下来我们以示例代码为例详细看看IC的工作流程：
   
     - IC 会为每个函数维护一个 反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。
     - 代码片中 return o.x 是一个调用点，因为它使用了对象和属性，那么V8会在 loadX 函数的反馈向量中为这个调用点分配一个插槽，每个插槽中包括了插槽的索引 (slot index)、插槽的类型 (type)、插槽的状态 (state)、隐藏类 (map) 的地址、还有属性的偏移量，当V8再次调用 loadX 函数执行到 return o.x 时，它会在对应的插槽中查找 x 属性的偏移量，之后 V8就能直接去内存中获取 o.x 的属性值了，可以大大提升执行效率。

#### 六、多态和超态 ####

- 通过缓存执行过程中的基础信息，就能够提升下次执行函数时的效率，但是这有一个前提，那就是多次执行时，对象的形状是固定的，如果对象的形状不是固定的，那 V8 会怎么处理呢？
- 我们调整一下上面这段 loadX 函数的代码，调整后的代码如下所示：
	
    function loadX(o) { 
	    return o.x
	}
	var o = { x: 1,y:3}
	var o1 = { x: 3, y:6,z:4}
	for (var i = 0; i < 90000; i++) {
	    loadX(o)
	    loadX(o1)
	}

  - 我们可以看到，对象 o 和 o1 的形状是不同的，这意味着 V8 为它们创建的隐藏类也是不同的。
  - 第一次执行时 loadX 时，V8 会将 o 的隐藏类记录在反馈向量中，并记录属性 x 的偏移量。那么当再次调用 loadX 函数时，V8 会取出反馈向量中记录的隐藏类，并和新的 o1 的隐藏类进行比较，发现不是一个隐藏类，那么此时 V8 就无法使用反馈向量中记录的偏移量信息了。
  - 面对这种情况，V8 会选择将新的隐藏类也记录在反馈向量中，同时记录属性值的偏移量，这时，反馈向量中的第一个槽里就包含了两个隐藏类和偏移量。当 V8 再次执行 loadX 函数中的 o.x 语句时，同样会查找反馈向量表，发现第一个槽中记录了两个隐藏类。这时，V8 需要额外做一件事，那就是拿这个新的隐藏类和第一个插槽中的两个隐藏类来一一比较，如果新的隐藏类和第一个插槽中某个隐藏类相同，那么就使用该命中的隐藏类的偏移量。如果没有相同的呢？同样将新的信息添加到反馈向量的第一个插槽中。
  - 一个反馈向量的一个插槽中可以包含多个隐藏类的信息，那么：

     - 如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；
     - 如果一个插槽中包含了 2～4 个隐藏类，那我们称这种状态为多态 (polymorphic)；
     - 如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。

- 如果函数 loadX 的反馈向量中存在多态或者超态的情况，其执行效率肯定要低于单态的，比如当执行到 o.x 的时候，V8 会查询反馈向量的第一个插槽，发现里面有多个 map 的记录，那么 V8 就需要取出 o 的隐藏类，来和插槽中记录的隐藏类一一比较，如果记录的隐藏类越多，那么比较的次数也就越多，这就意味着执行效率越低。
- 所以我们得出一个结论是 尽量保持单态，因为单态的性能优于多态和超态 。


#### 七、在 V8 引擎里 5 个优化代码的技巧 ####

- 对象属性的顺序: 在实例化你的对象属性的时候一定要使用相同的顺序，这样隐藏类和随后的优化代码才能共享；
- 动态属性: 在对象实例化之后再添加属性会强制使得隐藏类变化，并且会减慢为旧隐藏类所优化的代码的执行。所以，要在对象的构造函数中完成所有属性的分配；
- 方法: 重复执行相同的方法会运行的比不同的方法只执行一次要快 (因为内联缓存)；
- 数组: 避免使用 keys 不是递增的数字的稀疏数组，这种 key 值不是递增数字的稀疏数组其实是一个 hash 表。在这种数组中每一个元素的获取都是昂贵的代价。同时，要避免提前申请大数组。最好的做法是随着你的需要慢慢的增大数组。最后，不要删除数组中的元素，因为这会使得 keys 变得稀疏；

