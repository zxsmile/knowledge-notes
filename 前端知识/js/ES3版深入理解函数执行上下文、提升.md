#### 一、词法作用域（静态作用域）和动态作用域 ####

1. 作用域

- 作用域是指程序源代码中定义变量的区域，作用域规定了如何查找变量，也就是当前执行代码对变量的访问权限
- JavaScript采用词法作用域，也叫静态作用域

2. 静态作用域和动态作用域

- 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。
- 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

		var value = 1;
		
		function foo() {
		    console.log(value);
		}
		
		function bar() {
		    var value = 2;
		    foo();
		}
		
		bar();
		
		// 结果是 ???

        上面例子，如果是静态作用域结果就为1，动态作用域结果就为2，原因我们看接下来的分析

3. 作用域链

    - 我们知道在执行一段代码的时候，会创建对应的执行上下文，执行上下文中包含了this、变量对象VO、作用域链。
    
    - 但在创建执行上下文之前，我们还有一个创建作用域链的过程，最后我们的作用域链就是这两个作用域链之和。
    
    - 上面我们讲到函数的作用域在函数定义的时候就已经决定了，这是因为我们的函数有一个内部属性[[scope]]，当函数创建时，就会保存所有的父变量对象到其中。当执行函数时，创建函数的执行上下文，先创建变量对象，然后复制函数[[scope]]属性创建作用域链，将变量对象加到作用域的最前边形成完整作用域链，开始执行函数，随着函数的执行，修改 AO 的属性值。

         例：
			var value = 1;
		
			function foo() {
			    console.log(value);
			}
			
			function bar() {
			    var value = 2;
			    foo();
			}
			
			bar(); // 1

     - 过程分析：

        - （1）foo函数被创建，保存作用域链到内部属性[[scope]]
        
               foo.[[scope]] = [
				    globalContext.VO
				];
        
        - （2）bar函数被创建，保存作用域链到内部属性[[scope]]

               bar.[[scope]] = [
				    globalContext.VO
				];

        - （3）执行bar函数，创建bar函数执行上下文，bar函数执行上下文被压入执行上下文栈

				ECStack = [
				    barContext,
				    globalContext
				];
		
        - （4）barscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

				barContext = {
				    Scope: barscope.[[scope]],
				}

        - （5）第二步：用 arguments 创建变量对象，随后初始化活动对象，加入形参、函数声明、变量声明

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        value: undefined
				    }，
				    Scope: barscope.[[scope]],
				}

        - （6）第三步：将变量对象压入 barscope 作用域链顶端

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        value: undefined
				    },
				    Scope: [VO, [[Scope]]]
				}

       - （7）准备工作做完，开始执行函数，随着函数的执行，函数执行时，变量对象（VO）变为活动对象AO，修改 AO 的属性值

				barContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				        vaule: 2
				    },
				    Scope: [AO, [[Scope]]]
				}

       - （8）执行过程中，遇到foo()，则创建foo的执行上下文将其压入执行上下文栈中，和上边过程一样，复制函数[[scope]]属性创建作用域链

                fooContext = {
				    Scope: fooscope.[[scope]],
				}

       - （9）创建变量对象
 
                fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				    }，
				    Scope: fooscope.[[scope]],
				}

         - （10）将变量对象压入 fooscope 作用域链顶端

				fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        }				   
				    },
				    Scope: [VO, [[Scope]]]
				}

               这块就能看出，foo的作用域链是自己的变量对象+定义foo时的父级作用域链，所以最后结果为1
                
        - （11）准备工作做完，开始执行函数，随着函数的执行，函数执行时，变量对象（VO）变为活动对象AO，修改 AO 的属性值

				fooContext = {
				    VO: {
				        arguments: {
				            length: 0
				        },
				    },
				    Scope: [AO, [[Scope]]]
				}


#### 二、函数执行上下文（EC）####
https://segmentfault.com/a/1190000009041008

- 每当控制器转到ECMScript的可执行代码的时候，就会进入一个执行上下文
- 可执行代码包括：

   - 全局代码：例如加载外部js文件或者本地的<script></script>标签内的代码。全局代码不包括任何函数体内的代码，这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。
      
   - 函数代码：任何一个函数体内的代码，需要注意的是，任何一个函数体的代码是不包括内部函数的代码的

   - Eval代码：eval内部的代码

#### 三、执行环境栈（ECS）####

 - 我们知道js引擎是单线程的，也就是说同一时间只能发生一件事情，其他事情将被放在执行栈中排队等待。
 
 - 所以当浏览器首次载入你的脚本的时候，默认进入全局执行上下文，这时全局上下文就会被推入执行环境栈。如果你在你的全局代码中调用一个函数,这时，你的程序时序将进入被调用的函数，并创建一个新的执行上下文，并将该执行上下文推入执行环境栈的顶部。如果你调用的函数内部又调用了一个内部函数，会重复上述过程。

 - 上述是在一层一层的创建执行上下文的过程，并没有执行代码，该过程中会存在一个变量对象（VO）。
 
 - 先创建完所有的执行上下文之后才开始执行上下文，该过程中会存在一个活动对象（AO）。
 
 - 浏览器总会执行位于栈顶的执行上下文，一旦当前执行上下文函数执行结束，它将从栈顶弹出，并将上下文控制权交给当前栈

#### 四、变量对象（VO）和活动对象（AO）####

 1. 变量对象（VO）

    - js的执行上下文都有一个对象用来存放执行上下文可被访问但是不能被delete的函数标识符、形参、变量声明等，这个对象就叫变量对象（VO），它们会被挂在这个对象上。对象的属性名对应它们的名字，对象的属性值对应它们的值，但这个对象是规范上的或者说是引擎实现上的不可在js环境中访问到的活动对象。

 2. 活动对象（AO）

    - 有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文中的变量对象就会被激活，也就是该上下文中的函数标识符、形参、变量声明等就可以被访问到了。

#### 五、执行上下文建立细节分析 ####

1. 创建阶段（当函数被调用，函数所在的执行上下文被推入执行环境栈中，还未执行函数内部代码）

    - 创建作用域链（Scope Chain）
    - 创建参数、函数和变量
    - 求this的值

      - 我们可以将每个执行上下文抽象成一个对象，这个对象具有三个属性

	          ECObj={
	             scopeChain:{/*变量对象+所有父级执行上下文的变量对象*/}，
	             variableObject:{/*函数 arguments/参数，内部变量和函数声明*/}，
	             this:{}
	          }

2. 执行阶段

   - 初始化变量的值和函数的引用，执行代码

3. 解释器执行代码流程

   - （1）查找调用函数的代码
      
   - （2）执行代码之前，先进入创建执行上下文阶段

          - 初

            - 进入一个新的执行环境之后初始化作用域链，就会创建该环境的作用域链。
            - 作用链的作用是保证执行环境有权访问的所有变量和函数的有序访问。
            - 作用链的前端始终都是当前执行环境的活动对象，作用域链的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境。


          - 创建变量对象（VO）

             - 创建arguments对象，检查上下文
             - 初始化参数名称和值并创建引用的复制
             - 扫描上下文的函数声明（而非函数表达式）

                - 为发现的每一个函数，在变量对象上创建一个属性，属性名字为函数名字，其有一个指向函数在内存中的引用
                - 如果有和函数名字相同的属性已经存在，则就不用新建函数名字的属性了，直接覆盖该属性
                
              - 扫描上下文的变量声明

                 - 为发现的每个变量声明，在变量对象上创建一个属性，属性名字为变量的名字，并且将变量的值初始化为undefined
                 - 如果有和变量名字相同的属性已经存在，将不会进行任何操作并继续扫描（注意和函数声明的区别）

          - 求出上下文内部的this值

   - （3）激活/代码执行阶段

          - 在当前上下文上运行/解释函数代码，并随着代码一行行执行为变量赋值

			     例如：function foo(i){
			            var a = 'hello'
			            var b = function(){}
			            function c(){}
			          }
			
			          foo(22)

    
          - 当我们调用foo(22)时，先进入创建执行上下文阶段(VO初始化阶段)

    
			         ECObj={
			           scopeChain:{...},
			           variableObject:{
			             arguments:{
			                0:22,
			                length:1
			             },
			             i:22,
			             c:pointer to function c(),
			             a:undefined,
			             b:undefined
			           },
			           this:{...}
			         }
 
         - 正如上述过程所述：VO的初始化过程是有顺序的：形参->函数声明->变量声明


              - 形参：变量对象的一个属性，其属性名为形参的名字，属性值为实参的值，如果没有传递参数，其值为undefined
              - 函数声明：变量对象的一个属性，其属性名和属性值都是函数对象创建出来的，如果变量对象已经包含了相同名字的属性，则替换它的值

		                例：function foo1(a){
		                     console.log(a)
		                     function a(){}
		                   }
		
		                   foo1(20) //'function a(){}'

              - 变量声明：变量对象的一个属性，其属性名即如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性

		                例1：function foo2(a){
		                      console.log(a)
		                      var a = 10  
		                    }
		              
		                    foo2(20) //'20'
		
		                例2：function foo2(){
		                      console.log(a)
		                      var a = 10  
		                      function a(){}
		                    }
		              
		                    foo2(20) //'function a(){}'

              - 函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值

			                例1：function foo3(a){
			                      var a = 10  
			                      function a(){}
			                      console.log(a)
			                    }
			               
			                    foo3(20) //'10'
			
			                
			                例2：function foo3(a){
			                      var a
			                      function a(){}
			                      console.log(a)
			                    }
			               
			                    foo3(20) //'function a(){}'


       - （4） 然后是执行阶段（AO）

            - 正如上面过程所述，创建的过程仅负责处理定义属性的名字，而并不为他们指派具体的值，当然还有对形参/实参的处理。一旦创建阶段完成，执行流进入函数并且激活/代码执行阶段，看下面函数执行完成后的样子：

                          ECObj={
				           scopeChain:{...},
				           variableObject:{
				             arguments:{
				                0:22,
				                length:1
				             },
				             i:22,
				             c:pointer to function c(),
				             a:'hello',
				             b:pointer to function privateB()
				           },
				           this:{...}
				         }


#### 六、总结 ####

  1. 函数作用域链分为两部分，[[scope]]中的作用域链+变量对象
  1. EC分为两个阶段。创建执行上下文和执行代码
  2. 每个EC都可以抽离成一个对象，这个对象具有三个属性，分别为：作用域链Scope，VO/AO（VO和AO只能有一个）以及this
  3. 函数EC中的AO在进入函数EC时，确定了arguments对象的属性，在执行函数EC时，其他变量属性具体化
  4. EC创建过程是有先后顺序的：参数声明 > 函数声明 > 变量声明
              