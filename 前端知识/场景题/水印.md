# 一、明水印和暗水印的区别

前端水印可以分为明水印和暗水印两种类型。它们的区别如下:

**明水印：**明水印是通过在文本或图像上覆盖另一层图像或文字来实现的。这种水印会明显地出现在页面上，可以用来显示版权信息或其他相关信息。

**暗水印：**暗水印是指在文本或图像中隐藏相关信息的一种技术。这种水印不会直接出现在页面上，只有在特殊的程序或工具下才能被检测到。暗水印通常用于保护敏感信息以及追踪网页内容的来源和版本。

# 二、添加明水印手段有哪些

**1、重复的`dom`元素覆盖实现：**在页面上覆盖一个`position:fixed`的`div`盒子，盒子透明度设置较低，设置`pointer-events: none;`样式实现点击穿透，在这个盒子内通过js循环生成小的水印`div`，每个水印`div`内展示一个要显示的水印内容。

**2、`canvas`输出背景图：**绘制出一个水印区域，将这个水印通过`toDataURL`方法输出为一个图片，将这个图片设置为盒子的背景图，通过`backgroud-repeat:repeat;`样式实现填满整个屏幕的效果。

**3、`svg`实现背景图：**与`canvas`生成背景图的方法类似，只不过是生成背景图的方法换成了通过`svg`生成

**4、图片加水印**

# 三、具体实现思路

## 1、重复的`dom`元素覆盖实现

创建一个遮罩容器 根据可视容器的宽度和高度计算需要多少个小水印 可以动态生成水印内容

缺点重复生成 `dom`，不是很优雅

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<style>
    #watermark-box {
        width: 100%;
        height: 100vh;
        position: absolute;
        z-index: -1;
        top: 0;
        left: 0;
        display: flex;
        flex-wrap: wrap;
        padding: 0;
        margin: 0;
    }

    .watermark-item {
        transform: rotate(-30deg);
        opacity: 0.2;
    }
</style>

<body>
    <div id="watermark-box"></div>
    <div>我是正文我是正文我是正文我是正文我是正文我是正文我是正文我是正文我是正文我是正文</div>
</body>

<script>
    function initWaterMark(text,el) {
        const waterHeight = 100
        const waterWidth = 100
        const { clientWidth, clientHeight } =
            document.documentElement || document.body
        const column = Math.ceil(clientWidth / waterWidth)
        const rows = Math.ceil(clientHeight / waterHeight)
        for (let i = 0; i < column * rows; i++) {
            const wrap = document.createElement('div')
            wrap.setAttribute('class', 'watermark-item')
            wrap.style.width = waterWidth + 'px'
            wrap.style.height = waterHeight + 'px'
            wrap.textContent = text
            el.appendChild(wrap)
        }
    }
    window.onload = () => {
        const el = document.getElementById("watermark-box")
        initWaterMark('测试水印',el)
    }
</script>

</html>

```

![cj11](.\images\cj11.png)

## 2、`Canvas`绘制水印

#### 实现的思路

通过`Canvas`绘制水印的思路并不复杂，通过以下几步就可以简单实现

1. 提供一个父级容器，限定水印的展示范围
2. 创建一个水印元素，用于盛装水印
3. 通过`Canvas`元素创建一个画布，并绘制水印文本，生成水印图片，
4. 将水印图片作为水印元素的背景，并将水印元素添加到父级容器中

#### 具体实现

##### (一) 创建父级容器

一般情况下都是以`body`作为父级容器，有时也会出现特殊情况，比如局部水印，这时候需要自己创建一个父级容器。

```html
<!--创建一个div作为父级容器-->
<div id="water-mark"></div>
```

##### (二) 创建水印元素

创建水印元素，并给其设置对应的样式

```javascript
function cerateWatermark(){
  //获取父元素，用于包裹水印
  let parentEl = document.getElementById("water-mark");
  //设置父元素的定位为相对定位
  parentEl.style.position = "relative";

  //创建水印元素
  const waterMarkEl = document.createElement("div");
  //水印元素不会成为鼠标事件的target
  waterMarkEl.style.pointerEvents = "none";
  //设置与父级容器的定位
  waterMarkEl.style.top = "0";
  waterMarkEl.style.left = "0";
  //设置水印元素定位 为绝对定位
  waterMarkEl.style.position = "absolute";
  waterMarkEl.style.zIndex = "99999";

  //获取父元素的宽高，水印元素与其保持一致
  const {clientWidth,clientHeight} = parentEl;
  waterMarkEl.style.width = `${clientWidth}px`;
  waterMarkEl.style.height = `${clientHeight}px`;
}
```

##### (三) 创建画布

```javascript
// 设置水印文本的基本配置
const defaultConfig = {
    /** 文本颜色 */
    color: "#c0c4cc",
    /** 文本透明度 */
    opacity: 0.5,
    /** 文本字体大小 */
    size: 16,
    /** 文本字体 */
    family: "serif",
    /** 文本倾斜角度 */
    angle: -20,
    /** 一处水印所占宽度（数值越大水印密度越低） */
    width: 300,
    /** 一处水印所占高度（数值越大水印密度越低） */
    height: 200,
    /** 水印文本，暂时放到这里，一般会提取出来将其作为一个全局变量*/
    backupText:"水印文本"
}

function createBase64(){
    // 解构配置
    const {color,opacity,size,family,angle,width,height，backupText} = defaultConfig;
    // 创建一个画布
    const canvasEl = document.createElement("canvas");
    //设置宽高
    canvasEl.width = width;
    canvasEl.height = height;

    //创建 context 对象，getContext("2d") 对象是内建的 HTML5 对象，
    //拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法

    const ctx = canvasEl.getContext("2d");
    if(ctx){
        // 设置颜色
        ctx.fillStyle = color;
        // 设置透明度
        ctx.globalAlpha = opacity;
        //设置字体
        ctx.font = `${size}px ${family}`;
        //设置倾斜度
        ctx.rotate((Math.PI/180)\*angle);
        //设置水印文本
        ctx.fillText(backupText,0,height/2);
    }
    return canvasEl.toDataURL()
}
```

##### (四) 将水印元素添加进容器

```javascript
function cerateWatermark(){
  ...
  //设置水印元素的背景
  waterMarkEl.style.background = `url(${createBase64()}) left top repeat`;
  // 将水印元素 添加进容器
  parentEl.appendChild(waterMarkEl)
}
```

#### 基本实现效果

![cj10](.\images\cj10.png)

# 四、水印防御机制

上面只是实现了最基本的水印功能，还有很多问题需要解决。类似水印被删除或隐藏的情况。

![cj12](.\images\cj12.png)

![cj13](.\images\cj13.png)

在上面的例子中，我们创建了一个`div`作为水印元素，并将生成的水印图片作为其背景图片，如果直接在控制台将`div`元素删除或隐藏，对应的水印也会消失。

## `MutationObserver`

为了避免出现这种情况，可以使用`MutationObserver` 监听器 来监听父级容器和水印元素的变化。

`MutationObserver` 提供了监视对 `DOM` 树所做更改的能力，任何对`DOM`树做更改的操作都会被其监听到，因此当监听到水印元素或父级容器被删除或修改时可以在其回调函数中重新绘制。

## 实现过程

根据上面的思路，可以分为以下几步来完成

1. 创建监听器
2. 给监听器赋值并传入回调函数
3. 启动监听

```javascript
//将父级容器 和水印元素 提升为全局变量
let parentEl = undefined;
let waterMarkEl = undefined;

//设置监听器
const observer = {
  watermarkElMutationObserver: undefined,
  parentElMutationObserver: undefined,
}

  //创建水印
function createWatermark(){
  //获取父元素，用于包裹水印
  // let parentEl = document.getElementById("water-mark");
  parentEl = document.getElementById("water-mark");
  ...

  //创建水印元素
  // const waterMarkEl = document.createElement("div");
  waterMarkEl = document.createElement("div");
  ...

  // 监听水印元素和容器元素
  addMutationListener(parentEl);
}

// 添加监听器
function addMutationListener(targetNode){
  console.log('--监听器--',targetNode);
  
  const mutationCallback = (mutationList)=>{
    //水印的防御 (防止用户手动删除水印或通过css隐藏水印)
    console.log('--回调函数--',mutationList)
    mutationList.forEach(mutation => {
      switch (mutation.type) {
          case "childList":
              mutation.removedNodes.forEach((item)=>{
                  item === waterMarkEl && targetNode.appendChild(waterMarkEl);
              });
              break;
      }
    });
  }

  //创建观察器实例并传入回调
  observer.watermarkElMutationObserver = new MutationObserver(mutationCallback);
  observer.parentElMutationObserver = new MutationObserver(mutationCallback);

  //以上述配置 启动水印元素监听器，开始观察目标节点
  observer.watermarkElMutationObserver.observe(waterMarkEl,{
      // 观察目标节点属性是否变动，默认为 true
      attributes:true,
      // 观察目标子节点是否有添加或者删除，默认为 false
      childList:true,
      // 是否拓展到观察所有后代节点，默认为 false
      subtree:true
  })
  // 启动父级容器 监听器，
  observer.parentElMutationObserver.observe(targetNode,{
      attributes:true,
      childList:true,
      subtree:true
  })
}
```

## 结果展示

![cj14](.\images\cj14.png)

如上图所示，删除了子节点后水印仍然展示。 

## 完整代码

![cj15](.\images\cj15.png)