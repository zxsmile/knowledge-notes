## 一、需求（问题）描述

- 为节省资源将多个服务单元合并为一个服务，但个项目还是呈现独立状态。

## 二、方案构思

- 新建一个vue项目作为最外层的包裹项目，需要合并的项目作为该项目的子项目，最后将各个子项目打包到dist的不同目录中相互独立，通过不同的路由去访问各个子项目。

## 三、实践过程

#### 1、新建packages文件夹，存放所有子项目。

![project1](..\images\project1.png)

#### 2、package.json

**（1）增加workspaces字段可以直接在最外层的vue项目上执行npm install命令下载所有子项目的依赖**

- 理解
  - 项目的工作区配置，用于在本地的根目录下管理多个子项目。可以自动地在 npm install 时将 workspaces 下面的包，软链到根目录的 node_modules 中，不用手动执行 `npm link` 操作。

  - workspaces 字段接收一个数组，数组里可以是文件夹名称或者通配符。比如：

    ```
    "workspaces": [
      "workspace-a"
    ]
    ```

  - 表示在 workspace-a 目录下还有一个项目，它也有自己的 package.json。

    ```
    package.json
    workspace-a
      └── package.json
    ```

  - 通常子项目都会平铺管理在 packages 目录下，所以根目录下 workspaces 通常配置为：

    ```
    "workspaces": [
      "packages/*"
    ]
    ```

- 增加workspaces参数，它的作用是可以直接在最外层的vue项目上执行npm install命令下载所有子项目的依赖，但这个配置项的node要求为16+，因为我们当前项目的node为14.15.1，所以我在最外层直接执行npm install报错了，使用npm install -- legacy-peer-deps 命令可以成功下载依赖。

  - npm 从**版本v7**开始，install就默认以peerDependencies的方式去下载了：-
    - 如果用户在根目录的package.json文件里显式依赖了核心库，那么各个子项目里的peerDepenedencies声明（**和根目录一样的核心库，但版本不一定一样**）就可以忽略
    - 如果用户没有显式依赖核心库，那么就按照子项目的peerDepenedencies中声明的版本将依赖安装到项目根目录里
  - 而方式2就会导致一个问题：用户依赖的包版本与各个子项目依赖的包版本相互不兼容，那么就会报错（无法解析依赖树的问题（依赖冲突））让用户自行去修复，因而导致安装过程的中断。（因为是从npm v7引入的，因此npm v3-v6就不会发生这个错误）
  - npm install xxxx --legacy-peer-deps命令用于绕过peerDependency里依赖的自动安装；它告诉npm忽略项目中引入的各个依赖模块之间依赖相同但版本不同的问题，以npm v3-v6的方式去继续执行安装操作，保证各个引入的依赖之间对自身所使用的不同版本modules共存。
  - 注：在NPM v7中，现在默认安装peerDependencies。在很多情况下，这会导致版本冲突，从而中断安装过程。
  - 所以其实该命令并没有真的解决冲突，而是忽略了冲突，以“过时”（v3-v6）的方式进行下载操作。
  

**（2）修改script字段**

- 在该文件中的script字段里面配置构建脚本，使用PROJECT_NAME变量来区分构建的是那个子项目。

  ![project2](..\images\project2.png)

- `process.en`v属性返回一个包含用户环境信息的对象，在scripts中可以配置环境变量，通过`process.env.变量名` 来访问。

- **在scripts命令中注入的NODE_ENV只能被webpack的构建脚本访问，而被webpack打包的源码中是无法访问到的**，此时可以借助webpack的DefinePlugin插件，创建全局变量。

  ```
  const webpack = require('webpack');
  module.exports = {
      plugins: [
          new webpack.DefinePlugin({
          'process.env.NODE_ENV': '"development"'
          })
      ]
  }
  ```

-  当然DefinePlugin不仅仅可以定义process.env.NODE_ENV，你也可以根据自己的需要定义其他的全局变量。定义完成之后，就可以在项目代码中直接使用了。
       
-  所以就解决了上面的疑问，在**写 Vue 项目时，在客户端侧代码中，只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中，你才可以在应用的代码中访问它们**；当然，还有两个特殊的变量也可以在应用中访问：NODE_ENV 和 BASE_URL；同样在 React 应用中，除了一些内置变量（ NODE_ENV 和 PUBLIC_URL ）之外，变量名必须以 REACT_APP_ 开头才能使用。

####    跨平台的cross-env

 - 在window平台下直接设置NODE_ENV =XXX是会报错的，cross-env 能够提供一个设置环境变量的scripts，这样我们就能够以unix方式设 置环境变量，然后在windows上也能够兼容。

- 安装cross-env

  ```
  npm install cross-env --save
  ```

- 在NODE_ENV=XXX前面添加cross-env。

  ```
  "scripts": {
          "dev": "cross-env NODE_ENV=devlll NAME=222 vue-cli-service serve",
      }
  ```

- 这种写法就是在scripts中给process.env注入NODE_ENV和NAME属性，值分别为myDev和222，这个时候在vue.config.js打印process.env，重启服务在命令行中可以看到多了NODE_ENV和NAME属性。



3.vue.config.js

外部vue.config.js中配置，分别读取不同



## 四、实践过程中的问题

1、最外层的vue项目中执行npm i 报错，依赖冲突

  使用npm install xxxx --legacy-peer-deps解决

2.