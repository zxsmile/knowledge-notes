> **“每个子项目自己负责构建，外层仅通过脚本依次调用各项目的构建命令”**

同时融入了前面提到的关键优化点：**自动发现项目、并发控制、增量构建、结构化日志、错误处理、CLI 支持**。

## 📁 推荐目录结构

```
my-monorepo/
├── projects/                  # 子项目目录
│   ├── blog/
│   └── admin/
├── scripts/
│   └── build.js               # ← 主脚本（JavaScript 版）
└── package.json
```

```
// scripts/build.js
//
// 【用途】
// 本脚本是一个“外层调度器”，用于在 Monorepo（多项目仓库）中依次或并发地调用各个子项目的构建命令。
// 它不参与任何实际构建逻辑，只负责：
//   1. 发现子项目
//   2. 决定哪些项目需要构建（全量 or 增量）
//   3. 按配置并发执行每个项目的 `npm run build`（或 yarn/pnpm）
//   4. 统一日志、错误处理和退出码
//
// 【设计理念】
// - 子项目完全独立：每个项目有自己的 package.json、依赖、构建脚本，互不影响
// - 外层无侵入：子项目无需知道此脚本存在，也无需安装额外依赖
// - 安全可靠：环境隔离、错误可控、支持 CI/CD 集成

const { execSync, spawn } = require('child_process'); // 用于执行外部命令（如 git、npm）
const { existsSync, readdirSync, statSync } = require('fs'); // 文件系统操作 API
const { join, resolve, sep } = require('path'); // 路径拼接与标准化（兼容 Windows/macOS/Linux）
const { performance } = require('perf_hooks'); // 高精度计时器，用于测量构建耗时
const { Command } = require('commander'); // 行业标准 CLI 参数解析库（由 Git 团队维护）
const chalk = require('chalk'); // 输出带颜色的日志，提升可读性（尤其在 CI 日志中）

// ============================================================================
// 工具函数区：提供基础能力封装
// ============================================================================

/**

 * 判断一个路径是否存在且是一个目录
   *
 * 【为什么需要？】
 * 在扫描 projects/ 目录时，可能包含非目录文件（如 .DS_Store、README.md），
 * 必须过滤掉这些无效项，避免误判为项目。
   *
 * @param {string} dirPath - 待检查的路径（相对或绝对）
 * @returns {boolean} true 表示是有效目录，false 表示不存在或不是目录
   */
   function isDirectory(dirPath) {
     try {
   // statSync 同步获取文件状态；isDirectory() 判断是否为目录
   return statSync(dirPath).isDirectory();
     } catch (error) {
   // 如果路径不存在、权限不足等，statSync 会抛异常，此时视为“非目录”
   return false;
     }
   }

/**

 * 自动发现所有子项目
   *
 * 【约定】
 * - 所有子项目必须放在根目录下的 `projects/` 文件夹中
 * - 每个子项目必须是一个目录，且包含 `package.json`
     *
 * 【优势】
 * - 新增项目只需放入 projects/ 并添加 package.json，无需修改本脚本
 * - 避免硬编码项目列表，提升可维护性
     *
 * @param {string} rootDir - 子项目根目录，默认为 'projects'
 * @returns {Array<{ name: string, path: string }>} 返回项目信息数组
 * - name: 项目文件夹名（如 "blog"）
 * - path: 项目绝对路径（如 "/Users/xxx/my-monorepo/projects/blog"）
     */
     function discoverProjects(rootDir = 'projects') {
     // 将相对路径转为绝对路径，避免后续路径拼接出错
     const root = resolve(rootDir);

  // 校验 projects/ 目录是否存在
  if (!existsSync(root) || !isDirectory(root)) {
    throw new Error(`❌ 子项目根目录未找到: ${root}\n请确保存在 projects/ 文件夹`);
  }

  // 读取 projects/ 下所有条目（包括文件和目录），withFileTypes 提供类型信息
  const items = readdirSync(root, { withFileTypes: true });

  // 过滤并映射为标准项目对象
  const projectDirs = items
    .filter(item => item.isDirectory()) // 只保留目录（排除 .gitignore 等文件）
    .map(item => ({
      name: item.name, // 项目名 = 文件夹名
      path: join(root, item.name) // 拼接完整路径
    }))
    .filter(proj => {
      // 进一步校验：必须包含 package.json（这是 Node.js 项目的标志）
      const pkgPath = join(proj.path, 'package.json');
      return existsSync(pkgPath);
    });

  // 友好提示：如果没有找到项目
  if (projectDirs.length === 0) {
    console.warn(
      '⚠️  警告：在 projects/ 目录下未找到任何包含 package.json 的子项目。\n' +
      '   请检查：\n' +
      '     - 是否已创建 projects/ 目录？\n' +
      '     - 子项目是否包含 package.json？'
    );
  }

  return projectDirs;
}

/**

 * 自动识别子项目使用的包管理器
   *
 * 【背景】
 * 不同团队/项目可能使用 npm / yarn / pnpm，需自动适配。
   *
 * 【判断依据】（按优先级）
 * 1. 存在 pnpm-lock.yaml → 使用 pnpm
 * 2. 存在 yarn.lock → 使用 yarn
 * 3. 否则默认使用 npm
      *
 * 【注意】
 * 此逻辑假设项目已提交 lockfile（最佳实践），否则可能误判。
   *
 * @param {string} cwd - 子项目工作目录
 * @returns {'pnpm' | 'yarn' | 'npm'} 包管理器名称
   */
   function getPackageManager(cwd) {
     const dir = resolve(cwd);
     if (existsSync(join(dir, 'pnpm-lock.yaml'))) return 'pnpm';
     if (existsSync(join(dir, 'yarn.lock'))) return 'yarn';
     return 'npm'; // 最通用的 fallback
   }

/**

 * 执行 shell 命令（如 `npm install`、`pnpm run build`）
   *

 * 【关键设计】

 * - 使用 spawn 而非 exec：支持流式输出（实时看到子项目日志）

 * - 支持 silent 模式：用于内部命令（如 git diff）不污染主日志

 * - 清理环境变量：防止外层变量（如 VITE_API_URL）意外注入子项目
     *

 * @param {string} command - 要执行的完整命令字符串（如 "npm run build"）

 * @param {string} cwd - 工作目录（子项目路径）

 * @param {{silent?: boolean}} [options] - 配置选项

 * @returns {Promise<void>} 成功 resolve，失败 reject
   */
   function runCommand(command, cwd, { silent = false } = {}) {
     return new Promise((resolve, reject) => {
   // 拆分命令：例如 "npm run build" → bin="npm", args=["run", "build"]
   // 注意：简单 split(' ') 在复杂命令中可能出错，但本场景足够安全
   const [bin, ...args] = command.split(' ');

   // 启动子进程
   const child = spawn(bin, args, {
     cwd: resolve(cwd), // 设置子进程的工作目录
     stdio: silent ? 'pipe' : 'inherit', // 是否将子进程 stdout/stderr 接到主进程
     shell: true, // 使用系统 shell（兼容 Windows 的 cmd.exe / PowerShell）
     env: {
       ...process.env, // 继承当前环境变量
       // 清理前端框架专用变量，避免跨项目污染
       // 例如：外层设置了 NEXT_PUBLIC_API，不应影响 Vue 项目
       VITE_: undefined,
       NEXT_: undefined,
       NUXT_: undefined,
       // 可根据团队需要扩展更多前缀
     }
   });

   let stderr = '';
   if (silent) {
     // 在 silent 模式下，收集 stderr 用于错误报告
     child.stderr?.on('data', chunk => {
       stderr += chunk.toString();
     });
   }

   // 监听子进程退出
   child.on('close', (code) => {
     if (code === 0) {
       // 退出码 0 表示成功
       resolve();
     } else {
       // 构建失败：构造友好错误信息
       const errorMsg = silent
         ? `命令执行失败: ${command}\n错误详情:\n${stderr}`
         : `命令执行失败: ${command}`;
       reject(new Error(errorMsg));
     }
   });

   // （可选）监听启动错误（如命令不存在）
   child.on('error', (err) => {
     reject(new Error(`无法启动命令 "${command}": ${err.message}`));
   });
     });
   }

/**

 * 获取 Git 中相对于基准提交有变更的文件列表
   *
 * 【用途】
 * 实现“增量构建”：只构建代码有变动的子项目，大幅提升 CI 效率。
   *
 * 【原理】
 * 使用 `git diff --name-only HEAD~1 HEAD` 获取上次提交以来修改的文件路径。
   *
 * 【注意事项】
 * - 要求工作区是 Git 仓库，且至少有两次提交（否则 HEAD~1 不存在）
 * - 在 CI 中需确保 checkout 时 fetch-depth 足够（如 GitHub Actions 需设 fetch-depth: 0）
     *
 * @param {string} baseRef - 对比的基准引用，默认为 "HEAD~1"（上一次提交）
 * @returns {string[]} 变更的文件路径数组（如 ["projects/blog/src/App.vue", ...]）
   */
   function getChangedFiles(baseRef = 'HEAD~1') {
     try {
   // 执行 git 命令，获取纯文件名列表
   const output = execSync(`git diff --name-only ${baseRef} HEAD`, {
     encoding: 'utf-8', // 返回字符串而非 Buffer
     stdio: 'pipe' // 隐藏命令本身的输出
   });
   // 按换行分割，并过滤空行
   return output.trim().split('\n').filter(line => line.length > 0);
     } catch (e) {
   // 常见失败原因：
   //   - 不在 Git 仓库中
   //   - 仓库为空（无提交）
   //   - CI 中未拉取完整历史
   console.warn(
     '⚠️  无法获取 Git 变更记录（可能原因：非 Git 仓库、首次提交、CI 未拉全历史）\n' +
     '   将回退到全量构建所有项目。'
   );
   return []; // 返回空数组表示“无法判断变更”，触发全量构建
     }
   }

/**

 * 并发执行多个异步任务，但限制最大并发数量
   *
 * 【为什么需要？】
 * 如果同时构建 10 个项目，可能耗尽内存或 CPU，导致构建变慢甚至失败。
 * 通过控制并发数（如 4），平衡速度与稳定性。
   *
 * 【实现机制】
 * - 维护一个“正在执行”的 Promise 列表
 * - 当达到 maxConcurrency 时，等待任意一个任务完成（Promise.race）
 * - 任务完成后从列表中移除，腾出“槽位”
     *
 * @param {Array<() => Promise<any>>} tasks - 任务函数数组（每个返回 Promise）
 * @param {number} maxConcurrency - 最大并发数（建议 2~6，根据机器性能调整）
 * @returns {Promise<any[]>} 所有任务的结果（顺序与输入一致）
   */
   async function runConcurrent(tasks, maxConcurrency) {
     const results = [];
     const executing = []; // 存储当前正在运行的 Promise

  for (const task of tasks) {
    // 包装任务：捕获结果或错误，并在完成后清理 executing 列表
    const promise = task()
      .then(res => results.push(res)) // 成功：收集结果
      .catch(() => {
        /* 错误已在 task 内部处理（如打印日志），此处不中断流程 */
      })
      .finally(() => {
        // 任务结束（无论成功失败），从 executing 中移除自身
        const index = executing.indexOf(promise);
        if (index > -1) {
          executing.splice(index, 1);
        }
      });

    // 将新任务加入执行队列
    executing.push(promise);

    // 如果当前并发数已达上限，等待任一任务完成
    if (executing.length >= maxConcurrency) {
      await Promise.race(executing); // race 返回第一个完成的 Promise
    }
  }

  // 等待剩余所有任务完成
  await Promise.all(executing);
  return results;
}

// ============================================================================
// 核心业务逻辑区：构建单个项目 & 主流程
// ============================================================================

/**

 * 构建单个子项目
   *
 * 【步骤】
 * 1. 打印开始日志
 * 2. （Dry-run 模式）仅预览命令
 * 3. 安装依赖（使用 --frozen-lockfile 确保一致性）
 * 4. 执行构建命令（package.json 中的 "build" 脚本）
 * 5. 记录耗时并打印结果
      *
 * @param {{name: string, path: string}} project - 项目信息
 * @param {Object} opts - 构建选项（来自 CLI）
 * - dryRun: 是否为预演模式
 * - continueOnError: 失败是否继续
     */
     async function buildProject(project, opts) {
     const start = performance.now(); // 高精度开始时间（单位：毫秒）
     const pm = getPackageManager(project.path); // 自动识别包管理器
     const buildCmd = `${pm} run build`; // 构建命令

  // 打印项目开始构建日志（蓝色标识）
  console.log(`\n📦 ${chalk.blue('[Build]')} 正在构建项目: ${chalk.bold(project.name)}`);

  // Dry-run 模式：只打印命令，不实际执行（用于调试或 CI 预检）
  if (opts.dryRun) {
    console.log(`  [DRY-RUN] cd ${project.path} && ${buildCmd}`);
    return; // 提前退出
  }

  try {
    // 第一步：安装依赖
    // --frozen-lockfile：确保 lockfile 未被修改（pnpm/yarn 支持，npm 会忽略）
    // 这能防止因依赖漂移导致的构建不一致
    await runCommand(`${pm} install --frozen-lockfile`, project.path);

    // 第二步：执行构建
    // 子项目必须在 package.json 中定义 "scripts": { "build": "..." }
    await runCommand(buildCmd, project.path);

    // 构建成功：计算耗时并打印绿色成功日志
    const duration = ((performance.now() - start) / 1000).toFixed(1); // 转为秒，保留1位小数
    console.log(
      `✅ ${chalk.green('[Success]')} ${chalk.bold(project.name)} 构建成功 (${duration}s)`
    );
  } catch (err) {
    // 构建失败：打印红色错误日志
    console.error(
      `❌ ${chalk.red('[Failed]')} ${chalk.bold(project.name)}: ${err.message}`
    );

    // 如果配置为“失败即停”，立即终止整个脚本（退出码 1）
    if (!opts.continueOnError) {
      console.error(chalk.red('\n🛑 配置为失败即停，构建流程已终止。'));
      process.exit(1);
    }

    // 抛出错误，供并发控制逻辑统计失败次数（虽然此处不使用）
    throw err;
  }
}

/**

 * 主构建流程：协调发现、筛选、并发执行
   *
 * @param {Object} opts - 用户传入的选项
   */
   async function main(opts) {
     // 步骤 1：自动发现所有子项目
     const allProjects = discoverProjects();
     if (allProjects.length === 0) {
   console.log('📭 未发现任何子项目，构建流程结束。');
   return;
     }

  // 默认构建所有项目
  let projectsToBuild = allProjects;

  // 步骤 2：如果启用 --changed，进行增量构建筛选
  if (opts.changedOnly) {
    console.log('🔍 启用增量构建：正在检测 Git 变更...');
    const changedFiles = getChangedFiles();

    if (changedFiles.length > 0) {
      // 将项目路径标准化为正斜杠（兼容 Windows 的反斜杠路径）
      // 因为 git diff 输出始终是正斜杠（即使在 Windows）
      const normalizedProjectPaths = allProjects.map(p =>
        p.path.replace(/\\/g, '/') + '/' // 确保以 / 结尾，避免部分匹配
      );

      // 筛选：只要有一个变更文件属于该项目目录，就纳入构建
      projectsToBuild = allProjects.filter((proj, index) =>
        changedFiles.some(file => file.startsWith(normalizedProjectPaths[index]))
      );

      // 打印增量构建范围
      const projectNames = projectsToBuild.map(p => p.name);
      console.log(
        `📊 检测到 ${changedFiles.length} 个文件变更，涉及项目: ${
          projectNames.length > 0 ? projectNames.join(', ') : '无'
        }`
      );
    } else {
      console.log('📭 未检测到任何文件变更，跳过构建。');
      return;
    }
  }

  // 步骤 3：若无可构建项目，提前退出
  if (projectsToBuild.length === 0) {
    console.log('✅ 无项目需要构建，流程结束。');
    return;
  }

  // 步骤 4：打印构建概览
  console.log(
    `\n🚀 即将构建 ${projectsToBuild.length} 个项目: ${projectsToBuild.map(p => p.name).join(', ')}`
  );

  // Dry-run 模式全局提示
  if (opts.dryRun) {
    console.log(chalk.yellow('\n=== 🧪 DRY RUN 模式（仅预览命令，不会实际执行）==='));
  }

  // 步骤 5：并发构建
  // 为每个项目创建一个“任务函数”，延迟执行（避免立即启动）
  const tasks = projectsToBuild.map(proj => () => buildProject(proj, opts));
  await runConcurrent(tasks, opts.concurrency || 4);

  // 全部完成
  console.log(`\n🎉 ${chalk.green('所有项目构建完成！')}`);
}

// ============================================================================
// CLI 命令行接口：用户交互入口
// ============================================================================

// 创建 commander 实例
const program = new Command();

program
  .name('build') // 命令名
  .description('Monorepo 聚合构建工具 —— 一键构建多个独立子项目')
  // 定义命令行选项
  .option('-c, --changed', '【增量构建】仅构建有 Git 代码变更的项目（推荐用于 CI）')
  .option('--concurrency <num>', '【并发控制】最大同时构建项目数', '4')
  .option('--continue-on-error', '【容错模式】某个项目失败时，继续构建其他项目')
  .option('--dry-run', '【预演模式】只打印将执行的命令，不实际运行（用于调试）')
  // 当用户执行命令时触发的回调
  .action((cmdOpts) => {
    // 解析并校验参数
    const options = {
      changedOnly: !!cmdOpts.changed, // 转为布尔值
      concurrency: parseInt(cmdOpts.concurrency, 10) || 4, // 转数字，兜底为 4
      continueOnError: !!cmdOpts.continueOnError,
      dryRun: !!cmdOpts.dryRun
    };

    // 启动主流程，并捕获未处理的异常（如文件不存在）
    main(options).catch(err => {
      console.error(chalk.red('\n💥 构建流程发生未预期错误:'), err.message);
      console.error(chalk.gray(err.stack)); // 打印堆栈便于调试
      process.exit(1); // 退出码 1 表示失败（CI 会失败）
    });
  });

// 解析 process.argv 并执行对应逻辑
program.parse();
```



# 二、使用

```
# 全量构建（默认）
npm run build

# 增量构建（推荐 CI 使用）
npm run build -- --changed

# 高并发 + 容错
npm run build -- --concurrency 6 --continue-on-error

# 预演调试
npm run build -- --dry-run --changed
```

#  三、总结：这份脚本的价值

| 特性         | 说明                                   |
| ------------ | -------------------------------------- |
| **零侵入**   | 子项目完全 unaware，可独立开发/部署    |
| **自动发现** | 新项目自动纳入构建，无需改脚本         |
| **增量构建** | 节省 CI 时间，提升研发效率             |
| **并发控制** | 防止资源耗尽，稳定可靠                 |
| **环境隔离** | 避免变量污染，构建结果可重现           |
| **专业日志** | 彩色输出、耗时统计、错误定位清晰       |
| **CI 友好**  | 退出码正确、支持 dry-run、兼容主流平台 |