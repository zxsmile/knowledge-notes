## 一、回答

我们原来有五六个前端子项目，每个都独立部署在容器平台上，占用独立的服务单元和资源，不仅资源成本高，每次上线都要挨个走流程，效率很低。所以这次合并的目标就是——**多项目共用一个服务单元，一次部署，全部上线**。

但问题来了：怎么让这些原本独立的项目，在同一个容器里和谐共存，还能正常访问？

我的思路是：**用一个 `Vue` 作为壳项目，把各个子项目打包到不同的目录下，再通过统一的入口路由去分发访问**。听起来简单，但真正落地到容器平台的时候，就涉及到一整套 `CI/CD` 和容器化配置的问题。

## 二、追问问题

### 1、该方案在最外层对每个项目都执行了`npm run build`，是真正的一次构建吗？

- 如果是在外层项目中依次执行了多个子项目的 `npm run build`（即每个子项目独立构建），那么这 **不是真正的一次构建**。这属于“**聚合式构建**”或“**一键多构建**”，而不是“**统一构建流程**”意义上的“真正一次构建”。

#### 1.1、为什么不是“真正的一次构建”？

- 我们先明确“真正一次构建”的核心特征：

  | 特征           | 说明                                                       |
  | -------------- | ---------------------------------------------------------- |
  | 🔄 单一构建进程 | 只启动一个构建工具（如 `Webpack`、`Vite`）实例             |
  | 🧩 统一依赖解析 | 所有代码在同一个上下文中被分析、打包                       |
  | 📦 共享优化策略 | `splitChunks`、`tree-shaking`、`scope hoisting` 跨项目生效 |
  | 📁 一次输出     | 所有产物由同一个构建流程生成并写入 `dist/`                 |

### 2、子项目的技术栈都是一样的吗？若有不同技术栈的项目，这种方案还适合吗？如果不适合有什么别的方案？

#### 1.1、子项目的技术栈都是一样的吗？

- 在本次“前端多项目服务单元合并”项目中，所涉及的子项目**技术栈是统一的**，均为 **`Vue.js + Webpack + Vue CLI`** 构建的单页应用（`SPA`），并且路由模式、打包结构、公共资源引用方式等都较为一致。这为采用“外层壳工程 + 多入口构建”的方案提供了良好的前提条件。
- 在我们这个具体的项目中，参与合并的**所有子项目技术栈是统一的**——它们都是基于 **`Vue 2 + Vue CLI + Webpack`** 构建的单页应用，且由同一个前端团队维护，依赖版本和构建方式高度一致。正是基于这个前提，我们才能采用“外层 `Vue` 项目包裹 + 多入口构建 + 目录隔离”的方案，实现代码仓库合并、统一 CI/CD 流水线和部署到一个服务单元的目标

#### 1.2、若有不同技术栈的项目，这种方案还适合吗？

##### 1.2.1、不完全适用，存在较大局限性

- 我们当前方案的核心是：
  - 使用一个统一的 `Vue` 项目作为外壳；
  - 所有子项目通过相同构建工具（`Webpack`）打包输出到 `dist` 不同目录；
  - 通过 `Nginx` 路由映射实现按路径访问。
- 当前方案的核心优势（适用于技术栈统一场景）：
  - **构建可统一**：可以用一套 `Webpack` 配置处理所有子项目的打包逻辑。
  - **依赖可共享**：通过 `splitChunks` 提取公共依赖（如 `Vue`、`Element U`I、字体、公共组件等），显著减少整体包体积，实现资源复用。
  - **部署高效**：一次构建、一次部署，满足“多项目同步上线”的业务需求，降低运维成本。
  - **维护成本低**：工程化脚本集中管理，配置统一，适合内部系统快速迭代。
- 因此，当前“多入口 `Webpack` 构建 + 静态合并部署”的方案，仅适用于技术栈一致或高度相似的项目聚合场景。

- 所以，**这个方案非常适合技术栈一致、团队集中、追求上线效率的场景**。

##### 1.2.2、当子项目技术栈不同时（如 `React`、`Angular`、`Vue2/Vue3` 混合、甚至 `jQuery` 项目），会面临以下问题：

| 问题                                | 说明                                                         |
| ----------------------------------- | :----------------------------------------------------------- |
| **构建工具差异 / 构建工具链不一致** | 比如有的项目是 `React + Webpack`，有的是 `Vue 3 + Vite`，甚至还有 `Angular` 或原生 `JS` 项目，它们的构建输出结构、资源引用方式、环境变量处理都不同，无法用同一套 `Webpack` 配置统一构建。 |
| **依赖冲突**                        | 不同框架对 `node_modules`、`polyfill`、全局变量处理不同，不同框架的运行时（如 `React 17 vs React 18`）或公共库版本差异可能导致全局依赖安装失败或运行异常。 |
| **运行时冲突风险高**                | 多个 `Vue` 实例或 `React` 版本共存，导致内存泄漏、事件绑定错乱、样式污染等问题。 |
| **更新耦合严重**                    | 即使只修改了一个 `React` 子项目，也需要重新构建整个合并包，违背了“独立开发、独立部署”的微服务理念。 |
| **公共资源共享困难**                | 不同框架对 vendor chunk 的生成规则不同，`splitChunks` 无法跨工具生效 |
| **工程复杂度剧增**                  | 外层项目需要为每种技术栈写适配逻辑，构建脚本变得难以维护，`CI/CD` 流水线也会异常臃肿。 |

#### 1.3、如果不适合有什么别的方案？

##### 3.1、更合适的替代方案：微前端架构（`Micro Frontends`）

- 这是解决多技术栈前端聚合的最佳实践，当面临多技术栈、多团队协作、独立部署等复杂场景时，我会推荐采用 **微前端架构**，根据实际需求选择以下几种主流方案：

  （1）

  

  

  

  (1)1. **Module Federation（Webpack 5）** ✅ 推荐

  - **适用场景**：Vue/React/Angular 混合项目，构建时动态加载远程模块。

  - 优点

    ：

    - 原生支持，性能好。
    - 可共享依赖（如共同使用一个版本的 Vue 或 Lodash）。
    - 支持运行时动态加载子应用。

  - **实现方式**：主应用作为容器，从远程地址加载子应用的 `remoteEntry.js`。

  - 示例

    ：

    js深色版本

    ```
    // 主应用 webpack.config.js
    new ModuleFederationPlugin({
      name: 'shell_app',
      remotes: {
        risk: 'riskApp@https://risk.example.com/remoteEntry.js',
        audit: 'auditApp@https://audit.example.com/remoteEntry.js'
      },
      shared: ['vue', 'react', 'lodash']
    });
    ```

  ##### 2. **qiankun / single-spa**

  - **适用场景**：完全异构的技术栈，支持任意框架。

  - 优点

    ：

    - 灵活性极高，支持 Vue、React、Angular、jQuery 项目共存。
    - 提供 JS 沙箱、样式隔离、生命周期管理。

  - **缺点**：引入额外运行时开销，需处理通信、状态共享等问题。

  - **适合大型平台型产品**，如中台系统、企业级门户。

  ##### 3. **iframe 方案**

  - **适用场景**：系统完全独立、安全性要求高、接受一定性能损耗。
  - **优点**：天然隔离，技术栈自由，部署独立。
  - **缺点**：通信复杂、SEO 差、移动端体验不佳、无法共享登录态等。

  ##### 4. **反向代理 + 统一入口页（Nginx Gateway）**

  - 所有子项目独立部署，通过 Nginx 按路径转发请求。
  - 使用一个 Portal 页面做菜单导航或嵌入式跳转。
  - **适合轻量级整合**，无需深度集成。

  ------

  ### **我的技术选型思路总结：**

  | 场景特征                           | 推荐方案                       |
  | ---------------------------------- | ------------------------------ |
  | 技术栈统一、团队集中、追求部署效率 | ✅ 当前的多入口合并构建         |
  | 技术栈多样、多团队协作、需独立部署 | ✅ Module Federation 或 qiankun |
  | 安全隔离要求高、系统完全独立       | ✅ iframe + 独立部署            |
  | 快速整合、无需深度交互             | ✅ Nginx 反向代理 + Portal      |

  > 在我们反洗钱平台项目中，由于所有子系统均为 Vue 技术栈且由同一团队开发，因此选择“合并构建 + 统一部署”是最优解。但如果未来需要接入第三方系统或技术栈差异变大，我会优先推动向 **Module Federation** 迁移，因为它既能保持技术自由度，又能实现依赖共享和高效加载，是目前最平衡的微前端方案。

#### 1.4、微前端（`qiankun`）具体实现步骤

- 以 **主应用（`Main App`） + 子应用（`Sub App`）** 模式为例，实现多技术栈前端项目聚合。

**（1）主应用（`Container App`）搭建**

- 主应用负责路由分发、子应用生命周期管理、公共能力注入（如登录态、菜单、通知等）。

  ```
  # 1. 安装 qiankun
  npm install qiankun -S
  ```

  ```
  // 2. 在主应用入口注册微前端
  import { registerMicroApps, start } from 'qiankun';
  
  // 注册子应用
  registerMicroApps([
    {
      name: 'app-vue',           // 子应用名称
      entry: '//localhost:8081', // 子应用入口地址（HTML）
      container: '#subapp-container', // 渲染节点
      activeRule: '/app-vue',    // 激活路径
    },
    {
      name: 'app-react',
      entry: '//localhost:3000',
      container: '#subapp-container',
      activeRule: '/app-react',
    }
  ]);
  
  // 启动微前端
  start({
    sandbox: true,               // 启用沙箱（隔离样式和变量）
    singular: true,              // 单实例模式
  });
  ```

  ```
  <!-- 3. 主应用 HTML 中预留容器 -->
  <div id="subapp-container"></div>
  ```

**（2）子应用改造（以 `Vue` 和 `React` 为例）**

- 子应用需要支持“**作为模块被加载**”，不能直接挂载到 `#app`。

- #####  `Vue` 子应用改造（`Vue CLI`）

  ```
  // src/main.ts 或 main.js
  import { createApp } from 'vue';
  import App from './App.vue';
  
  let instance: any = null;
  
  // 封装渲染函数
  function render(props: any = {}) {
    const { container } = props;
    instance = createApp(App).mount(container ? container.querySelector('#app') : '#app');
  }
  
  // 判断是否在 qiankun 环境下
  if (!(window as any).__POWERED_BY_QIANKUN__) {
    // 独立运行时
    render();
  } else {
    // 微前端环境下，暴露生命周期钩子
    (window as any).render = render;
  }
  
  // 必须导出生命周期
  export async function bootstrap() {
    console.log('Vue app bootstraped');
  }
  
  export async function mount(props: any) {
    console.log('Vue app mounted', props);
    render(props);
  }
  
  export async function unmount() {
    instance?.unmount();
  }
  ```

  ```
  // vue.config.js：配置打包为 umd 模块
  module.exports = {
    outputDir: 'dist',
    assetsDir: 'static',
    publicPath: process.env.NODE_ENV === 'production' ? '/app-vue/' : 'http://localhost:8081/',
    configureWebpack: {
      output: {
        library: `vue-app`,
        libraryTarget: 'umd',
        jsonpFunction: `webpackJsonp_vue_app`,
      },
    },
  };
  ```

- **`React` 子应用改造（`Create React App`）**

  ```
  // src/index.tsx
  import React from 'react';
  import ReactDOM from 'react-dom/client';
  import App from './App';
  
  let root: any = null;
  
  function render(props: any = {}) {
    const { container } = props;
    const dom = container?.querySelector('#root') || document.getElementById('root');
    root = ReactDOM.createRoot(dom);
    root.render(<App />);
  }
  
  if (!(window as any).__POWERED_BY_QIANKUN__) {
    render();
  } else {
    (window as any).render = render;
  }
  
  export async function bootstrap() {}
  export async function mount(props: any) { render(props); }
  export async function unmount() { root?.unmount(); }
  ```

  ```
  // public/index.html：动态设置 base
  <script>
    if (window.__POWERED_BY_QIANKUN__) {
      // 动态设置 publicPath，防止资源加载失败
      __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
    }
  </script>
  ```

  ```
  // config-overrides.js（需使用 craco 或 react-app-rewired）
  module.exports = {
    webpack: (config) => {
      config.output.library = `react-app`;
      config.output.libraryTarget = 'umd';
      config.output.jsonpFunction = `webpackJsonp_react_app`;
      return config;
    },
  };
  ```

**（3）构建与部署**























