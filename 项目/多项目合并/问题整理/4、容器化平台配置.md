# 一、技术点描述

- [ ] **容器化平台配置：**新建流水线并配置构建命令以确保流水线`ci/cd`运行、基于 `Dockerfile` 打包镜像、新建服务单元并关联流水线、挂载配置性文件

# 二、关于该点回答

- [ ] 这里主要在容器平台上新建服务单元，并新建流水线，将服务单元与流水线进行关联。

# 三、衍生问题

#### 1、`ci/cd`

- [ ] `CI/CD`是 `Continuous Integration` 和 `Continuous Deployment` 的缩写，是一种软件开发流程。
- [ ] **`CI/CD`的主要思想是通过自动化的工具，频繁地把代码从开发环境持续集成到测试环境和生产环境，以实现快速反馈和持续交付。**在前端项目中，通常会实现以下步骤：
  - [ ] 在代码提交到版本库后，触发自动构建和测试。
  - [ ] 通过自动化测试工具检测代码质量，确保代码符合要求。
  - [ ] 在代码通过测试后，自动发布到生产环境。
- [ ] **`CI/CD` 可拆解为 `CI` 和 `CD`，其中 `CI` 为持续集成，`CD` 为持续交付与持续部署。**`CI/CD` 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。
- [ ] `Continuous Integration (CI)` 【持续集成】
  - [ ] **开发人员将代码不断地提交到源代码管理系统中，该过程中，自动化的测试和构建工具会自动从源代码库中获取最新的代码，进行编译、测试、打包等操作，并生成相应的构建产物。**
  - [ ] 现代应用开发的目标是让**多位开发人员同时处理同一应用的不同功能**。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为“合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（`IDE`)，而不是让团队就一个基于云的 `IDE` 达成一致，那么就会让问题更加雪上加霜。
  - [ ] **持续集成（`CI`）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或“主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。**这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，`CI` 可以更加轻松地快速修复这些错误。
- [ ] `Continuous Delivery (CD)` 【持续交付】
  - [ ] **将构建产物部署到测试环境，进行测试和验证，最终生成可部署的产物。**
  - [ ] 完成 `CI` 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 `CI` 已内置于开发管道。**持续交付的目标是拥有一个可随时部署到生产环境的代码库。**
  - [ ] 在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。
- [ ] `Continuous Deployment` (`CD`)【持续部署】
  - [ ] **将构建产物部署到生产环境，实现自动化的部署和发布，从而实现快速的交付和迭代。**
  - [ ] 对于一个成熟的 `CI/CD` 管道来说，最后的阶段是持续部署，指的是代码在通过所有测试后自动部署到生产环境，几乎不需要人为干预。

![project7](..\..\images\project7.png)

#### 2、`docker`

###### 2.1、环境配置的难题

- [ ] 软件开发最大的难题就是环境配置，要保证软件在机器中运行起来，用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行起来。
- [ ] 举例来说，安装一个`Python`应用，计算机必须有`Python`引擎，还必须有各种依赖，可能还要配置环境变量。环境变量配置很麻烦，如果换一台机器，就得重来一次，费时费力。
- [ ] 很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。

###### 2.2、虚拟机

- [ ] 虚拟机就是带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在 `Windows` 系统里面运行 Linux 系统。
- [ ] **可以将软件和操作系统一起打包成虚拟机部署在物理机中，这样用户就可以通过虚拟机还原软件的原始环境了**， 但这样在物理机中再运行一个完整的虚拟机，有几个缺点：
  - [ ] **（1）资源占用多**
    - [ ] **虚拟机会独占一部分内存和硬盘空间。**它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 `1MB`，虚拟机依然需要几百 `MB` 的内存才能运行。
  - [ ] **（2）冗余步骤多**
    - [ ] 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。
  - [ ] **（3）启动慢**
    - [ ] 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。
- [ ] 既然多加一个操作系统太重，那我就只打包**软件和系统依赖库加配置**就好了。然后将这部分系统文件挂到主机的操作系统下，利用一个叫 **`Namespace`**的能力让它看起来就像是一个独立操作系统一样。再利用一个叫 **`Cgroup`** 的能力限制它能使用的计算资源。这就省掉了一层笨重的操作系统，同时还让软件轻松跑在各类操作系统上。这就是我们常说的 **容器技术**。

###### 2.3、`Linux`容器

- [ ] 由于虚拟机存在这些缺点，`Linux` 发展出了另一种虚拟化技术：`Linux` 容器（`Linux Containers`，缩写为 `LXC`）。
- [ ] **`Linux` 容器不是模拟一个完整的操作系统，而是对进程进行隔离。**或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
- [ ] 由于容器是进程级别的，相比虚拟机有很多优势。
  - [ ] **（1）启动快**
    - [ ] 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，**启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。**
  - [ ] **（2）资源占用少**
    - [ ] 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。**另外，多个容器可以共享资源，虚拟机都是独享资源。**
  - [ ] **（3）体积小**
    - [ ] **容器只要包含用到的组件**即可，而**虚拟机是整个操作系统的打包**，所以容器文件比虚拟机文件要小很多。
- [ ] 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。
- [ ] 容器（`Container`）是一种**轻量级的虚拟化技术**，它通过**操作系统级**的虚拟化，将**应用程序及其依赖环境打包在一起**，确保应用程序可以在**任何环境**中**一致运行**。与虚拟机不同，**容器共享宿主操作系统的内核，而不是虚拟化整个操作系统。**
- [ ] **容器是一种操作系统层的虚拟化技术。**
- [ ] **容器使用宿主操作系统的内核，通过命名空间（`Namespace`）和控制组（`Cgroups`）技术实现资源的隔离和限制。命名空间确保每个容器拥有独立的系统视图，如进程树、网络接口和文件系统；控制组则限制和分配容器的资源使用，如`CPU`、内存和`I/O`。**
- [ ] **容器化技术通常依赖于镜像（`Image`）来实现应用程序的打包。一个镜像包含了应用程序运行所需的所有依赖项，包括代码、库、工具和配置文件。容器运行时（如`Docker`、`Podman`）负责管理和运行这些容器镜像。**
- [ ] 容器虚拟化中，**容器没有自己的操作系统（`OS`），直接共享宿主机的内核，也没有虚拟机软件（`hypervisor`）这一层进行资源隔离和限制，因此对容器的控制都是操作系统本身去控制的。**
- [ ] **容器只是运行在宿主机上的一种特殊的进程**，多个容器之间使用的还是同一个宿主机的操作系统内核。

![VM6](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/VM6.png)

- [ ] 容器彻底改变了 `IT` 和软件的开发。 它们允许**将软件和文件打包成独立的包（称为“容器映像”）**，这些包可在不同计算机（真实计算机或虚拟机）上运行，并且以**一致且可预测的方式执行**此操作。 以下描述引自 `Docker` 网站：
- [ ] “容器是一个标准的软件单元，它**将代码及其所有依赖项打包**，从而**使应用程序能够快速、可靠地从一个计算环境运行到另一个计算环境**。 `Docker` 容器映像是轻型、独立的可执行软件包，其中包括运行应用程序所需的一切内容：代码、运行时、系统工具、系统库和设置。”
- [ ] 容器化解决了软件开发过程中一个令人非常头疼的问题：开发人员编写代码，在自己本地环境测试完成后，将代码部署到测试或生产环境中，经常会遇到各种各样的问题。明明本地完美运行的代码为什么部署后出现很多 bug，原因有很多：**不同的操作系统、不同的依赖库等，总结一句话就是因为本地环境和远程环境不一致**。比如前端项目的node环境。
- [ ] **容器化技术正好解决了这一关键问题，它将软件程序和运行的基础环境分开。开发人员编码完成后将程序打包到一个容器镜像中，镜像中详细列出了所依赖的环境，在不同的容器中运行标准化的镜像，从根本上解决了环境不一致的问题。**

#### 4.容器的应用场景

- [ ] **微服务架构**：容器非常适合微服务架构，每个微服务可以运行在独立的容器中，具有高扩展性和灵活性。通过容器编排工具（如`Kubernetes`），可以实现自动化的部署、扩展和管理。
- [ ] **持续集成/持续部署（`CI/CD`）**：容器的快速启动和一致性特性，使其成为`CI/CD`流程中的理想选择。开发人员可以使用容器创建一致的开发和测试环境，确保代码在各个环境中的一致性。
- [ ] **跨平台部署**：容器化应用可以在不同的环境中一致运行，无论是开发、测试还是生产环境。这使得跨平台部署变得更加简单和可靠。

#### 5.容器的优点

- **轻量级**：容器不需要虚拟化整个操作系统，资源利用率高，启动速度快。
- **一致性**：由于容器镜像包含了所有依赖项，确保应用程序在不同环境中（开发、测试、生产）运行的一致性
- **易于部署和扩展**：容器可以很容易地复制、分发和部署，特别适合微服务架构和持续集成/持续部署（`CI/CD`）流程。
- **支持快速扩展**：由于容器的轻量级特性，可以快速启动和销毁，支持应用程序的弹性扩展。

#### 6、容器的缺点

- **隔离性不如虚拟机**：容器共享宿主操作系统的内核，隔离性较虚拟机弱，可能存在安全风险。
- **依赖宿主操作系统**：容器必须与宿主操作系统的内核兼容，限制了操作系统的多样性。
- **管理复杂性**：容器的快速启动和销毁虽然带来了灵活性，但也增加了管理的复杂性，尤其是在大规模容器集群中。

#### 7、`Docker`

**（1）什么是`docker`?**

- **`Docker` 属于 `Linux` 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 `Linux` 容器解决方案。

- **`Docker`必须部署在`Linux`内核的系统上，如果其他系统（比如：`Windows`、`macOS`）想部署`Docker`就必须安装一个虚拟`Linux`环境。**

  - 比如在`Windows`上部署`Docker`的方法都是先安装一个虚拟机，并在安装Linux系统的虚拟机中运行`Docker`。

- `Docker` 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 `Docker`，就不用担心环境问题。

- 总体来说，`Docker` 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

- `docker`是一种容器化技术的落地。是基于容器技术的轻量级虚拟化解决方案。

- **`docker`本身并不是容器，它是创建容器的工具，是应用容器引擎。**

- `docker`本质上是一个进程，使用go语言开发的一个工具。

- 通常，`Docker` 容器镜像必须为特定的平台构建。例如 `Windows` 容器不能在 `Linux` 上运行，反之亦然；以前，绕过此限制的一种方法是启动运行所需操作系统实例的虚拟机，并在虚拟机中运行容器。
  然而 `Docker` 团队后来设计了一个更优雅的解决方案，称为 **`manifest`**，它允许多个操作系统的镜像并行打包。尽管 `manifest` 还处于试验阶段，但这暗示了容器可能成为跨平台应用程序解决方案和跨环境应用程序解决方案。

- ![VM8](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/VM8.png)

  ![VM9](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/VM9.png)



**（2）`Docker`的基本组成**

- `Docker`的三大组成部分为：镜像（`image`）、容器（`container`）、仓库（`repository`）

- **镜像**

  - 是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是`image`镜像文件。

  - **镜像不包含任何动态数据，其内容在构建之后也不会改变**

  - 只有通过这个镜像文件才能生成`Docker`容器实例（`docker`镜像文件类似于Java的类模板，而`docker`容器实例类似于`java`中`new`出来的实例对象。）

  - `Docker` 镜像（`Image`）就是一个**只读**的模板。镜像可以用来创建 `Docker` 容器，**一个镜像可以创建很多容器。**

  - **镜像可以通过`Dockerfile`定义，在运行容器前需要编写 `Docker File`，通过 `Dockerfile`生成镜像，然后才能运行 `Docker` 容器。**

  - `Docker File` 定义了运行镜像（**`image`**）所需的所有内容，包括操作系统和软件安装位置。一般情况下都不需要从头开始编写 `Docker File`，在 `Docker Hub` 中有来自世界各地的工程师编写好的镜像，你可以基于此修改。

  - **镜像加载原理**

    - **`UnionFS`**

      - `UnionFS`（联合文件系统）: 是一种分层轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同的目录挂载到同一个虚拟文件系统下。`Union`文件系统时`Docker`镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。
      - 我们在下载的时候看到一层层的就是用的`UnionFS`
      - 最大层数127
      - 特性：一次同时加载多个文件系统，但从外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录

    - **镜像如何加载**

      - `docker`的镜像实际上由一层一层的文件系统组成，这种层级的文件系统`UnionFS`。最低层是一个引导文件系统，即`bootfs`。`Docker`镜像的第二层(由下而上数)是`root`文件系统`rootfs`也就是我们称为的`base image`基础镜像，它位于引导文件系统上。
      - `boots`(`boot file system`）主要包含 `bootloader`和 `Kernel`, `bootloader`主要是引导加 `kernel`, `Linux`刚启动时会加`bootfs`文件系统，在 `Docker`镜像的最底层是 `boots`。这一层与我们典型的`Linux/Unix`系统是一样的，包含`boot`加載器和内核。当`boot`加载完成之后整个内核就都在内存中了，此时内存的使用权已由 `bootfs`转交给内核，此时系统也会卸载`bootfs`。
      - `rootfs`（`root file system`),在 `bootfs`之上。包含的就是典型 `Linux`系统中的`/dev`,`/proc`,`/bin`,`/etc`等标准目录和文件。 `rootfs`就是各种不同的操作系统发行版，比如 `Ubuntu`, `Centos`等等。

    - **分层理解**

      - 我们在下载镜像的过程中，发现是一层一层的下载，为什么`Docker`镜像要采用这种分层结构？

      - 最大的好处，应该**资源共享**了！比如有多个镜像都从相同的基础镜像构建而来，那么只需在磁盘上保留一份基础镜像，同时内存中也只需要加载一份基础镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。

      - 所有的 `Docker`镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。

        - 举一个简单的例子，假如基于 `Ubuntu Linux16.04`创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 `Python`包， 就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含`3`个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。

          ![VM11](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/VM11.png)

        

        - **在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。**

    - **`Docke`r镜像层都是只读的，容器层是可写的。**

      - 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作‘容器层’，‘容器层’之下的都叫‘镜像层’。
      - 所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。

- **容器**

  - **容器是用镜像创建的运行实例，容器就类似于一个虚拟化的运行环境。**就像是`Java`中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。
  - 容器是在隔离的环境中运行的进程，具有自己的文件系统、网络空间和进程空间。
  - 容器可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台
  - 可以把容器看做是一个简易版的 `Linux` 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。
  - **`image` 文件生成的容器实例，本身也是一个文件，称为容器文件。**也就是说，一旦容器生成，就会同时存在两个文件： `image` 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。

- **仓库**

  - `Docker`仓库是用于存储和分享`Docker`镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。类似于：
    - `Maven`仓库，存放各种`jar`包的地方；
    - `github`仓库，存放各种`git`项目的地方；
    - `Docker`公司提供的官方`registry`被称为`Docker Hub`，存放各种镜像模板的地方。
  - 最常用的是`Docker Hub`，它是一个公共的镜像仓库，包含了大量的官方和社区维护的镜像。除了公共仓库，还可以搭建私有的`Docker`仓库，用于存储和分享自定义的镜像。国内的公开仓库包括阿里云 、网易云等

![VM10](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/VM10.png)

#### 8、`K8s(Kubernetes)`—容器编排系统

**（1）`K8s`出现的原因**

- 尽管 `Docker` 为容器化的应用程序提供了开放标准，但随着容器越来越多出现了一系列新问题：
  - 如何**协调、调度和管理**这些容器？
  - 如何在升级应用程序时**不中断服务**？
  - 如何**监视**应用程序的运行状况？
  - 如何批量重新启动容器里的程序？
- 解决这些问题需要容器编排技术，可以将众多机器抽象，对外呈现出一台超大机器。现在业界比较流行的有：**`k8s`**、`Mesos`、**`Docker Swarm`**。
- 在业务发展初期只有几个微服务，这时用 `Docker` 就足够了，但随着业务规模逐渐扩大，容器越来越多，运维人员的工作越来越复杂，这个时候就需要编排系统解救 `opers`。

**（2）`Kubernetes`与`Docker`的关系**

- `Kubernetes`与`Docker`之间的关系可以说是相辅相成的。**`Docker`为`Kubernetes`提供了强大的容器运行时环境，而`Kubernetes`则为`Docker`容器提供了自动化管理和编排的能力。**简而言之，**`Docker`解决了应用程序的打包和运行问题，而`Kubernetes`解决了应用程序的分布式管理和扩展问题**。
- `Docker`是`Kubernetes`中默认的容器运行时技术，但`Kubernetes`同时支持其他容器运行时，如`containerd`和`CRI-O`。这种灵活性使得`Kubernetes`能够满足不同用户的需求。相辅相成的关系使得Kubernetes和Docker在构建现代微服务架构方面具有优势。
- **`Docker` 是用于构建、分发、运行（`Build, Ship and Run`）容器的平台和工具。**
- **而 `k8s` 实际上是一个使用 `Docker` 容器进行编排的系统，主要围绕 `pods` 进行工作。`Pods` 是 `k8s` 生态中最小的调度单位，可以包含一个或多个容器。**
- `Docker` 和 `k8s` 是根本上不同的技术，两者可以很好的协同工作

**（3）`k8s`架构和组件**

- `k8s` 由众多组件组成，组件间通过 `API` 互相通信，归纳起来主要分为三个部分：

  - `controller manager`
  - `nodes`
  - `pods`

- **`k8s` 集群架构图**：

  ![k8s1](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/k8s1.png)

  - **`Controller Manager`**，即控制平面，用于**调度**程序以及节点状态**检测**。
  - **`Nodes`**，构成了 `Kubernetes` 集群的集体计算能力，**实际部署容器运行的地方**。
  - **`Pods`**，`Kubernetes` 集群中**资源的最小单位**。

- 下图是 **`Kubernetes` 集成 `Jenkins` 实现 `CICD`**（一图胜千言，需要对其有一个大致的认识）：

  ![k8s2](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/k8s2.png)

**（4）`Kubernetes`与`Docker`在微服务架构中的应用**

- **应用部署**
  - 通过`Docker`容器化技术，我们可以将应用程序及其依赖项打包到一个容器中，保证应用程序在不同环境中的一致性。`Kubernetes`作为编排平台，可以自动化地部署、管理和扩展这些容器，满足应用程序在不同场景下的需求。
- **服务发现与负载均衡**
  - `Kubernetes`提供了服务发现和负载均衡功能，**可以自动地将请求分发到不同的容器实例，从而实现高可用性和高性能**。此外，`Kubernetes`还支持基于应用程序性能和资源需求的自动扩缩容，进一步优化了系统的响应能力。
- **容错与故障恢复**
  - `Kubernetes`具有自我修复能力，**当某个容器实例出现故障时，`Kubernetes`会自动重新调度并启动一个新的实例来替换故障实例**。这样的设计可以保证微服务应用的高可用性和故障容忍能力。
- **系统监控与日志管理**
  - `Kubernetes`集成了一系列系统监控和日志管理工具，如`Prometheus`和`ELK Stack`，可以帮助开发者和运维人员实时监控容器和应用程序的性能、资源消耗和日志，从而快速定位和解决问题。

**（5）相关问题**

- 为什么要用`k8s`？没有`k8s`可以使用`docker`吗？
  - 可以。实际上一些小型公司，在业务不太复杂的情况下都是直接使用 `Docker`。尽管 `k8s` 有很多好处，但是众所周知它非常复杂，业务比较简单可以放弃使用 `k8s`。但 `k8s` 在业务达到一定规模后也得启用！
- 没有`Docker`可以使用`k8s`吗？
  - `k8s`是容器编排工具，必须有容器。`k8s` 经常与 `Docker` 进行搭配使用，但是也可以使用其他容器，如 `RunC`、`Containerted` 等。

## 四、容器与虚拟机

- 容器与虚拟机相似，因为它们都**提供了可以在其中运行软件的可预测且隔离的环境**。
- **容器和虚拟机并不互斥**。 实际上，它们经常一起使用。 如果 `Windows` 用户运行在 `Linux` 容器中打包的软件，则可在 `VM` 中运行 `Linux`，并在 `VM` 中承载 `Docker` 和容器化软件。 在云中，容器与其他云工作负载一样承载在 `VM` 中。
- 容器并不能替代虚拟机，它们两者也不应被视为功能相等。 与虚拟机不同，**容器不允许在同一计算机上并行运行多个操作系统**。 例如，如果主机运行 `Linux`，则该计算机上的所有容器也必须使用 `Linux`。 （`Windows` 用户经常在 `Windows` 上运行 `Linux` 容器，但这是可行的，因为 `Docker` 在 `Windows` 计算机上运行 `Linux VM` 并在 `VM` 中承载容器。）此外，由于容器不会对硬件进行虚拟化，因此不适用于执行涉及直接硬件交互的系统级任务的应用程序。 一种简单的思路是，虚拟机监控程序对整个计算机（包括其硬件）进行虚拟化，而容器对软件进行虚拟化并使用主机的操作系统作为操作系统平台。

![VM6](D:/张旭资料/knowledge-notes/前端知识/前端工程化/images/VM7.png)                      

**（1） 架构**

- **容器**：容器是一种**应用级或操作系统级**的虚拟化技术。它们**共享宿主操作系统的内核，但各自拥有独立的用户空间**。容器通过操作系统的虚拟化功能，如命名空间（`Namespace`）和控制组（`Cgroups`），实现资源的隔离和限制。容器中的每个应用程序都运行在与宿主操作系统共享的内核上，因此不需要独立的操作系统。
- **虚拟机**：虚拟机是一种**基础架构级或硬件级**的虚拟化技术。每个虚拟机都有自己**独立的操作系统内核、文件系统和内存分配**。虚拟机通过虚拟机监控器（`Hypervisor`）在物理硬件之上运行，虚拟机监控器负责将物理资源划分为多个虚拟实例，并为每个虚拟机提供独立的硬件虚拟化。

**（2）性能**

- **容器**：由于容器共享宿主操作系统的内核，减少了虚拟化层的开销，因此它们通常比虚拟机性能更好。容器通过直接利用宿主操作系统的资源，降低了资源消耗和延迟，从而提升了整体性能。
- **虚拟机**：虚拟机由于需要运行一个完整的客操作系统，同时管理虚拟化层的开销，其性能通常低于容器。虚拟机监控器在分配和管理资源时会引入额外的开销，导致资源利用率相对较低。

**（3）资源利用率**

- **容器**：容器通过直接利用宿主的资源，提供了更高效的资源利用率。由于容器不需要独立的操作系统，它们可以在更少的资源下运行多个实例，从而提高计算资源的利用效率。
- **虚拟机**：虚拟机需要为每个实例分配独立的资源，包括操作系统所需的`CPU`、内存和存储空间。由于每个虚拟机都运行在独立的操作系统上，资源利用率相对较低。

**（4）延迟**

- **容器**：容器由于能够**直接访问宿主硬件，并且不需要通过虚拟化层**，因此具有较低的延迟。这使得容器特别适合需要高性能和低延迟的应用程序。
- **虚拟机**：虚拟机引入了额外的虚拟化层，**需要通过虚拟机监控器来访问物理硬件**。这种额外的开销导致虚拟机的延迟相对较高。

**（5）启动时间**

- **容器**：容器的启动时间通常非常短，接近即时。因为**容器不需要启动完整的操作系统**，它们可以在几秒钟内启动并开始运行应用程序。这种快速启动特性使得容器非常适合需要快速部署和扩展的应用场景。
- **虚拟机**：虚拟机的启动时间较长，因为它们**需要加载和启动一个完整的操作系统**。通常，启动一个虚拟机需要几分钟的时间，这在需要频繁启动和关闭实例的场景中可能成为一种劣势。

**（6）隔离性**

- **容器**：容器使用操作系统级的隔离，通过命名空间和控制组来隔离不同的容器。然而，由于**容器共享宿主操作系统的内核，其隔离性不如虚拟机强**。这种隔离性不足可能带来一定的安全风险，尤其是在多租户环境中。
- **虚拟机**：虚拟机提供了**完整的隔离性**，因为每个虚拟机都运行在独立的虚拟机监控器上，并拥有自己的操作系统内核。这种**硬件级的隔离确保了虚拟机之间的完全独立**，即使一个虚拟机被攻破，也不会影响其他虚拟机。

**（7）可移植性**

- **容器**：容器具有高度的可移植性，可以在不同的系统上保持一致的行为。**容器镜像包含了应用程序的所有依赖项**，因此无论在**开发、测试还是生产环境中，容器化的应用程序都可以一致运行**。
- **虚拟机**：虚拟机的可移植性相对较低，因为它们**依赖于特定的硬件和操作系统配置**。将虚拟机从一个环境迁移到另一个环境时，可能需要进行**配置调整**，以确保虚拟机能够正常运行。

**（8）安全性**

- **容器**：由于容器共享宿主操作系统的内核，其**安全性依赖于宿主操作系统的安全性**。尽管容器运行时（如`Docker`、`Podman`）提供了一些安全功能（如命名空间和控制组），但容器的安全性通常低于虚拟机。**共享内核的设计**使得容器在某些情况下更容易受到攻击。
- **虚拟机**：虚拟机的安全性较高，因为每个虚拟机运行在**独立的操作系统**上，具有**强隔离性**。这种隔离性确保了即使一个虚拟机遭到攻击，其他虚拟机和宿主系统仍然保持安全。

**（9）灵活性**

- **容器**：容器在资源分配和扩展方面具有更大的灵活性。由于**容器轻量级且启动迅速**，它们可以轻松地进行动态扩展和缩减，以应对不同的负载需求。容器编排工具（如`Kubernetes`）进一步增强了这种灵活性，使得容器能够在大规模集群中自动化管理。
- **虚拟机**：虚拟机的灵活性较低，因为它们**需要固定的资源分配**。更改虚拟机的资源配置通常需要重新启动虚拟机，或对其配置进行手动调整。这使得虚拟机在处理动态负载变化时不如容器灵活。

**（10） 密度**

- **容器**：由于容器的轻量级特性，它们可以在一台宿主机上以更高的密度部署。多个容器可以**共享同一套资源**，而不会相互干扰，从而实现更高的资源利用率。
- **虚拟机**：虚拟机由于需要**独立的操作系统和更多的资源开销**，其密度通常低于容器。在同样的**硬件配置**下，能够运行的虚拟机数量往往少于容器。

**（11）效率**

- **容器**：容器在存储和内存利用率方面更加高效。由于容器**不需要独立的操作系统**，它们可以**在更少的存储和内存资源下运行多个实例**，特别适合大规模部署。
- **虚拟机**：虚拟机需**要为每个实例分配额外的存储和内存资源**，因为每个虚拟机都包含一个**完整的操作系统**。这种资源开销使得虚拟机的效率相对较低。

**（12）部署复杂性**

- **容器**：容器的部署过程相对简单。通过**容器镜像，应用程序及其依赖项可以被打包成一个独立的单元**，便于分发和部署。容器编排工具进一步简化了容器的管理，使得大规模部署更加容易。
- **虚拟机**：虚拟机的部署过程相对复杂，**需要配置和管理独立的操作系统。每个虚拟机实例都需要进行操作系统安装、配置和优化**，这使得虚拟机的部署和维护更加费时费力。

**（13） 使用场景**

- **容器**：容器非常适合**微服务架构、持续集成/持续部署（`CI/CD`）流程、应用程序的快速扩展和管理分布式系统**。在这些场景中，容器的**轻量级、快速启动和高密度特性**发挥了重要作用。
- **虚拟机**：虚拟机通常用于**运行遗留应用程序、测试不同的操作系统、创建隔离的操作系统环境以及开发沙箱**。虚拟机**强大的隔离性和多操作系统支持**，使其在需要高安全性和多样化操作系统的场景中具有优势。

# 五、`CI/CD`

3、配置性文件

