# 一、技术点描述

- [ ] **性能优化：**优化项目包体积，优化`web`端加载速度，采用`splitChunks`实现子项目共享字体包、`css`静态资源、`gzip`压缩包体积、浏览器强缓存`cache-control`等手段优化，解决了项目部署问题、字体闪动问题，加载慢问题，包体积从`36.61MB`减少至`18.41MB`，首次加载速度从`3023ms`减少至`1079ms`

# 二、关于该点回答

- [ ] 我们项目为了美观，用了自定义的字体，开发完成后发现，页面首次加载时文字会出现短暂的字体样式闪动，在网络情况较差时比较明显。究其原因，**是字体文件由`css`引入，在`css`解析后才会进行加载，加载完成之前浏览器只能使用降级字体。也就是说，字体文件加载的时机太迟，需要告诉浏览器提前进行加载，这恰恰是`preload`的用武之地。**

- [ ] 由于项目有明显的字体闪动问题，主要从共享静态资源，减小打包体积、利用浏览器缓存等方面来优化性能。

- [ ] 多个子项目共享基座的字体包，主要实现将字体`css`文件单独分离打包，子项目`nginx.conf`文件中配置rewrite来重定向到基座的字体包文件地址。

- [ ] 分离字体包的时候遇到问题，一开始尝试使用`webpack`中的`mini-css-extract-plugin`插件来单独分离`css`文件，一直报错，就去使用demo研究了一番。

- [ ] 一番研究之后的理解：`vue`其实已经给我们内置了`webpack`的`css`分离功能，可以通过源码查看并测试，注释了源码相关代码，再次打包确实不报错了

  ![project10](../../images/project10.png)

- [ ] 所以其实不需要像`webpack`中那样配置，只需要配置`vue.config.js`中的`css`选项的`extract`（内置`mini-css-extract-plugin`插件）即可，这个值默认就是true

  ![project11](../../images/project11.png)

- [ ] 思考之后再次理解“`mini-css-extract-plugin`插件来单独分离`css`文件”的含义是将`css`从`js`中分离出来，并且会将所有`css`文件打包合并生成一个`css`文件，并不能将特定的`css`文件单独打包成相应的`css`文件（比如`index.css->index.css，global.css->global.css`）

  ![project8](../../images/project8.png)

- [ ] 要实现将`css`打包成多个文件，需要结合`webpack`的代码分离特性`splitChunks`去实现。

  ![project9](../../images/project9.png)

  

# 三、衍生问题

#### 1、`webpack`

#### 2、共享静态资源/`cdn`

#### 3、浏览器缓存

#### 4、`gzip`

#### 5、首屏加载

- [ ] **spa -> 单页：**浏览器的加载过程是指将服务器上的静态资源（如：`CSS`、`JavaScript`文件）通过网络传输到用户的浏览器中，并存储在浏览器的内存中。

5.1、首先明白加载过程

 **(1) 拉取`html`，打包后的`html`里面只有`css`、`js`，此时就是`FP`的时候**

- [ ] `FP(First Paint)`：第一帧数据的像素落点，有一个东西回来渲染到页面上，第一帧绘制，`html`加载下来

  ```
  <静态资源>
  <div id="app"></div>
  ```

**(2) 加载静态资源、`css`、`js`，如果你的页面所有`js`全部都打包到`main.js`，下载的过程就很慢，需要加载的内容过多，时间过长，会出现长时间的白屏**

**(3) 解析`js` => 生成`html`(有了大致结构) 此时就是`FCP`的时候**

- [ ] `FCP(First Contentful Paint)`：结构出来了，标识渲染出第一个内容，有效的绘制。`css`、`js`加载下来（这个阶段很快）

  ```
  <div id="app">
      <div class="head"></div>
      <div class="body"></div>
  </div>
  ```

**(4) `ajax 0.5s`发请求获取项目接口数据**

- [ ] `LCP(Largest Contentful Paint)` ：结构和数据都出来了，真正有意义做优化的点，`ajax`数据请求回来了

  ```
  <div id="app">
      <div class="head">你好</div>
      <div class="body">新世界</div>
  </div>
  ```

- [ ] `FMP（First Meaningful Paint）`：首次渲染有意义的内容的时间，"有意义"没有一个标准的定义，`FMP`的计算方法也很复杂。比如新闻网页看标题加载出来，电商网站看图片加载出来。

- [ ] `LCP(Largest Contentful Paint)` ：首次渲染页面最大元素的时间（图片或文本），根据`W3C`网络性能工作组中讨论和Google所做的研究，我们发现，衡量页面主要内容的加载时间（首屏时间）的更准确方法是首次渲染页面最大元素的时间(`LCP`)

- [ ] 首屏时间指标原来一般用`fmp`，现在用`lcp`(都关注用户实际感知到的内容变化)，我优化也采用`LCP`作为首屏指标。

- [ ] 然后我就用谷歌浏览器的性能`Performance` 和 `Lighthouse`分析性能指标

- [ ] 性能面板：分析网站性能`lighthouse`：优化网站速度

  ![project12](../../images/project12.png)

![project13](../../images/project13.png)

- [ ] 分析完毕后我发现项目项目的首屏加载时间`LCP`要3秒左右

- [ ] 模拟首屏加载可以用`ctrl + f5`强制刷新浏览器，模拟首次加载，这样性能`Performance` 显示的`LCP`时间就是首次加载时间，因为第二次再刷新浏览器就会用缓存，那个`lcp`时间就会快很多，不是首次的，lighthouse你就直接分析就好。然后其实肉眼看的首屏加载速度是要比这个`lcp`指标快的，`lcp`并不完全等同于用户的主观感受，这个了解就好。

- [ ] 打包后的体积有`36.61`MB，主要是第三方库，字体包，还有`vue.js`

- [ ] 然后就从这两方面进行优化：从共享静态资源，代码分割、`gzip`压缩、利用浏览器缓存

- [ ] **代码分割（分包）**

  - [ ] 采用代码分割把项目里的文件单独打包，减少打包文件的体积，把框架和相关库单独打包，把项目的插件如`lodash`单独打包，把组件库单独打包。这样可以做到按需加载和复用缓存。

  - [ ] 不做代码分割的话，打包出来的`js`很大，都打包到一起了，进一个页面，其他页面也会加载，而且浏览器没法复用本地缓存，因为包打到一起，修改一个页面，整个包chunk名变了，缓存就失效了。

  - [ ] 代码分割的好处：

    - [ ] 缓存优化：框架代码更新频率低，单独打包可以利用浏览器缓存，业务代码更新频率，不影响框架代码的缓存。
    - [ ] 按需加载：不同页面可能需要不同的包，分开打包可以实现按需加载
    - [ ] 并行加载：多个小文件可以并行下载，提高资源加载速度。

    ```
    build:{
          rollupOptions: {
            output:{
             manualChunks:{
                //将vue相关库或 react打包成单独chunk中（按照自己实际项目来说）
               'vue-vendor':['vue','react','@vueuse/core'],
               //将 Lodash 库代码单独打包
               'lodash':['lodash'],
               //将组件库的代码打包（你项目里用什么组件库就说什么）
               'library':['element-plus','ant desing pro']
             }
            }
          }
    }
    ```

    

#### 6、白屏 

