一、概念

   - 垃圾回收机制只作用于对象，因为原始类型的值存在于栈中，会自动回收，而引用类型的值存在于堆中，它们的内存地址存在于栈中，我们在变量中保存的其实是指向引用变量的指针，所以我们不引用一个保存在堆内存中的引用类型的值的时候，需要垃圾回收机制帮我们回收掉这个对象，然后释放掉它的内存
   - 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
   
   - JavaScript的内存管理是自动的，而且是不可见的，当我们创建一个基本类型的值，对象，函数...所有这些都是需要内存的，只要我们创建的值被引用了，该值就保证存在内存中，当该值没有被引用的时候，就需要被回收释放掉它所占用的内存。垃圾回收机制就是找出那些没有被引用的引用类型的值，然后释放掉它的内存。由于垃圾回收器回收内存这个过程的开销比较大，所以这个过程不是实时的，而是定期（周期性）的。

      例1：var a={
               obj:2
              }

         上例中，由于{obj:2}这个对象被a变量引用了，所以这个值就一直存在内存中，如果将a重新赋值为null,这时{obj:2}没有被引用了，则{obj:2}就会被回收，它的内存会被释放掉。

      例2：var a={
               obj:2
              }

           var b = a
           a=null

         上例中，{obj:2}不会被回收，因为虽然a没有引用它，但b引用了它。如果b=null，那么{obj:2}就会被回收。

二、垃圾回收策略

  1.引用计数(不太常用)

   （1）原理

         - 引用计数就是跟踪每个值被引用的次数，被引用一次加1，当引用次数为0的时候，就被视为可回收的对象，每当过一段时间开始垃圾回收的时候，就把引用次数为0的变量回收。

   （2）过程

         - 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型的值的引用次数就是1
         - 同一个值又被赋值给了另一个变量，这个引用类型值的引用次数加1
         - 当包含这个引用类型值的变量又被赋值成另一个值了，那麽这个引用类型值的引用次数减1
         - 当引用次数变成0时，说明没办法访问这个值了
         - 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

         例：var a={name:'jone'}
             var b = a
             a=12
             b=456

          上例中，声明了一个变量并将{name:'jone'}赋值给a,所以{name:'jone'}的引用次数为1，又将{name:'jone'}赋值给了b,所以{name:'jone'}的引用次数为2，第三行又将a的值重新赋值为12，所以{name:'jone'}的引用次数又变成1，第四行又将b的值重新赋值为456，所以{name:'jone'}的引用次数又变成0，这是{name:'jone'}就变成了可回收的对象，垃圾回收器运行的时候它就会被回收。

   （3）循环引用

          function f() {
           var o1 = {name:566}
           var o2 = {name:122}
           o1.p = o2
           o2.p = o1
          }
             
         上例中,{name:566}和{name:122}两个对象都被引用了两次，由于函数的局部变量只在函数的执行过程中存在，当函数运行结束，会将局部变量o1和o2赋值为null，但此时{name:566}和{name:122}两个对象的引用次数为1不为0，所以这两个对象都不会被垃圾回收机制回收，但是这两个对象已经没有作用了，在函数外部也不可能使用到它们，所以这就造成了内存泄露

         解决方式：

             不使用的时候手动清除：o1.p = null
                                o2.p = null


  2.标记清除（常用）

   （1）原理

        - 根节点：一般来说，根是代码中引用的全局变量。例如，在 JavaScript 中，可以充当根节点的全局变量是“window”对象。Node.js 中的全局对象被称为“global”。完整的根节点列表由垃圾收集器构建。
      
        - 标记清除分为标记阶段和清除阶段
        
             - 标记阶段：标记清除其实就是可达性（对象是否可访问）测试，垃圾回收器从根集合出发，检查所有的根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。
	       
             - 清除阶段：从根节点开始遍历堆，垃圾收集器释放所有未被标记为活跃的内存块，并将这些内存返回给操作系统

        - 在使用标记清除算法时,未引用对象并不会被立即回收.取而代之的做法是,垃圾对象将一直累计到内存耗尽为止.当内存耗尽时,程序将会被挂起,垃圾回收开始执行.当所有的未引用对象被清理完毕时,程序才会继续执行.
   
   （2）解决循环引用

           function f() {
           var o1 = {name:566}
           var o2 = {name:122}
           o1.p = o2
           o2.p = o1
          }

         上例中，由于函数执行结束后，局部变量o1和o2就会被回收，全局对象就访问不到这两个对象了，因此，垃圾回收器会认为它们不可访问