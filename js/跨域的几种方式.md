一、跨域理解

* 跨域是浏览器本身施加的安全限制，并不是人为的给某一个特定的网站设置的

* 其次，跨域是浏览器上的概念，服务端不存在跨域的说法

* 本质，浏览器的同源策略决定了一个网站不可以执行非本网站下的脚本

* 只要协议，域名，端口有任意一个不同，都被当做不同的域，js不能在不同的域之间进行通信和传输数据

二、跨域的情况

* 通过Ajax向不同域请求数据
* 通过js获取页面中不同域的框架中的数据

三、同源策略

1.定义

两个页面地址中的协议，域名，端口号一致，则表示同源

2.为什么有同源策略

设置同源策略的主要目的是为了安全，如果没有同源限制，在浏览器中的cookie等其他数据可以任意读取，不同域下的DOM任意操作，ajax任意请求其他网站的数据，包括隐私数据

3.同源策略的限制

  * 无法用js读取非同源的Cookie、LocalStorage 和 IndexDB 无法读取

  * 无法用js获取非同源的DOM 

  * 无法用js发送非同源的AJAX请求 

四、跨域的方法

1.CORS（Cross-Origin Resource Sharing）跨域资源共享

* 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制
	
* 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉
	
* CORS需要浏览器和服务器同时支持，目前所有的浏览器都支持(IE浏览器不能低于IE10)，所以，要支持CORS，服务端都需要做好相应的配置,只要服务器实现了CORS接口，就可以跨源通信

* 浏览器将CORS请求分为两类:

(1)简单请求

* 同时满足以下两个条件就叫简单请求：

      * 请求方法是以下三种之一：

            * GET
     
            * POST
     
            * hEAD

      * HTTP的头信息不超过以下几种字段：

            * Accept
     
            * Accept-Language
           
            * Content-Language
     
            * Last-Event-ID
    
            * Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

* 基本流程

      * 对于简单请求，浏览器直接发出CORS请求，即就是在头信息之中，增加一个origin字段

            如下面的例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段

					GET /cors HTTP/1.1
					Origin: http://api.bob.com
					Host: api.alice.com
					Accept-Language: en-US
					Connection: keep-alive
					User-Agent: Mozilla/5.0...

      * origin字段用来说明本次请求来自那个源(协议+域名+端口)，服务器会根据这个值决定是否同意这次请求

      * 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200

      * 如果origin指定的域名在许可范围之内，服务器返回的响应会多出几个头信息字段

            * Access-Control-Allow-Origin: http://api.bob.com

                 * 该字段是必须的，它的值要么是请求时origin字段的值，要么是一个*，表示接受任意域名的请求

            * Access-Control-Allow-Credentials: true

                 * 该字段可选，它的值是一个布尔值，表示是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可
                 
            * Access-Control-Expose-Headers: FooBar

                 * 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。
           


* withCredentials属性

      * CORS默认不发送Cookie和HTTP认证信息，如果要把Cookie发送到服务器，一方面服务器同意，指定Access-Control-Allow-Credentials字段，另一方面，开发者必须在Ajax请求中打开withCredentials属性

          var xhr = new XMLHttpRequest();
          xhr.withCredentials = true;

      * 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

      * 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials

          xhr.withCredentials = false

      * 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie


(2)非简单请求

* 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段类型是application/json

* 非简单请求的CORS请求会在正式通信之前，增加一次HTTP查询请求，称为预检请求

* 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错

* 预检请求

     * 如下面是一段浏览器的js脚本

		    var url = 'http://api.alice.com/cors';
		    var xhr = new XMLHttpRequest();
		    xhr.open('PUT', url, true);
		    xhr.setRequestHeader('X-Custom-Header', 'value');
		    xhr.send();

	       上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。
	
    * 浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息


		    OPTIONS /cors HTTP/1.1
		    Origin: http://api.bob.com
		    Access-Control-Request-Method: PUT
		    Access-Control-Request-Headers: X-Custom-Header
		    Host: api.alice.com
		    Accept-Language: en-US
		    Connection: keep-alive
		    User-Agent: Mozilla/5.0...

            预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源


   * 除了Origin字段，"预检"请求的头信息包括两个特殊字段。
	
       * Access-Control-Request-Method
	
	      该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT
	
       * Access-Control-Request-Headers
	
	      该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header

* 预检请求回应

    * 服务器收到了预检请求以后，检查了Origin，Access-Control-Request-Method，Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以作出回应

			HTTP/1.1 200 OK
			Date: Mon, 01 Dec 2008 01:15:39 GMT
			Server: Apache/2.0.61 (Unix)
			Access-Control-Allow-Origin: http://api.bob.com
			Access-Control-Allow-Methods: GET, POST, PUT
			Access-Control-Allow-Headers: X-Custom-Header
			Content-Type: text/html; charset=utf-8
			Content-Encoding: gzip
			Content-Length: 0
			Keep-Alive: timeout=2, max=100
			Connection: Keep-Alive
			Content-Type: text/plain

   * 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

   * 如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息

   * 服务器回应的其他CORS相关字段如下：


	    Access-Control-Allow-Methods: GET, POST, PUT
	    Access-Control-Allow-Headers: X-Custom-Header
	    Access-Control-Allow-Credentials: true
	    Access-Control-Max-Age: 1728000

       * Access-Control-Allow-Methods

           * 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

       * Access-Control-Allow-Headers

           * 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

       * Access-Control-Allow-Credentials

           * 该字段与简单请求时的含义相同。

       * Access-Control-Max-Age

           * 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

* 浏览器的正常请求和回应

      * 一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。
	
      * 下面是"预检"请求之后，浏览器的正常CORS请求。
	
	
		    PUT /cors HTTP/1.1
		    Origin: http://api.bob.com
		    Host: api.alice.com
		    X-Custom-Header: value
		    Accept-Language: en-US
		    Connection: keep-alive
		    User-Agent: Mozilla/5.0...
	
	     上面头信息的Origin字段是浏览器自动添加的。
	
      * 下面是服务器正常的回应。
	
		    Access-Control-Allow-Origin: http://api.bob.com
		    Content-Type: text/html; charset=utf-8
	
	    上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的

2.JSONP

* 在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，我们知道img,script,这种标签如果有相应的src，那么便会发起一个http请求来请求相应的资源,如果有script标签对应的路径是一个js文件，那么在下载完毕这个js之后会马上执行，jsonp正是利用这个特性来实现的

* 怎么使用script来发送请求

       * 我们使用动态标签来实现

            如：let script = document.createElement('script');
				srcipt.src = 'www.somewhere.com/getdata';
				document.querySelector('head').appendChild(script);

* 请求得到的数据应该怎么在前端页面上接收并处理


       * 我们使用callback回调函数来实现，因为有可能是多个不同站点都要访问这个服务端，那么各个站点要调用的方法可能是各不相同的，如果把方法名写死的话，就会很不和谐。所以解决的办法是各个站点来访问服务端时，在url中带一个参数（callback）过来，服务端获取到这个参数，就会在生成js代码时，以这个callback参数作为方法名，再把数据放到这个方法里。这样各个站点就可以调用各自的方法了。这也是jsonp的一个要点

           <script>

			    var script = document.createElement('script');
			    script.type = 'text/javascript';
			
			    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
			    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
			    document.head.appendChild(script);
			
			    // 回调执行函数
			    function handleCallback(res) {
			        alert(JSON.stringify(res));
			    }

		 </script>


* 缺点

    * 只能发送get请求，因为script只能处理get请求
    * 需要后台配合

          * 服务端接收到url时，获取到callback参数，在后端进行了一次拼接返回

            node.js

				var querystring = require('querystring');
				var http = require('http');
				var server = http.createServer();
				
				server.on('request', function(req, res) {
				    var params = qs.parse(req.url.split('?')[1]);
				    var fn = params.callback;
				
				    // jsonp返回设置
				    res.writeHead(200, { 'Content-Type': 'text/javascript' });
				    res.write(fn + '(' + JSON.stringify(params) + ')');
				
				    res.end();
				});
				
				server.listen('8080');
				console.log('Server is running at port 8080...')


3.